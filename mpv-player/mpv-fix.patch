diff -ruN mpv-0.29.1/.travis.yml mpv-master/.travis.yml
--- mpv-0.29.1/.travis.yml	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/.travis.yml	2019-09-19 04:02:03.000000000 +0700
@@ -1,21 +1,34 @@
-language: generic
+language: c
 
-os:
-  - linux
+matrix:
+  include:
+    - os: osx
+      osx_image: xcode10.2
+      compiler: clang
+    - os: osx
+      osx_image: xcode10.1
+      compiler: clang
+    - os: osx
+      osx_image: xcode9.2
+      compiler: clang
+    - os: linux
+      compiler: gcc
+      env: CONTAINER=registry.cirno.systems/kiwi/containers/mpv-ci:stable-deps CI_SCRIPT=ci/build-tumbleweed.sh
+    - os: linux
+      compiler: clang
+      env: CONTAINER=registry.cirno.systems/kiwi/containers/mpv-ci:stable-deps CI_SCRIPT=ci/build-tumbleweed.sh
+    - os: linux
+      env: CONTAINER=registry.cirno.systems/kiwi/containers/mpv-ci-mingw64:i686 CI_SCRIPT=ci/build-mingw64.sh TARGET=i686-w64-mingw32
+    - os: linux
+      env: CONTAINER=registry.cirno.systems/kiwi/containers/mpv-ci-mingw64:x86_64 CI_SCRIPT=ci/build-mingw64.sh TARGET=x86_64-w64-mingw32
 
+dist: bionic
 services:
   - docker
 
 sudo: required
 
 env:
-  matrix:
-    - CONTAINER=registry.cirno.systems/kiwi/containers/mpv-ci:stable-deps CI_SCRIPT=ci/build-tumbleweed.sh CC=gcc
-    - CONTAINER=registry.cirno.systems/kiwi/containers/mpv-ci:stable-deps CI_SCRIPT=ci/build-tumbleweed.sh CC=clang
-    - CONTAINER=registry.cirno.systems/kiwi/containers/mpv-ci:snapshot-deps CI_SCRIPT=ci/build-tumbleweed.sh CC=gcc
-    - CONTAINER=registry.cirno.systems/kiwi/containers/mpv-ci:snapshot-deps CI_SCRIPT=ci/build-tumbleweed.sh CC=clang
-    - CONTAINER=registry.cirno.systems/kiwi/containers/mpv-ci-mingw64:i686 CI_SCRIPT=ci/build-mingw64.sh TARGET=i686-w64-mingw32
-    - CONTAINER=registry.cirno.systems/kiwi/containers/mpv-ci-mingw64:x86_64 CI_SCRIPT=ci/build-mingw64.sh TARGET=x86_64-w64-mingw32
   global:
     # Coverity token
     - secure: "H21mSRlMhk4BKS0xHZvCFGJxteCP0hRVUxTuNfM2Z9HBsyutuLEYMtViLO86VtM+Tqla3xXPzUdS4ozLwI72Ax/5ZUDXACROj73yW6QhFB5D6rLut12+FjqC7M33Qv2hl0xwgNBmR5dsm1ToP37+Wn+ecJQNvN8fkTXF+HVzOEw="
@@ -30,10 +43,14 @@
     - /release\/.*$/
 
 before_install:
-  - docker pull $CONTAINER
+  - if [ "$TRAVIS_COMPILER" = "clang" ]; then export CXX="clang++"; fi
+  - if [ "$TRAVIS_COMPILER" = "gcc" ]; then export CXX="g++"; fi
+  - if [ "$TRAVIS_OS_NAME" = "linux" ]; then docker pull $CONTAINER; fi
+  - if [ "$TRAVIS_OS_NAME" = "osx" ]; then "$TRAVIS_BUILD_DIR/ci/get_ffmpeg.sh"; fi
 script:
   - ./bootstrap.py
-  - docker run --env CC --env TARGET -v $TRAVIS_BUILD_DIR:/build $CONTAINER /bin/sh -c "cd /build && $CI_SCRIPT"
+  - if [ "$TRAVIS_OS_NAME" = "linux" ]; then docker run --env CC --env TARGET -v $TRAVIS_BUILD_DIR:/build $CONTAINER /bin/sh -c "cd /build && $CI_SCRIPT"; fi
+  - if [ "$TRAVIS_OS_NAME" = "osx" ]; then ./ci/build-macos.sh; fi
 after_failure: cat ./build/config.log
 after_script: TOOLS/travis-rebuild-website
 
@@ -54,3 +71,16 @@
     build_command_prepend: "./bootstrap.py && ./waf configure"
     build_command:   "./waf build"
     branch_pattern: coverity_scan
+  homebrew:
+    packages:
+      - autoconf
+      - automake
+      - freetype
+      - fribidi
+      - libass
+      - libtool
+      - little-cms2
+      - luajit
+      - nasm
+      - pkg-config
+    update: true
diff -ruN mpv-0.29.1/DOCS/client-api-changes.rst mpv-master/DOCS/client-api-changes.rst
--- mpv-0.29.1/DOCS/client-api-changes.rst	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/DOCS/client-api-changes.rst	2019-09-19 04:02:03.000000000 +0700
@@ -31,6 +31,15 @@
 ===========
 
 ::
+ --- mpv 0.30.0 ---
+ 1.104  - Deprecate struct mpv_opengl_drm_params. Replaced by mpv_opengl_drm_params_v2
+        - Deprecate MPV_RENDER_PARAM_DRM_DISPLAY. Replaced by MPV_RENDER_PARAM_DRM_DISPLAY_V2.
+ 1.103  - redo handling of async commands
+        - add mpv_event_command and make it possible to return values from
+          commands issued with mpv_command_async() or mpv_command_node_async()
+        - add mpv_abort_async_command()
+ 1.102  - rename struct mpv_opengl_drm_osd_size to mpv_opengl_drm_draw_surface_size
+        - rename MPV_RENDER_PARAM_DRM_OSD_SIZE to MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE
 
  --- mpv 0.29.0 ---
  1.101  - add MPV_RENDER_PARAM_ADVANCED_CONTROL and related API
diff -ruN mpv-0.29.1/DOCS/compile-windows.md mpv-master/DOCS/compile-windows.md
--- mpv-0.29.1/DOCS/compile-windows.md	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/DOCS/compile-windows.md	2019-09-19 04:02:03.000000000 +0700
@@ -136,7 +136,7 @@
 
 # Install the most important MinGW-w64 dependencies. libass and lcms2 are also
 # pulled in as dependencies of ffmpeg.
-pacman -S $MINGW_PACKAGE_PREFIX-{ffmpeg,libjpeg-turbo,lua51,angleproject-git}
+pacman -S $MINGW_PACKAGE_PREFIX-{ffmpeg,libjpeg-turbo,lua51}
 ```
 
 Building mpv
diff -ruN mpv-0.29.1/DOCS/edl-mpv.rst mpv-master/DOCS/edl-mpv.rst
--- mpv-0.29.1/DOCS/edl-mpv.rst	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/DOCS/edl-mpv.rst	2019-09-19 04:02:03.000000000 +0700
@@ -147,6 +147,24 @@
 
 Plays chapter 3 and ends with the start of chapter 7 (4 chapters later).
 
+Implicit chapters
+=================
+
+mpv will add one chapter per segment entry to the virtual timeline.
+
+By default, the chapter's titles will match the entries' filenames.
+You can override set the ``title`` option to override the chapter title for
+that segment.
+
+Example::
+
+    # mpv EDL v0
+    cap.ts,5,240
+    OP.mkv,0,90,title=Show Opening
+
+The virtual timeline will have two chapters, one called "cap.ts" from 0-240s
+and a second one called "Show Opening" from 240-330s.
+
 Syntax of EDL URIs
 ==================
 
diff -ruN mpv-0.29.1/DOCS/interface-changes.rst mpv-master/DOCS/interface-changes.rst
--- mpv-0.29.1/DOCS/interface-changes.rst	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/DOCS/interface-changes.rst	2019-09-19 04:02:03.000000000 +0700
@@ -19,8 +19,75 @@
 
 ::
 
- --- mpv 0.29.1 ---
-    - add --cocoa-cb-sw-renderer to control the usage of Apple Software Renderer
+ --- mpv 0.30.0 ---
+    - rename `--drm-osd-plane-id` to `--drm-draw-plane`, `--drm-video-plane-id` to
+      `--drm-drmprime-video-plane` and `--drm-osd-size` to `--drm-draw-surface-size`
+      to better reflect what the options actually control, that the values they
+      accept aren't actually internal DRM ID's (like with similar options in
+      ffmpeg's KMS support), and that the video plane is only used when the drmprime
+      overlay hwdec interop is active, with the video being drawn to the draw plane
+      otherwise.
+    - in addition to the above, the `--drm-draw-plane` and `--drm-drmprime-video-plane`
+      options now accept either an integer index, or the values primary or overlay.
+      `--drm-draw-plane` now defaults to primary and `--drm-drmprime-video-plane`
+      defaults to overlay. This should be similar to previous behavior on most drivers
+      due to how planes are usually sorted.
+    - rename --opensles-frames-per-buffer to --opensles-frames-per-enqueue to
+      better reflect its purpose. In the past it overrides the buffer size the AO
+      requests (but not the default/value of the generic --audio-buffer option).
+      Now it only guarantees that the soft buffer size will not be smaller than
+      itself while setting the size per Enqueue.
+    - add --opensles-buffer-size-in-ms, allowing user to tune the soft buffer size.
+      It overrides the --audio-buffer option unless it's set to 0 (with the default
+      being 250).
+    - remove `--linear-scaling`, replaced by `--linear-upscaling` and
+      `--linear-downscaling`. This means that `--sigmoid-upscaling` no longer
+      implies linear light downscaling as well, which was confusing.
+    - the built-in `gpu-hq` profile now includes` --linear-downscaling`.
+    - support for `--spirv-compiler=nvidia` has been removed, leaving `shaderc`
+      as the only option. The `--spirv-compiler` option itself has been marked
+      as deprecated, and may be removed in the future.
+    - split up `--tone-mapping-desaturate`` into strength + exponent, instead of
+      only using a single value (which previously just controlled the exponent).
+      The strength now linearly blends between the linear and nonlinear tone
+      mapped versions of a color.
+    - add --hdr-peak-decay-rate and --hdr-scene-threshold-low/high
+    - add --tone-mapping-max-boost
+    - ipc: require that "request_id" fields are integers. Other types are still
+      accepted for compatibility, but this will stop in the future. Also, if no
+      request_id is provided, 0 will be assumed.
+    - mpv_command_node() and mp.command_native() now support named arguments
+      (see manpage). If you want to use them, use a new version of the manpage
+      as reference, which lists the definitive names.
+    - edition and disc title switching will now fully reload playback (may have
+      consequences for scripts, client API, or when using file-local options)
+    - with the removal of the stream cache, the following properties and options were
+      dropped: `cache`, `cache-size`, `cache-free`, `cache-used`, `--cache-default`,
+      `--cache-initial`, `--cache-seek-min`, `--cache-backbuffer`, `--cache-file`,
+      `--cache-file-size`
+    - remove async playback abort hack. This breaks aborting playback in the
+      following cases, iff the current stream is a network stream that
+      completely stopped responding:
+        - setting "program" property
+        - setting "cache-size" property
+      In earlier versions of mpv, the player core froze as well in these cases,
+      but could still be aborted with the quit, stop, playlist-prev,
+      playlist-next commands. If these properties are not accessed, frozen
+      network streams should not freeze the player core (only playback in
+      uncached regions), and differing behavior should be reported as a bug.
+      If --demuxer-thread=no is used, there are no guarantees.
+    - remove `--macos-title-bar-style`, replaced by `--macos-title-bar-material`
+      and `--macos-title-bar-appearance`.
+    - The default for `--vulkan-async-compute` has changed to `yes` from `no`
+      with the move to libplacebo as the back-end for vulkan rendering.
+    - Remove "disc-titles", "disc-title", "disc-title-list", and "angle"
+      properties. dvd:// does not support title ranges anymore.
+    - Remove all "tv-..." options and properties, along with the classic Linux
+      analog TV support.
+    - remove "program" property (no replacement)
+    - always prefer EGL over GLX, which helps with AMD/vaapi, but will break
+      vdpau with --vo=gpu - use --gpu-context=x11 to be able to use vdpau. This
+      does not affect --vo=vdpau or --hwdec=vdpau-copy.
  --- mpv 0.29.0 ---
     - drop --opensles-sample-rate, as --audio-samplerate should be used if desired
     - drop deprecated --videotoolbox-format, --ff-aid, --ff-vid, --ff-sid,
@@ -105,8 +172,6 @@
       of 3D content doesn't justify such an option anyway.
     - change cycle-values command to use the current value, instead of an
       internal counter that remembered the current position.
-    - edition and disc title switching will now fully reload playback (may have
-      consequences for scripts, client API, or when using file-local options)
     - remove deprecated ao/vo auto profiles. Consider using scripts like
       auto-profiles.lua instead.
  --- mpv 0.28.0 ---
diff -ruN mpv-0.29.1/DOCS/man/input.rst mpv-master/DOCS/man/input.rst
--- mpv-0.29.1/DOCS/man/input.rst	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/DOCS/man/input.rst	2019-09-19 04:02:03.000000000 +0700
@@ -41,10 +41,10 @@
 (Only closing the window will make **mpv** exit, pressing normal keys will
 merely display the binding, even if mapped to quit.)
 
-General Input Command Syntax
-----------------------------
+input.conf syntax
+-----------------
 
-``[Shift+][Ctrl+][Alt+][Meta+]<key> [{<section>}] [<prefixes>] <command> (<argument>)* [; <command>]``
+``[Shift+][Ctrl+][Alt+][Meta+]<key> [{<section>}] <command> ( ; <command> )*``
 
 Note that by default, the right Alt key can be used to create special
 characters, and thus does not register as a modifier. The option
@@ -59,9 +59,9 @@
 ``<section>`` (braced with ``{`` and ``}``) is the input section for this
 command.
 
-Arguments are separated by whitespace. This applies even to string arguments.
-For this reason, string arguments should be quoted with ``"``. Inside quotes,
-C-style escaping can be used.
+``<command>`` is the command itself. It consists of the command name and
+multiple (or none) commands, all separated by whitespace. String arguments
+need to be quoted with ``"``. Details see ``Flat command syntax``.
 
 You can bind multiple commands to one key. For example:
 
@@ -78,15 +78,89 @@
 can be remapped to ``ignore`` in order to avoid this issue. The maximum number
 of (non-modifier) keys for combinations is currently 4.
 
+Flat command syntax
+-------------------
+
+This is the syntax used in input.conf, and referred to "input.conf syntax" in
+a number of other places.
+
+``<command> ::= [<prefixes>] <command_name> (<argument>)*``
+``<argument> ::= (<string> | " <quoted_string> " )``
+
+``command_name`` is an unquoted string with the command name itself. See
+`List of Input Commands`_ for a list.
+
+Arguments are separated by whitespace. This applies even to string arguments.
+For this reason, string arguments should be quoted with ``"``. If a string
+argument contains spaces or certain special characters, quoting and possibly
+escaping is mandatory, or the command cannot be parsed correctly.
+
+Inside quotes, C-style escaping can be used. JSON escapes according to RFC 8259,
+minus surrogate pair escapes, should be a safe subset that can be used.
+
+Commands specified as arrays
+----------------------------
+
+This applies to certain APIs, such as ``mp.commandv()`` or
+``mp.command_native()`` (with array parameters) in Lua scripting, or
+``mpv_command()`` or ``mpv_command_node()`` (with MPV_FORMAT_NODE_ARRAY) in the
+C libmpv client API.
+
+The command as well as all arguments are passed as a single array. Similar to
+the `Flat command syntax`_, you can first pass prefixes as strings (each as
+separate array item), then the command name as string, and then each argument
+as string or a native value.
+
+Since these APIs pass arguments as separate strings or native values, they do
+not expect quotes, and do support escaping. Technically, there is the input.conf
+parser, which first splits the command string into arguments, and then invokes
+argument parsers for each argument. The input.conf parser normally handles
+quotes and escaping. The array command APIs mentioned above pass strings
+directly to the argument parsers, or can sidestep them by the ability to pass
+non-string values.
+
+Sometimes commands have string arguments, that in turn are actually parsed by
+other components (e.g. filter strings with ``vf add``) - in these cases, you
+you would have to double-escape in input.conf, but not with the array APIs.
+
+For complex commands, consider using `Named arguments`_ instead, which should
+give slightly more compatibility. Some commands do not support named arguments
+and inherently take an array, though.
+
+Named arguments
+---------------
+
+This applies to certain APIs, such as ``mp.command_native()`` (with tables that
+have string keys) in Lua scripting, or ``mpv_command_node()`` (with
+MPV_FORMAT_NODE_MAP) in the C libmpv client API.
+
+Like with array commands, quoting and escaping is inherently not needed in the
+normal case.
+
+The name of each command is defined in each command description in the
+`List of Input Commands`_. ``--input-cmdlist`` also lists them.
+
+Some commands do not support named arguments (e.g. ``run`` command). You need
+to use APIs that pass arguments as arrays.
+
+Named arguments are not supported in the "flat" input.conf syntax, which means
+you cannot use them for key bindings in input.conf at all.
+
 List of Input Commands
 ----------------------
 
+Commands with parameters have the parameter name enclosed in ``<`` / ``>``.
+Don't add those to the actual command. Optional arguments are enclosed in
+``[`` / ``]``. If you don't pass them, they will be set to a default value.
+
+Remember to quote string arguments in input.conf (see `Flat command syntax`_).
+
 ``ignore``
     Use this to "block" keys that should be unbound, and do nothing. Useful for
     disabling default bindings, without disabling all bindings with
     ``--no-input-default-bindings``.
 
-``seek <seconds> [relative|absolute|absolute-percent|relative-percent|exact|keyframes]``
+``seek <target> [<flags>]``
     Change the playback position. By default, seeks by a relative amount of
     seconds.
 
@@ -107,14 +181,15 @@
 
     Multiple flags can be combined, e.g.: ``absolute+keyframes``.
 
-    By default, ``keyframes`` is used for relative seeks, and ``exact`` is used
-    for absolute seeks.
+    By default, ``keyframes`` is used for ``relative``, ``relative-percent``,
+    and ``absolute-percent`` seeks, while ``exact`` is used for ``absolute``
+    seeks.
 
     Before mpv 0.9, the ``keyframes`` and ``exact`` flags had to be passed as
     3rd parameter (essentially using a space instead of ``+``). The 3rd
     parameter is still parsed, but is considered deprecated.
 
-``revert-seek [mode]``
+``revert-seek [<flags>]``
     Undoes the ``seek`` command, and some other commands that seek (but not
     necessarily all of them). Calling this command once will jump to the
     playback position before the seek. Calling it a second time undoes the
@@ -144,22 +219,24 @@
 
     This does not work with audio-only playback.
 
-``set <property> "<value>"``
-    Set the given property to the given value.
-
-``add <property> [<value>]``
-    Add the given value to the property. On overflow or underflow, clamp the
-    property to the maximum. If ``<value>`` is omitted, assume ``1``.
-
-``cycle <property> [up|down]``
-    Cycle the given property. ``up`` and ``down`` set the cycle direction. On
-    overflow, set the property back to the minimum, on underflow set it to the
-    maximum. If ``up`` or ``down`` is omitted, assume ``up``.
+``set <name> <value>``
+    Set the given property or option to the given value.
 
-``multiply <property> <factor>``
-    Multiplies the value of a property with the numeric factor.
+``add <name> [<value>]``
+    Add the given value to the property or option. On overflow or underflow,
+    clamp the property to the maximum. If ``<value>`` is omitted, assume ``1``.
+
+``cycle <name> [<value>]``
+    Cycle the given property or option. The second argument can be ``up`` or
+    ``down`` to set the cycle direction. On overflow, set the property back to
+    the minimum, on underflow set it to the maximum. If ``up`` or ``down`` is
+    omitted, assume ``up``.
+
+``multiply <name> <value>``
+    Similar to ``add``, but multiplies the property or option with the numeric
+    value.
 
-``screenshot [subtitles|video|window|single|each-frame]``
+``screenshot <flags>``
     Take a screenshot.
 
     Multiple flags are available (some can be combined with ``+``):
@@ -186,45 +263,46 @@
     second argument (and did not have flags). This syntax is still understood,
     but deprecated and might be removed in the future.
 
-    Setting the ``async`` flag will make encoding and writing the actual image
-    file asynchronous in most cases. (``each-frame`` mode ignores this flag
-    currently.) Requesting async screenshots too early or too often could lead
-    to the same filenames being chosen, and overwriting each others in undefined
-    order.
+    If you combine this command with another one using ``;``, you can use the
+    ``async`` flag to make encoding/writing the image file asynchronous. For
+    normal standalone commands, this is always asynchronous, and the flag has
+    no effect. (This behavior changed with mpv 0.29.0.)
 
-``screenshot-to-file "<filename>" [subtitles|video|window]``
+``screenshot-to-file <filename> <flags>``
     Take a screenshot and save it to a given file. The format of the file will
     be guessed by the extension (and ``--screenshot-format`` is ignored - the
     behavior when the extension is missing or unknown is arbitrary).
 
-    The second argument is like the first argument to ``screenshot``.
+    The second argument is like the first argument to ``screenshot`` and
+    supports ``subtitles``, ``video``, ``window``.
 
     If the file already exists, it's overwritten.
 
     Like all input command parameters, the filename is subject to property
     expansion as described in `Property Expansion`_.
 
-    The ``async`` flag has an effect on this command (see ``screenshot``
-    command).
-
-``playlist-next [weak|force]``
+``playlist-next <flags>``
     Go to the next entry on the playlist.
 
+    First argument:
+
     weak (default)
         If the last file on the playlist is currently played, do nothing.
     force
         Terminate playback if there are no more files on the playlist.
 
-``playlist-prev [weak|force]``
+``playlist-prev <flags>``
     Go to the previous entry on the playlist.
 
+    First argument:
+
     weak (default)
         If the first file on the playlist is currently played, do nothing.
     force
         Terminate playback if the first file is being played.
 
-``loadfile "<file>" [replace|append|append-play [options]]``
-    Load the given file and play it.
+``loadfile <url> [<flags> [<options>]]``
+    Load the given file or URL and play it.
 
     Second argument:
 
@@ -242,13 +320,20 @@
     Not all options can be changed this way. Some options require a restart
     of the player.
 
-``loadlist "<playlist>" [replace|append]``
-    Load the given playlist file (like ``--playlist``).
+``loadlist <url> [<flags>]``
+    Load the given playlist file or URL (like ``--playlist``).
+
+    Second argument:
+
+    <replace> (default)
+        Stop playback and replace the internal playlist with the new one.
+    <append>
+        Append the new playlist at the end of the current internal playlist.
 
 ``playlist-clear``
     Clear the playlist, except the currently played file.
 
-``playlist-remove current|<index>``
+``playlist-remove <index>``
     Remove the playlist entry at the given index. Index values start counting
     with 0. The special value ``current`` removes the current entry. Note that
     removing the current entry also stops playback and starts playing the next
@@ -265,12 +350,14 @@
     Shuffle the playlist. This is similar to what is done on start if the
     ``--shuffle`` option is used.
 
-``run "command" "arg1" "arg2" ...``
+``run <command> [<arg1> [<arg2> [...]]]``
     Run the given command. Unlike in MPlayer/mplayer2 and earlier versions of
     mpv (0.2.x and older), this doesn't call the shell. Instead, the command
     is run directly, with each argument passed separately. Each argument is
-    expanded like in `Property Expansion`_. Note that there is a static limit
-    of (as of this writing) 9 arguments (this limit could be raised on demand).
+    expanded like in `Property Expansion`_.
+
+    This command has a variable number of arguments, and cannot be used with
+    named arguments.
 
     The program is run in a detached way. mpv doesn't wait until the command
     is completed, but continues playback right after spawning it.
@@ -287,6 +374,81 @@
         execute arbitrary shell commands. It is recommended to write a small
         shell script, and call that with ``run``.
 
+``subprocess``
+    Similar to ``run``, but gives more control about process execution to the
+    caller, and does does not detach the process.
+
+    This has the following named arguments. The order of them is not guaranteed,
+    so you should always call them with named arguments, see `Named arguments`_.
+
+    ``args`` (``MPV_FORMAT_NODE_ARRAY[MPV_FORMAT_STRING]``)
+        Array of strings with the command as first argument, and subsequent
+        command line arguments following. This is just like the ``run`` command
+        argument list.
+
+        The first array entry is either an absolute path to the executable, or
+        a filename with no path components, in which case the ``PATH``
+        environment variable. On Unix, this is equivalent to ``posix_spawnp``
+        and ``execvp`` behavior.
+
+    ``playback_only`` (``MPV_FORMAT_FLAG``)
+        Boolean indicating whether the process should be killed when playback
+        terminates (optional, default: yes). If enabled, stopping playback
+        will automatically kill the process, and you can't start it outside of
+        playback.
+
+    ``capture_size`` (``MPV_FORMAT_INT64``)
+        Integer setting the maximum number of stdout plus stderr bytes that can
+        be captured (optional, default: 64MB). If the number of bytes exceeds
+        this, capturing is stopped. The limit is per captured stream.
+
+    ``capture_stdout`` (``MPV_FORMAT_FLAG``)
+        Capture all data the process outputs to stdout and return it once the
+        process ends (optional, default: no).
+
+    ``capture_stderr`` (``MPV_FORMAT_FLAG``)
+        Same as ``capture_stdout``, but for stderr.
+
+    The command returns the following result (as ``MPV_FORMAT_NODE_MAP``):
+
+    ``status`` (``MPV_FORMAT_INT64``)
+        The raw exit status of the process. It will be negative on error. The
+        meaning of negative values is undefined, other than meaning error (and
+        does not necessarily correspond to OS low level exit status values).
+
+        On Windows, it can happen that a negative return value is returned
+        even if the process exits gracefully, because the win32 ``UINT`` exit
+        code is assigned to an ``int`` variable before being set as ``int64_t``
+        field in the result map. This might be fixed later.
+
+    ``stdout`` (``MPV_FORMAT_BYTE_ARRAY``)
+        Captured stdout stream, limited to ``capture_size``.
+
+    ``stderr`` (``MPV_FORMAT_BYTE_ARRAY``)
+        Same as ``stdout``, but for stderr.
+
+    ``error_string`` (``MPV_FORMAT_STRING``)
+        Empty string if the process exited gracefully. The string ``killed`` if
+        the process was terminated in an unusual way. The string ``init`` if the
+        process could not be started.
+
+        On Windows, ``killed`` is only returned when the process has been
+        killed by mpv as a result of ``playback_only`` being set to ``yes``.
+
+    ``killed_by_us`` (``MPV_FORMAT_FLAG``)
+        Set to ``yes`` if the process has been killed by mpv as a result
+        of ``playback_only`` being set to ``yes``.
+
+    Note that the command itself will always return success as long as the
+    parameters are correct. Whether the process could be spawned or whether
+    it was somehow killed or returned an error status has to be queried from
+    the result value.
+
+    This command can be asynchronously aborted via API.
+
+    In all cases, the subprocess will be terminated on player exit. Only the
+    ``run`` command can start processes in a truly detached way.
+
 ``quit [<code>]``
     Exit the player. If an argument is given, it's used as process exit code.
 
@@ -295,15 +457,15 @@
     will seek to the previous position on start. The (optional) argument is
     exactly as in the ``quit`` command.
 
-``sub-add "<file>" [<flags> [<title> [<lang>]]]``
-    Load the given subtitle file. It is selected as current subtitle after
-    loading.
+``sub-add <url> [<flags> [<title> [<lang>]]]``
+    Load the given subtitle file or stream. By default, it is selected as
+    current subtitle  after loading.
 
-    The ``flags`` args is one of the following values:
+    The ``flags`` argument is one of the following values:
 
     <select>
 
-        Select the subtitle immediately.
+        Select the subtitle immediately (default).
 
     <auto>
 
@@ -346,11 +508,11 @@
     events that have already been displayed, or are within a short prefetch
     range.
 
-``print-text "<string>"``
+``print-text <text>``
     Print text to stdout. The string can contain properties (see
-    `Property Expansion`_).
+    `Property Expansion`_). Take care to put the argument in quotes.
 
-``show-text "<string>" [<duration>|-1 [<level>]]``
+``show-text <text> [<duration>|-1 [<level>]]``
     Show text on the OSD. The string can contain properties, which are expanded
     as described in `Property Expansion`_. This can be used to show playback
     time, filename, and so on.
@@ -362,7 +524,7 @@
     <level>
         The minimum OSD level to show the text at (see ``--osd-level``).
 
-``expand-text "<string>"``
+``expand-text <string>``
     Property-expand the argument and return the expanded string. This can be
     used only through the client API or from a script using
     ``mp.command_native``. (see `Property Expansion`_).
@@ -380,7 +542,7 @@
     essentially like ``quit``. Useful for the client API: playback can be
     stopped without terminating the player.
 
-``mouse <x> <y> [<button> [single|double]]``
+``mouse <x> <y> [<button> [<mode>]]``
     Send a mouse event with given coordinate (``<x>``, ``<y>``).
 
     Second argument:
@@ -397,24 +559,24 @@
     <double>
         The mouse event represents double-click.
 
-``keypress <key_name>``
+``keypress <name>``
     Send a key event through mpv's input handler, triggering whatever
-    behavior is configured to that key. ``key_name`` uses the ``input.conf``
+    behavior is configured to that key. ``name`` uses the ``input.conf``
     naming scheme for keys and modifiers. Useful for the client API: key events
     can be sent to libmpv to handle internally.
 
-``keydown <key_name>``
+``keydown <name>``
     Similar to ``keypress``, but sets the ``KEYDOWN`` flag so that if the key is
     bound to a repeatable command, it will be run repeatedly with mpv's key
     repeat timing until the ``keyup`` command is called.
 
-``keyup [<key_name>]``
+``keyup [<name>]``
     Set the ``KEYUP`` flag, stopping any repeated behavior that had been
-    triggered. ``key_name`` is optional. If ``key_name`` is not given or is an
+    triggered. ``name`` is optional. If ``name`` is not given or is an
     empty string, ``KEYUP`` will be set on all keys. Otherwise, ``KEYUP`` will
-    only be set on the key specified by ``key_name``.
+    only be set on the key specified by ``name``.
 
-``audio-add "<file>" [<flags> [<title> [<lang>]]]``
+``audio-add <url> [<flags> [<title> [<lang>]]]``
     Load the given audio file. See ``sub-add`` command.
 
 ``audio-remove [<id>]``
@@ -442,21 +604,21 @@
 Input Commands that are Possibly Subject to Change
 --------------------------------------------------
 
-``af set|add|toggle|del|clr "filter1=params,filter2,..."``
+``af <operation> <value>``
     Change audio filter chain. See ``vf`` command.
 
-``vf set|add|toggle|del|clr "filter1=params,filter2,..."``
+``vf <operation> <value>``
     Change video filter chain.
 
     The first argument decides what happens:
 
-    set
+    <set>
         Overwrite the previous filter chain with the new one.
 
-    add
+    <add>
         Append the new filter chain to the previous one.
 
-    toggle
+    <toggle>
         Check if the given filter (with the exact parameters) is already
         in the video chain. If yes, remove the filter. If no, add the filter.
         (If several filters are passed to the command, this is done for
@@ -466,14 +628,14 @@
         without filter name and parameters as filter entry. This toggles the
         enable/disable flag.
 
-    del
+    <del>
         Remove the given filters from the video chain. Unlike in the other
         cases, the second parameter is a comma separated list of filter names
         or integer indexes. ``0`` would denote the first filter. Negative
         indexes start from the last filter, and ``-1`` denotes the last
         filter.
 
-    clr
+    <clr>
         Remove all filters. Note that like the other sub-commands, this does
         not control automatically inserted filters.
 
@@ -512,18 +674,21 @@
           "disabled" flag for the filter with the label ``deband`` when the
           ``a`` key is hit.
 
-``cycle-values ["!reverse"] <property> "<value1>" "<value2>" ...``
+``cycle-values [<"!reverse">] <property> <value1> [<value2> [...]]``
     Cycle through a list of values. Each invocation of the command will set the
     given property to the next value in the list. The command will use the
     current value of the property/option, and use it to determine the current
     position in the list of values. Once it has found it, it will set the
     next value in the list (wrapping around to the first item if needed).
 
+    This command has a variable number of arguments, and cannot be used with
+    named arguments.
+
     The special argument ``!reverse`` can be used to cycle the value list in
     reverse. The only advantage is that you don't need to reverse the value
     list yourself when adding a second key binding for cycling backwards.
 
-``enable-section "<section>" [flags]``
+``enable-section <name> [<flags>]``
     Enable all key bindings in the named input section.
 
     The enabled input sections form a stack. Bindings in sections on the top of
@@ -545,10 +710,10 @@
     <allow-vo-dragging>
         Same.
 
-``disable-section "<section>"``
+``disable-section <name>``
     Disable the named input section. Undoes ``enable-section``.
 
-``define-section "<section>" "<contents>" [default|force]``
+``define-section <name> <contents> [<flags>]``
     Create a named input section, or replace the contents of an already existing
     input section. The ``contents`` parameter uses the same syntax as the
     ``input.conf`` file (except that using the section syntax in it is not
@@ -576,7 +741,7 @@
     information about the key state. The special key name ``unmapped`` can be
     used to match any unmapped key.
 
-``overlay-add <id> <x> <y> "<file>" <offset> "<fmt>" <w> <h> <stride>``
+``overlay-add <id> <x> <y> <file> <offset> <fmt> <w> <h> <stride>``
     Add an OSD overlay sourced from raw data. This might be useful for scripts
     and applications controlling mpv, and which want to display things on top
     of the video window.
@@ -587,6 +752,9 @@
     anamorphic video (such as DVD), ``osd-par`` should be read as well, and the
     overlay should be aspect-compensated.
 
+    This has the following named arguments. The order of them is not guaranteed,
+    so you should always call them with named arguments, see `Named arguments`_.
+
     ``id`` is an integer between 0 and 63 identifying the overlay element. The
     ID can be used to add multiple overlay parts, update a part by using this
     command with an already existing ID, or to remove a part with
@@ -644,18 +812,24 @@
     Remove an overlay added with ``overlay-add`` and the same ID. Does nothing
     if no overlay with this ID exists.
 
-``script-message "<arg1>" "<arg2>" ...``
+``script-message [<arg1> [<arg2> [...]]]``
     Send a message to all clients, and pass it the following list of arguments.
     What this message means, how many arguments it takes, and what the arguments
     mean is fully up to the receiver and the sender. Every client receives the
     message, so be careful about name clashes (or use ``script-message-to``).
 
-``script-message-to "<target>" "<arg1>" "<arg2>" ...``
+    This command has a variable number of arguments, and cannot be used with
+    named arguments.
+
+``script-message-to <target> [<arg1> [<arg2> [...]]]``
     Same as ``script-message``, but send it only to the client named
     ``<target>``. Each client (scripts etc.) has a unique name. For example,
     Lua scripts can get their name via ``mp.get_script_name()``.
 
-``script-binding "<name>"``
+    This command has a variable number of arguments, and cannot be used with
+    named arguments.
+
+``script-binding <name>``
     Invoke a script-provided key binding. This can be used to remap key
     bindings provided by external Lua scripts.
 
@@ -692,7 +866,7 @@
     unseekable streams that are going out of sync.
     This command might be changed or removed in the future.
 
-``screenshot-raw [subtitles|video|window]``
+``screenshot-raw [<flags>]``
     Return a screenshot in memory. This can be used only through the client
     API. The MPV_FORMAT_NODE_MAP returned by this command has the ``w``, ``h``,
     ``stride`` fields set to obvious contents. The ``format`` field is set to
@@ -702,7 +876,10 @@
     is freed as soon as the result mpv_node is freed. As usual with client API
     semantics, you are not allowed to write to the image data.
 
-``vf-command "<label>" "<cmd>" "<args>"``
+    The ``flags`` argument is like the first argument to ``screenshot`` and
+    supports ``subtitles``, ``video``, ``window``.
+
+``vf-command <label> <command> <argument>``
     Send a command to the filter with the given ``<label>``. Use ``all`` to send
     it to all filters at once. The command and argument string is filter
     specific. Currently, this only works with the ``lavfi`` filter - see
@@ -711,10 +888,10 @@
     Note that the ``<label>`` is a mpv filter label, not a libavfilter filter
     name.
 
-``af-command "<label>" "<cmd>" "<args>"``
+``af-command <label> <command> <argument>``
     Same as ``vf-command``, but for audio filters.
 
-``apply-profile "<name>"``
+``apply-profile <name>``
     Apply the contents of a named profile. This is like using ``profile=name``
     in a config file, except you can map it to a key binding to change it at
     runtime.
@@ -722,14 +899,14 @@
     There is no such thing as "unapplying" a profile - applying a profile
     merely sets all option values listed within the profile.
 
-``load-script "<path>"``
+``load-script <filename>``
     Load a script, similar to the ``--script`` option. Whether this waits for
     the script to finish initialization or not changed multiple times, and the
     future behavior is left undefined.
 
-``change-list "<option>" "<operation>" "<value>"``
+``change-list <name> <operation> <value>``
     This command changes list options as described in `List Options`_. The
-    ``<option>`` parameter is the normal option name, while ``<operation>`` is
+    ``<name>`` parameter is the normal option name, while ``<operation>`` is
     the suffix or action used on the option.
 
     Some operations take no value, but the command still requires the value
@@ -744,8 +921,7 @@
         ``--glsl-shader=file.glsl``.
 
 
-Undocumented commands: ``tv-last-channel`` (TV/DVB only),
-``ao-reload`` (experimental/internal).
+Undocumented commands: ``ao-reload`` (experimental/internal).
 
 Hooks
 ~~~~~
@@ -870,11 +1046,49 @@
     are asynchronous by default (or rather, their effects might manifest
     after completion of the command). The semantics of this flag might change
     in the future. Set it only if you don't rely on the effects of this command
-    being fully realized when it returns.
+    being fully realized when it returns. See `Synchronous vs. Asynchronous`_.
+``sync``
+    Allow synchronous execution (if possible). Normally, all commands are
+    synchronous by default, but some are asynchronous by default for
+    compatibility with older behavior.
 
 All of the osd prefixes are still overridden by the global ``--osd-level``
 settings.
 
+Synchronous vs. Asynchronous
+----------------------------
+
+The ``async`` and ``sync`` prefix matter only for how the issuer of the command
+waits on the completion of the command. Normally it does not affect how the
+command behaves by itself. There are the following cases:
+
+- Normal input.conf commands are always run asynchronously. Slow running
+  commands are queued up or run in parallel.
+- "Multi" input.conf commands (1 key binding, concatenated with ``;``) will be
+  executed in order, except for commands that are async (either prefixed with
+  ``async``, or async by default for some commands). The async commands are
+  run in a detached manner, possibly in parallel to the remaining sync commands
+  in the list.
+- Normal Lua and libmpv commands (e.g. ``mpv_command()``) are run in a blocking
+  manner, unless the ``async`` prefix is used, or the command is async by
+  default. This means in the sync case the caller will block, even if the core
+  continues playback. Async mode runs the command in a detached manner.
+- Async libmpv command API (e.g. ``mpv_command_async()``) never blocks the
+  caller, and always notify their completion with a message. The ``sync`` and
+  ``async`` prefixes make no difference.
+- In all cases, async mode can still run commands in a synchronous manner, even
+  in detached mode. This can for example happen in cases when a command does not
+  have an  asynchronous implementation. The async libmpv API still never blocks
+  the caller in these cases.
+
+Before mpv 0.29.0, the ``async`` prefix was only used by screenshot commands,
+and made them run the file saving code in a detached manner. This is the
+default now, and ``async`` changes behavior only in the ways mentioned above.
+
+Currently the following commands have different waiting characteristics with
+sync vs. async: sub-add, audio-add, sub-reload, audio-reload,
+rescan-external-files, screenshot, screenshot-to-file.
+
 Input Sections
 --------------
 
@@ -967,8 +1181,6 @@
 ``media-title``
     If the currently played file has a ``title`` tag, use that.
 
-    Otherwise, if the media type is DVD, return the volume ID of DVD.
-
     Otherwise, return the ``filename`` property.
 
 ``file-format``
@@ -1081,40 +1293,6 @@
     Current MKV edition number. Setting this property to a different value will
     restart playback. The number of the first edition is 0.
 
-``disc-titles``
-    Number of BD/DVD titles.
-
-    This has a number of sub-properties. Replace ``N`` with the 0-based edition
-    index.
-
-    ``disc-titles/count``
-        Number of titles.
-
-    ``disc-titles/id``
-        Title ID as integer. Currently, this is the same as the title index.
-
-    ``disc-titles/length``
-        Length in seconds. Can be unavailable in a number of cases (currently
-        it works for libdvdnav only).
-
-    When querying the property with the client API using ``MPV_FORMAT_NODE``,
-    or with Lua ``mp.get_property_native``, this will return a mpv_node with
-    the following contents:
-
-    ::
-
-        MPV_FORMAT_NODE_ARRAY
-            MPV_FORMAT_NODE_MAP (for each edition)
-                "id"                MPV_FORMAT_INT64
-                "length"            MPV_FORMAT_DOUBLE
-
-``disc-title-list``
-    List of BD/DVD titles.
-
-``disc-title`` (RW)
-    Current BD/DVD title number. Writing works only for ``dvdnav://`` and
-    ``bd://`` (and aliases for these).
-
 ``chapters``
     Number of chapters.
 
@@ -1154,9 +1332,6 @@
                 "title"             MPV_FORMAT_STRING
                 "default"           MPV_FORMAT_FLAG
 
-``angle`` (RW)
-    Current DVD angle.
-
 ``metadata``
     Metadata key/value pairs.
 
@@ -1241,38 +1416,11 @@
     playing at all. In other words, it's only ``no`` if there's actually
     video playing. (Behavior since mpv 0.7.0.)
 
-``cache``
-    Network cache fill state (0-100.0).
-
-``cache-size`` (RW)
-    Network cache size in KB. This is similar to ``--cache``. This allows
-    setting the cache size at runtime. Currently, it's not possible to enable
-    or disable the cache at runtime using this property, just to resize an
-    existing cache.
-
-    This does not include the backbuffer size (changed after mpv 0.10.0).
-
-    Note that this tries to keep the cache contents as far as possible. To make
-    this easier, the cache resizing code will allocate the new cache while the
-    old cache is still allocated.
-
-    Don't use this when playing DVD or Blu-ray.
-
-``cache-free`` (R)
-    Total free cache size in KB.
-
-``cache-used`` (R)
-    Total used cache size in KB.
-
 ``cache-speed`` (R)
     Current I/O read speed between the cache and the lower layer (like network).
     This gives the number bytes per seconds over a 1 second window (using
     the type ``MPV_FORMAT_INT64`` for the client API).
 
-``cache-idle`` (R)
-    Returns ``yes`` if the cache is idle, which means the cache is filled as
-    much as possible, and is currently not reading more data.
-
 ``demuxer-cache-duration``
     Approximate duration of video buffered in the demuxer, in seconds. The
     guess is very unreliable, and often the property will not be available
@@ -1542,7 +1690,8 @@
         Intended display rotation in degrees (clockwise).
 
     ``video-params/stereo-in``
-        Source file stereo 3D mode. (See ``--video-stereo-mode`` option.)
+        Source file stereo 3D mode. (See the ``format`` video filter's
+        ``stereo-in`` option.)
 
     When querying the property with the client API using ``MPV_FORMAT_NODE``,
     or with Lua ``mp.get_property_native``, this will return a mpv_node with
@@ -1630,7 +1779,9 @@
     are the xrandr names (LVDS1, HDMI1, DP1, VGA1, etc.). On Windows, these
     are the GDI names (\\.\DISPLAY1, \\.\DISPLAY2, etc.) and the first display
     in the list will be the one that Windows considers associated with the
-    window (as determined by the MonitorFromWindow API.)
+    window (as determined by the MonitorFromWindow API.) On macOS these are the
+    Display Product Names as used in the System Information and only one display
+    name is returned since a window can only be on one screen.
 
 ``display-fps`` (RW)
     The refresh rate of the current display. Currently, this is the lowest FPS
@@ -1661,18 +1812,6 @@
 ``osd-par``
     Last known OSD display pixel aspect (can be 0).
 
-``program`` (W)
-    Switch TS program (write-only).
-
-``dvb-channel`` (W)
-    Pair of integers: card,channel of current DVB stream.
-    Can be switched to switch to another channel on the same card.
-
-``dvb-channel-name`` (RW)
-    Name of current DVB program.
-    On write, a channel-switch to the named channel on the same
-    card is performed. Can also be used for channel switching.
-
 ``sub-text``
     Return the current subtitle text. Formatting is stripped. If a subtitle
     is selected, but no text is currently visible, or the subtitle is not
@@ -1680,9 +1819,6 @@
 
     This property is experimental and might be removed in the future.
 
-``tv-brightness``, ``tv-contrast``, ``tv-saturation``, ``tv-hue`` (RW)
-    TV stuff.
-
 ``playlist-pos`` (RW)
     Current position on playlist. The first entry is on position 0. Writing
     to the property will restart playback at the written entry.
diff -ruN mpv-0.29.1/DOCS/man/ipc.rst mpv-master/DOCS/man/ipc.rst
--- mpv-0.29.1/DOCS/man/ipc.rst	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/DOCS/man/ipc.rst	2019-09-19 04:02:03.000000000 +0700
@@ -74,6 +74,12 @@
 Protocol
 --------
 
+The protocol uses UTF-8-only JSON as defined by RFC-8259. Unlike standard JSON,
+"\u" escape sequences are not allowed to construct surrogate pairs. To avoid
+getting conflicts, encode all text characters including and above codepoint
+U+0020 as UTF-8. mpv might output broken UTF-8 in corner cases (see "UTF-8"
+section below).
+
 Clients can execute commands on the player by sending JSON messages of the
 following form:
 
@@ -108,7 +114,10 @@
 which response goes with which command. Commands may optionally include a
 ``request_id`` which, if provided in the command request, will be copied
 verbatim into the response. mpv does not intrepret the ``request_id`` in any
-way; it is solely for the use of the requester.
+way; it is solely for the use of the requester. The only requirement is that
+the ``request_id`` field must be an integer (a number without fractional parts
+in the range ``-2^63..2^63-1``). Using other types is deprecated and will
+currently show a warning. In the future, this will raise an error.
 
 For example, this request:
 
@@ -122,6 +131,11 @@
 
     { "error": "success", "data": 1.468135, "request_id": 100 }
 
+If you don't specify a ``request_id``, command replies will set it to 0.
+
+Commands may run asynchronously in the future, instead of blocking the  socket
+until a reply is sent.
+
 All commands, replies, and events are separated from each other with a line
 break character (``\n``).
 
@@ -258,4 +272,28 @@
 parser, it should filter the raw data for invalid UTF-8 sequences and perform
 the desired replacement, before feeding the data to its JSON parser.
 
-mpv will not attempt to construct invalid UTF-8 with broken escape sequences.
+mpv will not attempt to construct invalid UTF-8 with broken "\u" escape
+sequences. This includes surrogate pairs.
+
+JSON extensions
+---------------
+
+The following non-standard extensions are supported:
+
+    - a list or object item can have a trailing ","
+    - object syntax accepts "=" in addition of ":"
+    - object keys can be unquoted, if they start with a character in "A-Za-z\_"
+      and contain only characters in "A-Za-z0-9\_"
+    - byte escapes with "\xAB" are allowed (with AB being a 2 digit hex number)
+
+Example:
+
+::
+
+    { objkey = "value\x0A" }
+
+Is equivalent to:
+
+::
+
+    { "objkey": "value\n" }
diff -ruN mpv-0.29.1/DOCS/man/javascript.rst mpv-master/DOCS/man/javascript.rst
--- mpv-0.29.1/DOCS/man/javascript.rst	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/DOCS/man/javascript.rst	2019-09-19 04:02:03.000000000 +0700
@@ -88,7 +88,7 @@
 
 (LE) - Last-Error, indicates that ``mp.last_error()`` can be used after the
 call to test for success (empty string) or failure (non empty reason string).
-Otherwise, where the Lua APIs return ``nil`` on error, JS returns ``undefined``.
+Where the Lua APIs use ``nil`` to indicate error, JS APIs use ``undefined``.
 
 ``mp.command(string)`` (LE)
 
@@ -96,6 +96,11 @@
 
 ``mp.command_native(table [,def])`` (LE)
 
+``id = mp.command_native_async(table [,fn])`` (LE) Notes: ``id`` is true-thy on
+success, ``fn`` is called always a-sync, ``error`` is empty string on success.
+
+``mp.abort_async_command(id)``
+
 ``mp.get_property(name [,def])`` (LE)
 
 ``mp.get_property_osd(name [,def])`` (LE)
diff -ruN mpv-0.29.1/DOCS/man/lua.rst mpv-master/DOCS/man/lua.rst
--- mpv-0.29.1/DOCS/man/lua.rst	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/DOCS/man/lua.rst	2019-09-19 04:02:03.000000000 +0700
@@ -109,12 +109,43 @@
 ``mp.command_native(table [,def])``
     Similar to ``mp.commandv``, but pass the argument list as table. This has
     the advantage that in at least some cases, arguments can be passed as
-    native types.
+    native types. It also allows you to use named argument.
+
+    If the table is an array, each array item is like an argument in
+    ``mp.commandv()`` (but can be a native type instead of a string).
+
+    If the table contains string keys, it's interpreted as command with named
+    arguments. This requires at least an entry with the key ``name`` to be
+    present, which must be a string, and contains the command name. The special
+    entry ``_flags`` is optional, and if present, must be an array of
+    `Input Command Prefixes`_ to apply. All other entries are interpreted as
+    arguments.
 
     Returns a result table on success (usually empty), or ``def, error`` on
     error. ``def`` is the second parameter provided to the function, and is
     nil if it's missing.
 
+``mp.command_native_async(table [,fn])``
+    Like ``mp.command_native()``, but the command is ran asynchronously (as far
+    as possible), and upon completion, fn is called. fn has two arguments:
+    ``fn(success, result, error)``. ``success`` is always a Boolean and is true
+    if the command was successful, otherwise false. The second parameter is
+    the result value (can be nil) in case of success, nil otherwise (as returned
+    by ``mp.command_native()``). The third parameter is the error string in case
+    of an error, nil otherwise.
+
+    Returns a table with undefined contents, which can be used as argument for
+    ``mp.abort_async_command``.
+
+    If starting the command failed for some reason, ``nil, error`` is returned,
+    and ``fn`` is called indicating failure, using the same error value.
+
+``mp.abort_async_command(t)``
+    Abort a ``mp.command_native_async`` call. The argument is the return value
+    of that command (which starts asynchronous execution of the command).
+    Whether this works and how long it takes depends on the command and the
+    situation. The abort call itself is asynchronous. Does not return anything.
+
 ``mp.get_property(name [,def])``
     Return the value of the given property as string. These are the same
     properties as used in input.conf. See `Properties`_ for a list of
@@ -634,45 +665,23 @@
 
 ``utils.subprocess(t)``
     Runs an external process and waits until it exits. Returns process status
-    and the captured output.
-
-    The parameter ``t`` is a table. The function reads the following entries:
-
-        ``args``
-            Array of strings. The first array entry is the executable. This
-            can be either an absolute path, or a filename with no path
-            components, in which case the ``PATH`` environment variable is
-            used to resolve the executable. The other array elements are
-            passed as command line arguments.
-
-        ``cancellable``
-            Optional. If set to ``true`` (default), then if the user stops
-            playback or goes to the next file while the process is running,
-            the process will be killed.
-
-        ``max_size``
-            Optional. The maximum size in bytes of the data that can be captured
-            from stdout. (Default: 16 MB.)
-
-    The function returns a table as result with the following entries:
-
-        ``status``
-            The raw exit status of the process. It will be negative on error.
-
-        ``stdout``
-            Captured output stream as string, limited to ``max_size``.
-
-        ``error``
-            ``nil`` on success. The string ``killed`` if the process was
-            terminated in an unusual way. The string ``init`` if the process
-            could not be started.
-
-            On Windows, ``killed`` is only returned when the process has been
-            killed by mpv as a result of ``cancellable`` being set to ``true``.
-
-        ``killed_by_us``
-            Set to ``true`` if the process has been killed by mpv as a result
-            of ``cancellable`` being set to ``true``.
+    and the captured output. This is a legacy wrapper around calling the
+    ``subprocess`` command with ``mp.command_native``. It does the following
+    things:
+
+    - copy the table ``t``
+    - rename ``cancellable`` field to ``playback_only``
+    - rename ``max_size`` to ``capture_size``
+    - set ``capture_stdout`` field to ``true`` if unset
+    - set ``name`` field to ``subprocess``
+    - call ``mp.command_native(copied_t)``
+    - if the command failed, create a dummy result table
+    - copy ``error_string`` to ``error`` field if the string is non-empty
+    - return the result table
+
+    It is recommended to use ``mp.command_native`` or ``mp.command_native_async``
+    directly, instead of calling this legacy wrapper. It is for compatibility
+    only.
 
 ``utils.subprocess_detached(t)``
     Runs an external process and detaches it from mpv's control.
@@ -685,6 +694,9 @@
 
     The function returns ``nil``.
 
+    This is a legacy wrapper around calling the ``run`` command with
+    ``mp.commandv`` and other functions.
+
 ``utils.getpid()``
     Returns the process ID of the running mpv process. This can be used to identify
     the calling mpv when launching (detached) subprocesses.
diff -ruN mpv-0.29.1/DOCS/man/mpv.rst mpv-master/DOCS/man/mpv.rst
--- mpv-0.29.1/DOCS/man/mpv.rst	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/DOCS/man/mpv.rst	2019-09-19 04:02:03.000000000 +0700
@@ -218,6 +218,11 @@
     Show the list of audio and subtitle streams (useful only if a UI window  is
     used, broken on the terminal).
 
+i and I
+    Show/toggle an overlay displaying statistics about the currently playing
+    file such as codec, framerate, number of dropped frames and so on. See
+    `STATS`_ for more information.
+
 (The following keys are valid only when using a video output that supports the
 corresponding adjustment.)
 
@@ -505,23 +510,6 @@
 Alternatively, running ``mpv PATH`` should auto-detect a DVD directory
 tree and play the longest title.
 
-.. note:: DVD library choices
-
-    mpv uses a different default DVD library than MPlayer. MPlayer
-    uses libdvdread by default, and mpv uses libdvdnav by default.
-    Both libraries are developed in parallel, but libdvdnav is
-    intended to support more sophisticated DVD features such as menus
-    and multi-angle playback. mpv uses libdvdnav for files specified
-    as either ``dvd://...`` or ``dvdnav://...``. To use libdvdread,
-    which will produce behavior more like MPlayer, specify
-    ``dvdread://...`` instead. Some users have experienced problems
-    when using libdvdnav, in which playback gets stuck in a DVD menu
-    stream. These problems are reported to go away when auto-selecting
-    the title (``dvd://`` rather than ``dvd://1``) or when using
-    libdvdread (e.g. ``dvdread://0``). There are also outstanding bugs
-    in libdvdnav with seeking backwards and forwards in a video
-    stream. Specify ``dvdread://...`` to fix such problems.
-
 .. note:: DVD subtitles
     
     DVDs use image-based subtitles. Image subtitles are implemented as
@@ -625,7 +613,8 @@
 
         # a profile that can be enabled with --profile=big-cache
         [big-cache]
-        cache=123400
+        cache=yes
+        demuxer-max-bytes=123400KiB
         demuxer-readahead-secs=20
 
         [slow]
diff -ruN mpv-0.29.1/DOCS/man/options.rst mpv-master/DOCS/man/options.rst
--- mpv-0.29.1/DOCS/man/options.rst	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/DOCS/man/options.rst	2019-09-19 04:02:03.000000000 +0700
@@ -427,7 +427,6 @@
     the player with Shift+Q.
 
 ``--watch-later-directory=<path>``
-
     The directory in which to store the "watch later" temporary files.
 
     The default is a subdirectory named "watch_later" underneath the
@@ -750,7 +749,7 @@
     likely works with Intel GPUs only. It also requires the opengl EGL backend.
 
     The ``cuda`` and ``cuda-copy`` modes provides deinterlacing in the decoder
-    which is useful as there is no other deinterlacing mechanism in the opengl
+    which is useful as there is no other deinterlacing mechanism in the gpu
     output path. To use this deinterlacing you must pass the option:
     ``vd-lavc-o=deint=[weave|bob|adaptive]``.
     Pass ``weave`` (or leave the option unset) to not attempt any
@@ -779,6 +778,11 @@
         codecs. See ``--hwdec-codecs`` to enable hardware decoding for more
         codecs.
 
+    .. note::
+
+       Most non-copy methods only work with the OpenGL GPU backend. Currently,
+       only the ``nvdec`` and ``cuda`` methods work with Vulkan.
+
     .. admonition:: Quality reduction with hardware decoding
 
         In theory, hardware decoding does not reduce video quality (at least
@@ -888,14 +892,18 @@
     format, with likely no advantages.
 
 ``--cuda-decode-device=<auto|0..>``
-    Choose the GPU device used for decoding when using the ``cuda`` hwdec.
+    Choose the GPU device used for decoding when using the ``cuda`` or
+    ``nvdec`` hwdecs with the OpenGL GPU backend.
 
-    By default, the device that is being used to provide OpenGL output will
+    By default, the device that is being used to provide ``gpu`` output will
     also be used for decoding (and in the vast majority of cases, only one
     GPU will be present).
 
-    Note that when using the ``cuda-copy`` hwdec, a different option must be
-    passed: ``--vd-lavc-o=gpu=<0..>``.
+    Note that when using the ``cuda-copy`` or ``nvdec-copy`` hwdec, a
+    different option must be passed: ``--vd-lavc-o=gpu=<0..>``.
+
+    Note that this option is not available with the Vulkan GPU backend. With
+    Vulkan, decoding must always happen on the display device.
 
 ``--vaapi-device=<device file>``
     Choose the DRM device for ``vaapi-copy``. This should be the path to a
@@ -978,22 +986,6 @@
     which means the value ``0`` would rotate the video according to the
     rotation metadata.)
 
-``--video-stereo-mode=<no|mode>``
-    Set the stereo 3D output mode (default: ``mono``). This is mostly broken and
-    thus deprecated.
-
-    The pseudo-mode ``no`` disables automatic conversion completely.
-
-    The mode ``mono`` is an alias to ``ml``, which refers to the left frame in
-    2D. This is the default, which means mpv will try to show 3D movies in 2D,
-    instead of the mangled 3D image not intended for consumption (such as
-    showing the left and right frame side by side, etc.).
-
-    Use ``--video-stereo-mode=help`` to list all available modes. Check with
-    the ``stereo3d`` filter documentation to see what the names mean. Note that
-    some names refer to modes not supported by ``stereo3d`` - these modes can
-    appear in files, but can't be handled properly by mpv.
-
 ``--video-zoom=<value>``
     Adjust the video display scale factor by the given value. The parameter is
     given log 2. For example, ``--video-zoom=0`` is unscaled,
@@ -1084,7 +1076,7 @@
     You can get the list of allowed codecs with ``mpv --vd=help``. Remove the
     prefix, e.g. instead of ``lavc:h264`` use ``h264``.
 
-    By default, this is set to ``h264,vc1,wmv3,hevc,mpeg2video,vp9``. Note that
+    By default, this is set to ``h264,vc1,hevc,vp9``. Note that
     the hardware acceleration special codecs like ``h264_vdpau`` are not
     relevant anymore, and in fact have been removed from Libav in this form.
 
@@ -1318,8 +1310,10 @@
     Since mpv 0.18.1, this always controls the internal mixer (aka "softvol").
 
 ``--replaygain=<no|track|album>``
-    Adjust volume gain according to the track-gain or album-gain replaygain
-    value stored in the file metadata (default: no replaygain).
+    Adjust volume gain according to replaygain values stored in the file
+    metadata. With ``--replaygain=no`` (the default), perform no adjustment.
+    With ``--replaygain=track``, apply track gain. With ``--replaygain=album``,
+    apply album gain if present and fall back to track gain otherwise.
 
 ``--replaygain-preamp=<db>``
     Pre-amplification gain in dB to apply to the selected replaygain gain
@@ -2944,6 +2938,19 @@
 
     Disabling this option is not recommended. Use it for debugging only.
 
+``--demuxer-termination-timeout=<seconds>``
+    Number of seconds the player should wait to shutdown the demuxer (default:
+    0.1). The player will wait up to this much time before it closes the
+    stream layer forcefully. Forceful closing usually means the network I/O is
+    given no chance to close its connections gracefully (of course the OS can
+    still close TCP connections properly), and might result in annoying messages
+    being logged, and in some cases, confused remote servers.
+
+    This timeout is usually only applied when loading has finished properly. If
+    loading is aborted by the user, or in some corner cases like removing
+    external tracks sourced from network during playback, forceful closing is
+    always used.
+
 ``--demuxer-readahead-secs=<seconds>``
     If ``--demuxer-thread`` is enabled, this controls how much the demuxer
     should buffer ahead in seconds (default: 1). As long as no packet has
@@ -3312,6 +3319,7 @@
     :png:       PNG
     :jpg:       JPEG (default)
     :jpeg:      JPEG (alias for jpg)
+    :webp:      WebP
 
 ``--screenshot-tag-colorspace=<yes|no>``
     Tag screenshots with the appropriate colorspace.
@@ -3445,6 +3453,17 @@
     of compression that can be achieved. For most images, "mixed" achieves the
     best compression ratio, hence it is the default.
 
+``--screenshot-webp-lossless=<yes|no>``
+    Write lossless WebP files. ``--screenshot-webp-quality`` is ignored if this
+    is set. The default is no.
+
+``--screenshot-webp-quality=<0-100>``
+    Set the WebP quality level. Higher means better quality. The default is 75.
+
+``--screenshot-webp-compression=<0-6>``
+    Set the WebP compression level. Higher means better compression, but takes
+    more CPU time. Note that this also affects the screenshot quality when used
+    with lossy WebP files. The default is 4.
 
 Software Scaler
 ---------------
@@ -3634,285 +3653,18 @@
 ``--msg-time``
     Prepend timing information to each console message.
 
-
-TV
---
-
-``--tv-...``
-    These options tune various properties of the TV capture module. For
-    watching TV with mpv, use ``tv://`` or ``tv://<channel_number>`` or
-    even ``tv://<channel_name>`` (see option ``tv-channels`` for ``channel_name``
-    below) as a media URL. You can also use ``tv:///<input_id>`` to start
-    watching a video from a composite or S-Video input (see option ``input`` for
-    details).
-
-``--tv-device=<value>``
-    Specify TV device (default: ``/dev/video0``).
-
-``--tv-channel=<value>``
-    Set tuner to <value> channel.
-
-``--no-tv-audio``
-    no sound
-
-``--tv-automute=<0-255> (v4l and v4l2 only)``
-    If signal strength reported by device is less than this value, audio
-    and video will be muted. In most cases automute=100 will be enough.
-    Default is 0 (automute disabled).
-
-``--tv-driver=<value>``
-    See ``--tv=driver=help`` for a list of compiled-in TV input drivers.
-    available: dummy, v4l2 (default: autodetect)
-
-``--tv-input=<value>``
-    Specify input (default: 0 (TV), see console output for available
-    inputs).
-
-``--tv-freq=<value>``
-    Specify the frequency to set the tuner to (e.g. 511.250). Not
-    compatible with the channels parameter.
-
-``--tv-outfmt=<value>``
-    Specify the output format of the tuner with a preset value supported
-    by the V4L driver (YV12, UYVY, YUY2, I420) or an arbitrary format given
-    as hex value.
-
-``--tv-width=<value>``
-    output window width
-
-``--tv-height=<value>``
-    output window height
-
-``--tv-fps=<value>``
-    framerate at which to capture video (frames per second)
-
-``--tv-buffersize=<value>``
-    maximum size of the capture buffer in megabytes (default: dynamical)
-
-``--tv-norm=<value>``
-    See the console output for a list of all available norms.
-
-    See also: ``--tv-normid``.
-
-``--tv-normid=<value> (v4l2 only)``
-    Sets the TV norm to the given numeric ID. The TV norm depends on the
-    capture card. See the console output for a list of available TV norms.
-
-``--tv-chanlist=<value>``
-    available: argentina, australia, china-bcast, europe-east,
-    europe-west, france, ireland, italy, japan-bcast, japan-cable,
-    newzealand, russia, southafrica, us-bcast, us-cable, us-cable-hrc
-
-``--tv-channels=<chan>-<name>[=<norm>],<chan>-<name>[=<norm>],...``
-    Set names for channels.
-
-    .. note::
-
-        If <chan> is an integer greater than 1000, it will be treated as
-        frequency (in kHz) rather than channel name from frequency table.
-        Use _ for spaces in names (or play with quoting ;-) ). The channel
-        names will then be written using OSD, and the input commands
-        ``tv_step_channel``, ``tv_set_channel`` and ``tv_last_channel``
-        will be usable for a remote control. Not compatible with
-        the ``frequency`` parameter.
-
-    .. note::
-
-        The channel number will then be the position in the 'channels'
-        list, beginning with 1.
-
-    .. admonition:: Examples
-
-        ``tv://1``, ``tv://TV1``, ``tv_set_channel 1``,
-        ``tv_set_channel TV1``
-
-``--tv-[brightness|contrast|hue|saturation]=<-100-100>``
-    Set the image equalizer on the card.
-
-``--tv-audiorate=<value>``
-    Set input audio sample rate.
-
-``--tv-forceaudio``
-    Capture audio even if there are no audio sources reported by v4l.
-
-``--tv-alsa``
-    Capture from ALSA.
-
-``--tv-amode=<0-3>``
-    Choose an audio mode:
-
-    :0: mono
-    :1: stereo
-    :2: language 1
-    :3: language 2
-
-``--tv-forcechan=<1-2>``
-    By default, the count of recorded audio channels is determined
-    automatically by querying the audio mode from the TV card. This option
-    allows forcing stereo/mono recording regardless of the amode option
-    and the values returned by v4l. This can be used for troubleshooting
-    when the TV card is unable to report the current audio mode.
-
-``--tv-adevice=<value>``
-    Set an audio device. <value> should be ``/dev/xxx`` for OSS and a
-    hardware ID for ALSA. You must replace any ':' by a '.' in the
-    hardware ID for ALSA.
-
-``--tv-audioid=<value>``
-    Choose an audio output of the capture card, if it has more than one.
-
-``--tv-[volume|bass|treble|balance]=<0-100>``
-    These options set parameters of the mixer on the video capture card.
-    They will have no effect, if your card does not have one. For v4l2 50
-    maps to the default value of the control, as reported by the driver.
-
-``--tv-gain=<0-100>``
-    Set gain control for video devices (usually webcams) to the desired
-    value and switch off automatic control. A value of 0 enables automatic
-    control. If this option is omitted, gain control will not be modified.
-
-``--tv-immediatemode=<bool>``
-    A value of 0 means capture and buffer audio and video together. A
-    value of 1 (default) means to do video capture only and let the audio
-    go through a loopback cable from the TV card to the sound card.
-
-``--tv-mjpeg``
-    Use hardware MJPEG compression (if the card supports it). When using
-    this option, you do not need to specify the width and height of the
-    output window, because mpv will determine it automatically from
-    the decimation value (see below).
-
-``--tv-decimation=<1|2|4>``
-    choose the size of the picture that will be compressed by hardware
-    MJPEG compression:
-
-    :1: full size
-
-        - 704x576 PAL
-        - 704x480 NTSC
-
-    :2: medium size
-
-        - 352x288 PAL
-        - 352x240 NTSC
-
-    :4: small size
-
-        - 176x144 PAL
-        - 176x120 NTSC
-
-``--tv-quality=<0-100>``
-    Choose the quality of the JPEG compression (< 60 recommended for full
-    size).
-
-``--tv-scan-autostart``
-    Begin channel scanning immediately after startup (default: disabled).
-
-``--tv-scan-period=<0.1-2.0>``
-    Specify delay in seconds before switching to next channel (default:
-    0.5). Lower values will cause faster scanning, but can detect inactive
-    TV channels as active.
-
-``--tv-scan-threshold=<1-100>``
-    Threshold value for the signal strength (in percent), as reported by
-    the device (default: 50). A signal strength higher than this value will
-    indicate that the currently scanning channel is active.
-
-
 Cache
 -----
 
-``--cache=<kBytes|yes|no|auto>``
-    Set the size of the cache in kilobytes, disable it with ``no``, or
-    automatically enable it if needed with ``auto`` (default: ``auto``).
-    With ``auto``, the cache will usually be enabled for network streams,
-    using the size set by ``--cache-default``. With ``yes``, the cache will
-    always be enabled with the size set by ``--cache-default`` (unless the
-    stream cannot be cached, or ``--cache-default`` disables caching).
-
-    May be useful when playing files from slow media, but can also have
-    negative effects, especially with file formats that require a lot of
-    seeking, such as MP4.
-
-    Note that half the cache size will be used to allow fast seeking back. This
-    is also the reason why a full cache is usually not reported as 100% full.
-    The cache fill display does not include the part of the cache reserved for
-    seeking back. The actual maximum percentage will usually be the ratio
-    between readahead and backbuffer sizes.
-
-``--cache-default=<kBytes|no>``
-    Set the size of the cache in kilobytes (default: 10000 KB). Using ``no``
-    will not automatically enable the cache e.g. when playing from a network
-    stream. Note that using ``--cache`` will always override this option.
-
-``--cache-initial=<kBytes>``
-    Playback will start when the cache has been filled up with this many
-    kilobytes of data (default: 0).
-
-``--cache-seek-min=<kBytes>``
-    If a seek is to be made to a position within ``<kBytes>`` of the cache
-    size from the current position, mpv will wait for the cache to be
-    filled to this position rather than performing a stream seek (default:
-    500).
-
-    This matters for small forward seeks. With slow streams (especially HTTP
-    streams) there is a tradeoff between skipping the data between current
-    position and seek destination, or performing an actual seek. Depending
-    on the situation, either of these might be slower than the other method.
-    This option allows control over this.
-
-``--cache-backbuffer=<kBytes>``
-    Size of the cache back buffer (default: 10000 KB). This will add to the total
-    cache size, and reserved the amount for seeking back. The reserved amount
-    will not be used for readahead, and instead preserves already read data to
-    enable fast seeking back.
-
-``--cache-file=<TMP|path>``
-    Create a cache file on the filesystem.
-
-    There are two ways of using this:
-
-    1. Passing a path (a filename). The file will always be overwritten. When
-       the general cache is enabled, this file cache will be used to store
-       whatever is read from the source stream.
-
-       This will always overwrite the cache file, and you can't use an existing
-       cache file to resume playback of a stream. (Technically, mpv wouldn't
-       even know which blocks in the file are valid and which not.)
-
-       The resulting file will not necessarily contain all data of the source
-       stream. For example, if you seek, the parts that were skipped over are
-       never read and consequently are not written to the cache. The skipped over
-       parts are filled with zeros. This means that the cache file doesn't
-       necessarily correspond to a full download of the source stream.
-
-       Both of these issues could be improved if there is any user interest.
-
-       .. warning:: Causes random corruption when used with ordered chapters or
-                    with ``--audio-file``.
-
-    2. Passing the string ``TMP``. This will not be interpreted as filename.
-       Instead, an invisible temporary file is created. It depends on your
-       C library where this file is created (usually ``/tmp/``), and whether
-       filename is visible (the ``tmpfile()`` function is used). On some
-       systems, automatic deletion of the cache file might not be guaranteed.
-
-       If you want to use a file cache, this mode is recommended, because it
-       doesn't break ordered chapters or ``--audio-file``. These modes open
-       multiple cache streams, and using the same file for them obviously
-       clashes.
-
-    See also: ``--cache-file-size``.
-
-``--cache-file-size=<kBytes>``
-    Maximum size of the file created with ``--cache-file``. For read accesses
-    above this size, the cache is simply not used.
-
-    Keep in mind that some use-cases, like playing ordered chapters with cache
-    enabled, will actually create multiple cache files, each of which will
-    use up to this much disk space.
+``--cache=<yes|no|auto>``
+    Decide whether to use network cache settings (default: auto).
+
+    If enabled, use the maximum of ``--cache-secs`` and ``--demuxer-max-bytes``
+    for the cache size. If disabled, ``--cache-pause`` and related are
+    implicitly disabled.
 
-    (Default: 1048576, 1 GB.)
+    The ``auto`` choice sets this depending on whether the stream is thought to
+    involve network accesses (this is an imperfect heuristic).
 
 ``--no-cache``
     Turn off input stream caching. See ``--cache``.
@@ -4049,8 +3801,8 @@
 DVB
 ---
 
-``--dvbin-card=<1-4>``
-    Specifies using card number 1-4 (default: 1).
+``--dvbin-card=<0-15>``
+    Specifies using card number 0-15 (default: 0).
 
 ``--dvbin-file=<filename>``
     Instructs mpv to read the channels list from ``<filename>``. The default is
@@ -4314,11 +4066,6 @@
     will reproduce the source image perfectly if no scaling is performed.
     Enabled by default. Note that this option never affects ``--cscale``.
 
-``--linear-scaling``
-    Scale in linear light. It should only be used with a
-    ``--fbo-format`` that has at least 16 bit precision. This option
-    has no effect on HDR content.
-
 ``--correct-downscaling``
     When using convolution based filters, extend the filter size when
     downscaling. Increases quality, but reduces performance while downscaling.
@@ -4327,6 +4074,32 @@
     better than without it) since it will extend the size to match only the
     milder of the scale factors between the axes.
 
+``--linear-downscaling``
+    Scale in linear light when downscaling. It should only be used with a
+    ``--fbo-format`` that has at least 16 bit precision. This option
+    has no effect on HDR content.
+
+``--linear-upscaling``
+    Scale in linear light when upscaling. Like ``--linear-downscaling``, it
+    should only be used with a ``--fbo-format`` that has at least 16 bits
+    precisions. This is not usually recommended except for testing/specific
+    purposes. Users are advised to either enable ``--sigmoid-upscaling`` or
+    keep both options disabled (i.e. scaling in gamma light).
+
+``--sigmoid-upscaling``
+    When upscaling, use a sigmoidal color transform to avoid emphasizing
+    ringing artifacts. This is incompatible with and replaces
+    ``--linear-upscaling``. (Note that sigmoidization also requires
+    linearization, so the ``LINEAR`` rendering step fires in both cases)
+
+``--sigmoid-center``
+    The center of the sigmoid curve used for ``--sigmoid-upscaling``, must be a
+    float between 0.0 and 1.0. Defaults to 0.75 if not specified.
+
+``--sigmoid-slope``
+    The slope of the sigmoid curve used for ``--sigmoid-upscaling``, must be a
+    float between 1.0 and 20.0. Defaults to 6.5 if not specified.
+
 ``--interpolation``
     Reduce stuttering caused by mismatches in the video fps and display refresh
     rate (also known as judder).
@@ -4384,10 +4157,16 @@
 
     Used in ``--dither=fruit`` mode only.
 
-``--dither=<fruit|ordered|no>``
+``--dither=<fruit|ordered|error-diffusion|no>``
     Select dithering algorithm (default: fruit). (Normally, the
     ``--dither-depth`` option controls whether dithering is enabled.)
 
+    The ``error-diffusion`` option requires compute shader support. It also
+    requires large amount of shared memory to run, the size of which depends on
+    both the kernel (see ``--error-diffusion`` option below) and the height of
+    video window. It will fallback to ``fruit`` dithering if there is no enough
+    shared memory to run the shader.
+
 ``--temporal-dither``
     Enable temporal dithering. (Only active if dithering is enabled in
     general.) This changes between 8 different dithering patterns on each frame
@@ -4400,6 +4179,29 @@
     ``--temporal-dither`` is in use. 1 (the default) will update on every video
     frame, 2 on every other frame, etc.
 
+``--error-diffusion=<kernel>``
+    The error diffusion kernel to use when ``--dither=error-diffusion`` is set.
+
+    ``simple``
+        Propagate error to only two adjacent pixels. Fastest but low quality.
+
+    ``sierra-lite``
+        Fast with reasonable quality. This is the default.
+
+    ``floyd-steinberg``
+        Most notable error diffusion kernel.
+
+    ``atkinson``
+        Looks different from other kernels because only fraction of errors will
+        be propagated during dithering. A typical use case of this kernel is
+        saving dithered screenshot (in window mode). This kernel produces
+        slightly smaller file, with still reasonable dithering quality.
+
+    There are other kernels (use ``--error-diffusion=help`` to list) but most of
+    them are much slower and demanding even larger amount of shared memory.
+    Among these kernels, ``burkes`` achieves a good balance between performance
+    and quality, and probably is the one you want to try first.
+
 ``--gpu-debug``
     Enables GPU debugging. What this means depends on the API type. For OpenGL,
     it calls ``glGetError()``, and requests a debug context. For Vulkan, it
@@ -4493,18 +4295,19 @@
 
 ``--spirv-compiler=<compiler>``
     Controls which compiler is used to translate GLSL to SPIR-V. This is
-    (currently) only relevant for ``--gpu-api=vulkan``. The possible choices
-    are:
+    (currently) only relevant for ``--gpu-api=vulkan`` and `--gpu-api=d3d11`.
+    The possible choices are currently only:
 
     auto
         Use the first available compiler. (Default)
     shaderc
         Use libshaderc, which is an API wrapper around glslang. This is
         generally the most preferred, if available.
-    nvidia
-        Use nvidia's built-in compiler. Only works for nvidia GPUs. Can be
-        buggy, but also supports some features glslang does not. Only works
-        with vulkan.
+
+    .. note::
+
+        This option is deprecated, since there is only one reasonable value.
+        It may be removed in the future.
 
 ``--glsl-shaders=<file-list>``
     Custom GLSL hooks. These are a flexible way to add custom fragment shaders,
@@ -4609,13 +4412,19 @@
         hook point can still cause that hook point to be saved, which has some
         minor overhead)
 
-    OFFSET <ox> <oy>
+    OFFSET <ox oy | ALIGN>
         Indicates a pixel shift (offset) introduced by this pass. These pixel
         offsets will be accumulated and corrected during the next scaling pass
         (``cscale`` or ``scale``). The default values are 0 0 which correspond
         to no shift. Note that offsets are ignored when not overwriting the
         hooked texture.
 
+        A special value of ``ALIGN`` will attempt to fix existing offset of
+        HOOKED by align it with reference. It requires HOOKED to be resizable
+        (see below). It works transparently with fragment shader. For compute
+        shader, the predefined ``texmap`` macro is required to handle coordinate
+        mapping.
+
     COMPONENTS <n>
         Specifies how many components of this pass's output are relevant and
         should be stored in the texture, up to 4 (rgba). By default, this value
@@ -4715,7 +4524,8 @@
 
     LINEAR (fixed)
         Linear light image, before scaling. This only fires when
-        ``--linear-scaling`` is in effect.
+        ``--linear-upscaling``, ``--linear-downscaling`` or
+        ``--sigmoid-upscaling`` is in effect.
 
     SIGMOID (fixed)
         Sigmoidized light, before scaling. This only fires when
@@ -4772,18 +4582,6 @@
     remaining quantization artifacts. Higher numbers add more noise. (Default
     48)
 
-``--sigmoid-upscaling``
-    When upscaling, use a sigmoidal color transform to avoid emphasizing
-    ringing artifacts. This also implies ``--linear-scaling``.
-
-``--sigmoid-center``
-    The center of the sigmoid curve used for ``--sigmoid-upscaling``, must be a
-    float between 0.0 and 1.0. Defaults to 0.75 if not specified.
-
-``--sigmoid-slope``
-    The slope of the sigmoid curve used for ``--sigmoid-upscaling``, must be a
-    float between 1.0 and 20.0. Defaults to 6.5 if not specified.
-
 ``--sharpen=<value>``
     If set to a value other than 0, enable an unsharp masking filter. Positive
     values will sharpen the image (but add more ringing and aliasing). Negative
@@ -4890,17 +4688,74 @@
 
     OS X only.
 
-``--macos-title-bar-style=<dark|ultradark|light|mediumlight|auto>``
-    Sets the styling of the title bar (default: dark).
-    OS X and cocoa-cb only
-
-    :dark:        Dark title bar with vibrancy, a subtle blurring effect that
-                  dynamically blends the background (Video) into the title bar.
-    :ultradark:   Darker title bar with vibrancy (like QuickTime Player).
-    :light:       Bright title bar with vibrancy.
-    :mediumlight: Less bright title bar with vibrancy.
-    :auto:        Detects the system settings and sets the title bar styling
-                  appropriately, either ultradark or mediumlight.
+``--macos-title-bar-appearance=<appearance>``
+    Sets the appearance of the title bar (default: auto). Not all combinations
+    of appearances and ``--macos-title-bar-material`` materials make sense or
+    are unique. Appearances that are not supported by you current macOS version
+    fall back to the default value.
+    macOS and cocoa-cb only
+
+    ``<appearance>`` can be one of the following:
+
+    :auto:                     Detects the system settings and sets the title
+                               bar appearance appropriately. On macOS 10.14 it
+                               also detects run time changes.
+    :aqua:                     The standard macOS Light appearance.
+    :darkAqua:                 The standard macOS Dark appearance. (macOS 10.14+)
+    :vibrantLight:             Light vibrancy appearance with.
+    :vibrantDark:              Dark vibrancy appearance with.
+    :aquaHighContrast:         Light Accessibility appearance. (macOS 10.14+)
+    :darkAquaHighContrast:     Dark Accessibility appearance. (macOS 10.14+)
+    :vibrantLightHighContrast: Light vibrancy Accessibility appearance.
+                               (macOS 10.14+)
+    :vibrantDarkHighContrast:  Dark vibrancy Accessibility appearance.
+                               (macOS 10.14+)
+
+``--macos-title-bar-material=<material>``
+    Sets the material of the title bar (default: titlebar). All deprecated
+    materials should not be used on macOS 10.14+ because their functionality
+    is not guaranteed. Not all combinations of materials and
+    ``--macos-title-bar-appearance`` appearances make sense or are unique.
+    Materials that are not supported by you current macOS version fall back to
+    the default value.
+    macOS and cocoa-cb only
+
+    ``<material>`` can be one of the following:
+
+    :titlebar:              The standard macOS titel bar material.
+    :selection:             The standard macOS selection material.
+    :menu:                  The standard macOS menu material. (macOS 10.11+)
+    :popover:               The standard macOS popover material. (macOS 10.11+)
+    :sidebar:               The standard macOS sidebar material. (macOS 10.11+)
+    :headerView:            The standard macOS header view material.
+                            (macOS 10.14+)
+    :sheet:                 The standard macOS sheet material. (macOS 10.14+)
+    :windowBackground:      The standard macOS window background material.
+                            (macOS 10.14+)
+    :hudWindow:             The standard macOS hudWindow material. (macOS 10.14+)
+    :fullScreen:            The standard macOS full screen material.
+                            (macOS 10.14+)
+    :toolTip:               The standard macOS tool tip material. (macOS 10.14+)
+    :contentBackground:     The standard macOS content background material.
+                            (macOS 10.14+)
+    :underWindowBackground: The standard macOS under window background material.
+                            (macOS 10.14+)
+    :underPageBackground:   The standard macOS under page background material.
+                            (deprecated in macOS 10.14+)
+    :dark:                  The standard macOS dark material.
+                            (deprecated in macOS 10.14+)
+    :light:                 The standard macOS light material.
+                            (macOS 10.14+)
+    :mediumLight:           The standard macOS mediumLight material.
+                            (macOS 10.11+, deprecated in macOS 10.14+)
+    :ultraDark:             The standard macOS ultraDark material.
+                            (macOS 10.11+ deprecated in macOS 10.14+)
+
+``--macos-title-bar-color=<color>``
+    Sets the color of the title bar (default: completely transparent). Is
+    influenced by ``--macos-title-bar-appearance`` and
+    ``--macos-title-bar-material``.
+    See ``--sub-color`` for color syntax.
 
 ``--macos-fs-animation-duration=<default|0-1000>``
     Sets the fullscreen resize animation duration in ms (default: default).
@@ -4959,9 +4814,6 @@
         X11/GLX
     x11vk
         VK_KHR_xlib_surface
-    x11probe
-        For internal autoprobing, equivalent to ``x11`` otherwise. Don't use
-        directly, it could be removed without warning as autoprobing is changed.
     wayland
         Wayland/EGL
     waylandvk
@@ -5123,7 +4975,7 @@
         The user should independently guarantee this before using these signal
         formats for display.
 
-``--target-peak=<nits>``
+``--target-peak=<auto|nits>``
     Specifies the measured peak brightness of the output display, in cd/m^2
     (AKA nits). The interpretation of this brightness depends on the configured
     ``--target-trc``. In all cases, it imposes a limit on the signal values
@@ -5135,9 +4987,9 @@
     above 100 essentially causes the display to be treated as if it were an HDR
     display in disguise. (See the note below)
 
-    By default, the chosen peak defaults to an appropriate value based on the
-    TRC in use. For SDR curves, it defaults to 100. For HDR curves, it
-    defaults to 100 * the transfer function's nominal peak.
+    In ``auto`` mode (the default), the chosen peak is an appropriate value
+    based on the TRC in use. For SDR curves, it uses 100. For HDR curves, it
+    uses 100 * the transfer function's nominal peak.
 
     .. note::
 
@@ -5214,6 +5066,14 @@
     linear
         Specifies the scale factor to use while stretching. Defaults to 1.0.
 
+``--tone-mapping-max-boost=<1.0..10.0>``
+    Upper limit for how much the tone mapping algorithm is allowed to boost
+    the average brightness by over-exposing the image. The default value of 1.0
+    allows no additional brightness boost. A value of 2.0 would allow
+    over-exposing by a factor of 2, and so on. Raising this setting can help
+    reveal details that would otherwise be hidden in dark scenes, but raising
+    it too high will make dark scenes appear unnaturally bright.
+
 ``--hdr-compute-peak=<auto|yes|no>``
     Compute the HDR peak and frame average brightness per-frame instead of
     relying on tagged metadata. These values are averaged over local regions as
@@ -5224,17 +5084,50 @@
     The special value ``auto`` (default) will enable HDR peak computation
     automatically if compute shaders and SSBOs are supported.
 
-``--tone-mapping-desaturate=<value>``
-    Apply desaturation for highlights. The parameter essentially controls the
-    steepness of the desaturation curve. The higher the parameter, the more
-    aggressively colors will be desaturated. This setting helps prevent
-    unnaturally blown-out colors for super-highlights, by (smoothly) turning
-    into white instead. This makes images feel more natural, at the cost of
-    reducing information about out-of-range colors.
-
-    The default of 0.5 provides a good balance. This value is weaker than the
-    ACES ODT curves' recommendation, but works better for most content in
-    practice. A setting of 0.0 disables this option.
+``--hdr-peak-decay-rate=<1.0..1000.0>``
+    The decay rate used for the HDR peak detection algorithm (default: 100.0).
+    This is only relevant when ``--hdr-compute-peak`` is enabled. Higher values
+    make the peak decay more slowly, leading to more stable values at the cost
+    of more "eye adaptation"-like effects (although this is mitigated somewhat
+    by ``--hdr-scene-threshold``). A value of 1.0 (the lowest possible) disables
+    all averaging, meaning each frame's value is used directly as measured,
+    but doing this is not recommended for "noisy" sources since it may lead
+    to excessive flicker. (In signal theory terms, this controls the time
+    constant "tau" of an IIR low pass filter)
+
+``--hdr-scene-threshold-low=<0.0..100.0>``, ``--hdr-scene-threshold-high=<0.0..100.0>``
+    The lower and upper thresholds (in dB) for a brightness difference
+    to be considered a scene change (default: 5.5 low, 10.0 high). This is only
+    relevant when ``--hdr-compute-peak`` is enabled. Normally, small
+    fluctuations in the frame brightness are compensated for by the peak
+    averaging mechanism, but for large jumps in the brightness this can result
+    in the frame remaining too bright or too dark for up to several seconds,
+    depending on the value of ``--hdr-peak-decay-rate``. To counteract this,
+    when the brightness between the running average and the current frame
+    exceeds the low threshold, mpv will make the averaging filter more
+    aggressive, up to the limit of the high threshold (at which point the
+    filter becomes instant).
+
+``--tone-mapping-desaturate=<0.0..1.0>``
+    Apply desaturation for highlights (default: 0.75). The parameter controls
+    the strength of the desaturation curve. A value of 0.0 completely disables
+    it, while a value of 1.0 means that overly bright colors will tend towards
+    white. (This is not always the case, especially not for highlights that are
+    near primary colors)
+
+    Values in between apply progressively more/less aggressive desaturation.
+    This setting helps prevent unnaturally oversaturated colors for
+    super-highlights, by (smoothly) turning them into less saturated (per
+    channel tone mapped) colors instead. This makes images feel more natural,
+    at the cost of chromatic distortions for out-of-range colors. The default
+    value of 0.75 provides a good balance. Setting this to 0.0 preserves the
+    chromatic accuracy of the tone mapping process.
+
+``--tone-mapping-desaturate-exponent=<0.0..20.0>``
+    This setting controls the exponent of the desaturation curve, which
+    controls how bright a color needs to be in order to start being
+    desaturated. The default of 1.5 provides a reasonable balance.  Decreasing
+    this exponent makes the curve more aggressive.
 
 ``--gamut-warning``
     If enabled, mpv will mark all clipped/out-of-gamut pixels that exceed a
@@ -5295,12 +5188,14 @@
     Size of the 3D LUT generated from the ICC profile in each dimension.
     Default is 64x64x64. Sizes may range from 2 to 512.
 
-``--icc-contrast=<0-1000000>``
+``--icc-contrast=<0-1000000|inf>``
     Specifies an upper limit on the target device's contrast ratio. This is
     detected automatically from the profile if possible, but for some profiles
     it might be missing, causing the contrast to be assumed as infinite. As a
     result, video may appear darker than intended. This only affects BT.1886
-    content. The default of 0 means no limit.
+    content. The default of 0 means no limit if the detected contrast is less
+    than 100000, and limits to 1000 otherwise. Use ``--icc-contrast=inf`` to
+    preserve the infinite contrast (most likely when using OLED displays).
 
 ``--blend-subtitles=<yes|video|no>``
     Blend subtitles directly onto upscaled video frames, before interpolation
@@ -5615,6 +5510,12 @@
     it to a template (similar to ``--screenshot-template``), being renamed,
     removed, or anything else, until it is declared semi-stable.
 
+``--stream-record=<file>``
+    Similar to ``--record-file``, but write packets as they are received. The
+    implementation of this does not tolerate seeks (outside of demuxer cache),
+    or streams being selected/deselected during recording. Can not be set at
+    runtime. Use with care.
+
 ``--lavfi-complex=<string>``
     Set a "complex" libavfilter filter, which means a single filter graph can
     take input from multiple source audio and video tracks. The graph can result
diff -ruN mpv-0.29.1/DOCS/man/osc.rst mpv-master/DOCS/man/osc.rst
--- mpv-0.29.1/DOCS/man/osc.rst	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/DOCS/man/osc.rst	2019-09-19 04:02:03.000000000 +0700
@@ -167,9 +167,14 @@
 ``seekbarstyle``
     Default: bar
 
-    Sets the style of the seekbar, slider (diamond marker), knob (circle
-    marker with guide), or bar (fill).
-    Default pre-0.21.0 was 'slider'.
+    Sets the style of the playback position marker and overall shape
+    of the seekbar: ``bar``, ``diamond`` or ``knob``.
+
+``seekbarhandlesize``
+    Default: 0.6
+
+    Size ratio of the seek handle if ``seekbarstyle`` is set to ``dimaond``
+    or ``knob``. This is relative to the full height of the seekbar.
 
 ``seekbarkeyframes``
     Default: yes
@@ -180,6 +185,28 @@
     useful in cases where keyframes cannot be found. Note that using exact
     seeks can potentially make mouse dragging much slower.
 
+``seekrangestyle``
+    Default: inverted
+
+    Display seekable ranges on the seekbar. ``bar`` shows them on the full
+    height of the bar, ``line`` as a thick line and ``inverted`` as a thin
+    line that is inverted over playback position markers. ``none`` will hide
+    them. Additionally, ``slider`` will show a permanent handle inside the seekbar
+    with cached ranges marked inside. Note that these will look differently
+    based on the seekbarstyle option. Also, ``slider`` does not work with
+    ``seekbarstyle`` set to ``bar``.
+
+``seekrangeseparate``
+    Default: yes
+
+    Controls whether to show line-style seekable ranges on top of the
+    seekbar or separately if ``seekbarstyle`` is set to ``bar``.
+
+``seekrangealpha``
+    Default: 200
+
+    Alpha of the seekable ranges, 0 (opaque) to 255 (fully transparent).
+
 ``deadzonesize``
     Default: 0.5
 
@@ -281,11 +308,6 @@
 
     Display timecodes with milliseconds
 
-``seekranges``
-    Default: yes
-
-    Display seekable ranges on the seekbar
-
 ``visibility``
     Default: auto (auto hide/show on mouse move)
 
diff -ruN mpv-0.29.1/DOCS/man/vf.rst mpv-master/DOCS/man/vf.rst
--- mpv-0.29.1/DOCS/man/vf.rst	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/DOCS/man/vf.rst	2019-09-19 04:02:03.000000000 +0700
@@ -249,12 +249,13 @@
        :gamma1.2:     Scene-referred using a pure power OOTF (gamma=1.2)
 
     ``<stereo-in>``
-        Set the stereo mode the video is assumed to be encoded in. Takes the
-        same values as the ``--video-stereo-mode`` option.
+        Set the stereo mode the video is assumed to be encoded in. Use
+        ``--vf format:stereo-in=help`` to list all available modes. Check with
+        the ``stereo3d`` filter documentation to see what the names mean.
 
     ``<stereo-out>``
         Set the stereo mode the video should be displayed as. Takes the
-        same values as the ``--video-stereo-mode`` option.
+        same values as the ``stereo-in`` option.
 
     ``<rotate>``
         Set the rotation the video is assumed to be encoded with in degrees.
@@ -468,8 +469,9 @@
     other userdata type will result in hard crashes.
 
 ``vavpp``
-    VA-AP-API video post processing. Works with ``--vo=vaapi`` and ``--vo=gpu``
-    only. Currently deinterlaces. This filter is automatically inserted if
+    VA-API video post processing. Requires the system to support VA-API,
+    i.e. Linux/BSD only. Works with ``--vo=vaapi`` and ``--vo=gpu`` only.
+    Currently deinterlaces. This filter is automatically inserted if
     deinterlacing is requested (either using the ``d`` key, by default mapped to
     the command ``cycle deinterlace``, or the ``--deinterlace`` option).
 
diff -ruN mpv-0.29.1/DOCS/man/vo.rst mpv-master/DOCS/man/vo.rst
--- mpv-0.29.1/DOCS/man/vo.rst	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/DOCS/man/vo.rst	2019-09-19 04:02:03.000000000 +0700
@@ -308,7 +308,7 @@
     For tuning, refer to your copy of the file ``SDL_hints.h``.
 
     .. note:: This driver is for compatibility with systems that don't provide
-              proper graphics drivers, or which support GLES only.
+              proper graphics drivers.
 
     The following global options are supported by this video output:
 
@@ -415,6 +415,8 @@
             JPEG files, extension .jpeg.
         png
             PNG files.
+        webp
+            WebP files.
 
     ``--vo-image-png-compression=<0-9>``
         PNG compression factor (speed vs. file size tradeoff) (default: 7)
@@ -425,6 +427,12 @@
         JPEG quality factor (default: 90)
     ``--vo-image-jpeg-optimize=<0-100>``
         JPEG optimization factor (default: 100)
+    ``--vo-image-webp-lossless=<yes|no>``
+        Enable writing lossless WebP files (default: no)
+    ``--vo-image-webp-quality=<0-100>``
+        WebP quality (default: 75)
+    ``--vo-image-webp-compression=<0-6>``
+        WebP compression factor (default: 4)
     ``--vo-image-outdir=<dirname>``
         Specify the directory to save the image files to (default: ``./``).
 
@@ -479,28 +487,59 @@
     ``--drm-connector=[<gpu_number>.]<name>``
         Select the connector to use (usually this is a monitor.) If ``<name>``
         is empty or ``auto``, mpv renders the output on the first available
-        connector. Use ``--drm-connector=help`` to get list of available
+        connector. Use ``--drm-connector=help`` to get a list of available
         connectors. When using multiple graphic cards, use the ``<gpu_number>``
         argument to disambiguate.
         (default: empty)
 
-    ``--drm-mode=<number>``
-        Mode ID to use (resolution and frame rate).
-        (default: 0)
-
-    ``--drm-osd-plane-id=<number>``
-        Select the DRM plane index to use for OSD (or OSD and video).
-        Index is zero based, and related to crtc.
-        When using this option with the drm_prime renderer, it will only affect
-        the OSD contents. Otherwise it will set OSD & video plane.
-        (default: primary plane)
-
-    ``--drm-video-plane-id=<number>``
-        Select the DRM plane index to use for video layer.
-        Index is zero based, and related to crtc.
-        This option only has effect when using the drm_prime renderer (which
-        supports several layers) together with ``vo=gpu`` and ``gpu-context=drm``.
-        (default: first overlay plane)
+    ``--drm-mode=<preferred|highest|N|WxH[@R]>``
+        Mode to use (resolution and frame rate).
+        Possible values:
+
+        :preferred: Use the preferred mode for the screen on the selected
+                    connector. (default)
+        :highest:   Use the mode with the highest resolution available on the
+                    selected connector.
+        :N:         Select mode by index.
+        :WxH[@R]:   Specify mode by width, height, and optionally refresh rate.
+                    In case several modes match, selects the mode that comes
+                    first in the EDID list of modes.
+
+        Use ``--drm-mode=help`` to get a list of available modes for all active
+        connectors.
+
+    ``--drm-atomic=<no|auto>``
+        Toggle use of atomic modesetting. Mostly useful for debugging.
+
+        :no:    Use legacy modesetting.
+        :auto:  Use atomic modesetting, falling back to legacy modesetting if
+                not available. (default)
+
+        Note: Only affects ``gpu-context=drm``. ``vo=drm`` supports legacy
+        modesetting only.
+
+    ``--drm-draw-plane=<primary|overlay|N>``
+        Select the DRM plane to which video and OSD is drawn to, under normal
+        circumstances. The plane can be specified as ``primary``, which will
+        pick the first applicable primary plane; ``overlay``, which will pick
+        the first applicable overlay plane; or by index. The index is zero
+        based, and related to the CRTC.
+        (default: primary)
+
+        When using this option with the drmprime-drm hwdec interop, only the OSD
+        is rendered to this plane.
+
+    ``--drm-drmprime-video-plane=<primary|overlay|N>``
+        Select the DRM plane to use for video with the drmprime-drm hwdec
+        interop (used by e.g. the rkmpp hwdec on RockChip SoCs, and v4l2 hwdec:s
+        on various other SoC:s). The plane is unused otherwise. This option
+        accepts the same values as ``--drm-draw-plane``. (default: overlay)
+
+        To be able to successfully play 4K video on various SoCs you might need
+        to set ``--drm-draw-plane=overlay --drm-drmprime-video-plane=primary``
+        and setting ``--drm-draw-surface-size=1920x1080``, to render the OSD at a
+        lower resolution (the video when handled by the hwdec will be on the
+        drmprime-video plane and at full 4K resolution)
 
     ``--drm-format=<xrgb8888|xrgb2101010>``
         Select the DRM format to use (default: xrgb8888). This allows you to
@@ -509,17 +548,24 @@
         xrgb2101010 is a packed 30 bits per pixel/10 bits per channel packed RGB
         format with 2 bits of padding.
 
-        Unless you have an intel graphics card, a recent kernel and a recent
+        Unless you have an Intel graphics card, a recent kernel and a recent
         version of mesa (>=18) xrgb2101010 is unlikely to work for you.
 
         This currently only has an effect when used together with the ``drm``
         backend for the ``gpu`` VO. The ``drm`` VO always uses xrgb8888.
 
-    ``--drm-osd-size=<[WxH]>``
-        Sets the OSD OpenGL size to the specified size. OSD will then be upscaled
-        to the current screen resolution. This option can be useful when using
-        several layers in high resolutions with a GPU which cannot handle it.
-        Note : this option is only available with DRM atomic support.
+    ``--drm-draw-surface-size=<[WxH]>``
+        Sets the size of the surface used on the draw plane. The surface will
+        then be upscaled to the current screen resolution. This option can be
+        useful when used together with the drmprime-drm hwdec interop at high
+        resolutions, as it allows scaling the draw plane (which in this case
+        only handles the OSD) down to a size the GPU can handle.
+
+        When used without the drmprime-drm hwdec interop this option will just
+        cause the video to get rendered at a different resolution and then
+        scaled to screen size.
+
+        Note: this option is only available with DRM atomic support.
         (default: display resolution)
 
 ``mediacodec_embed`` (Android)
@@ -531,5 +577,5 @@
     many of mpv's features (subtitle rendering, OSD/OSC, video filters, etc)
     are not available with this driver.
 
-    To use hardware decoding with ``--vo-gpu`` instead, use
+    To use hardware decoding with ``--vo=gpu`` instead, use
     ``--hwdec=mediacodec-copy`` along with ``--gpu-context=android``.
diff -ruN mpv-0.29.1/README.md mpv-master/README.md
--- mpv-0.29.1/README.md	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/README.md	2019-09-19 04:02:03.000000000 +0700
@@ -1,8 +1,6 @@
-![http://mpv.io/](https://raw.githubusercontent.com/mpv-player/mpv.io/master/source/images/mpv-logo-128.png)
+![mpv logo](https://raw.githubusercontent.com/mpv-player/mpv.io/master/source/images/mpv-logo-128.png)
 
-## mpv
-
---------------
+# mpv
 
 
 * [External links](#external-links)
@@ -228,12 +226,9 @@
 
 Most activity happens on the IRC channel and the github issue tracker.
 
- - **GitHub issue tracker**: [issue tracker][issue-tracker] (report bugs here)
- - **User IRC Channel**: `#mpv` on `irc.freenode.net`
- - **Developer IRC Channel**: `#mpv-devel` on `irc.freenode.net`
-
-To contact the `mpv` team in private write to `mpv-team@googlegroups.com`. Use
-only if discretion is required.
+- **GitHub issue tracker**: [issue tracker][issue-tracker] (report bugs here)
+- **User IRC Channel**: `#mpv` on `irc.freenode.net`
+- **Developer IRC Channel**: `#mpv-devel` on `irc.freenode.net`
 
 [releases]: https://github.com/mpv-player/mpv/releases
 [mpv-build]: https://github.com/mpv-player/mpv-build
diff -ruN mpv-0.29.1/RELEASE_NOTES mpv-master/RELEASE_NOTES
--- mpv-0.29.1/RELEASE_NOTES	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/RELEASE_NOTES	2019-09-19 04:02:03.000000000 +0700
@@ -1,35 +1,30 @@
-Release 0.29.1
+Release 0.30.0
 ==============
 
-A bug fix release for the 0.29 release branch.
+This release has replaced the internal Vulkan rendering abstraction
+with libplacebo's more up-to-date implementation.
 
-Fixes and Minor Enhancements
-----------------------------
+Features
+--------
+
+Added
+~~~~~
+
+- vo_gpu: Vulkan API implementation based on libplacebo.
+
+Changed
+~~~~~~~
+
+
+Deprecated
+~~~~~~~~~~
+
+
+Removed
+~~~~~~~
+
+- vo_gpu: Internal Vulkan API implementation.
 
-- af_rubberband: Fix for A-V drift on seeking.
-- ao_alsa: Fixes to remove spam during pausing and end-of-file.
-- ao_jack: Fix for mpv attempting to connect to non-standard devices such as MIDI.
-- ao_openal: Drop support for Apple's bundled OpenAL due to lack of features to successfully build.
-- ao_pulse: Fix for audio buffer length calculation.
-- demux_lavf: Fix EDL playback of certain DASH streams.
-- demux_lavf: Mark v4l streams as not seekable.
-- demux_raw: Fix for gapless playback from raw audio input.
-- drm_atomic: Fix to enable video output with devices without a video overlay plane.
-- encode: Fix for crashes in case of failure to write to output.
-- encode: Fix for encoding when utilizing lavfi-complex.
-- Fix to strip HDR peak metadata if attached to SDR video (#6111)
-- macOS: Capability to fall back on SW rendering for testing purposes.
-- macOS: Fix for issues with the main menu.
-- macOS: Fix for side by side split view.
-- macOS: Fixes for crashes, most notably those happening on 10.14 (#5908, #6097, #6041, #6062).
-- macOS: No longer let older, unsupported versions of the Swift build tools through configure.
-- manpage: Misc fixups.
-- stream_{smb,file}: Fix for partial writes to buffers.
-- stream_libarchive: Fix hang when an out-of-bound seek happens.
-- stream_smb: Fix for crashes due to libsmbclient and threading (#5936).
-- vo_gpu: Fix for corruption when multiple compute shaders override each others' block sizes (#6083).
-- ytdl_hook: Always load "ytdl://" URLs with ytdl_hook first.
-- ytdl_hook: Fix audio streams not being picked up for some sites.
 
 Options and Commands
 --------------------
@@ -37,7 +32,23 @@
 Added
 ~~~~~
 
-- `--cocoa-cb-sw-renderer` to control whether or not to fall back on software rendering on macOS.
+
+Changed
+~~~~~~~
+
+
+Deprecated
+~~~~~~~~~~
+
+
+Removed
+~~~~~~~
+
+
+Fixes and Minor Enhancements
+----------------------------
+
+
 
 Release 0.29.0
 ==============
diff -ruN mpv-0.29.1/TOOLS/appveyor-build.sh mpv-master/TOOLS/appveyor-build.sh
--- mpv-0.29.1/TOOLS/appveyor-build.sh	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/TOOLS/appveyor-build.sh	2019-09-19 04:02:03.000000000 +0700
@@ -10,11 +10,9 @@
 "$PYTHON" bootstrap.py
 "$PYTHON" waf configure \
     --check-c-compiler=gcc \
-    --disable-egl-angle-lib \
-    --enable-crossc \
+    --enable-spirv-cross \
     --enable-d3d-hwaccel \
     --enable-d3d11 \
-    --enable-egl-angle \
     --enable-jpeg \
     --enable-lcms2 \
     --enable-libarchive \
diff -ruN mpv-0.29.1/TOOLS/appveyor-install.sh mpv-master/TOOLS/appveyor-install.sh
--- mpv-0.29.1/TOOLS/appveyor-install.sh	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/TOOLS/appveyor-install.sh	2019-09-19 04:02:03.000000000 +0700
@@ -1,6 +1,8 @@
 #!/usr/bin/bash
 set -e
 
+export PYTHON=/usr/bin/python3
+
 # Write an empty fonts.conf to speed up fc-cache
 export FONTCONFIG_FILE=/dummy-fonts.conf
 cat >"$FONTCONFIG_FILE" <<EOF
@@ -12,12 +14,12 @@
 # Install build dependencies for mpv
 pacman -S --noconfirm --needed \
     $MINGW_PACKAGE_PREFIX-toolchain \
-    $MINGW_PACKAGE_PREFIX-angleproject-git \
     $MINGW_PACKAGE_PREFIX-cmake \
     $MINGW_PACKAGE_PREFIX-lcms2 \
     $MINGW_PACKAGE_PREFIX-libarchive \
     $MINGW_PACKAGE_PREFIX-libass \
     $MINGW_PACKAGE_PREFIX-libjpeg-turbo \
+    $MINGW_PACKAGE_PREFIX-libplacebo \
     $MINGW_PACKAGE_PREFIX-lua51 \
     $MINGW_PACKAGE_PREFIX-ninja \
     $MINGW_PACKAGE_PREFIX-rubberband \
@@ -52,21 +54,19 @@
 # Compile shaderc
 (
     git clone --depth=1 https://github.com/google/shaderc && cd shaderc
-    git clone --depth=1 https://github.com/google/glslang.git third_party/glslang
-    git clone --depth=1 https://github.com/KhronosGroup/SPIRV-Tools.git third_party/spirv-tools
-    git clone --depth=1 https://github.com/KhronosGroup/SPIRV-Headers.git third_party/spirv-headers
+    "$PYTHON" utils/git-sync-deps
 
     mkdir build && cd build
     cmake -GNinja -DCMAKE_BUILD_TYPE=Release -DSHADERC_SKIP_TESTS=ON \
           -DCMAKE_INSTALL_PREFIX=$MINGW_PREFIX ..
     ninja install
-    cp -f libshaderc/libshaderc_shared.dll $MINGW_PREFIX/bin/
 )
 
-# Compile crossc
+# Compile SPIRV-Cross
 (
-    git clone --depth=1 https://github.com/rossy/crossc && cd crossc
-    git submodule update --init
+    git clone --depth=1 https://github.com/KhronosGroup/SPIRV-Cross && cd SPIRV-Cross
 
-    make -j4 install prefix=$MINGW_PREFIX
+    mkdir build && cd build
+    cmake -GNinja -DSPIRV_CROSS_SHARED=ON -DCMAKE_INSTALL_PREFIX=$MINGW_PREFIX ..
+    ninja install
 )
diff -ruN mpv-0.29.1/TOOLS/dylib-unhell.py mpv-master/TOOLS/dylib-unhell.py
--- mpv-0.29.1/TOOLS/dylib-unhell.py	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/TOOLS/dylib-unhell.py	2019-09-19 04:02:03.000000000 +0700
@@ -20,7 +20,8 @@
            not "libc." in libname and \
            not "libgcc." in libname and \
            not os.path.basename(libname) == 'Python' and \
-           not os.path.basename(objfile) in libname
+           not os.path.basename(objfile) in libname and \
+           not "libswift" in libname
 
 def otool(objfile):
     command = "otool -L %s | grep -e '\t' | awk '{ print $1 }'" % objfile
@@ -33,6 +34,9 @@
 def install_name_tool_id(name, objfile):
     subprocess.call(["install_name_tool", "-id", name, objfile])
 
+def install_name_tool_add_rpath(rpath, binary):
+    subprocess.call(["install_name_tool", "-add_rpath", rpath, binary])
+
 def libraries(objfile, result = dict()):
     libs_list       = otool(objfile)
     result[objfile] = libs_list
@@ -82,15 +86,30 @@
 
     return ls
 
+def process_swift_libraries(binary):
+    command = ['xcrun', '--find', 'swift-stdlib-tool']
+    swiftStdlibTool = subprocess.check_output(command, universal_newlines=True).strip()
+
+    command = [swiftStdlibTool, '--copy', '--platform', 'macosx', '--scan-executable', binary, '--destination', lib_path(binary)]
+    subprocess.check_output(command, universal_newlines=True)
+
+    print(">> setting additional rpath for swift libraries")
+    install_name_tool_add_rpath("@executable_path/lib", binary)
+
 def main():
     binary = os.path.abspath(sys.argv[1])
     if not os.path.exists(lib_path(binary)):
         os.makedirs(lib_path(binary))
+    print(">> gathering all linked libraries")
     libs = libraries(binary)
 
+    print(">> copying and processing all linked libraries")
     libs_processed = process_libraries(libs, binary)
     while libs_processed is not None:
         libs_processed = process_libraries(libs, binary, libs_processed)
 
+    print(">> copying and processing swift libraries")
+    process_swift_libraries(binary)
+
 if __name__ == "__main__":
     main()
diff -ruN mpv-0.29.1/TOOLS/lua/command-test.lua mpv-master/TOOLS/lua/command-test.lua
--- mpv-0.29.1/TOOLS/lua/command-test.lua	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/TOOLS/lua/command-test.lua	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,95 @@
+-- Test script for some command API details.
+
+local utils = require("mp.utils")
+
+function join(sep, arr, count)
+    local r = ""
+    if count == nil then
+        count = #arr
+    end
+    for i = 1, count do
+        if i > 1 then
+            r = r .. sep
+        end
+        r = r .. utils.to_string(arr[i])
+    end
+    return r
+end
+
+mp.observe_property("vo-configured", "bool", function(_, v)
+    if v ~= true then
+        return
+    end
+
+    print("async expand-text")
+    mp.command_native_async({"expand-text", "hello ${path}!"},
+        function(res, val, err)
+            print("done async expand-text: " .. join(" ", {res, val, err}))
+        end)
+
+    -- make screenshot writing very slow
+    mp.set_property("screenshot-format", "png")
+    mp.set_property("screenshot-png-compression", "9")
+
+    timer = mp.add_periodic_timer(0.1, function() print("I'm alive") end)
+    timer:resume()
+
+    print("Slow screenshot command...")
+    res, err = mp.command_native({"screenshot"})
+    print("done, res: " .. utils.to_string(res))
+
+    print("Slow screenshot async command...")
+    res, err = mp.command_native_async({"screenshot"}, function(res)
+        print("done (async), res: " .. utils.to_string(res))
+        timer:kill()
+    end)
+    print("done (sending), res: " .. utils.to_string(res))
+
+    print("Broken screenshot async command...")
+    mp.command_native_async({"screenshot-to-file", "/nonexistent/bogus.png"},
+        function(res, val, err)
+            print("done err scr.: " .. join(" ", {res, val, err}))
+        end)
+
+    mp.command_native_async({name = "subprocess", args = {"sh", "-c", "echo hi && sleep 10s"}, capture_stdout = true},
+        function(res, val, err)
+            print("done subprocess: " .. join(" ", {res, val, err}))
+        end)
+
+    local x = mp.command_native_async({name = "subprocess", args = {"sleep", "inf"}},
+        function(res, val, err)
+            print("done sleep inf subprocess: " .. join(" ", {res, val, err}))
+        end)
+    mp.add_timeout(15, function()
+        print("aborting sleep inf subprocess after timeout")
+        mp.abort_async_command(x)
+    end)
+
+    -- (assuming this "freezes")
+    local y = mp.command_native_async({name = "sub-add", url = "-"},
+        function(res, val, err)
+            print("done sub-add stdin: " .. join(" ", {res, val, err}))
+        end)
+    mp.add_timeout(20, function()
+        print("aborting sub-add stdin after timeout")
+        mp.abort_async_command(y)
+    end)
+
+
+
+    -- This should get killed on script exit.
+    mp.command_native_async({name = "subprocess", playback_only = false,
+                             args = {"sleep", "inf"}}, function()end)
+
+    -- Runs detached; should be killed on player exit (forces timeout)
+    mp.command_native({_flags={"async"}, name = "subprocess",
+                       playback_only = false, args = {"sleep", "inf"}})
+end)
+
+mp.register_event("shutdown", function()
+    -- This "freezes" the script, should be killed via timeout.
+    print("freeze!")
+    local x = mp.command_native({name = "subprocess", playback_only = false,
+                                 args = {"sleep", "inf"}})
+    print("done, killed=" .. utils.to_string(x.killed_by_us))
+end)
diff -ruN mpv-0.29.1/TOOLS/osxbundle.py mpv-master/TOOLS/osxbundle.py
--- mpv-0.29.1/TOOLS/osxbundle.py	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/TOOLS/osxbundle.py	2019-09-19 04:02:03.000000000 +0700
@@ -7,7 +7,7 @@
 from optparse import OptionParser
 
 def sh(command):
-    return os.popen(command).read()
+    return os.popen(command).read().strip()
 
 def bundle_path(binary_name):
     return "%s.app" % binary_name
@@ -80,7 +80,7 @@
 
     if options.deps:
         print("> bundling dependencies")
-        sh(" ".join(["TOOLS/dylib-unhell.py", target_binary(binary_name)]))
+        print(sh(" ".join(["TOOLS/dylib-unhell.py", target_binary(binary_name)])))
 
     print("done.")
 
diff -ruN mpv-0.29.1/TOOLS/travis-rebuild-website mpv-master/TOOLS/travis-rebuild-website
--- mpv-0.29.1/TOOLS/travis-rebuild-website	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/TOOLS/travis-rebuild-website	2019-09-19 04:02:03.000000000 +0700
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-if [ "x$LIBAV" != "xffmpeg-git" ] || [ "x$TRAVIS_OS_NAME" != "xlinux" ]; then
+if [ "x$TARGET" != "xx86_64-w64-mingw32" ]; then
   # trigger build only on one of the matrix nodes
   exit;
 fi
diff -ruN mpv-0.29.1/VERSION mpv-master/VERSION
--- mpv-0.29.1/VERSION	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/VERSION	2019-09-19 04:02:03.000000000 +0700
@@ -1 +1 @@
-0.29.1
+0.29.0-UNKNOWN
diff -ruN mpv-0.29.1/appveyor.yml mpv-master/appveyor.yml
--- mpv-0.29.1/appveyor.yml	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/appveyor.yml	2019-09-19 04:02:03.000000000 +0700
@@ -15,6 +15,12 @@
 test: off
 
 install:
+  # Support for Ada and Objective-C was removed from MSYS2. GCC won't update if
+  # these packages are installed.
+  - >-
+    C:\msys64\usr\bin\pacman -R --noconfirm --noprogressbar
+    mingw-w64-i686-gcc-ada mingw-w64-i686-gcc-objc mingw-w64-x86_64-gcc-ada
+    mingw-w64-x86_64-gcc-objc
   # Update core packages
   - C:\msys64\usr\bin\pacman -Syyuu --noconfirm --noprogressbar --ask=20
   # Update non-core packages
diff -ruN mpv-0.29.1/audio/decode/ad_lavc.c mpv-master/audio/decode/ad_lavc.c
--- mpv-0.29.1/audio/decode/ad_lavc.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/audio/decode/ad_lavc.c	2019-09-19 04:02:03.000000000 +0700
@@ -37,6 +37,7 @@
 #include "demux/stheader.h"
 #include "filters/f_decoder_wrapper.h"
 #include "filters/filter_internal.h"
+#include "options/m_config.h"
 #include "options/options.h"
 
 struct priv {
@@ -80,8 +81,9 @@
                  const char *decoder)
 {
     struct priv *ctx = da->priv;
-    struct MPOpts *mpopts = da->global->opts;
-    struct ad_lavc_params *opts = mpopts->ad_lavc_params;
+    struct MPOpts *mpopts = mp_get_config_group(ctx, da->global, GLOBAL_CONFIG);
+    struct ad_lavc_params *opts =
+        mp_get_config_group(ctx, da->global, &ad_lavc_conf);
     AVCodecContext *lavc_context;
     AVCodec *lavc_codec;
 
diff -ruN mpv-0.29.1/audio/decode/ad_spdif.c mpv-master/audio/decode/ad_spdif.c
--- mpv-0.29.1/audio/decode/ad_spdif.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/audio/decode/ad_spdif.c	2019-09-19 04:02:03.000000000 +0700
@@ -208,13 +208,21 @@
         break;
     case AV_CODEC_ID_DTS: {
         bool is_hd = profile == FF_PROFILE_DTS_HD_HRA ||
-                     profile == FF_PROFILE_DTS_HD_MA ||
+                     profile == FF_PROFILE_DTS_HD_MA  ||
                      profile == FF_PROFILE_UNKNOWN;
+
+        // Apparently, DTS-HD over SPDIF is specified to be 7.1 (8 channels)
+        // for DTS-HD MA, and stereo (2 channels) for DTS-HD HRA. The bit
+        // streaming rate as well as the signaled channel count are defined
+        // based on this value.
+        int dts_hd_spdif_channel_count = profile == FF_PROFILE_DTS_HD_HRA ?
+                                         2 : 8;
         if (spdif_ctx->use_dts_hd && is_hd) {
-            av_dict_set(&format_opts, "dtshd_rate", "768000", 0); // 4*192000
+            av_dict_set_int(&format_opts, "dtshd_rate",
+                            dts_hd_spdif_channel_count * 96000, 0);
             sample_format               = AF_FORMAT_S_DTSHD;
             samplerate                  = 192000;
-            num_channels                = 2*4;
+            num_channels                = dts_hd_spdif_channel_count;
         } else {
             sample_format               = AF_FORMAT_S_DTS;
             samplerate                  = 48000;
diff -ruN mpv-0.29.1/audio/out/ao.c mpv-master/audio/out/ao.c
--- mpv-0.29.1/audio/out/ao.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/audio/out/ao.c	2019-09-19 04:02:03.000000000 +0700
@@ -120,7 +120,7 @@
 }
 
 // For the ao option
-const struct m_obj_list ao_obj_list = {
+static const struct m_obj_list ao_obj_list = {
     .get_desc = get_desc,
     .description = "audio outputs",
     .allow_unknown_entries = true,
@@ -129,13 +129,30 @@
     .use_global_options = true,
 };
 
+#define OPT_BASE_STRUCT struct ao_opts
+const struct m_sub_options ao_conf = {
+    .opts = (const struct m_option[]) {
+        OPT_SETTINGSLIST("ao", audio_driver_list, 0, &ao_obj_list, ),
+        OPT_STRING("audio-device", audio_device, UPDATE_AUDIO),
+        OPT_STRING("audio-client-name", audio_client_name, UPDATE_AUDIO),
+        OPT_DOUBLE("audio-buffer", audio_buffer, M_OPT_MIN | M_OPT_MAX,
+                   .min = 0, .max = 10),
+        {0}
+    },
+    .size = sizeof(OPT_BASE_STRUCT),
+    .defaults = &(const OPT_BASE_STRUCT){
+        .audio_buffer = 0.2,
+        .audio_device = "auto",
+        .audio_client_name = "mpv",
+    },
+};
+
 static struct ao *ao_alloc(bool probing, struct mpv_global *global,
                            void (*wakeup_cb)(void *ctx), void *wakeup_ctx,
                            char *name)
 {
     assert(wakeup_cb);
 
-    struct MPOpts *opts = global->opts;
     struct mp_log *log = mp_log_new(NULL, global->log, "ao");
     struct m_obj_desc desc;
     if (!m_obj_list_find(&desc, &ao_obj_list, bstr0(name))) {
@@ -143,6 +160,7 @@
         talloc_free(log);
         return NULL;
     };
+    struct ao_opts *opts = mp_get_config_group(NULL, global, &ao_conf);
     struct ao *ao = talloc_ptrtype(NULL, ao);
     talloc_steal(ao, log);
     *ao = (struct ao) {
@@ -155,6 +173,7 @@
         .def_buffer = opts->audio_buffer,
         .client_name = talloc_strdup(ao, opts->audio_client_name),
     };
+    talloc_free(opts);
     ao->priv = m_config_group_from_desc(ao, ao->log, global, &desc, name);
     if (!ao->priv)
         goto error;
@@ -267,8 +286,8 @@
                         struct encode_lavc_context *encode_lavc_ctx,
                         int samplerate, int format, struct mp_chmap channels)
 {
-    struct MPOpts *opts = global->opts;
     void *tmp = talloc_new(NULL);
+    struct ao_opts *opts = mp_get_config_group(tmp, global, &ao_conf);
     struct mp_log *log = mp_log_new(tmp, global->log, "ao");
     struct ao *ao = NULL;
     struct m_obj_settings *ao_list = NULL;
diff -ruN mpv-0.29.1/audio/out/ao.h mpv-master/audio/out/ao.h
--- mpv-0.29.1/audio/out/ao.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/audio/out/ao.h	2019-09-19 04:02:03.000000000 +0700
@@ -83,6 +83,13 @@
 struct input_ctx;
 struct encode_lavc_context;
 
+struct ao_opts {
+    struct m_obj_settings *audio_driver_list;
+    char *audio_device;
+    char *audio_client_name;
+    double audio_buffer;
+};
+
 struct ao *ao_init_best(struct mpv_global *global,
                         int init_flags,
                         void (*wakeup_cb)(void *ctx), void *wakeup_ctx,
diff -ruN mpv-0.29.1/audio/out/ao_audiounit.m mpv-master/audio/out/ao_audiounit.m
--- mpv-0.29.1/audio/out/ao_audiounit.m	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/audio/out/ao_audiounit.m	2019-09-19 04:02:03.000000000 +0700
@@ -49,8 +49,8 @@
         planes[n] = buffer_list->mBuffers[n].mData;
 
     int64_t end = mp_time_us();
-    end += ca_frames_to_us(ao, frames);
     end += p->device_latency * 1e6;
+    end += ca_get_latency(ts) + ca_frames_to_us(ao, frames);
     ao_read_data(ao, planes, frames, end);
     return noErr;
 }
@@ -155,7 +155,7 @@
     struct priv *p = ao->priv;
     AVAudioSession *instance = AVAudioSession.sharedInstance;
 
-    p->device_latency = [instance outputLatency];
+    p->device_latency = [instance outputLatency] + [instance IOBufferDuration];
 
     OSStatus err = AudioOutputUnitStart(p->audio_unit);
     CHECK_CA_WARN("can't start audio unit");
@@ -192,7 +192,7 @@
     .name           = "audiounit",
     .uninit         = uninit,
     .init           = init,
-    .pause          = stop,
+    .reset          = stop,
     .resume         = start,
     .priv_size      = sizeof(struct priv),
 };
diff -ruN mpv-0.29.1/audio/out/ao_coreaudio_utils.c mpv-master/audio/out/ao_coreaudio_utils.c
--- mpv-0.29.1/audio/out/ao_coreaudio_utils.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/audio/out/ao_coreaudio_utils.c	2019-09-19 04:02:03.000000000 +0700
@@ -31,6 +31,8 @@
 #if HAVE_COREAUDIO
 #include "audio/out/ao_coreaudio_properties.h"
 #include <CoreAudio/HostTime.h>
+#else
+#include <mach/mach_time.h>
 #endif
 
 CFStringRef cfstr_from_cstr(char *str)
@@ -310,9 +312,9 @@
     return frames / (float) ao->samplerate * 1e6;
 }
 
-#if HAVE_COREAUDIO
 int64_t ca_get_latency(const AudioTimeStamp *ts)
 {
+#if HAVE_COREAUDIO
     uint64_t out = AudioConvertHostTimeToNanos(ts->mHostTime);
     uint64_t now = AudioConvertHostTimeToNanos(AudioGetCurrentHostTime());
 
@@ -320,8 +322,22 @@
         return 0;
 
     return (out - now) * 1e-3;
+#else
+    static mach_timebase_info_data_t timebase;
+    if (timebase.denom == 0)
+        mach_timebase_info(&timebase);
+
+    uint64_t out = ts->mHostTime;
+    uint64_t now = mach_absolute_time();
+
+    if (now > out)
+        return 0;
+
+    return (out - now) * timebase.numer / timebase.denom / 1e3;
+#endif
 }
 
+#if HAVE_COREAUDIO
 bool ca_stream_supports_compressed(struct ao *ao, AudioStreamID stream)
 {
     AudioStreamRangedDescription *formats = NULL;
diff -ruN mpv-0.29.1/audio/out/ao_coreaudio_utils.h mpv-master/audio/out/ao_coreaudio_utils.h
--- mpv-0.29.1/audio/out/ao_coreaudio_utils.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/audio/out/ao_coreaudio_utils.h	2019-09-19 04:02:03.000000000 +0700
@@ -65,9 +65,7 @@
                        AudioStreamBasicDescription *new);
 
 int64_t ca_frames_to_us(struct ao *ao, uint32_t frames);
-#if HAVE_COREAUDIO
 int64_t ca_get_latency(const AudioTimeStamp *ts);
-#endif
 
 #if HAVE_COREAUDIO
 bool ca_stream_supports_compressed(struct ao *ao, AudioStreamID stream);
diff -ruN mpv-0.29.1/audio/out/ao_opensles.c mpv-master/audio/out/ao_opensles.c
--- mpv-0.29.1/audio/out/ao_opensles.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/audio/out/ao_opensles.c	2019-09-19 04:02:03.000000000 +0700
@@ -35,18 +35,13 @@
     SLBufferQueueItf buffer_queue;
     SLEngineItf engine;
     SLPlayItf play;
-    char *buf;
-    size_t buffer_size;
+    void *buf;
+    int bytes_per_enqueue;
     pthread_mutex_t buffer_lock;
     double audio_latency;
 
-    int cfg_frames_per_buffer;
-};
-
-static const int fmtmap[][2] = {
-    { AF_FORMAT_U8, SL_PCMSAMPLEFORMAT_FIXED_8 },
-    { AF_FORMAT_S16, SL_PCMSAMPLEFORMAT_FIXED_16 },
-    { 0 }
+    int frames_per_enqueue;
+    int buffer_size_in_ms;
 };
 
 #define DESTROY(thing) \
@@ -71,7 +66,6 @@
 
     free(p->buf);
     p->buf = NULL;
-    p->buffer_size = 0;
 }
 
 #undef DESTROY
@@ -81,26 +75,22 @@
     struct ao *ao = context;
     struct priv *p = ao->priv;
     SLresult res;
-    void *data[1];
     double delay;
 
     pthread_mutex_lock(&p->buffer_lock);
 
-    data[0] = p->buf;
-    delay = 2 * p->buffer_size / (double)ao->bps;
+    delay = p->frames_per_enqueue / (double)ao->samplerate;
     delay += p->audio_latency;
-    ao_read_data(ao, data, p->buffer_size / ao->sstride,
+    ao_read_data(ao, &p->buf, p->frames_per_enqueue,
         mp_time_us() + 1000000LL * delay);
 
-    res = (*buffer_queue)->Enqueue(buffer_queue, p->buf, p->buffer_size);
+    res = (*buffer_queue)->Enqueue(buffer_queue, p->buf, p->bytes_per_enqueue);
     if (res != SL_RESULT_SUCCESS)
         MP_ERR(ao, "Failed to Enqueue: %d\n", res);
 
     pthread_mutex_unlock(&p->buffer_lock);
 }
 
-#define DEFAULT_BUFFER_SIZE_MS 250
-
 #define CHK(stmt) \
     { \
         SLresult res = stmt; \
@@ -115,7 +105,7 @@
     struct priv *p = ao->priv;
     SLDataLocator_BufferQueue locator_buffer_queue;
     SLDataLocator_OutputMix locator_output_mix;
-    SLDataFormat_PCM pcm;
+    SLAndroidDataFormat_PCM_EX pcm;
     SLDataSource audio_source;
     SLDataSink audio_sink;
 
@@ -129,43 +119,55 @@
     CHK((*p->output_mix)->Realize(p->output_mix, SL_BOOLEAN_FALSE));
 
     locator_buffer_queue.locatorType = SL_DATALOCATOR_BUFFERQUEUE;
-    locator_buffer_queue.numBuffers = 1;
+    locator_buffer_queue.numBuffers = 8;
 
-    pcm.formatType = SL_DATAFORMAT_PCM;
-    pcm.numChannels = 2;
-
-    int compatible_formats[AF_FORMAT_COUNT + 1];
-    af_get_best_sample_formats(ao->format, compatible_formats);
-    pcm.bitsPerSample = 0;
-    for (int i = 0; compatible_formats[i] && !pcm.bitsPerSample; ++i)
-        for (int j = 0; fmtmap[j][0]; ++j)
-            if (compatible_formats[i] == fmtmap[j][0]) {
-                ao->format = fmtmap[j][0];
-                pcm.bitsPerSample = fmtmap[j][1];
-                break;
-            }
-    if (!pcm.bitsPerSample) {
-        MP_ERR(ao, "Cannot find compatible audio format\n");
-        goto error;
+    if (af_fmt_is_int(ao->format)) {
+        // Be future-proof
+        if (af_fmt_to_bytes(ao->format) > 2)
+            ao->format = AF_FORMAT_S32;
+        else
+            ao->format = af_fmt_from_planar(ao->format);
+        pcm.formatType = SL_DATAFORMAT_PCM;
+    } else {
+        ao->format = AF_FORMAT_FLOAT;
+        pcm.formatType = SL_ANDROID_DATAFORMAT_PCM_EX;
+        pcm.representation = SL_ANDROID_PCM_REPRESENTATION_FLOAT;
     }
-    pcm.containerSize = 8 * af_fmt_to_bytes(ao->format);
+    pcm.numChannels = ao->channels.num;
+    pcm.containerSize = pcm.bitsPerSample = 8 * af_fmt_to_bytes(ao->format);
     pcm.channelMask = SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT;
     pcm.endianness = SL_BYTEORDER_LITTLEENDIAN;
+    pcm.sampleRate = ao->samplerate * 1000;
 
-    // samplesPerSec is misnamed, actually it's samples per ms
-    pcm.samplesPerSec = ao->samplerate * 1000;
+    if (p->buffer_size_in_ms) {
+        ao->device_buffer = ao->samplerate * p->buffer_size_in_ms / 1000;
+        // As the purpose of buffer_size_in_ms is to request a specific
+        // soft buffer size:
+        ao->def_buffer = 0;
+    }
+
+    // But it does not make sense if it is smaller than the enqueue size:
+    if (p->frames_per_enqueue) {
+        ao->device_buffer = MPMAX(ao->device_buffer, p->frames_per_enqueue);
+    } else {
+        if (ao->device_buffer) {
+            p->frames_per_enqueue = ao->device_buffer;
+        } else if (ao->def_buffer) {
+            p->frames_per_enqueue = ao->def_buffer * ao->samplerate;
+        } else {
+            MP_ERR(ao, "Enqueue size is not set and can neither be derived\n");
+            goto error;
+        }
+    }
 
-    if (p->cfg_frames_per_buffer)
-        ao->device_buffer = p->cfg_frames_per_buffer;
-    else
-        ao->device_buffer = ao->samplerate * DEFAULT_BUFFER_SIZE_MS / 1000;
-    p->buffer_size = ao->device_buffer * ao->channels.num *
+    p->bytes_per_enqueue = p->frames_per_enqueue * ao->channels.num *
         af_fmt_to_bytes(ao->format);
-    p->buf = calloc(1, p->buffer_size);
+    p->buf = calloc(1, p->bytes_per_enqueue);
     if (!p->buf) {
         MP_ERR(ao, "Failed to allocate device buffer\n");
         goto error;
     }
+
     int r = pthread_mutex_init(&p->buffer_lock, NULL);
     if (r) {
         MP_ERR(ao, "Failed to initialize the mutex: %d\n", r);
@@ -248,8 +250,12 @@
     .resume    = resume,
 
     .priv_size = sizeof(struct priv),
+    .priv_defaults = &(const struct priv) {
+        .buffer_size_in_ms = 250,
+    },
     .options = (const struct m_option[]) {
-        OPT_INTRANGE("frames-per-buffer", cfg_frames_per_buffer, 0, 1, 96000),
+        OPT_INTRANGE("frames-per-enqueue", frames_per_enqueue, 0, 1, 96000),
+        OPT_INTRANGE("buffer-size-in-ms", buffer_size_in_ms, 0, 0, 500),
         {0}
     },
     .options_prefix = "opensles",
diff -ruN mpv-0.29.1/bootstrap.py mpv-master/bootstrap.py
--- mpv-0.29.1/bootstrap.py	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/bootstrap.py	2019-09-19 04:02:03.000000000 +0700
@@ -16,6 +16,10 @@
         print("Found 'waf', skipping download.")
         sys.exit(0)
 
+if "--no-download" in sys.argv[1:]:
+    print("Did not find {} and no download was requested.".format(WAFRELEASE))
+    sys.exit(1)
+
 try:
     from urllib.request import urlopen, URLError
 except:
diff -ruN mpv-0.29.1/ci/build-macos.sh mpv-master/ci/build-macos.sh
--- mpv-0.29.1/ci/build-macos.sh	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/ci/build-macos.sh	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,26 @@
+#!/usr/bin/env bash
+
+set -e
+
+FFMPEG_SYSROOT="${HOME}/deps/sysroot"
+MPV_INSTALL_PREFIX="${HOME}/out/mpv"
+MPV_VARIANT="${TRAVIS_OS_NAME}"
+
+if [[ -d "./build/${MPV_VARIANT}" ]] ; then
+    rm -rf "./build/${MPV_VARIANT}"
+fi
+
+if [[ ! -e "./waf" ]] ; then
+    python3 ./bootstrap.py
+fi
+
+PKG_CONFIG_PATH="${FFMPEG_SYSROOT}/lib/pkgconfig/" CC="${CC}" CXX="${CXX}" python3 \
+  ./waf configure \
+    --variant="${MPV_VARIANT}" \
+    --prefix="${MPV_INSTALL_PREFIX}" \
+    --enable-{gl,iconv,lcms2,libass,libass-osd,libmpv-shared,lua,jpeg,plain-gl,zlib} \
+    --enable-{apple-remote,cocoa,coreaudio,gl-cocoa,macos-cocoa-cb,macos-touchbar,videotoolbox-gl}
+
+python3 ./waf build --variant="${MPV_VARIANT}" -j4
+
+python3 ./waf install --variant="${MPV_VARIANT}"
diff -ruN mpv-0.29.1/ci/build-mingw64.sh mpv-master/ci/build-mingw64.sh
--- mpv-0.29.1/ci/build-mingw64.sh	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/ci/build-mingw64.sh	2019-09-19 04:02:03.000000000 +0700
@@ -24,7 +24,6 @@
     --enable-libarchive \
     --enable-libass \
     --enable-libbluray \
-    --enable-dvdread \
     --enable-dvdnav \
     --enable-uchardet \
     --enable-vulkan \
diff -ruN mpv-0.29.1/ci/build-tumbleweed.sh mpv-master/ci/build-tumbleweed.sh
--- mpv-0.29.1/ci/build-tumbleweed.sh	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/ci/build-tumbleweed.sh	2019-09-19 04:02:03.000000000 +0700
@@ -5,7 +5,6 @@
   --enable-cdda          \
   --enable-dvbin         \
   --enable-dvdnav        \
-  --enable-dvdread       \
   --enable-libarchive    \
   --enable-libmpv-shared \
   --enable-libsmbclient  \
diff -ruN mpv-0.29.1/ci/get_ffmpeg.sh mpv-master/ci/get_ffmpeg.sh
--- mpv-0.29.1/ci/get_ffmpeg.sh	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/ci/get_ffmpeg.sh	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,38 @@
+#!/usr/bin/env bash
+
+set -e
+
+FFMPEG_SRC_DIR="${HOME}/deps/src/ffmpeg"
+FFMPEG_BUILD_DIR="${FFMPEG_SRC_DIR}/${TRAVIS_OS_NAME}"
+FFMPEG_SYSROOT="${HOME}/deps/sysroot"
+FFMPEG_HASH="18928e2bb4568cbe5e9061c3e6b63559392af3d2"
+
+# Get the sauce if not around
+if [[ ! -d "${FFMPEG_SRC_DIR}" ]] ; then
+    git clone "https://git.videolan.org/git/ffmpeg.git" "${FFMPEG_SRC_DIR}"
+fi
+
+# pop into FFmpeg's source dir and clean up & check out our wanted revision
+pushd "${FFMPEG_SRC_DIR}"
+git reset --hard HEAD && git clean -dfx
+git checkout "${FFMPEG_HASH}"
+popd
+
+# If a build dir of the same type is around, clean it up
+if [[ -d "${FFMPEG_BUILD_DIR}" ]] ; then
+    rm -rf "${FFMPEG_BUILD_DIR}"
+fi
+
+# Create and move into the build dir, configure and build!
+mkdir -p "${FFMPEG_BUILD_DIR}" && pushd "${FFMPEG_BUILD_DIR}"
+
+PKG_CONFIG_PATH="${FFMPEG_SYSROOT}/lib/pkgconfig/" ../configure \
+  --disable-{autodetect,stripping} \
+  --cc="${CC}" \
+  --cxx="${CXX}" \
+  --prefix="${FFMPEG_SYSROOT}" \
+  --enable-{zlib,securetransport,videotoolbox}
+
+make -j4 && make install && popd
+
+exit 0
diff -ruN mpv-0.29.1/common/encode_lavc.c mpv-master/common/encode_lavc.c
--- mpv-0.29.1/common/encode_lavc.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/common/encode_lavc.c	2019-09-19 04:02:03.000000000 +0700
@@ -422,6 +422,11 @@
 
     dst->encoder_timebase = info->timebase;
     dst->st->time_base = info->timebase; // lavf will change this on muxer init
+    // Some muxers (e.g. Matroska one) expect the sample_aspect_ratio to be
+    // set on the AVStream.
+    if (info->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
+        dst->st->sample_aspect_ratio = info->codecpar->sample_aspect_ratio;
+    
     if (avcodec_parameters_copy(dst->st->codecpar, info->codecpar) < 0)
         MP_HANDLE_OOM(0);
 
@@ -476,8 +481,6 @@
     if (av_interleaved_write_frame(p->muxer, pkt) < 0) {
         MP_ERR(p, "Writing packet failed.\n");
         p->failed = true;
-        pkt = NULL;
-        goto done;
     }
 
     pkt = NULL;
diff -ruN mpv-0.29.1/common/global.h mpv-master/common/global.h
--- mpv-0.29.1/common/global.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/common/global.h	2019-09-19 04:02:03.000000000 +0700
@@ -8,10 +8,7 @@
     struct mp_log *log;
     struct m_config_shadow *config;
     struct mp_client_api *client_api;
-
-    // Using this is deprecated and should be avoided (missing synchronization).
-    // Use m_config_cache to access mpv_global.config instead.
-    struct MPOpts *opts;
+    char *configdir;
 };
 
 #endif
diff -ruN mpv-0.29.1/common/msg.c mpv-master/common/msg.c
--- mpv-0.29.1/common/msg.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/common/msg.c	2019-09-19 04:02:03.000000000 +0700
@@ -127,19 +127,19 @@
     pthread_mutex_unlock(&mp_msg_lock);
 }
 
-// Return whether the message at this verbosity level would be actually printed.
+// Get the current effective msg level.
 // Thread-safety: see mp_msg().
-bool mp_msg_test(struct mp_log *log, int lev)
+int mp_msg_level(struct mp_log *log)
 {
     struct mp_log_root *root = log->root;
     if (!root)
-        return false;
+        return -1;
     if (atomic_load_explicit(&log->reload_counter, memory_order_relaxed) !=
         atomic_load_explicit(&root->reload_counter, memory_order_relaxed))
     {
         update_loglevel(log);
     }
-    return lev <= log->level;
+    return log->level;
 }
 
 // Reposition cursor and clear lines for outputting the status line. In certain
@@ -460,8 +460,6 @@
     struct mp_log *log = mp_log_new(root, &dummy, "");
 
     global->log = log;
-
-    mp_msg_update_msglevels(global);
 }
 
 // If opt is different from *current_path, reopen *file and update *current_path.
@@ -501,13 +499,9 @@
     talloc_free(tmp);
 }
 
-void mp_msg_update_msglevels(struct mpv_global *global)
+void mp_msg_update_msglevels(struct mpv_global *global, struct MPOpts *opts)
 {
     struct mp_log_root *root = global->log->root;
-    struct MPOpts *opts = global->opts;
-
-    if (!opts)
-        return;
 
     pthread_mutex_lock(&mp_msg_lock);
 
@@ -522,8 +516,7 @@
     }
 
     m_option_type_msglevels.free(&root->msg_levels);
-    m_option_type_msglevels.copy(NULL, &root->msg_levels,
-                                 &global->opts->msg_levels);
+    m_option_type_msglevels.copy(NULL, &root->msg_levels, &opts->msg_levels);
 
     atomic_fetch_add(&root->reload_counter, 1);
     pthread_mutex_unlock(&mp_msg_lock);
diff -ruN mpv-0.29.1/common/msg.h mpv-master/common/msg.h
--- mpv-0.29.1/common/msg.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/common/msg.h	2019-09-19 04:02:03.000000000 +0700
@@ -52,7 +52,12 @@
     PRINTF_ATTRIBUTE(3, 4);
 void mp_msg_va(struct mp_log *log, int lev, const char *format, va_list va);
 
-bool mp_msg_test(struct mp_log *log, int lev);
+int mp_msg_level(struct mp_log *log);
+
+static inline bool mp_msg_test(struct mp_log *log, int lev)
+{
+    return lev <= mp_msg_level(log);
+}
 
 // Convenience macros.
 #define mp_fatal(log, ...)      mp_msg(log, MSGL_FATAL, __VA_ARGS__)
diff -ruN mpv-0.29.1/common/msg_control.h mpv-master/common/msg_control.h
--- mpv-0.29.1/common/msg_control.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/common/msg_control.h	2019-09-19 04:02:03.000000000 +0700
@@ -4,9 +4,10 @@
 #include <stdbool.h>
 
 struct mpv_global;
+struct MPOpts;
 void mp_msg_init(struct mpv_global *global);
 void mp_msg_uninit(struct mpv_global *global);
-void mp_msg_update_msglevels(struct mpv_global *global);
+void mp_msg_update_msglevels(struct mpv_global *global, struct MPOpts *opts);
 void mp_msg_force_stderr(struct mpv_global *global, bool force_stderr);
 bool mp_msg_has_status_line(struct mpv_global *global);
 bool mp_msg_has_log_file(struct mpv_global *global);
diff -ruN mpv-0.29.1/common/playlist.c mpv-master/common/playlist.c
--- mpv-0.29.1/common/playlist.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/common/playlist.c	2019-09-19 04:02:03.000000000 +0700
@@ -275,13 +275,14 @@
     }
 }
 
-struct playlist *playlist_parse_file(const char *file, struct mpv_global *global)
+struct playlist *playlist_parse_file(const char *file, struct mp_cancel *cancel,
+                                     struct mpv_global *global)
 {
     struct mp_log *log = mp_log_new(NULL, global->log, "!playlist_parser");
     mp_verbose(log, "Parsing playlist file %s...\n", file);
 
     struct demuxer_params p = {.force_format = "playlist"};
-    struct demuxer *d = demux_open_url(file, &p, NULL, global);
+    struct demuxer *d = demux_open_url(file, &p, cancel, global);
     if (!d) {
         talloc_free(log);
         return NULL;
@@ -296,7 +297,7 @@
                          "pass it to the player\ndirectly. Don't use --playlist.\n");
         }
     }
-    free_demuxer_and_stream(d);
+    demux_free(d);
 
     if (ret) {
         mp_verbose(log, "Playlist successfully parsed\n");
diff -ruN mpv-0.29.1/common/playlist.h mpv-master/common/playlist.h
--- mpv-0.29.1/common/playlist.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/common/playlist.h	2019-09-19 04:02:03.000000000 +0700
@@ -101,8 +101,10 @@
 int playlist_entry_count(struct playlist *pl);
 struct playlist_entry *playlist_entry_from_index(struct playlist *pl, int index);
 
+struct mp_cancel;
 struct mpv_global;
-struct playlist *playlist_parse_file(const char *file, struct mpv_global *global);
+struct playlist *playlist_parse_file(const char *file, struct mp_cancel *cancel,
+                                     struct mpv_global *global);
 
 void playlist_entry_unref(struct playlist_entry *e);
 
diff -ruN mpv-0.29.1/common/recorder.c mpv-master/common/recorder.c
--- mpv-0.29.1/common/recorder.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/common/recorder.c	2019-09-19 04:02:03.000000000 +0700
@@ -335,8 +335,7 @@
 // mp_recorder_create().
 struct mp_recorder_sink *mp_recorder_get_sink(struct mp_recorder *r, int stream)
 {
-    assert(stream >= 0 && stream < r->num_streams);
-    return r->streams[stream];
+    return stream >= 0 && stream < r->num_streams ? r->streams[stream] : NULL;
 }
 
 // Pass a packet to the given stream. The function does not own the packet, but
diff -ruN mpv-0.29.1/demux/codec_tags.c mpv-master/demux/codec_tags.c
--- mpv-0.29.1/demux/codec_tags.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/demux/codec_tags.c	2019-09-19 04:02:03.000000000 +0700
@@ -50,14 +50,8 @@
     return id == AV_CODEC_ID_NONE ? NULL : mp_codec_from_av_codec_id(id);
 }
 
-static const unsigned char guid_pcm[16] =
-    {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
-     0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71};
-static const unsigned char guid_float[16] =
-    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
-     0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71};
-// Corresponds to FF_MEDIASUBTYPE_BASE_GUID (plus 4 bytes of padding).
-static const unsigned char guid_ffext[16] =
+// Corresponds to WMMEDIASUBTYPE_Base.
+static const unsigned char guid_ext_base[16] =
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
      0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71};
 
@@ -74,18 +68,14 @@
 
         // WAVEFORMATEXTENSIBLE.SubFormat
         unsigned char *subformat = c->extradata + 6;
-        if (memcmp(subformat + 4, guid_ffext + 4, 12) == 0) {
+        if (memcmp(subformat + 4, guid_ext_base + 4, 12) == 0) {
             c->codec_tag = AV_RL32(subformat);
             c->codec = lookup_tag(c->type, c->codec_tag);
         }
-        if (memcmp(subformat, guid_pcm, 16) == 0)
-            c->codec_tag = 0x0;
-        if (memcmp(subformat, guid_float, 16) == 0)
-            c->codec_tag = 0x3;
 
         // Compressed formats might use this.
         c->extradata += 22;
-        c->extradata_size += 22;
+        c->extradata_size -= 22;
     }
 
     int bits = c->bits_per_coded_sample;
diff -ruN mpv-0.29.1/demux/cue.c mpv-master/demux/cue.c
--- mpv-0.29.1/demux/cue.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/demux/cue.c	2019-09-19 04:02:03.000000000 +0700
@@ -113,16 +113,17 @@
     return data;
 }
 
-// Read a 2 digit unsigned decimal integer.
+// Read an unsigned decimal integer.
+// Optionally check if it is 2 digit.
 // Return -1 on failure.
-static int read_int_2(struct bstr *data)
+static int read_int(struct bstr *data, bool two_digit)
 {
     *data = bstr_lstrip(*data);
     if (data->len && data->start[0] == '-')
         return -1;
     struct bstr s = *data;
     int res = (int)bstrtoll(s, &s, 10);
-    if (data->len == s.len || data->len - s.len > 2)
+    if (data->len == s.len || (two_digit && data->len - s.len > 2))
         return -1;
     *data = s;
     return res;
@@ -132,11 +133,11 @@
 {
     struct bstr s = *data;
     bool ok = true;
-    double t1 = read_int_2(&s);
+    double t1 = read_int(&s, false);
     ok = eat_char(&s, ':') && ok;
-    double t2 = read_int_2(&s);
+    double t2 = read_int(&s, true);
     ok = eat_char(&s, ':') && ok;
-    double t3 = read_int_2(&s);
+    double t3 = read_int(&s, true);
     ok = ok && t1 >= 0 && t2 >= 0 && t3 >= 0;
     return ok ? t1 * 60.0 + t2 + t3 * SECS_PER_CUE_FRAME : 0;
 }
@@ -205,7 +206,7 @@
             break;
         }
         case CUE_INDEX: {
-            int type = read_int_2(&param);
+            int type = read_int(&param, true);
             double time = read_time(&param);
             if (cur_track) {
                 if (type == 1) {
diff -ruN mpv-0.29.1/demux/demux.c mpv-master/demux/demux.c
--- mpv-0.29.1/demux/demux.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/demux/demux.c	2019-09-19 04:02:03.000000000 +0700
@@ -22,6 +22,7 @@
 #include <unistd.h>
 #include <limits.h>
 #include <pthread.h>
+#include <stdint.h>
 
 #include <math.h>
 
@@ -34,7 +35,10 @@
 #include "mpv_talloc.h"
 #include "common/msg.h"
 #include "common/global.h"
+#include "common/recorder.h"
+#include "misc/thread_tools.h"
 #include "osdep/atomic.h"
+#include "osdep/timer.h"
 #include "osdep/threads.h"
 
 #include "stream/stream.h"
@@ -48,12 +52,10 @@
 extern const struct demuxer_desc demuxer_desc_cue;
 extern const demuxer_desc_t demuxer_desc_rawaudio;
 extern const demuxer_desc_t demuxer_desc_rawvideo;
-extern const demuxer_desc_t demuxer_desc_tv;
 extern const demuxer_desc_t demuxer_desc_mf;
 extern const demuxer_desc_t demuxer_desc_matroska;
 extern const demuxer_desc_t demuxer_desc_lavf;
 extern const demuxer_desc_t demuxer_desc_playlist;
-extern const demuxer_desc_t demuxer_desc_disc;
 extern const demuxer_desc_t demuxer_desc_rar;
 extern const demuxer_desc_t demuxer_desc_libarchive;
 extern const demuxer_desc_t demuxer_desc_null;
@@ -64,19 +66,14 @@
  * libraries and demuxers requiring binary support. */
 
 const demuxer_desc_t *const demuxer_list[] = {
-    &demuxer_desc_disc,
     &demuxer_desc_edl,
     &demuxer_desc_cue,
     &demuxer_desc_rawaudio,
     &demuxer_desc_rawvideo,
-#if HAVE_TV
-    &demuxer_desc_tv,
-#endif
     &demuxer_desc_matroska,
 #if HAVE_LIBARCHIVE
     &demuxer_desc_libarchive,
 #endif
-    &demuxer_desc_rar,
     &demuxer_desc_lavf,
     &demuxer_desc_mf,
     &demuxer_desc_playlist,
@@ -85,6 +82,7 @@
 };
 
 struct demux_opts {
+    int enable_cache;
     int64_t max_bytes;
     int64_t max_bytes_bw;
     double min_secs;
@@ -93,25 +91,34 @@
     int access_references;
     int seekable_cache;
     int create_ccs;
+    char *record_file;
 };
 
 #define OPT_BASE_STRUCT struct demux_opts
 
+#define MAX_BYTES MPMIN(INT64_MAX, SIZE_MAX / 2)
+
 const struct m_sub_options demux_conf = {
     .opts = (const struct m_option[]){
+        OPT_CHOICE("cache", enable_cache, 0,
+                   ({"no", 0}, {"auto", -1}, {"yes", 1})),
         OPT_DOUBLE("demuxer-readahead-secs", min_secs, M_OPT_MIN, .min = 0),
-        OPT_BYTE_SIZE("demuxer-max-bytes", max_bytes, 0, 0, INT_MAX),
-        OPT_BYTE_SIZE("demuxer-max-back-bytes", max_bytes_bw, 0, 0, INT_MAX),
+        // (The MAX_BYTES sizes may not be accurate because the max field is
+        // of double type.)
+        OPT_BYTE_SIZE("demuxer-max-bytes", max_bytes, 0, 0, MAX_BYTES),
+        OPT_BYTE_SIZE("demuxer-max-back-bytes", max_bytes_bw, 0, 0, MAX_BYTES),
         OPT_FLAG("force-seekable", force_seekable, 0),
         OPT_DOUBLE("cache-secs", min_secs_cache, M_OPT_MIN, .min = 0),
         OPT_FLAG("access-references", access_references, 0),
         OPT_CHOICE("demuxer-seekable-cache", seekable_cache, 0,
                    ({"auto", -1}, {"no", 0}, {"yes", 1})),
         OPT_FLAG("sub-create-cc-track", create_ccs, 0),
+        OPT_STRING("stream-record", record_file, 0),
         {0}
     },
     .size = sizeof(struct demux_opts),
     .defaults = &(const struct demux_opts){
+        .enable_cache = -1, // auto
         .max_bytes = 150 * 1024 * 1024,
         .max_bytes_bw = 50 * 1024 * 1024,
         .min_secs = 1.0,
@@ -124,11 +131,15 @@
 struct demux_internal {
     struct mp_log *log;
 
+    struct demux_opts *opts;
+
     // The demuxer runs potentially in another thread, so we keep two demuxer
     // structs; the real demuxer can access the shadow struct only.
     struct demuxer *d_thread;   // accessed by demuxer impl. (producer)
     struct demuxer *d_user;     // accessed by player (consumer)
 
+    bool owns_stream;
+
     // The lock protects the packet queues (struct demux_stream),
     // and the fields below.
     pthread_mutex_t lock;
@@ -139,6 +150,7 @@
 
     bool thread_terminate;
     bool threading;
+    bool shutdown_async;
     void (*wakeup_cb)(void *ctx);
     void *wakeup_cb_ctx;
 
@@ -160,8 +172,8 @@
     bool idle;
     bool autoselect;
     double min_secs;
-    int max_bytes;
-    int max_bytes_bw;
+    size_t max_bytes;
+    size_t max_bytes_bw;
     bool seekable_cache;
 
     // At least one decoder actually requested data since init or the last seek.
@@ -207,11 +219,16 @@
     // Transient state.
     double duration;
     // Cached state.
-    bool force_cache_update;
-    struct stream_cache_info stream_cache_info;
     int64_t stream_size;
+    int64_t last_speed_query;
+    uint64_t bytes_per_second;
+    int64_t next_cache_update;
     // Updated during init only.
     char *stream_base_filename;
+
+    // -- Access from demuxer thread only
+    bool enable_recording;
+    struct mp_recorder *recorder;
 };
 
 // A continuous range of cached packets for all enabled streams.
@@ -508,23 +525,40 @@
     range->is_bof = true;
     range->is_eof = true;
 
+    double min_start_pts = MP_NOPTS_VALUE;
+    double max_end_pts = MP_NOPTS_VALUE;
+
     for (int n = 0; n < range->num_streams; n++) {
         struct demux_queue *queue = range->streams[n];
 
         if (queue->ds->selected && queue->ds->eager) {
-            range->seek_start = MP_PTS_MAX(range->seek_start, queue->seek_start);
-            range->seek_end = MP_PTS_MIN(range->seek_end, queue->seek_end);
+            if (queue->is_bof) {
+                min_start_pts = MP_PTS_MIN(min_start_pts, queue->seek_start);
+            } else {
+                range->seek_start =
+                    MP_PTS_MAX(range->seek_start, queue->seek_start);
+            }
+
+            if (queue->is_eof) {
+                max_end_pts = MP_PTS_MAX(max_end_pts, queue->seek_end);
+            } else {
+                range->seek_end = MP_PTS_MIN(range->seek_end, queue->seek_end);
+            }
 
             range->is_eof &= queue->is_eof;
             range->is_bof &= queue->is_bof;
 
-            if (queue->seek_start >= queue->seek_end) {
-                range->seek_start = range->seek_end = MP_NOPTS_VALUE;
-                break;
-            }
+            bool empty = queue->is_eof && !queue->head;
+            if (queue->seek_start >= queue->seek_end && !empty)
+                goto broken;
         }
     }
 
+    if (range->is_eof)
+        range->seek_end = max_end_pts;
+    if (range->is_bof)
+        range->seek_start = min_start_pts;
+
     // Sparse stream behavior is not very clearly defined, but usually we don't
     // want it to restrict the range of other streams, unless
     // This is incorrect in any of these cases:
@@ -552,7 +586,12 @@
     }
 
     if (range->seek_start >= range->seek_end)
-        range->seek_start = range->seek_end = MP_NOPTS_VALUE;
+        goto broken;
+
+    return;
+
+broken:
+    range->seek_start = range->seek_end = MP_NOPTS_VALUE;
 }
 
 // Remove queue->head from the queue. Does not update in->fw_bytes/in->fw_packs.
@@ -920,35 +959,113 @@
     return r;
 }
 
-void free_demuxer(demuxer_t *demuxer)
+static void demux_shutdown(struct demux_internal *in)
 {
-    if (!demuxer)
-        return;
-    struct demux_internal *in = demuxer->in;
-    assert(demuxer == in->d_user);
+    struct demuxer *demuxer = in->d_user;
 
-    demux_stop_thread(demuxer);
+    if (in->recorder) {
+        mp_recorder_destroy(in->recorder);
+        in->recorder = NULL;
+    }
 
     if (demuxer->desc->close)
         demuxer->desc->close(in->d_thread);
+    demuxer->priv = NULL;
+    in->d_thread->priv = NULL;
 
     demux_flush(demuxer);
     assert(in->total_bytes == 0);
 
+    if (in->owns_stream)
+        free_stream(demuxer->stream);
+    demuxer->stream = NULL;
+}
+
+static void demux_dealloc(struct demux_internal *in)
+{
     for (int n = 0; n < in->num_streams; n++)
         talloc_free(in->streams[n]);
     pthread_mutex_destroy(&in->lock);
     pthread_cond_destroy(&in->wakeup);
-    talloc_free(demuxer);
+    talloc_free(in->d_user);
 }
 
-void free_demuxer_and_stream(struct demuxer *demuxer)
+void demux_free(struct demuxer *demuxer)
 {
     if (!demuxer)
         return;
-    struct stream *s = demuxer->stream;
-    free_demuxer(demuxer);
-    free_stream(s);
+    struct demux_internal *in = demuxer->in;
+    assert(demuxer == in->d_user);
+
+    demux_stop_thread(demuxer);
+    demux_shutdown(in);
+    demux_dealloc(in);
+}
+
+// Start closing the demuxer and eventually freeing the demuxer asynchronously.
+// You must not access the demuxer once this has been started. Once the demuxer
+// is shutdown, the wakeup callback is invoked. Then you need to call
+// demux_free_async_finish() to end the operation (it must not be called from
+// the wakeup callback).
+// This can return NULL. Then the demuxer cannot be free'd asynchronously, and
+// you need to call demux_free() instead.
+struct demux_free_async_state *demux_free_async(struct demuxer *demuxer)
+{
+    struct demux_internal *in = demuxer->in;
+    assert(demuxer == in->d_user);
+
+    if (!in->threading)
+        return NULL;
+
+    pthread_mutex_lock(&in->lock);
+    in->thread_terminate = true;
+    in->shutdown_async = true;
+    pthread_cond_signal(&in->wakeup);
+    pthread_mutex_unlock(&in->lock);
+
+    return (struct demux_free_async_state *)demuxer->in; // lies
+}
+
+// As long as state is valid, you can call this to request immediate abort.
+// Roughly behaves as demux_cancel_and_free(), except you still need to wait
+// for the result.
+void demux_free_async_force(struct demux_free_async_state *state)
+{
+    struct demux_internal *in = (struct demux_internal *)state; // reverse lies
+
+    mp_cancel_trigger(in->d_user->cancel);
+}
+
+// Check whether the demuxer is shutdown yet. If not, return false, and you
+// need to call this again in the future (preferably after you were notified by
+// the wakeup callback). If yes, deallocate all state, and return true (in
+// particular, the state ptr becomes invalid, and the wakeup callback will never
+// be called again).
+bool demux_free_async_finish(struct demux_free_async_state *state)
+{
+    struct demux_internal *in = (struct demux_internal *)state; // reverse lies
+
+    pthread_mutex_lock(&in->lock);
+    bool busy = in->shutdown_async;
+    pthread_mutex_unlock(&in->lock);
+
+    if (busy)
+        return false;
+
+    demux_stop_thread(in->d_user);
+    demux_dealloc(in);
+    return true;
+}
+
+// Like demux_free(), but trigger an abort, which will force the demuxer to
+// terminate immediately. If this wasn't opened with demux_open_url(), there is
+// some chance this will accidentally abort other things via demuxer->cancel.
+void demux_cancel_and_free(struct demuxer *demuxer)
+{
+    if (!demuxer)
+        return;
+    mp_cancel_trigger(demuxer->cancel);
+    demux_free(demuxer);
 }
 
 // Start the demuxer thread, which reads ahead packets on its own.
@@ -1397,6 +1514,33 @@
         }
     }
 
+    // (should preferable be outside of the lock)
+    if (in->enable_recording && !in->recorder &&
+        in->opts->record_file && in->opts->record_file[0])
+    {
+        // Later failures shouldn't make it retry and overwrite the previously
+        // recorded file.
+        in->enable_recording = false;
+
+        in->recorder =
+            mp_recorder_create(in->d_thread->global, in->opts->record_file,
+                               in->streams, in->num_streams);
+        if (!in->recorder)
+            MP_ERR(in, "Disabling recording.\n");
+    }
+
+    if (in->recorder) {
+        struct mp_recorder_sink *sink =
+            mp_recorder_get_sink(in->recorder, dp->stream);
+        if (sink) {
+            mp_recorder_feed_packet(sink, dp);
+        } else {
+            MP_ERR(in, "New stream appeared; stopping recording.\n");
+            mp_recorder_destroy(in->recorder);
+            in->recorder = NULL;
+        }
+    }
+
     wakeup_ds(ds);
     pthread_mutex_unlock(&in->lock);
 }
@@ -1564,8 +1708,6 @@
                 }
                 prev = prev->next;
             }
-
-            update_seek_ranges(range);
         }
 
         bool done = false;
@@ -1574,6 +1716,8 @@
             remove_head_packet(queue);
         }
 
+        update_seek_ranges(range);
+
         if (range != in->current_range && range->seek_start == MP_NOPTS_VALUE)
             free_empty_cached_ranges(in);
     }
@@ -1592,9 +1736,6 @@
     if (in->d_thread->desc->control)
         in->d_thread->desc->control(in->d_thread, DEMUXER_CTRL_SWITCHED_TRACKS, 0);
 
-    stream_control(in->d_thread->stream, STREAM_CTRL_SET_READAHEAD,
-                   &(int){any_selected});
-
     pthread_mutex_lock(&in->lock);
 }
 
@@ -1643,11 +1784,10 @@
         if (read_packet(in))
             return true; // read_packet unlocked, so recheck conditions
     }
-    if (in->force_cache_update) {
+    if (mp_time_us() >= in->next_cache_update) {
         pthread_mutex_unlock(&in->lock);
         update_cache(in);
         pthread_mutex_lock(&in->lock);
-        in->force_cache_update = false;
         return true;
     }
     return false;
@@ -1658,12 +1798,24 @@
     struct demux_internal *in = pctx;
     mpthread_set_name("demux");
     pthread_mutex_lock(&in->lock);
+
     while (!in->thread_terminate) {
         if (thread_work(in))
             continue;
         pthread_cond_signal(&in->wakeup);
-        pthread_cond_wait(&in->wakeup, &in->lock);
+        struct timespec until = mp_time_us_to_timespec(in->next_cache_update);
+        pthread_cond_timedwait(&in->wakeup, &in->lock, &until);
     }
+
+    if (in->shutdown_async) {
+        pthread_mutex_unlock(&in->lock);
+        demux_shutdown(in);
+        pthread_mutex_lock(&in->lock);
+        in->shutdown_async = false;
+        if (in->wakeup_cb)
+            in->wakeup_cb(in->wakeup_cb_ctx);
+    }
+
     pthread_mutex_unlock(&in->lock);
     return NULL;
 }
@@ -1941,12 +2093,17 @@
 {
     struct replaygain_data rg = {0};
 
+    // Set values in *rg, using track gain as a fallback for album gain if the
+    // latter is not present. This behavior matches that in demux/demux_lavf.c's
+    // export_replaygain; if you change this, please make equivalent changes
+    // there too.
     if (decode_gain(log, tags, "REPLAYGAIN_TRACK_GAIN", &rg.track_gain) >= 0 &&
         decode_peak(log, tags, "REPLAYGAIN_TRACK_PEAK", &rg.track_peak) >= 0)
     {
         if (decode_gain(log, tags, "REPLAYGAIN_ALBUM_GAIN", &rg.album_gain) < 0 ||
             decode_peak(log, tags, "REPLAYGAIN_ALBUM_PEAK", &rg.album_peak) < 0)
         {
+            // Album gain is undefined; fall back to track gain.
             rg.album_gain = rg.track_gain;
             rg.album_peak = rg.track_peak;
         }
@@ -2030,14 +2187,6 @@
     assert(demuxer == demuxer->in->d_user);
     struct demux_internal *in = demuxer->in;
 
-    int num_streams = MPMIN(in->num_streams, demuxer->num_update_stream_tags);
-    for (int n = 0; n < num_streams; n++) {
-        struct sh_stream *sh = in->streams[n];
-        // (replace them even if unnecessary, simpler and doesn't hurt)
-        if (sh->ds->tags_reader)
-            mp_tags_replace(sh->tags, sh->ds->tags_reader->sh);
-    }
-
     struct mp_packet_tags *tags =
         in->master_stream ? in->master_stream->tags_reader : NULL;
 
@@ -2162,6 +2311,19 @@
     }
 }
 
+// Return whether "heavy" caching on this stream is enabled. By default, this
+// corresponds to whether the source stream is considered in the network. The
+// only effect should be adjusting display behavior (of cache stats etc.), and
+// possibly switching between which set of options influence cache settings.
+bool demux_is_network_cached(demuxer_t *demuxer)
+{
+    struct demux_internal *in = demuxer->in;
+    bool use_cache = demuxer->stream->streaming;
+    if (in->opts->enable_cache >= 0)
+        use_cache = in->opts->enable_cache == 1;
+    return use_cache;
+}
+
 static struct demuxer *open_given_type(struct mpv_global *global,
                                        struct mp_log *log,
                                        const struct demuxer_desc *desc,
@@ -2177,6 +2339,7 @@
     *demuxer = (struct demuxer) {
         .desc = desc,
         .stream = stream,
+        .cancel = stream->cancel,
         .seekable = stream->seekable,
         .filepos = -1,
         .global = global,
@@ -2189,12 +2352,11 @@
         .duration = -1,
     };
     demuxer->seekable = stream->seekable;
-    if (demuxer->stream->underlying && !demuxer->stream->underlying->seekable)
-        demuxer->seekable = false;
 
     struct demux_internal *in = demuxer->in = talloc_ptrtype(demuxer, in);
     *in = (struct demux_internal){
         .log = demuxer->log,
+        .opts = opts,
         .d_thread = talloc(demuxer, struct demuxer),
         .d_user = demuxer,
         .min_secs = opts->min_secs,
@@ -2204,6 +2366,7 @@
         .highest_av_pts = MP_NOPTS_VALUE,
         .seeking_in_progress = MP_NOPTS_VALUE,
         .demux_ts = MP_NOPTS_VALUE,
+        .enable_recording = params && params->stream_record,
     };
     pthread_mutex_init(&in->lock, NULL);
     pthread_cond_init(&in->wakeup, NULL);
@@ -2255,10 +2418,8 @@
         fixup_metadata(in);
         in->events = DEMUX_EVENT_ALL;
         demux_update(demuxer);
-        stream_control(demuxer->stream, STREAM_CTRL_SET_READAHEAD,
-                       &(int){params ? params->initial_readahead : false});
         int seekable = opts->seekable_cache;
-        if (demuxer->is_network || stream->caching) {
+        if (demux_is_network_cached(demuxer)) {
             in->min_secs = MPMAX(in->min_secs, opts->min_secs_cache);
             if (seekable < 0)
                 seekable = 1;
@@ -2282,7 +2443,7 @@
         return demuxer;
     }
 
-    free_demuxer(demuxer);
+    demux_free(demuxer);
     return NULL;
 }
 
@@ -2291,6 +2452,9 @@
 static const int d_force[]   = {DEMUX_CHECK_FORCE, -1};
 
 // params can be NULL
+// If params->does_not_own_stream==false, this does _not_ free the stream if
+// opening fails. But if it succeeds, a later demux_free() call will free the
+// stream.
 struct demuxer *demux_open(struct stream *stream, struct demuxer_params *params,
                            struct mpv_global *global)
 {
@@ -2303,7 +2467,7 @@
     if (!force_format)
         force_format = stream->demuxer;
 
-    if (force_format && force_format[0]) {
+    if (force_format && force_format[0] && !stream->is_directory) {
         check_levels = d_request;
         if (force_format[0] == '+') {
             force_format += 1;
@@ -2330,6 +2494,8 @@
                 if (demuxer) {
                     talloc_steal(demuxer, log);
                     log = NULL;
+                    demuxer->in->owns_stream =
+                        params ? !params->does_not_own_stream : true;
                     goto done;
                 }
             }
@@ -2343,28 +2509,36 @@
 
 // Convenience function: open the stream, enable the cache (according to params
 // and global opts.), open the demuxer.
-// (use free_demuxer_and_stream() to free the underlying stream too)
 // Also for some reason may close the opened stream if it's not needed.
+// demuxer->cancel is not the cancel parameter, but is its own object that will
+// be a slave (mp_cancel_set_parent()) to provided cancel object.
+// demuxer->cancel is automatically freed.
 struct demuxer *demux_open_url(const char *url,
-                                struct demuxer_params *params,
-                                struct mp_cancel *cancel,
-                                struct mpv_global *global)
+                               struct demuxer_params *params,
+                               struct mp_cancel *cancel,
+                               struct mpv_global *global)
 {
     struct demuxer_params dummy = {0};
     if (!params)
         params = &dummy;
+    assert(!params->does_not_own_stream); // API user error
+    struct mp_cancel *priv_cancel = mp_cancel_new(NULL);
+    if (cancel)
+        mp_cancel_set_parent(priv_cancel, cancel);
     struct stream *s = stream_create(url, STREAM_READ | params->stream_flags,
-                                     cancel, global);
-    if (!s)
+                                     priv_cancel, global);
+    if (!s) {
+        talloc_free(priv_cancel);
         return NULL;
-    if (!params->disable_cache)
-        stream_enable_cache_defaults(&s);
+    }
     struct demuxer *d = demux_open(s, params, global);
     if (d) {
+        talloc_steal(d->in, priv_cancel);
         demux_maybe_replace_stream(d);
     } else {
         params->demuxer_failed = true;
         free_stream(s);
+        talloc_free(priv_cancel);
     }
     return d;
 }
@@ -2850,8 +3024,10 @@
 
 static void demuxer_sort_chapters(demuxer_t *demuxer)
 {
-    qsort(demuxer->chapters, demuxer->num_chapters,
-          sizeof(struct demux_chapter), chapter_compare);
+    if (demuxer->num_chapters) {
+        qsort(demuxer->chapters, demuxer->num_chapters,
+            sizeof(struct demux_chapter), chapter_compare);
+    }
 }
 
 int demuxer_add_chapter(demuxer_t *demuxer, char *name,
@@ -2911,15 +3087,16 @@
 
     // Don't lock while querying the stream.
     struct mp_tags *stream_metadata = NULL;
-    struct stream_cache_info stream_cache_info = {.size = -1};
 
     int64_t stream_size = stream_get_size(stream);
     stream_control(stream, STREAM_CTRL_GET_METADATA, &stream_metadata);
-    stream_control(stream, STREAM_CTRL_GET_CACHE_INFO, &stream_cache_info);
+
+    demuxer->total_unbuffered_read_bytes += stream->total_unbuffered_read_bytes;
+    stream->total_unbuffered_read_bytes = 0;
 
     pthread_mutex_lock(&in->lock);
+
     in->stream_size = stream_size;
-    in->stream_cache_info = stream_cache_info;
     if (stream_metadata) {
         for (int n = 0; n < in->num_streams; n++) {
             struct demux_stream *ds = in->streams[n]->ds;
@@ -2928,24 +3105,28 @@
         }
         talloc_free(stream_metadata);
     }
+
+    in->next_cache_update = INT64_MAX;
+
+    int64_t now = mp_time_us();
+    int64_t diff = now - in->last_speed_query;
+    if (diff >= MP_SECOND_US) {
+        uint64_t bytes = demuxer->total_unbuffered_read_bytes;
+        demuxer->total_unbuffered_read_bytes = 0;
+        in->last_speed_query = now;
+        in->bytes_per_second = bytes / (diff / (double)MP_SECOND_US);
+    }
+    // The idea is to update as long as there is "activity".
+    if (in->bytes_per_second)
+        in->next_cache_update = now + MP_SECOND_US + 1;
+
     pthread_mutex_unlock(&in->lock);
 }
 
 // must be called locked
 static int cached_stream_control(struct demux_internal *in, int cmd, void *arg)
 {
-    // If the cache is active, wake up the thread to possibly update cache state.
-    if (in->stream_cache_info.size >= 0) {
-        in->force_cache_update = true;
-        pthread_cond_signal(&in->wakeup);
-    }
-
     switch (cmd) {
-    case STREAM_CTRL_GET_CACHE_INFO:
-        if (in->stream_cache_info.size < 0)
-            return STREAM_UNSUPPORTED;
-        *(struct stream_cache_info *)arg = in->stream_cache_info;
-        return STREAM_OK;
     case STREAM_CTRL_GET_SIZE:
         if (in->stream_size < 0)
             return STREAM_UNSUPPORTED;
@@ -2995,6 +3176,7 @@
             .seeking = in->seeking_in_progress,
             .low_level_seeks = in->low_level_seeks,
             .ts_last = in->demux_ts,
+            .bytes_per_second = in->bytes_per_second,
         };
         bool any_packets = false;
         for (int n = 0; n < in->num_streams; n++) {
@@ -3113,7 +3295,7 @@
 
 bool demux_cancel_test(struct demuxer *demuxer)
 {
-    return mp_cancel_test(demuxer->stream->cancel);
+    return mp_cancel_test(demuxer->cancel);
 }
 
 struct demux_chapter *demux_copy_chapter_data(struct demux_chapter *c, int num)
diff -ruN mpv-0.29.1/demux/demux.h mpv-master/demux/demux.h
--- mpv-0.29.1/demux/demux.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/demux/demux.h	2019-09-19 04:02:03.000000000 +0700
@@ -32,7 +32,6 @@
 
 enum demux_ctrl {
     DEMUXER_CTRL_SWITCHED_TRACKS = 1,
-    DEMUXER_CTRL_RESYNC,
     DEMUXER_CTRL_IDENTIFY_PROGRAM,
     DEMUXER_CTRL_STREAM_CTRL,
     DEMUXER_CTRL_GET_READER_STATE,
@@ -56,6 +55,7 @@
     double seeking; // current low level seek target, or NOPTS
     int low_level_seeks; // number of started low level seeks
     double ts_last; // approx. timestamp of demuxer position
+    uint64_t bytes_per_second; // low level statistics
     // Positions that can be seeked to without incurring the latency of a low
     // level seek.
     int num_seek_ranges;
@@ -174,12 +174,12 @@
     bool *matroska_was_valid;
     struct timeline *timeline;
     bool disable_timeline;
-    bool initial_readahead;
     bstr init_fragment;
     bool skip_lavf_probing;
+    bool does_not_own_stream; // if false, stream is free'd on demux_free()
+    bool stream_record; // if true, enable stream recording if option is set
     // -- demux_open_url() only
     int stream_flags;
-    bool disable_cache;
     // result
     bool demuxer_failed;
 };
@@ -230,8 +230,12 @@
 
     // internal to demux.c
     struct demux_internal *in;
-    struct mp_tags **update_stream_tags;
-    int num_update_stream_tags;
+
+    // Triggered when ending demuxing forcefully. Usually bound to the stream too.
+    struct mp_cancel *cancel;
+
+    // Demuxer thread only.
+    uint64_t total_unbuffered_read_bytes;
 
     // Since the demuxer can run in its own thread, and the stream is not
     // thread-safe, only the demuxer is allowed to access the stream directly.
@@ -240,13 +244,13 @@
     struct stream *stream;
 } demuxer_t;
 
-typedef struct {
-    int progid;      //program id
-    int aid, vid, sid; //audio, video and subtitle id
-} demux_program_t;
+void demux_free(struct demuxer *demuxer);
+void demux_cancel_and_free(struct demuxer *demuxer);
 
-void free_demuxer(struct demuxer *demuxer);
-void free_demuxer_and_stream(struct demuxer *demuxer);
+struct demux_free_async_state;
+struct demux_free_async_state *demux_free_async(struct demuxer *demuxer);
+void demux_free_async_force(struct demux_free_async_state *state);
+bool demux_free_async_finish(struct demux_free_async_state *state);
 
 void demux_add_packet(struct sh_stream *stream, demux_packet_t *dp);
 void demuxer_feed_caption(struct sh_stream *stream, demux_packet_t *dp);
@@ -307,6 +311,7 @@
 void demux_update(demuxer_t *demuxer);
 
 void demux_disable_cache(demuxer_t *demuxer);
+bool demux_is_network_cached(demuxer_t *demuxer);
 
 struct sh_stream *demuxer_stream_by_demuxer_id(struct demuxer *d,
                                                enum stream_type t, int id);
diff -ruN mpv-0.29.1/demux/demux_disc.c mpv-master/demux/demux_disc.c
--- mpv-0.29.1/demux/demux_disc.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/demux/demux_disc.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,377 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <string.h>
-#include <math.h>
-#include <assert.h>
-
-#include "common/common.h"
-#include "common/msg.h"
-
-#include "stream/stream.h"
-#include "video/mp_image.h"
-#include "demux.h"
-#include "stheader.h"
-
-#include "video/csputils.h"
-
-struct priv {
-    struct demuxer *slave;
-    // streams[slave_stream_index] == our_stream
-    struct sh_stream **streams;
-    int num_streams;
-    // This contains each DVD sub stream, or NULL. Needed because DVD packets
-    // can come arbitrarily late in the MPEG stream, so the slave demuxer
-    // might add the streams only later.
-    struct sh_stream *dvd_subs[32];
-    // Used to rewrite the raw MPEG timestamps to playback time.
-    double base_time;   // playback display start time of current segment
-    double base_dts;    // packet DTS that maps to base_time
-    double last_dts;    // DTS of previously demuxed packet
-    bool seek_reinit;   // needs reinit after seek
-
-    bool is_dvd, is_cdda;
-};
-
-// If the timestamp difference between subsequent packets is this big, assume
-// a reset. It should be big enough to account for 1. low video framerates and
-// large audio frames, and 2. bad interleaving.
-#define DTS_RESET_THRESHOLD 5.0
-
-static void reselect_streams(demuxer_t *demuxer)
-{
-    struct priv *p = demuxer->priv;
-    int num_slave = demux_get_num_stream(p->slave);
-    for (int n = 0; n < MPMIN(num_slave, p->num_streams); n++) {
-        if (p->streams[n]) {
-            demuxer_select_track(p->slave, demux_get_stream(p->slave, n),
-                MP_NOPTS_VALUE, demux_stream_is_selected(p->streams[n]));
-        }
-    }
-}
-
-static void get_disc_lang(struct stream *stream, struct sh_stream *sh, bool dvd)
-{
-    struct stream_lang_req req = {.type = sh->type, .id = sh->demuxer_id};
-    if (dvd && sh->type == STREAM_SUB)
-        req.id = req.id & 0x1F; // mpeg ID to index
-    stream_control(stream, STREAM_CTRL_GET_LANG, &req);
-    if (req.name[0])
-        sh->lang = talloc_strdup(sh, req.name);
-}
-
-static void add_dvd_streams(demuxer_t *demuxer)
-{
-    struct priv *p = demuxer->priv;
-    struct stream *stream = demuxer->stream;
-    if (!p->is_dvd)
-        return;
-    struct stream_dvd_info_req info;
-    if (stream_control(stream, STREAM_CTRL_GET_DVD_INFO, &info) > 0) {
-        for (int n = 0; n < MPMIN(32, info.num_subs); n++) {
-            struct sh_stream *sh = demux_alloc_sh_stream(STREAM_SUB);
-            sh->demuxer_id = n + 0x20;
-            sh->codec->codec = "dvd_subtitle";
-            get_disc_lang(stream, sh, true);
-            // p->streams _must_ match with p->slave->streams, so we can't add
-            // it yet - it has to be done when the real stream appears, which
-            // could be right on start, or any time later.
-            p->dvd_subs[n] = sh;
-
-            // emulate the extradata
-            struct mp_csp_params csp = MP_CSP_PARAMS_DEFAULTS;
-            struct mp_cmat cmatrix;
-            mp_get_csp_matrix(&csp, &cmatrix);
-
-            char *s = talloc_strdup(sh, "");
-            s = talloc_asprintf_append(s, "palette: ");
-            for (int i = 0; i < 16; i++) {
-                int color = info.palette[i];
-                int y[3] = {(color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff};
-                int c[3];
-                mp_map_fixp_color(&cmatrix, 8, y, 8, c);
-                color = (c[2] << 16) | (c[1] << 8) | c[0];
-
-                if (i != 0)
-                    s = talloc_asprintf_append(s, ", ");
-                s = talloc_asprintf_append(s, "%06x", color);
-            }
-            s = talloc_asprintf_append(s, "\n");
-
-            sh->codec->extradata = s;
-            sh->codec->extradata_size = strlen(s);
-
-            demux_add_sh_stream(demuxer, sh);
-        }
-    }
-}
-
-static void add_streams(demuxer_t *demuxer)
-{
-    struct priv *p = demuxer->priv;
-
-    for (int n = p->num_streams; n < demux_get_num_stream(p->slave); n++) {
-        struct sh_stream *src = demux_get_stream(p->slave, n);
-        if (src->type == STREAM_SUB) {
-            struct sh_stream *sub = NULL;
-            if (src->demuxer_id >= 0x20 && src->demuxer_id <= 0x3F)
-                sub = p->dvd_subs[src->demuxer_id - 0x20];
-            if (sub) {
-                assert(p->num_streams == n); // directly mapped
-                MP_TARRAY_APPEND(p, p->streams, p->num_streams, sub);
-                continue;
-            }
-        }
-        struct sh_stream *sh = demux_alloc_sh_stream(src->type);
-        assert(p->num_streams == n); // directly mapped
-        MP_TARRAY_APPEND(p, p->streams, p->num_streams, sh);
-        // Copy all stream fields that might be relevant
-        *sh->codec = *src->codec;
-        sh->demuxer_id = src->demuxer_id;
-        if (src->type == STREAM_VIDEO) {
-            double ar;
-            if (stream_control(demuxer->stream, STREAM_CTRL_GET_ASPECT_RATIO, &ar)
-                                == STREAM_OK)
-            {
-                struct mp_image_params f = {.w = src->codec->disp_w,
-                                            .h = src->codec->disp_h};
-                mp_image_params_set_dsize(&f, 1728 * ar, 1728);
-                sh->codec->par_w = f.p_w;
-                sh->codec->par_h = f.p_h;
-            }
-        }
-        get_disc_lang(demuxer->stream, sh, p->is_dvd);
-        demux_add_sh_stream(demuxer, sh);
-    }
-    reselect_streams(demuxer);
-}
-
-static void d_seek(demuxer_t *demuxer, double seek_pts, int flags)
-{
-    struct priv *p = demuxer->priv;
-
-    if (p->is_cdda) {
-        demux_seek(p->slave, seek_pts, flags);
-        return;
-    }
-
-    if (flags & SEEK_FACTOR) {
-        double tmp = 0;
-        stream_control(demuxer->stream, STREAM_CTRL_GET_TIME_LENGTH, &tmp);
-        seek_pts *= tmp;
-    }
-
-    MP_VERBOSE(demuxer, "seek to: %f\n", seek_pts);
-
-    double seek_arg[] = {seek_pts, flags};
-    stream_control(demuxer->stream, STREAM_CTRL_SEEK_TO_TIME, seek_arg);
-    demux_control(p->slave, DEMUXER_CTRL_RESYNC, NULL);
-
-    p->seek_reinit = true;
-}
-
-static void reset_pts(demuxer_t *demuxer)
-{
-    struct priv *p = demuxer->priv;
-
-    double base;
-    if (stream_control(demuxer->stream, STREAM_CTRL_GET_CURRENT_TIME, &base) < 1)
-        base = 0;
-
-    MP_VERBOSE(demuxer, "reset to time: %f\n", base);
-
-    p->base_dts = p->last_dts = MP_NOPTS_VALUE;
-    p->base_time = base;
-    p->seek_reinit = false;
-}
-
-static int d_fill_buffer(demuxer_t *demuxer)
-{
-    struct priv *p = demuxer->priv;
-
-    struct demux_packet *pkt = demux_read_any_packet(p->slave);
-    if (!pkt)
-        return 0;
-
-    demux_update(p->slave);
-
-    if (p->seek_reinit)
-        reset_pts(demuxer);
-
-    add_streams(demuxer);
-    if (pkt->stream >= p->num_streams) { // out of memory?
-        talloc_free(pkt);
-        return 0;
-    }
-
-    struct sh_stream *sh = p->streams[pkt->stream];
-    if (!demux_stream_is_selected(sh)) {
-        talloc_free(pkt);
-        return 1;
-    }
-
-    if (p->is_cdda) {
-        demux_add_packet(sh, pkt);
-        return 1;
-    }
-
-    MP_TRACE(demuxer, "ipts: %d %f %f\n", sh->type, pkt->pts, pkt->dts);
-
-    if (sh->type == STREAM_SUB) {
-        if (p->base_dts == MP_NOPTS_VALUE)
-            MP_WARN(demuxer, "subtitle packet along PTS reset\n");
-    } else if (pkt->dts != MP_NOPTS_VALUE) {
-        // Use the very first DTS to rebase the start time of the MPEG stream
-        // to the playback time.
-        if (p->base_dts == MP_NOPTS_VALUE)
-            p->base_dts = pkt->dts;
-
-        if (p->last_dts == MP_NOPTS_VALUE)
-            p->last_dts = pkt->dts;
-
-        if (fabs(p->last_dts - pkt->dts) >= DTS_RESET_THRESHOLD) {
-            MP_WARN(demuxer, "PTS discontinuity: %f->%f\n", p->last_dts, pkt->dts);
-            p->base_time += p->last_dts - p->base_dts;
-            p->base_dts = pkt->dts - pkt->duration;
-        }
-        p->last_dts = pkt->dts;
-    }
-
-    if (p->base_dts != MP_NOPTS_VALUE) {
-        double delta = -p->base_dts + p->base_time;
-        if (pkt->pts != MP_NOPTS_VALUE)
-            pkt->pts += delta;
-        if (pkt->dts != MP_NOPTS_VALUE)
-            pkt->dts += delta;
-    }
-
-    MP_TRACE(demuxer, "opts: %d %f %f\n", sh->type, pkt->pts, pkt->dts);
-
-    demux_add_packet(sh, pkt);
-    return 1;
-}
-
-static void add_stream_chapters(struct demuxer *demuxer)
-{
-    int num = 0;
-    if (stream_control(demuxer->stream, STREAM_CTRL_GET_NUM_CHAPTERS, &num) < 1)
-        return;
-    for (int n = 0; n < num; n++) {
-        double p = n;
-        if (stream_control(demuxer->stream, STREAM_CTRL_GET_CHAPTER_TIME, &p) < 1)
-            continue;
-        demuxer_add_chapter(demuxer, "", p, 0);
-    }
-}
-
-static int d_open(demuxer_t *demuxer, enum demux_check check)
-{
-    struct priv *p = demuxer->priv = talloc_zero(demuxer, struct priv);
-
-    if (check != DEMUX_CHECK_FORCE)
-        return -1;
-
-    struct demuxer_params params = {.force_format = "+lavf"};
-
-    struct stream *cur = demuxer->stream;
-    const char *sname = "";
-    while (cur) {
-        if (cur->info)
-            sname = cur->info->name;
-        cur = cur->underlying; // down the caching chain
-    }
-
-    p->is_cdda = strcmp(sname, "cdda") == 0;
-    p->is_dvd = strcmp(sname, "dvd") == 0 ||
-                strcmp(sname, "ifo") == 0 ||
-                strcmp(sname, "dvdnav") == 0 ||
-                strcmp(sname, "ifo_dvdnav") == 0;
-
-    if (p->is_cdda)
-        params.force_format = "+rawaudio";
-
-    char *t = NULL;
-    stream_control(demuxer->stream, STREAM_CTRL_GET_DISC_NAME, &t);
-    if (t) {
-        mp_tags_set_str(demuxer->metadata, "TITLE", t);
-        talloc_free(t);
-    }
-
-    // Initialize the playback time. We need to read _some_ data to get the
-    // correct stream-layer time (at least with libdvdnav).
-    stream_peek(demuxer->stream, 1);
-    reset_pts(demuxer);
-
-    p->slave = demux_open(demuxer->stream, &params, demuxer->global);
-    if (!p->slave)
-        return -1;
-
-    // So that we don't miss initial packets of delayed subtitle streams.
-    demux_set_stream_autoselect(p->slave, true);
-
-    // With cache enabled, the stream can be seekable. This causes demux_lavf.c
-    // (actually libavformat/mpegts.c) to seek sometimes when reading a packet.
-    // It does this to seek back a bit in case the current file position points
-    // into the middle of a packet.
-    if (!p->is_cdda) {
-        demuxer->stream->seekable = false;
-
-        // Can be seekable even if the stream isn't.
-        demuxer->seekable = true;
-    }
-
-    add_dvd_streams(demuxer);
-    add_streams(demuxer);
-    add_stream_chapters(demuxer);
-
-    double len;
-    if (stream_control(demuxer->stream, STREAM_CTRL_GET_TIME_LENGTH, &len) >= 1)
-        demuxer->duration = len;
-
-    return 0;
-}
-
-static void d_close(demuxer_t *demuxer)
-{
-    struct priv *p = demuxer->priv;
-    free_demuxer(p->slave);
-}
-
-static int d_control(demuxer_t *demuxer, int cmd, void *arg)
-{
-    struct priv *p = demuxer->priv;
-
-    switch (cmd) {
-    case DEMUXER_CTRL_RESYNC:
-        demux_flush(p->slave);
-        break; // relay to slave demuxer
-    case DEMUXER_CTRL_SWITCHED_TRACKS:
-        reselect_streams(demuxer);
-        return CONTROL_OK;
-    }
-    return demux_control(p->slave, cmd, arg);
-}
-
-const demuxer_desc_t demuxer_desc_disc = {
-    .name = "disc",
-    .desc = "CD/DVD/BD wrapper",
-    .fill_buffer = d_fill_buffer,
-    .open = d_open,
-    .close = d_close,
-    .seek = d_seek,
-    .control = d_control,
-};
diff -ruN mpv-0.29.1/demux/demux_edl.c mpv-master/demux/demux_edl.c
--- mpv-0.29.1/demux/demux_edl.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/demux/demux_edl.c	2019-09-19 04:02:03.000000000 +0700
@@ -41,6 +41,7 @@
     bool offset_set;
     bool chapter_ts;
     double length;              // length of the part (-1 if rest of the file)
+    char *title;
 };
 
 struct tl_parts {
@@ -79,8 +80,10 @@
 {
     struct tl_parts *tl = talloc_zero(NULL, struct tl_parts);
     while (str.len) {
-        if (bstr_eatstart0(&str, "#"))
+        if (bstr_eatstart0(&str, "#")) {
             bstr_split_tok(str, "\n", &(bstr){0}, &str);
+            continue;
+        }
         if (bstr_eatstart0(&str, "\n") || bstr_eatstart0(&str, ";"))
             continue;
         bool is_header = bstr_eatstart0(&str, "!");
@@ -123,6 +126,8 @@
             } else if (bstr_equals0(name, "timestamps")) {
                 if (bstr_equals0(val, "chapters"))
                     p.chapter_ts = true;
+            } else if (bstr_equals0(name, "title")) {
+                p.title = bstrto0(tl, val);
             }
             if (nparam >= MAX_PARAMS)
                 goto error;
@@ -296,7 +301,7 @@
                 .pts = starttime,
                 .metadata = talloc_zero(tl, struct mp_tags),
             };
-            mp_tags_set_str(ch.metadata, "title", part->filename);
+            mp_tags_set_str(ch.metadata, "title", part->title ? part->title : part->filename);
             MP_TARRAY_APPEND(tl, tl->chapters, tl->num_chapters, ch);
 
             // Also copy the source file's chapters for the relevant parts
diff -ruN mpv-0.29.1/demux/demux_lavf.c mpv-master/demux/demux_lavf.c
--- mpv-0.29.1/demux/demux_lavf.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/demux/demux_lavf.c	2019-09-19 04:02:03.000000000 +0700
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2004 Michael Niedermayer <michaelni@gmx.at>
+ * Copyright (C) 2018 Google LLC
  *
  * This file is part of mpv.
  *
@@ -42,6 +43,7 @@
 #include "common/av_common.h"
 #include "misc/bstr.h"
 #include "misc/charset_conv.h"
+#include "misc/thread_tools.h"
 
 #include "stream/stream.h"
 #include "demux.h"
@@ -190,6 +192,11 @@
     {0}
 };
 
+struct nested_stream {
+    AVIOContext *id;
+    int64_t last_bytes;
+};
+
 typedef struct lavf_priv {
     struct stream *stream;
     bool own_stream;
@@ -203,14 +210,35 @@
     AVIOContext *pb;
     struct sh_stream **streams; // NULL for unknown streams
     int num_streams;
-    int cur_program;
     char *mime_type;
     double seek_delay;
+    bool optical_crap_hack;
 
     struct demux_lavf_opts *opts;
     double mf_fps;
+
+    // Proxying nested streams.
+    struct nested_stream *nested;
+    int num_nested;
+    int (*default_io_open)(struct AVFormatContext *s, AVIOContext **pb,
+                           const char *url, int flags, AVDictionary **options);
+    void (*default_io_close)(struct AVFormatContext *s, AVIOContext *pb);
 } lavf_priv_t;
 
+static void update_read_stats(struct demuxer *demuxer)
+{
+    lavf_priv_t *priv = demuxer->priv;
+
+    for (int n = 0; n < priv->num_nested; n++) {
+        struct nested_stream *nest = &priv->nested[n];
+
+        int64_t cur = nest->id->bytes_read;
+        int64_t new = cur - nest->last_bytes;
+        nest->last_bytes = cur;
+        demuxer->total_unbuffered_read_bytes += new;
+    }
+}
+
 // At least mp4 has name="mov,mp4,m4a,3gp,3g2,mj2", so we split the name
 // on "," in general.
 static bool matches_avinputformat_name(struct lavf_priv *priv,
@@ -561,17 +589,27 @@
         av_rgain = (AVReplayGain*)src_sd->data;
         rgain    = talloc_ptrtype(demuxer, rgain);
 
-        rgain->track_gain = (av_rgain->track_gain != INT32_MIN) ?
-            av_rgain->track_gain / 100000.0f : 0.0;
-
-        rgain->track_peak = (av_rgain->track_peak != 0.0) ?
-            av_rgain->track_peak / 100000.0f : 1.0;
-
-        rgain->album_gain = (av_rgain->album_gain != INT32_MIN) ?
-            av_rgain->album_gain / 100000.0f : 0.0;
-
-        rgain->album_peak = (av_rgain->album_peak != 0.0) ?
-            av_rgain->album_peak / 100000.0f : 1.0;
+        // Set values in *rgain, using track gain as a fallback for album gain
+        // if the latter is not present. This behavior matches that in
+        // demux/demux.c's decode_rgain; if you change this, please make
+        // equivalent changes there too.
+        if (av_rgain->track_gain != INT32_MIN && av_rgain->track_peak != 0.0) {
+            // Track gain is defined.
+            rgain->track_gain = av_rgain->track_gain / 100000.0f;
+            rgain->track_peak = av_rgain->track_peak / 100000.0f;
+
+            if (av_rgain->album_gain != INT32_MIN &&
+                av_rgain->album_peak != 0.0)
+            {
+                // Album gain is also defined.
+                rgain->album_gain = av_rgain->album_gain / 100000.0f;
+                rgain->album_peak = av_rgain->album_peak / 100000.0f;
+            } else {
+                // Album gain is undefined; fall back to track gain.
+                rgain->album_gain = rgain->track_gain;
+                rgain->album_peak = rgain->track_peak;
+            }
+        }
 
         // This must be run only before the stream was added, otherwise there
         // will be race conditions with accesses from the user thread.
@@ -721,6 +759,10 @@
             sh->forced_track = true;
         if (st->disposition & AV_DISPOSITION_DEPENDENT)
             sh->dependent_track = true;
+        if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED)
+            sh->visual_impaired_track = true;
+        if (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED)
+            sh->hearing_impaired_track = true;
         if (st->disposition & AV_DISPOSITION_STILL_IMAGE)
             sh->still_image = true;
         if (priv->format_hack.use_stream_ids)
@@ -777,8 +819,7 @@
 static int interrupt_cb(void *ctx)
 {
     struct demuxer *demuxer = ctx;
-    lavf_priv_t *priv = demuxer->priv;
-    return mp_cancel_test(priv->stream->cancel);
+    return mp_cancel_test(demuxer->cancel);
 }
 
 static int block_io_open(struct AVFormatContext *s, AVIOContext **pb,
@@ -789,6 +830,38 @@
     return AVERROR(EACCES);
 }
 
+static int nested_io_open(struct AVFormatContext *s, AVIOContext **pb,
+                          const char *url, int flags, AVDictionary **options)
+{
+    struct demuxer *demuxer = s->opaque;
+    lavf_priv_t *priv = demuxer->priv;
+
+    int r = priv->default_io_open(s, pb, url, flags, options);
+    if (r >= 0) {
+        struct nested_stream nest = {
+            .id = *pb,
+        };
+        MP_TARRAY_APPEND(priv, priv->nested, priv->num_nested, nest);
+    }
+    return r;
+}
+
+static void nested_io_close(struct AVFormatContext *s, AVIOContext *pb)
+{
+    struct demuxer *demuxer = s->opaque;
+    lavf_priv_t *priv = demuxer->priv;
+
+    for (int n = 0; n < priv->num_nested; n++) {
+        if (priv->nested[n].id == pb) {
+            MP_TARRAY_REMOVE_AT(priv->nested, priv->num_nested, n);
+            break;
+        }
+    }
+
+
+    priv->default_io_close(s, pb);
+}
+
 static int demux_open_lavf(demuxer_t *demuxer, enum demux_check check)
 {
     AVFormatContext *avfc;
@@ -883,8 +956,14 @@
     };
 
     avfc->opaque = demuxer;
-    if (!demuxer->access_references)
+    if (demuxer->access_references) {
+        priv->default_io_open = avfc->io_open;
+        priv->default_io_close = avfc->io_close;
+        avfc->io_open = nested_io_open;
+        avfc->io_close = nested_io_close;
+    } else {
         avfc->io_open = block_io_open;
+    }
 
     mp_set_avdict(&dopts, lavfdopts->avopts);
 
@@ -977,6 +1056,13 @@
                 "broken as well.\n");
     }
 
+    double len = -1;
+    if (stream_control(priv->stream, STREAM_CTRL_OPTICAL_CRAP_HACK1, &len) > 0) {
+        priv->optical_crap_hack = true;
+        demuxer->duration = len;
+        demuxer->seekable = true;
+    }
+
     return 0;
 }
 
@@ -986,6 +1072,7 @@
 
     AVPacket *pkt = &(AVPacket){0};
     int r = av_read_frame(priv->avfc, pkt);
+    update_read_stats(demux);
     if (r < 0) {
         av_packet_unref(pkt);
         if (r == AVERROR(EAGAIN))
@@ -1040,6 +1127,13 @@
     int avsflags = 0;
     int64_t seek_pts_av = 0;
 
+    if (priv->optical_crap_hack) {
+        if (flags & SEEK_FACTOR)
+            seek_pts = seek_pts * demuxer->duration;
+        stream_control(priv->stream, STREAM_CTRL_OPTICAL_CRAP_HACK2, &seek_pts);
+        return;
+    }
+
     if (!(flags & SEEK_FORWARD))
         avsflags = AVSEEK_FLAG_BACKWARD;
 
@@ -1076,6 +1170,8 @@
         av_strerror(r, buf, sizeof(buf));
         MP_VERBOSE(demuxer, "Seek failed (%s)\n", buf);
     }
+
+    update_read_stats(demuxer);
 }
 
 static int demux_lavf_control(demuxer_t *demuxer, int cmd, void *arg)
@@ -1084,79 +1180,8 @@
 
     switch (cmd) {
     case DEMUXER_CTRL_SWITCHED_TRACKS:
-    {
         select_tracks(demuxer, 0);
         return CONTROL_OK;
-    }
-    case DEMUXER_CTRL_IDENTIFY_PROGRAM:
-    {
-        demux_program_t *prog = arg;
-        AVProgram *program;
-        int p, i;
-        int start;
-
-        add_new_streams(demuxer);
-
-        prog->vid = prog->aid = prog->sid = -2;
-        if (priv->avfc->nb_programs < 1)
-            return CONTROL_FALSE;
-
-        if (prog->progid == -1) {
-            p = 0;
-            while (p < priv->avfc->nb_programs && priv->avfc->programs[p]->id != priv->cur_program)
-                p++;
-            p = (p + 1) % priv->avfc->nb_programs;
-        } else {
-            for (i = 0; i < priv->avfc->nb_programs; i++)
-                if (priv->avfc->programs[i]->id == prog->progid)
-                    break;
-            if (i == priv->avfc->nb_programs)
-                return CONTROL_FALSE;
-            p = i;
-        }
-        start = p;
-redo:
-        prog->vid = prog->aid = prog->sid = -2;
-        program = priv->avfc->programs[p];
-        for (i = 0; i < program->nb_stream_indexes; i++) {
-            struct sh_stream *stream = priv->streams[program->stream_index[i]];
-            if (stream) {
-                switch (stream->type) {
-                case STREAM_VIDEO:
-                    if (prog->vid == -2)
-                        prog->vid = stream->demuxer_id;
-                    break;
-                case STREAM_AUDIO:
-                    if (prog->aid == -2)
-                        prog->aid = stream->demuxer_id;
-                    break;
-                case STREAM_SUB:
-                    if (prog->sid == -2)
-                        prog->sid = stream->demuxer_id;
-                    break;
-                }
-            }
-        }
-        if (prog->progid == -1 && prog->vid == -2 && prog->aid == -2) {
-            p = (p + 1) % priv->avfc->nb_programs;
-            if (p == start)
-                return CONTROL_FALSE;
-            goto redo;
-        }
-        priv->cur_program = prog->progid = program->id;
-
-        mp_tags_copy_from_av_dictionary(demuxer->metadata, priv->avfc->programs[p]->metadata);
-        update_metadata(demuxer);
-        // Enforce metadata update even if no explicit METADATA_UPDATED since we switched program.
-        demux_metadata_changed(demuxer);
-
-        return CONTROL_OK;
-    }
-    case DEMUXER_CTRL_RESYNC:
-        stream_drop_buffers(priv->stream);
-        avio_flush(priv->avfc->pb);
-        avformat_flush(priv->avfc);
-        return CONTROL_OK;
     case DEMUXER_CTRL_REPLACE_STREAM:
         if (priv->own_stream)
             free_stream(priv->stream);
@@ -1172,7 +1197,19 @@
 {
     lavf_priv_t *priv = demuxer->priv;
     if (priv) {
+        // This will be a dangling pointer; but see below.
+        AVIOContext *leaking = priv->avfc ? priv->avfc->pb : NULL;
         avformat_close_input(&priv->avfc);
+        // The ffmpeg garbage breaks its own API yet again: hls.c will call
+        // io_open on the main playlist, but never calls io_close. This happens
+        // to work out for us (since we don't really use custom I/O), but it's
+        // still weird. Compensate.
+        if (priv->num_nested == 1 && priv->nested[0].id == leaking)
+            priv->num_nested = 0;
+        if (priv->num_nested) {
+            MP_WARN(demuxer, "Leaking %d nested connections (FFmpeg bug).\n",
+                    priv->num_nested);
+        }
         if (priv->pb)
             av_freep(&priv->pb->buffer);
         av_freep(&priv->pb);
diff -ruN mpv-0.29.1/demux/demux_mkv_timeline.c mpv-master/demux/demux_mkv_timeline.c
--- mpv-0.29.1/demux/demux_mkv_timeline.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/demux/demux_mkv_timeline.c	2019-09-19 04:02:03.000000000 +0700
@@ -39,6 +39,7 @@
 #include "options/options.h"
 #include "options/path.h"
 #include "misc/bstr.h"
+#include "misc/thread_tools.h"
 #include "common/common.h"
 #include "common/playlist.h"
 #include "stream/stream.h"
@@ -171,7 +172,6 @@
         .matroska_wanted_segment = segment,
         .matroska_was_valid = &was_valid,
         .disable_timeline = true,
-        .disable_cache = true,
     };
     struct mp_cancel *cancel = ctx->tl->cancel;
     if (mp_cancel_test(cancel))
@@ -215,21 +215,12 @@
                 }
             }
 
-            if (stream_wants_cache(d->stream, ctx->opts->stream_cache)) {
-                free_demuxer_and_stream(d);
-                params.disable_cache = false;
-                params.matroska_wanted_uids = ctx->uids; // potentially reallocated, same data
-                d = demux_open_url(filename, &params, cancel, ctx->global);
-                if (!d)
-                    return false;
-            }
-
             ctx->sources[i] = d;
             return true;
         }
     }
 
-    free_demuxer_and_stream(d);
+    demux_free(d);
     return was_valid;
 }
 
@@ -263,7 +254,8 @@
             MP_INFO(ctx, "Loading references from '%s'.\n",
                     opts->ordered_chapters_files);
             struct playlist *pl =
-                playlist_parse_file(opts->ordered_chapters_files, ctx->global);
+                playlist_parse_file(opts->ordered_chapters_files,
+                                    ctx->tl->cancel, ctx->global);
             talloc_steal(tmp, pl);
             for (struct playlist_entry *e = pl ? pl->first : NULL; e; e = e->next)
                 MP_TARRAY_APPEND(tmp, filenames, num_filenames, e->filename);
@@ -305,6 +297,16 @@
         ctx->num_sources = j;
     }
 
+    // Copy attachments from referenced sources so fonts are loaded for sub
+    // rendering.
+    for (int i = 1; i < ctx->num_sources; i++) {
+        for (int j = 0; j < ctx->sources[i]->num_attachments; j++) {
+            struct demux_attachment *att = &ctx->sources[i]->attachments[j];
+            demuxer_add_attachment(ctx->demuxer, att->name, att->type,
+                                   att->data, att->data_size);
+        }
+    }
+
     talloc_free(tmp);
 }
 
@@ -515,7 +517,7 @@
         .global = tl->global,
         .tl = tl,
         .demuxer = demuxer,
-        .opts = mp_get_config_group(ctx, tl->global, NULL),
+        .opts = mp_get_config_group(ctx, tl->global, GLOBAL_CONFIG),
     };
 
     if (!ctx->opts->ordered_chapters || !demuxer->access_references) {
diff -ruN mpv-0.29.1/demux/demux_playlist.c mpv-master/demux/demux_playlist.c
--- mpv-0.29.1/demux/demux_playlist.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/demux/demux_playlist.c	2019-09-19 04:02:03.000000000 +0700
@@ -25,6 +25,7 @@
 #include "options/options.h"
 #include "common/msg.h"
 #include "common/playlist.h"
+#include "misc/thread_tools.h"
 #include "options/path.h"
 #include "stream/stream.h"
 #include "osdep/io.h"
diff -ruN mpv-0.29.1/demux/demux_rar.c mpv-master/demux/demux_rar.c
--- mpv-0.29.1/demux/demux_rar.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/demux/demux_rar.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,65 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "common/common.h"
-#include "common/playlist.h"
-#include "stream/stream.h"
-#include "stream/rar.h"
-#include "demux.h"
-
-static int open_file(struct demuxer *demuxer, enum demux_check check)
-{
-    if (!demuxer->access_references)
-        return -1;
-
-    if (RarProbe(demuxer->stream))
-        return -1;
-
-    int count;
-    rar_file_t **files;
-    if (RarParse(demuxer->stream, &count, &files))
-        return -1;
-
-    void *tmp = talloc_new(NULL);
-    talloc_steal(tmp, files);
-
-    struct playlist *pl = talloc_zero(demuxer, struct playlist);
-    demuxer->playlist = pl;
-
-    // make it load rar://
-    pl->disable_safety = true;
-
-    char *prefix = mp_url_escape(tmp, demuxer->stream->url, "~|");
-    for (int n = 0; n < count; n++) {
-        // stream_rar.c does the real work
-        playlist_add_file(pl,
-                talloc_asprintf(tmp, "rar://%s|%s", prefix, files[n]->name));
-        RarFileDelete(files[n]);
-    }
-
-    demuxer->filetype = "rar";
-    demuxer->fully_read = true;
-
-    talloc_free(tmp);
-    return 0;
-}
-
-const struct demuxer_desc demuxer_desc_rar = {
-    .name = "rar",
-    .desc = "Rar archive file",
-    .open = open_file,
-};
diff -ruN mpv-0.29.1/demux/demux_timeline.c mpv-master/demux/demux_timeline.c
--- mpv-0.29.1/demux/demux_timeline.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/demux/demux_timeline.c	2019-09-19 04:02:03.000000000 +0700
@@ -147,7 +147,7 @@
     for (int n = 0; n < p->num_segments; n++) {
         struct segment *seg = p->segments[n];
         if (seg != p->current && seg->d && seg->lazy) {
-            free_demuxer_and_stream(seg->d);
+            demux_free(seg->d);
             seg->d = NULL;
         }
     }
@@ -167,7 +167,7 @@
         .skip_lavf_probing = true,
     };
     p->current->d = demux_open_url(p->current->url, &params,
-                                   demuxer->stream->cancel, demuxer->global);
+                                   demuxer->cancel, demuxer->global);
     if (!p->current->d && !demux_cancel_test(demuxer))
         MP_ERR(demuxer, "failed to load segment\n");
     if (p->current->d)
@@ -431,7 +431,7 @@
     p->current = NULL;
     close_lazy_segments(demuxer);
     timeline_destroy(p->tl);
-    free_demuxer(master);
+    demux_free(master);
 }
 
 static int d_control(struct demuxer *demuxer, int cmd, void *arg)
diff -ruN mpv-0.29.1/demux/demux_tv.c mpv-master/demux/demux_tv.c
--- mpv-0.29.1/demux/demux_tv.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/demux/demux_tv.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,265 +0,0 @@
-/*
- * Copyright (C) 2001 Alex Beregszaszi
- *
- * Feb 19, 2002: Significant rewrites by Charles R. Henrich (henrich@msu.edu)
- *               to add support for audio, and bktr *BSD support.
- *
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <assert.h>
-
-#include "common/common.h"
-#include "common/msg.h"
-
-#include "options/m_option.h"
-#include "options/m_config.h"
-#include "options/options.h"
-
-#include "demux.h"
-#include "codec_tags.h"
-
-#include "audio/format.h"
-#include "osdep/endian.h"
-
-#include "stream/stream.h"
-#include "stream/tv.h"
-
-static int demux_open_tv(demuxer_t *demuxer, enum demux_check check)
-{
-    tvi_handle_t *tvh;
-    const tvi_functions_t *funcs;
-
-    if (check > DEMUX_CHECK_REQUEST)
-        return -1;
-
-    if (!demuxer->stream->info || strcmp(demuxer->stream->info->name, "tv") != 0)
-        return -1;
-
-    tv_param_t *params = mp_get_config_group(demuxer, demuxer->global,
-                                             &tv_params_conf);
-    bstr urlparams = bstr0(demuxer->stream->path);
-    bstr channel, input;
-    bstr_split_tok(urlparams, "/", &channel, &input);
-    if (channel.len) {
-        talloc_free(params->channel);
-        params->channel = bstrto0(NULL, channel);
-    }
-    if (input.len) {
-        bstr r;
-        params->input = bstrtoll(input, &r, 0);
-        if (r.len) {
-            MP_ERR(demuxer->stream, "invalid input: '%.*s'\n", BSTR_P(input));
-            return -1;
-        }
-    }
-
-    assert(demuxer->priv==NULL);
-    if(!(tvh=tv_begin(params, demuxer->log))) return -1;
-    if (!tvh->functions->init(tvh->priv)) return -1;
-
-    tvh->demuxer = demuxer;
-
-    if (!open_tv(tvh)){
-        tv_uninit(tvh);
-        return -1;
-    }
-    funcs = tvh->functions;
-    demuxer->priv=tvh;
-
-    struct sh_stream *sh_v = demux_alloc_sh_stream(STREAM_VIDEO);
-
-    /* get IMAGE FORMAT */
-    int fourcc;
-    funcs->control(tvh->priv, TVI_CONTROL_VID_GET_FORMAT, &fourcc);
-    if (fourcc == MP_FOURCC_MJPEG || fourcc == MP_FOURCC_JPEG) {
-        sh_v->codec->codec = "mjpeg";
-    } else {
-        sh_v->codec->codec = "rawvideo";
-        sh_v->codec->codec_tag = fourcc;
-    }
-
-    /* set FPS and FRAMETIME */
-
-    if(!sh_v->codec->fps)
-    {
-        float tmp;
-        if (funcs->control(tvh->priv, TVI_CONTROL_VID_GET_FPS, &tmp) != TVI_CONTROL_TRUE)
-             sh_v->codec->fps = 25.0f; /* on PAL */
-        else sh_v->codec->fps = tmp;
-    }
-
-    if (tvh->tv_param->fps != -1.0f)
-        sh_v->codec->fps = tvh->tv_param->fps;
-
-    /* If playback only mode, go to immediate mode, fail silently */
-    if(tvh->tv_param->immediate == 1)
-        {
-        funcs->control(tvh->priv, TVI_CONTROL_IMMEDIATE, 0);
-        tvh->tv_param->audio = 0;
-        }
-
-    /* set width */
-    funcs->control(tvh->priv, TVI_CONTROL_VID_GET_WIDTH, &sh_v->codec->disp_w);
-
-    /* set height */
-    funcs->control(tvh->priv, TVI_CONTROL_VID_GET_HEIGHT, &sh_v->codec->disp_h);
-
-    demux_add_sh_stream(demuxer, sh_v);
-
-    demuxer->seekable = 0;
-
-    /* here comes audio init */
-    if (tvh->tv_param->audio && funcs->control(tvh->priv, TVI_CONTROL_IS_AUDIO, 0) == TVI_CONTROL_TRUE)
-    {
-        int audio_format;
-
-        /* yeah, audio is present */
-
-        funcs->control(tvh->priv, TVI_CONTROL_AUD_SET_SAMPLERATE,
-                                  &tvh->tv_param->audiorate);
-
-        if (funcs->control(tvh->priv, TVI_CONTROL_AUD_GET_FORMAT, &audio_format) != TVI_CONTROL_TRUE)
-            goto no_audio;
-
-        switch(audio_format)
-        {
-            // This is the only format any of the current inputs generate.
-            case AF_FORMAT_S16:
-                break;
-            default:
-                MP_ERR(tvh, "Audio type '%s' unsupported!\n",
-                    af_fmt_to_str(audio_format));
-                goto no_audio;
-        }
-
-        struct sh_stream *sh_a = demux_alloc_sh_stream(STREAM_AUDIO);
-
-        funcs->control(tvh->priv, TVI_CONTROL_AUD_GET_SAMPLERATE,
-                   &sh_a->codec->samplerate);
-        int nchannels = sh_a->codec->channels.num;
-        funcs->control(tvh->priv, TVI_CONTROL_AUD_GET_CHANNELS,
-                   &nchannels);
-        mp_chmap_from_channels(&sh_a->codec->channels, nchannels);
-
-        // s16ne
-        mp_set_pcm_codec(sh_a->codec, true, false, 16, BYTE_ORDER == BIG_ENDIAN);
-
-        demux_add_sh_stream(demuxer, sh_a);
-
-        MP_VERBOSE(tvh, "  TV audio: %d channels, %d bits, %d Hz\n",
-                   nchannels, 16, sh_a->codec->samplerate);
-    }
-no_audio:
-
-    if(!(funcs->start(tvh->priv))){
-        // start failed :(
-        tv_uninit(tvh);
-        return -1;
-    }
-
-    /* set color eq */
-    tv_set_color_options(tvh, TV_COLOR_BRIGHTNESS, tvh->tv_param->brightness);
-    tv_set_color_options(tvh, TV_COLOR_HUE, tvh->tv_param->hue);
-    tv_set_color_options(tvh, TV_COLOR_SATURATION, tvh->tv_param->saturation);
-    tv_set_color_options(tvh, TV_COLOR_CONTRAST, tvh->tv_param->contrast);
-
-    if(tvh->tv_param->gain!=-1)
-        if(funcs->control(tvh->priv,TVI_CONTROL_VID_SET_GAIN,&tvh->tv_param->gain)!=TVI_CONTROL_TRUE)
-            MP_WARN(tvh, "Unable to set gain control!\n");
-
-    return 0;
-}
-
-static void demux_close_tv(demuxer_t *demuxer)
-{
-    tvi_handle_t *tvh=(tvi_handle_t*)(demuxer->priv);
-    if (!tvh) return;
-    tv_uninit(tvh);
-    free(tvh);
-    demuxer->priv=NULL;
-}
-
-static int demux_tv_fill_buffer(demuxer_t *demux)
-{
-    tvi_handle_t *tvh=(tvi_handle_t*)(demux->priv);
-    demux_packet_t* dp;
-    unsigned int len=0;
-    struct sh_stream *want_audio = NULL, *want_video = NULL;
-
-    int num_streams = demux_get_num_stream(demux);
-    for (int n = 0; n < num_streams; n++) {
-        struct sh_stream *sh = demux_get_stream(demux, n);
-        if (!demux_has_packet(sh) && demux_stream_is_selected(sh)) {
-            if (sh->type == STREAM_AUDIO)
-                want_audio = sh;
-            if (sh->type == STREAM_VIDEO)
-                want_video = sh;
-        }
-    }
-
-    /* ================== ADD AUDIO PACKET =================== */
-
-    if (want_audio && tvh->tv_param->audio &&
-        tvh->functions->control(tvh->priv,
-                                TVI_CONTROL_IS_AUDIO, 0) == TVI_CONTROL_TRUE)
-    {
-        len = tvh->functions->get_audio_framesize(tvh->priv);
-
-        dp=new_demux_packet(len);
-        if (dp) {
-            dp->keyframe = true;
-            dp->pts=tvh->functions->grab_audio_frame(tvh->priv, dp->buffer,len);
-            demux_add_packet(want_audio, dp);
-        }
-    }
-
-    /* ================== ADD VIDEO PACKET =================== */
-
-    if (want_video && tvh->functions->control(tvh->priv,
-                            TVI_CONTROL_IS_VIDEO, 0) == TVI_CONTROL_TRUE)
-    {
-        len = tvh->functions->get_video_framesize(tvh->priv);
-        dp=new_demux_packet(len);
-        if (dp) {
-            dp->keyframe = true;
-            dp->pts=tvh->functions->grab_video_frame(tvh->priv, dp->buffer, len);
-            demux_add_packet(want_video, dp);
-        }
-    }
-
-    if (tvh->tv_param->scan) tv_scan(tvh);
-    return 1;
-}
-
-static int demux_tv_control(demuxer_t *demuxer, int cmd, void *arg)
-{
-    tvi_handle_t *tvh=(tvi_handle_t*)(demuxer->priv);
-    if (cmd != DEMUXER_CTRL_STREAM_CTRL)
-        return CONTROL_UNKNOWN;
-    struct demux_ctrl_stream_ctrl *ctrl = arg;
-    ctrl->res = tv_stream_control(tvh, ctrl->ctrl, ctrl->arg);
-    return CONTROL_OK;
-}
-
-const demuxer_desc_t demuxer_desc_tv = {
-    .name = "tv",
-    .desc = "TV card demuxer",
-    .fill_buffer = demux_tv_fill_buffer,
-    .control = demux_tv_control,
-    .open = demux_open_tv,
-    .close = demux_close_tv,
-};
diff -ruN mpv-0.29.1/demux/stheader.h mpv-master/demux/stheader.h
--- mpv-0.29.1/demux/stheader.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/demux/stheader.h	2019-09-19 04:02:03.000000000 +0700
@@ -46,6 +46,8 @@
     bool default_track;         // container default track flag
     bool forced_track;          // container forced track flag
     bool dependent_track;       // container dependent track flag
+    bool visual_impaired_track; // container flag
+    bool hearing_impaired_track;// container flag
     bool still_image;           // video stream contains still images
     int hls_bitrate;
 
diff -ruN mpv-0.29.1/demux/timeline.c mpv-master/demux/timeline.c
--- mpv-0.29.1/demux/timeline.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/demux/timeline.c	2019-09-19 04:02:03.000000000 +0700
@@ -14,7 +14,7 @@
     *tl = (struct timeline){
         .global = global,
         .log = log,
-        .cancel = demuxer->stream->cancel,
+        .cancel = demuxer->cancel,
         .demuxer = demuxer,
         .track_layout = demuxer,
     };
@@ -34,9 +34,9 @@
     for (int n = 0; n < tl->num_sources; n++) {
         struct demuxer *d = tl->sources[n];
         if (d != tl->demuxer && d != tl->track_layout)
-            free_demuxer_and_stream(d);
+            demux_free(d);
     }
     if (tl->track_layout && tl->track_layout != tl->demuxer)
-        free_demuxer_and_stream(tl->track_layout);
+        demux_free(tl->track_layout);
     talloc_free(tl);
 }
diff -ruN mpv-0.29.1/etc/builtin.conf mpv-master/etc/builtin.conf
--- mpv-0.29.1/etc/builtin.conf	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/etc/builtin.conf	2019-09-19 04:02:03.000000000 +0700
@@ -40,6 +40,7 @@
 dscale=mitchell
 dither-depth=auto
 correct-downscaling=yes
+linear-downscaling=yes
 sigmoid-upscaling=yes
 deband=yes
 
diff -ruN mpv-0.29.1/etc/input.conf mpv-master/etc/input.conf
--- mpv-0.29.1/etc/input.conf	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/etc/input.conf	2019-09-19 04:02:03.000000000 +0700
@@ -133,9 +133,9 @@
 #_ cycle video
 #T cycle ontop                          # toggle video window ontop of other windows
 #f cycle fullscreen                     # toggle fullscreen
-#s async screenshot                     # take a screenshot
-#S async screenshot video               # ...without subtitles
-#Ctrl+s async screenshot window         # ...with subtitles and OSD, and scaled
+#s screenshot                           # take a screenshot
+#S screenshot video                     # ...without subtitles
+#Ctrl+s screenshot window               # ...with subtitles and OSD, and scaled
 #Alt+s screenshot each-frame            # automatically screenshot every frame
 #w add panscan -0.1                     # zoom out with -panscan 0 -fs
 #W add panscan +0.1                     #      in
diff -ruN mpv-0.29.1/etc/mpv.conf mpv-master/etc/mpv.conf
--- mpv-0.29.1/etc/mpv.conf	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/etc/mpv.conf	2019-09-19 04:02:03.000000000 +0700
@@ -95,9 +95,6 @@
 
 # cache settings
 #
-# Use 150MB input cache by default. The cache is enabled for network streams only.
-#cache-default=153600
-#
 # Use 150MB input cache for everything, even local files.
 #cache=153600
 #
diff -ruN mpv-0.29.1/filters/f_auto_filters.c mpv-master/filters/f_auto_filters.c
--- mpv-0.29.1/filters/f_auto_filters.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/filters/f_auto_filters.c	2019-09-19 04:02:03.000000000 +0700
@@ -75,6 +75,10 @@
     } else if (img->imgfmt == IMGFMT_D3D11) {
         p->sub.filter =
             mp_create_user_filter(f, MP_OUTPUT_CHAIN_VIDEO, "d3d11vpp", NULL);
+    } else if (img->imgfmt == IMGFMT_CUDA) {
+        char *args[] = {"mode", "send_field", NULL};
+        p->sub.filter =
+            mp_create_user_filter(f, MP_OUTPUT_CHAIN_VIDEO, "yadif_cuda", args);
     } else if (mp_sws_supports_input(img->imgfmt)) {
         char *args[] = {"mode", "send_field", NULL};
         p->sub.filter =
diff -ruN mpv-0.29.1/filters/f_decoder_wrapper.c mpv-master/filters/f_decoder_wrapper.c
--- mpv-0.29.1/filters/f_decoder_wrapper.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/filters/f_decoder_wrapper.c	2019-09-19 04:02:03.000000000 +0700
@@ -27,7 +27,7 @@
 #include "config.h"
 #include "options/options.h"
 #include "common/msg.h"
-
+#include "options/m_config.h"
 #include "osdep/timer.h"
 
 #include "demux/demux.h"
@@ -50,7 +50,7 @@
 struct priv {
     struct mp_filter *f;
     struct mp_log *log;
-    struct MPOpts *opts;
+    struct m_config_cache *opt_cache;
 
     struct sh_stream *header;
     struct mp_codec_params *codec;
@@ -162,7 +162,8 @@
 bool mp_decoder_wrapper_reinit(struct mp_decoder_wrapper *d)
 {
     struct priv *p = d->f->priv;
-    struct MPOpts *opts = p->opts;
+    struct MPOpts *opts = p->opt_cache->opts;
+    m_config_cache_update(p->opt_cache);
 
     if (p->decoder)
         talloc_free(p->decoder->f);
@@ -236,9 +237,10 @@
 static void fix_image_params(struct priv *p,
                              struct mp_image_params *params)
 {
-    struct MPOpts *opts = p->opts;
     struct mp_image_params m = *params;
     struct mp_codec_params *c = p->codec;
+    struct MPOpts *opts = p->opt_cache->opts;
+    m_config_cache_update(p->opt_cache);
 
     MP_VERBOSE(p, "Decoder format: %s\n", mp_image_params_to_str(params));
     p->dec_format = *params;
@@ -302,7 +304,8 @@
 
 static void process_video_frame(struct priv *p, struct mp_image *mpi)
 {
-    struct MPOpts *opts = p->opts;
+    struct MPOpts *opts = p->opt_cache->opts;
+    m_config_cache_update(p->opt_cache);
 
     // Note: the PTS is reordered, but the DTS is not. Both should be monotonic.
     double pts = mpi->pts;
@@ -645,13 +648,15 @@
 
     struct priv *p = f->priv;
     struct mp_decoder_wrapper *w = &p->public;
-    p->opts = f->global->opts;
+    p->opt_cache = m_config_cache_alloc(p, f->global, GLOBAL_CONFIG);
     p->log = f->log;
     p->f = f;
     p->header = src;
     p->codec = p->header->codec;
     w->f = f;
 
+    struct MPOpts *opts = p->opt_cache->opts;
+
     mp_filter_add_pin(f, MP_PIN_OUT, "out");
 
     if (p->header->type == STREAM_VIDEO) {
@@ -661,8 +666,8 @@
 
         MP_VERBOSE(p, "Container reported FPS: %f\n", p->public.fps);
 
-        if (p->opts->force_fps) {
-            p->public.fps = p->opts->force_fps;
+        if (opts->force_fps) {
+            p->public.fps = opts->force_fps;
             MP_INFO(p, "FPS forced to %5.3f.\n", p->public.fps);
             MP_INFO(p, "Use --no-correct-pts to force FPS based timing.\n");
         }
diff -ruN mpv-0.29.1/filters/f_swresample.c mpv-master/filters/f_swresample.c
--- mpv-0.29.1/filters/f_swresample.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/filters/f_swresample.c	2019-09-19 04:02:03.000000000 +0700
@@ -399,7 +399,7 @@
     if (!mp_aframe_set_chmap(mpa, newmap))
         return false;
 
-    int num_planes = newmap->num;
+    int num_planes = mp_aframe_get_planes(mpa);
     uint8_t **planes = mp_aframe_get_data_rw(mpa);
     uint8_t *old_planes[MP_NUM_CHANNELS];
     assert(num_planes <= MP_NUM_CHANNELS);
diff -ruN mpv-0.29.1/input/cmd.c mpv-master/input/cmd.c
--- mpv-0.29.1/input/cmd.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/input/cmd.c	2019-09-19 04:02:03.000000000 +0700
@@ -18,6 +18,7 @@
 #include <stddef.h>
 
 #include "misc/bstr.h"
+#include "misc/node.h"
 #include "common/common.h"
 #include "common/msg.h"
 #include "options/m_option.h"
@@ -27,15 +28,13 @@
 
 #include "libmpv/client.h"
 
-const struct mp_cmd_def mp_cmd_list = {
-    .name = "list",
-};
-
 static void destroy_cmd(void *ptr)
 {
     struct mp_cmd *cmd = ptr;
-    for (int n = 0; n < cmd->nargs; n++)
-        m_option_free(cmd->args[n].type, &cmd->args[n].v);
+    for (int n = 0; n < cmd->nargs; n++) {
+        if (cmd->args[n].type)
+            m_option_free(cmd->args[n].type, &cmd->args[n].v);
+    }
 }
 
 struct flag {
@@ -52,7 +51,8 @@
     {"expand-properties",   0,               MP_EXPAND_PROPERTIES},
     {"raw",                 MP_EXPAND_PROPERTIES, 0},
     {"repeatable",          0,               MP_ALLOW_REPEAT},
-    {"async",               0,               MP_ASYNC_CMD},
+    {"async",               MP_SYNC_CMD,     MP_ASYNC_CMD},
+    {"sync",                MP_ASYNC_CMD,     MP_SYNC_CMD},
     {0}
 };
 
@@ -114,34 +114,93 @@
     return opt && opt->type ? opt : NULL;
 }
 
-// Verify that there are missing args, fill in missing optional args.
+// Return the name of the argument, possibly as stack allocated string (which is
+// why this is a macro, and out of laziness). Otherwise as get_arg_type().
+#define get_arg_name(cmd, i)                                    \
+    ((i) < MP_CMD_DEF_MAX_ARGS && (cmd)->args[(i)].name &&      \
+     (cmd)->args[(i)].name[0]                                   \
+     ? (cmd)->args[(i)].name : mp_tprintf(10, "%d", (i) + 1))
+
+// Verify that there are no missing args, fill in missing optional args.
 static bool finish_cmd(struct mp_log *log, struct mp_cmd *cmd)
 {
-    for (int i = cmd->nargs; i < MP_CMD_DEF_MAX_ARGS; i++) {
+    for (int i = 0; i < MP_CMD_DEF_MAX_ARGS; i++) {
+        // (type==NULL is used for yet unset arguments)
+        if (i < cmd->nargs && cmd->args[i].type)
+            continue;
         const struct m_option *opt = get_arg_type(cmd->def, i);
-        if (!opt || is_vararg(cmd->def, i))
+        if (i >= cmd->nargs && (!opt || is_vararg(cmd->def, i)))
             break;
         if (!opt->defval && !(opt->flags & MP_CMD_OPT_ARG)) {
-            mp_err(log, "Command %s: more than %d arguments required.\n",
-                    cmd->name, cmd->nargs);
+            mp_err(log, "Command %s: required argument %s not set.\n",
+                   cmd->name, get_arg_name(cmd->def, i));
             return false;
         }
         struct mp_cmd_arg arg = {.type = opt};
         if (opt->defval)
             m_option_copy(opt, &arg.v, opt->defval);
-        MP_TARRAY_APPEND(cmd, cmd->args, cmd->nargs, arg);
+        assert(i <= cmd->nargs);
+        if (i == cmd->nargs) {
+            MP_TARRAY_APPEND(cmd, cmd->args, cmd->nargs, arg);
+        } else {
+            cmd->args[i] = arg;
+        }
     }
+
+    if (!(cmd->flags & (MP_ASYNC_CMD | MP_SYNC_CMD)))
+        cmd->flags |= cmd->def->default_async ? MP_ASYNC_CMD : MP_SYNC_CMD;
+
     return true;
 }
 
-struct mp_cmd *mp_input_parse_cmd_node(struct mp_log *log, mpv_node *node)
+static bool set_node_arg(struct mp_log *log, struct mp_cmd *cmd, int i,
+                         mpv_node *val)
 {
-    struct mp_cmd *cmd = talloc_ptrtype(NULL, cmd);
-    talloc_set_destructor(cmd, destroy_cmd);
-    *cmd = (struct mp_cmd) { .scale = 1, .scale_units = 1 };
+    const char *name = get_arg_name(cmd->def, i);
 
-    if (node->format != MPV_FORMAT_NODE_ARRAY)
-        goto error;
+    const struct m_option *opt = get_arg_type(cmd->def, i);
+    if (!opt) {
+        mp_err(log, "Command %s: has only %d arguments.\n", cmd->name, i);
+        return false;
+    }
+
+    if (i < cmd->nargs && cmd->args[i].type) {
+        mp_err(log, "Command %s: argument %s was already set.\n", cmd->name, name);
+        return false;
+    }
+
+    struct mp_cmd_arg arg = {.type = opt};
+    void *dst = &arg.v;
+    if (val->format == MPV_FORMAT_STRING) {
+        int r = m_option_parse(log, opt, bstr0(cmd->name),
+                                bstr0(val->u.string), dst);
+        if (r < 0) {
+            mp_err(log, "Command %s: argument %s can't be parsed: %s.\n",
+                   cmd->name, name, m_option_strerror(r));
+            return false;
+        }
+    } else {
+        int r = m_option_set_node(opt, dst, val);
+        if (r < 0) {
+            mp_err(log, "Command %s: argument %s has incompatible type.\n",
+                   cmd->name, name);
+            return false;
+        }
+    }
+
+    // (leave unset arguments blank, to be set later or checked by finish_cmd())
+    while (i >= cmd->nargs) {
+        struct mp_cmd_arg t = {0};
+        MP_TARRAY_APPEND(cmd, cmd->args, cmd->nargs, t);
+    }
+
+    cmd->args[i] = arg;
+    return true;
+}
+
+static bool cmd_node_array(struct mp_log *log, struct mp_cmd *cmd, mpv_node *node)
+{
+    assert(node->format == MPV_FORMAT_NODE_ARRAY);
     mpv_node_list *args = node->u.list;
     int cur = 0;
 
@@ -157,47 +216,97 @@
     if (cur < args->num && args->values[cur].format == MPV_FORMAT_STRING)
         cmd_name = bstr0(args->values[cur++].u.string);
     if (!find_cmd(log, cmd, cmd_name))
-        goto error;
+        return false;
 
     int first = cur;
     for (int i = 0; i < args->num - first; i++) {
-        const struct m_option *opt = get_arg_type(cmd->def, i);
-        if (!opt) {
-            mp_err(log, "Command %s: has only %d arguments.\n", cmd->name, i);
-            goto error;
-        }
-        mpv_node *val = &args->values[cur++];
-        struct mp_cmd_arg arg = {.type = opt};
-        void *dst = &arg.v;
-        if (val->format == MPV_FORMAT_STRING) {
-            int r = m_option_parse(log, opt, bstr0(cmd->name),
-                                   bstr0(val->u.string), dst);
-            if (r < 0) {
-                mp_err(log, "Command %s: argument %d can't be parsed: %s.\n",
-                       cmd->name, i + 1, m_option_strerror(r));
-                goto error;
+        if (!set_node_arg(log, cmd, cmd->nargs, &args->values[cur++]))
+            return false;
+    }
+
+    return true;
+}
+
+static bool cmd_node_map(struct mp_log *log, struct mp_cmd *cmd, mpv_node *node)
+{
+    assert(node->format == MPV_FORMAT_NODE_MAP);
+    mpv_node_list *args = node->u.list;
+
+    mpv_node *name = node_map_get(node, "name");
+    if (!name || name->format != MPV_FORMAT_STRING)
+        return false;
+
+    if (!find_cmd(log, cmd, bstr0(name->u.string)))
+        return false;
+
+    if (cmd->def->vararg) {
+        mp_err(log, "Command %s: this command uses a variable number of "
+               "arguments, which does not work with named arguments.\n",
+               cmd->name);
+        return false;
+    }
+
+    for (int n = 0; n < args->num; n++) {
+        const char *key = args->keys[n];
+        mpv_node *val = &args->values[n];
+
+        if (strcmp(key, "name") == 0) {
+            // already handled above
+        } else if (strcmp(key, "_flags") == 0) {
+            if (val->format != MPV_FORMAT_NODE_ARRAY)
+                return false;
+            mpv_node_list *flags = val->u.list;
+            for (int i = 0; i < flags->num; i++) {
+                if (flags->values[i].format != MPV_FORMAT_STRING)
+                    return false;
+                if (!apply_flag(cmd, bstr0(flags->values[i].u.string)))
+                    return false;
             }
         } else {
-            int r = m_option_set_node(opt, dst, val);
-            if (r < 0) {
-                mp_err(log, "Command %s: argument %d has incompatible type.\n",
-                       cmd->name, i + 1);
-                goto error;
+            int arg = -1;
+
+            for (int i = 0; i < MP_CMD_DEF_MAX_ARGS; i++) {
+                const char *arg_name = cmd->def->args[i].name;
+                if (arg_name && arg_name[0] && strcmp(key, arg_name) == 0) {
+                    arg = i;
+                    break;
+                }
             }
+
+            if (arg < 0) {
+                mp_err(log, "Command %s: no argument %s.\n", cmd->name, key);
+                return false;
+            }
+
+            if (!set_node_arg(log, cmd, arg, val))
+                return false;
         }
-        MP_TARRAY_APPEND(cmd, cmd->args, cmd->nargs, arg);
     }
 
-    if (!finish_cmd(log, cmd))
-        goto error;
+    return true;
+}
+
+struct mp_cmd *mp_input_parse_cmd_node(struct mp_log *log, mpv_node *node)
+{
+    struct mp_cmd *cmd = talloc_ptrtype(NULL, cmd);
+    talloc_set_destructor(cmd, destroy_cmd);
+    *cmd = (struct mp_cmd) { .scale = 1, .scale_units = 1 };
+
+    bool res = false;
+    if (node->format == MPV_FORMAT_NODE_ARRAY) {
+        res = cmd_node_array(log, cmd, node);
+    } else if (node->format == MPV_FORMAT_NODE_MAP) {
+        res = cmd_node_map(log, cmd, node);
+    }
+
+    res = res && finish_cmd(log, cmd);
+
+    if (!res)
+        TA_FREEP(&cmd);
 
     return cmd;
-error:
-    talloc_free(cmd);
-    return NULL;
 }
 
-
 static bool read_token(bstr str, bstr *out_rest, bstr *out_token)
 {
     bstr t = bstr_lstrip(str);
@@ -443,34 +552,6 @@
     mp_msg(log, msgl, "]\n");
 }
 
-// 0: no, 1: maybe, 2: sure
-static int is_abort_cmd(struct mp_cmd *cmd)
-{
-    if (cmd->def->is_abort)
-        return 2;
-    if (cmd->def->is_soft_abort)
-        return 1;
-    if (cmd->def == &mp_cmd_list) {
-        int r = 0;
-        for (struct mp_cmd *sub = cmd->args[0].v.p; sub; sub = sub->queue_next) {
-            int x = is_abort_cmd(sub);
-            r = MPMAX(r, x);
-        }
-        return r;
-    }
-    return 0;
-}
-
-bool mp_input_is_maybe_abort_cmd(struct mp_cmd *cmd)
-{
-    return is_abort_cmd(cmd) >= 1;
-}
-
-bool mp_input_is_abort_cmd(struct mp_cmd *cmd)
-{
-    return is_abort_cmd(cmd) >= 2;
-}
-
 bool mp_input_is_repeatable_cmd(struct mp_cmd *cmd)
 {
     return (cmd->def->allow_auto_repeat) || cmd->def == &mp_cmd_list ||
@@ -488,12 +569,13 @@
         const struct mp_cmd_def *def = &mp_cmds[i];
         mp_info(out, "%-20.20s", def->name);
         for (int j = 0; j < MP_CMD_DEF_MAX_ARGS && def->args[j].type; j++) {
-            const char *type = def->args[j].type->name;
-            if (def->args[j].defval)
-                mp_info(out, " [%s]", type);
-            else
-                mp_info(out, " %s", type);
+            const struct m_option *arg = &def->args[j];
+            bool is_opt = arg->defval || (arg->flags & MP_CMD_OPT_ARG);
+            mp_info(out, " %s%s=%s%s", is_opt ? "[" : "", arg->name,
+                    arg->type->name, is_opt ? "]" : "");
         }
+        if (def->vararg)
+            mp_info(out, "..."); // essentially append to last argument
         mp_info(out, "\n");
     }
 }
diff -ruN mpv-0.29.1/input/cmd.h mpv-master/input/cmd.h
--- mpv-0.29.1/input/cmd.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/input/cmd.h	2019-09-19 04:02:03.000000000 +0700
@@ -39,9 +39,26 @@
     bool on_updown;     // always emit it on both up and down key events
     bool vararg;        // last argument can be given 0 to multiple times
     bool scalable;
-    bool is_abort;
-    bool is_soft_abort;
     bool is_ignore;
+    bool default_async; // default to MP_ASYNC flag if none set by user
+    // If you set this, handler() must ensure mp_cmd_ctx_complete() is called
+    // at some point (can be after handler() returns). If you don't set it, the
+    // common code will call mp_cmd_ctx_complete() when handler() returns.
+    // You must make sure that the core cannot disappear while you do work. The
+    // common code keeps the core referenced only until handler() returns.
+    bool exec_async;
+    // If set, handler() is run on a separate worker thread. This means you can
+    // use mp_core_[un]lock() to temporarily unlock and re-lock the core (while
+    // unlocked, you have no synchronized access to mpctx, but you can do long
+    // running operations without blocking playback or input handling).
+    bool spawn_thread;
+    // If this is set, mp_cmd_ctx.abort is set. Set this if handler() can do
+    // asynchronous abort of the command, and explicitly uses mp_cmd_ctx.abort.
+    // (Not setting it when it's not needed can save resources.)
+    bool can_abort;
+    // If playback ends, and the command is still running, an abort is
+    // automatically triggered.
+    bool abort_on_playback_end;
 };
 
 enum mp_cmd_flags {
@@ -51,7 +68,11 @@
     MP_ON_OSD_MSG = 4,          // force a message, if applicable
     MP_EXPAND_PROPERTIES = 8,   // expand strings as properties
     MP_ALLOW_REPEAT = 16,       // if used as keybinding, allow key repeat
-    MP_ASYNC_CMD = 32,
+
+    // Exactly one of the following 2 bits is set. Which one is used depends on
+    // the command parser (prefixes and mp_cmd_def.default_async).
+    MP_ASYNC_CMD = 32,          // do not wait for command to complete
+    MP_SYNC_CMD = 64,           // block on command completion
 
     MP_ON_OSD_FLAGS = MP_ON_OSD_NO | MP_ON_OSD_AUTO |
                       MP_ON_OSD_BAR | MP_ON_OSD_MSG,
@@ -64,6 +85,7 @@
     const struct m_option *type;
     union {
         int i;
+        int64_t i64;
         float f;
         double d;
         char *s;
@@ -73,7 +95,6 @@
 };
 
 typedef struct mp_cmd {
-    int id;
     char *name;
     struct mp_cmd_arg *args;
     int nargs;
@@ -98,11 +119,6 @@
 extern const struct mp_cmd_def mp_cmds[];
 extern const struct mp_cmd_def mp_cmd_list;
 
-// Executing this command will maybe abort playback (play something else, or quit).
-bool mp_input_is_maybe_abort_cmd(struct mp_cmd *cmd);
-// This command will definitely abort playback.
-bool mp_input_is_abort_cmd(struct mp_cmd *cmd);
-
 bool mp_input_is_repeatable_cmd(struct mp_cmd *cmd);
 
 bool mp_input_is_scalable_cmd(struct mp_cmd *cmd);
diff -ruN mpv-0.29.1/input/input.c mpv-master/input/input.c
--- mpv-0.29.1/input/input.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/input/input.c	2019-09-19 04:02:03.000000000 +0700
@@ -153,9 +153,6 @@
 
     struct cmd_queue cmd_queue;
 
-    void (*cancel)(void *cancel_ctx);
-    void *cancel_ctx;
-
     void (*wakeup_cb)(void *ctx);
     void *wakeup_ctx;
 };
@@ -531,13 +528,11 @@
 }
 
 // We don't want the append to the command queue indefinitely, because that
-// could lead to situations where recovery would take too long. On the other
-// hand, don't drop commands that will abort playback.
+// could lead to situations where recovery would take too long.
 static bool should_drop_cmd(struct input_ctx *ictx, struct mp_cmd *cmd)
 {
     struct cmd_queue *queue = &ictx->cmd_queue;
-    return queue_count_cmds(queue) >= ictx->opts->key_fifo_size &&
-           !mp_input_is_abort_cmd(cmd);
+    return queue_count_cmds(queue) >= ictx->opts->key_fifo_size;
 }
 
 static struct mp_cmd *resolve_key(struct input_ctx *ictx, int code)
@@ -883,26 +878,10 @@
     }
 }
 
-static bool test_abort_cmd(struct input_ctx *ictx, struct mp_cmd *new)
-{
-    if (!mp_input_is_maybe_abort_cmd(new))
-        return false;
-    if (mp_input_is_abort_cmd(new))
-        return true;
-    // Abort only if there are going to be at least 2 commands in the queue.
-    for (struct mp_cmd *cmd = ictx->cmd_queue.first; cmd; cmd = cmd->queue_next) {
-        if (mp_input_is_maybe_abort_cmd(cmd))
-            return true;
-    }
-    return false;
-}
-
 int mp_input_queue_cmd(struct input_ctx *ictx, mp_cmd_t *cmd)
 {
     input_lock(ictx);
     if (cmd) {
-        if (ictx->cancel && test_abort_cmd(ictx, cmd))
-            ictx->cancel(ictx->cancel_ctx);
         queue_add_tail(&ictx->cmd_queue, cmd);
         mp_input_wakeup(ictx);
     }
@@ -1391,8 +1370,11 @@
     }
 
 #if HAVE_WIN32_PIPES
-    if (ictx->global->opts->input_file && *ictx->global->opts->input_file)
-        mp_input_pipe_add(ictx, ictx->global->opts->input_file);
+    char *ifile;
+    mp_read_option_raw(ictx->global, "input-file", &m_option_type_string, &ifile);
+    if (ifile && ifile[0])
+        mp_input_pipe_add(ictx, ifile);
+    talloc_free(ifile);
 #endif
 
     input_unlock(ictx);
@@ -1423,14 +1405,6 @@
     talloc_free(ictx);
 }
 
-void mp_input_set_cancel(struct input_ctx *ictx, void (*cb)(void *c), void *c)
-{
-    input_lock(ictx);
-    ictx->cancel = cb;
-    ictx->cancel_ctx = c;
-    input_unlock(ictx);
-}
-
 bool mp_input_use_alt_gr(struct input_ctx *ictx)
 {
     input_lock(ictx);
diff -ruN mpv-0.29.1/input/input.h mpv-master/input/input.h
--- mpv-0.29.1/input/input.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/input/input.h	2019-09-19 04:02:03.000000000 +0700
@@ -193,10 +193,6 @@
 // Wake up sleeping input loop from another thread.
 void mp_input_wakeup(struct input_ctx *ictx);
 
-// Used to asynchronously abort playback. Needed because the core still can
-// block on network in some situations.
-void mp_input_set_cancel(struct input_ctx *ictx, void (*cb)(void *c), void *c);
-
 // If this returns true, use Right Alt key as Alt Gr to produce special
 // characters. If false, count Right Alt as the modifier Alt key.
 bool mp_input_use_alt_gr(struct input_ctx *ictx);
diff -ruN mpv-0.29.1/input/ipc-unix.c mpv-master/input/ipc-unix.c
--- mpv-0.29.1/input/ipc-unix.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/input/ipc-unix.c	2019-09-19 04:02:03.000000000 +0700
@@ -36,6 +36,7 @@
 #include "common/msg.h"
 #include "input/input.h"
 #include "libmpv/client.h"
+#include "options/m_config.h"
 #include "options/options.h"
 #include "options/path.h"
 #include "player/client.h"
@@ -73,7 +74,7 @@
             if (rc == 0)
                 return -1;
 
-            if (errno == EBADF) {
+            if (errno == EBADF || errno == ENOTSOCK) {
                 client->writable = false;
                 return 0;
             }
@@ -324,7 +325,7 @@
     }
 
     ipc_un.sun_family = AF_UNIX,
-    strncpy(ipc_un.sun_path, arg->path, sizeof(ipc_un.sun_path));
+    strncpy(ipc_un.sun_path, arg->path, sizeof(ipc_un.sun_path) - 1);
 
     unlink(ipc_un.sun_path);
 
@@ -386,7 +387,7 @@
 struct mp_ipc_ctx *mp_init_ipc(struct mp_client_api *client_api,
                                struct mpv_global *global)
 {
-    struct MPOpts *opts = global->opts;
+    struct MPOpts *opts = mp_get_config_group(NULL, global, GLOBAL_CONFIG);
 
     struct mp_ipc_ctx *arg = talloc_ptrtype(NULL, arg);
     *arg = (struct mp_ipc_ctx){
@@ -397,10 +398,12 @@
     };
     char *input_file = mp_get_user_path(arg, global, opts->input_file);
 
+    talloc_free(opts);
+
     if (input_file && *input_file)
         ipc_start_client_text(arg, input_file);
 
-    if (!opts->ipc_path || !*opts->ipc_path)
+    if (!arg->path || !arg->path[0])
         goto out;
 
     if (mp_make_wakeup_pipe(arg->death_pipe) < 0)
diff -ruN mpv-0.29.1/input/ipc-win.c mpv-master/input/ipc-win.c
--- mpv-0.29.1/input/ipc-win.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/input/ipc-win.c	2019-09-19 04:02:03.000000000 +0700
@@ -29,6 +29,7 @@
 #include "common/msg.h"
 #include "input/input.h"
 #include "libmpv/client.h"
+#include "options/m_config.h"
 #include "options/options.h"
 #include "player/client.h"
 
@@ -449,7 +450,7 @@
 struct mp_ipc_ctx *mp_init_ipc(struct mp_client_api *client_api,
                                struct mpv_global *global)
 {
-    struct MPOpts *opts = global->opts;
+    struct MPOpts *opts = mp_get_config_group(NULL, global, GLOBAL_CONFIG);
 
     struct mp_ipc_ctx *arg = talloc_ptrtype(NULL, arg);
     *arg = (struct mp_ipc_ctx){
@@ -478,12 +479,14 @@
     if (pthread_create(&arg->thread, NULL, ipc_thread, arg))
         goto out;
 
+    talloc_free(opts);
     return arg;
 
 out:
     if (arg->death_event)
         CloseHandle(arg->death_event);
     talloc_free(arg);
+    talloc_free(opts);
     return NULL;
 }
 
diff -ruN mpv-0.29.1/input/ipc.c mpv-master/input/ipc.c
--- mpv-0.29.1/input/ipc.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/input/ipc.c	2019-09-19 04:02:03.000000000 +0700
@@ -20,23 +20,12 @@
 #include "common/msg.h"
 #include "input/input.h"
 #include "misc/json.h"
+#include "misc/node.h"
 #include "options/m_option.h"
 #include "options/options.h"
 #include "options/path.h"
 #include "player/client.h"
 
-static mpv_node *mpv_node_map_get(mpv_node *src, const char *key)
-{
-    if (src->format != MPV_FORMAT_NODE_MAP)
-        return NULL;
-
-    for (int i = 0; i < src->u.list->num; i++)
-        if (!strcmp(key, src->u.list->keys[i]))
-            return &src->u.list->values[i];
-
-    return NULL;
-}
-
 static mpv_node *mpv_node_array_get(mpv_node *src, int index)
 {
     if (src->format != MPV_FORMAT_NODE_ARRAY)
@@ -217,9 +206,13 @@
         goto error;
     }
 
-    reqid_node = mpv_node_map_get(&msg_node, "request_id");
+    reqid_node = node_map_get(&msg_node, "request_id");
+    if (reqid_node && reqid_node->format != MPV_FORMAT_INT64) {
+        mp_warn(log, "'request_id' must be an integer. Using other types is "
+                "deprecated and will trigger an error in the future!\n");
+    }
 
-    mpv_node *cmd_node = mpv_node_map_get(&msg_node, "command");
+    mpv_node *cmd_node = node_map_get(&msg_node, "command");
     if (!cmd_node ||
         (cmd_node->format != MPV_FORMAT_NODE_ARRAY) ||
         !cmd_node->u.list->num)
@@ -415,6 +408,8 @@
      */
     if (reqid_node) {
         mpv_node_map_add(ta_parent, &reply_node, "request_id", reqid_node);
+    } else {
+        mpv_node_map_add_int64(ta_parent, &reply_node, "request_id", 0);
     }
 
     mpv_node_map_add_string(ta_parent, &reply_node, "error", mpv_error_string(rc));
diff -ruN mpv-0.29.1/libmpv/client.h mpv-master/libmpv/client.h
--- mpv-0.29.1/libmpv/client.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/libmpv/client.h	2019-09-19 04:02:03.000000000 +0700
@@ -107,8 +107,9 @@
  * careful not accidentally interpret the mpv_event->reply_userdata if an
  * event is not a reply. (For non-replies, this field is set to 0.)
  *
- * Currently, asynchronous calls are always strictly ordered (even with
- * synchronous calls) for each client, although that may change in the future.
+ * Asynchronous calls may be reordered in arbitrarily with other synchronous
+ * and asynchronous calls. If you want a guaranteed order, you need to wait
+ * until asynchronous calls report completion before doing the next call.
  *
  * Multithreading
  * --------------
@@ -195,6 +196,18 @@
  * or change the underlying datatypes. It might be a good idea to prefer
  * MPV_FORMAT_STRING over other types to decouple your code from potential
  * mpv changes.
+ *
+ * Future changes
+ * --------------
+ *
+ * This are the planned changes that will most likely be done on the next major
+ * bump of the library:
+ *
+ *  - remove all symbols and include files that are marked as deprecated
+ *  - reassign enum numerical values to remove gaps
+ *  - remove the mpv_opengl_init_params.extra_exts field
+ *  - change the type of mpv_event_end_file.reason
+ *  - disabling all events by default
  */
 
 /**
@@ -210,7 +223,7 @@
  * relational operators (<, >, <=, >=).
  */
 #define MPV_MAKE_VERSION(major, minor) (((major) << 16) | (minor) | 0UL)
-#define MPV_CLIENT_API_VERSION MPV_MAKE_VERSION(1, 101)
+#define MPV_CLIENT_API_VERSION MPV_MAKE_VERSION(1, 104)
 
 /**
  * The API user is allowed to "#define MPV_ENABLE_DEPRECATED 0" before
@@ -928,10 +941,25 @@
  *
  * Does not use OSD and string expansion by default.
  *
- * @param[in] args mpv_node with format set to MPV_FORMAT_NODE_ARRAY; each entry
- *                 is an argument using an arbitrary format (the format must be
- *                 compatible to the used command). Usually, the first item is
- *                 the command name (as MPV_FORMAT_STRING).
+ * The args argument can have one of the following formats:
+ *
+ * MPV_FORMAT_NODE_ARRAY:
+ *      Positional arguments. Each entry is an argument using an arbitrary
+ *      format (the format must be compatible to the used command). Usually,
+ *      the first item is the command name (as MPV_FORMAT_STRING). The order
+ *      of arguments is as documented in each command description.
+ *
+ * MPV_FORMAT_NODE_MAP:
+ *      Named arguments. This requires at least an entry with the key "name"
+ *      to be present, which must be a string, and contains the command name.
+ *      The special entry "_flags" is optional, and if present, must be an
+ *      array of strings, each being a command prefix to apply. All other
+ *      entries are interpreted as arguments. They must use the argument names
+ *      as documented in each command description. Some commands do not
+ *      support named arguments at all, and must use MPV_FORMAT_NODE_ARRAY.
+ *
+ * @param[in] args mpv_node with format set to one of the values documented
+ *                 above (see there for details)
  * @param[out] result Optional, pass NULL if unused. If not NULL, and if the
  *                    function succeeds, this is set to command-specific return
  *                    data. You must call mpv_free_node_contents() to free it
@@ -954,14 +982,11 @@
  * Same as mpv_command, but run the command asynchronously.
  *
  * Commands are executed asynchronously. You will receive a
- * MPV_EVENT_COMMAND_REPLY event. (This event will also have an
- * error code set if running the command failed.)
- *
- * This has nothing to do with the "async" command prefix, although they might
- * be unified in the future. For now, calling this API means that the command
- * will be synchronously executed on the core, without blocking the API user.
+ * MPV_EVENT_COMMAND_REPLY event. This event will also have an
+ * error code set if running the command failed. For commands that
+ * return data, the data is put into mpv_event_command.result.
  *
- * * Safe to be called from mpv render API threads.
+ * Safe to be called from mpv render API threads.
  *
  * @param reply_userdata the value mpv_event.reply_userdata of the reply will
  *                       be set to (see section about asynchronous calls)
@@ -976,8 +1001,7 @@
  * function is to mpv_command_node() what mpv_command_async() is to
  * mpv_command().
  *
- * See mpv_command_async() for details. Retrieving the result is not
- * supported yet.
+ * See mpv_command_async() for details.
  *
  * Safe to be called from mpv render API threads.
  *
@@ -990,6 +1014,38 @@
                            mpv_node *args);
 
 /**
+ * Signal to all async requests with the matching ID to abort. This affects
+ * the following API calls:
+ *
+ *      mpv_command_async
+ *      mpv_command_node_async
+ *
+ * All of these functions take a reply_userdata parameter. This API function
+ * tells all requests with the matching reply_userdata value to try to return
+ * as soon as possible. If there are multiple requests with matching ID, it
+ * aborts all of them.
+ *
+ * This API function is mostly asynchronous itself. It will not wait until the
+ * command is aborted. Instead, the command will terminate as usual, but with
+ * some work not done. How this is signaled depends on the specific command (for
+ * example, the "subprocess" command will indicate it by "killed_by_us" set to
+ * true in the result). How long it takes also depends on the situation. The
+ * aborting process is completely asynchronous.
+ *
+ * Not all commands may support this functionality. In this case, this function
+ * will have no effect. The same is true if the request using the passed
+ * reply_userdata has already terminated, has not been started yet, or was
+ * never in use at all.
+ *
+ * You have to be careful of race conditions: the time during which the abort
+ * request will be effective is _after_ e.g. mpv_command_async() has returned,
+ * and before the command has signaled completion with MPV_EVENT_COMMAND_REPLY.
+ *
+ * @param reply_userdata ID of the request to be aborted (see above)
+ */
+void mpv_abort_async_command(mpv_handle *ctx, uint64_t reply_userdata);
+
+/**
  * Set a property to a given value. Properties are essentially variables which
  * can be queried or set at runtime. For example, writing to the pause property
  * will actually pause or unpause playback.
@@ -1202,7 +1258,8 @@
      */
     MPV_EVENT_SET_PROPERTY_REPLY = 4,
     /**
-     * Reply to a mpv_command_async() request.
+     * Reply to a mpv_command_async() or mpv_command_node_async() request.
+     * See also mpv_event and mpv_event_command.
      */
     MPV_EVENT_COMMAND_REPLY     = 5,
     /**
@@ -1549,6 +1606,17 @@
     uint64_t id;
 } mpv_event_hook;
 
+// Since API version 1.102.
+typedef struct mpv_event_command {
+    /**
+     * Result data of the command. Note that success/failure is signaled
+     * separately via mpv_event.error. This field is only for result data
+     * in case of success. Most commands leave it at MPV_FORMAT_NONE. Set
+     * to MPV_FORMAT_NONE on failure.
+     */
+    mpv_node result;
+} mpv_event_command;
+
 typedef struct mpv_event {
     /**
      * One of mpv_event. Keep in mind that later ABI compatible releases might
@@ -1575,6 +1643,7 @@
      *  MPV_EVENT_SET_PROPERTY_REPLY
      *  MPV_EVENT_COMMAND_REPLY
      *  MPV_EVENT_PROPERTY_CHANGE
+     *  MPV_EVENT_HOOK
      */
     uint64_t reply_userdata;
     /**
@@ -1584,6 +1653,8 @@
      *  MPV_EVENT_LOG_MESSAGE:            mpv_event_log_message*
      *  MPV_EVENT_CLIENT_MESSAGE:         mpv_event_client_message*
      *  MPV_EVENT_END_FILE:               mpv_event_end_file*
+     *  MPV_EVENT_HOOK:                   mpv_event_hook*
+     *  MPV_EVENT_COMMAND_REPLY*          mpv_event_command*
      *  other: NULL
      *
      * Note: future enhancements might add new event structs for existing or new
diff -ruN mpv-0.29.1/libmpv/mpv.def mpv-master/libmpv/mpv.def
--- mpv-0.29.1/libmpv/mpv.def	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/libmpv/mpv.def	2019-09-19 04:02:03.000000000 +0700
@@ -1,3 +1,4 @@
+mpv_abort_async_command
 mpv_client_api_version
 mpv_client_name
 mpv_command
diff -ruN mpv-0.29.1/libmpv/render.h mpv-master/libmpv/render.h
--- mpv-0.29.1/libmpv/render.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/libmpv/render.h	2019-09-19 04:02:03.000000000 +0700
@@ -277,20 +277,31 @@
      */
     MPV_RENDER_PARAM_SKIP_RENDERING = 13,
     /**
-     * DRM display, contains drm display handles.
-     * Valid for mpv_render_context_create().
+     * Deprecated. Not supported. Use MPV_RENDER_PARAM_DRM_DISPLAY_V2 instead.
      * Type : struct mpv_opengl_drm_params*
      */
     MPV_RENDER_PARAM_DRM_DISPLAY = 14,
     /**
-     * DRM osd size, contains osd dimensions.
+     * DRM draw surface size, contains draw surface dimensions.
      * Valid for mpv_render_context_create().
-     * Type : struct mpv_opengl_drm_osd_size*
+     * Type : struct mpv_opengl_drm_draw_surface_size*
      */
-    MPV_RENDER_PARAM_DRM_OSD_SIZE = 15,
+    MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE = 15,
+    /**
+     * DRM display, contains drm display handles.
+     * Valid for mpv_render_context_create().
+     * Type : struct mpv_opengl_drm_params_v2*
+    */
+    MPV_RENDER_PARAM_DRM_DISPLAY_V2 = 16,
 } mpv_render_param_type;
 
 /**
+ * For backwards compatibility with the old naming of
+ * MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE
+ */
+#define MPV_RENDER_PARAM_DRM_OSD_SIZE MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE
+
+/**
  * Used to pass arbitrary parameters to some mpv_render_* functions. The
  * meaning of the data parameter is determined by the type, and each
  * MPV_RENDER_PARAM_* documents what type the value must point to.
diff -ruN mpv-0.29.1/libmpv/render_gl.h mpv-master/libmpv/render_gl.h
--- mpv-0.29.1/libmpv/render_gl.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/libmpv/render_gl.h	2019-09-19 04:02:03.000000000 +0700
@@ -107,11 +107,13 @@
     /**
      * This retrieves OpenGL function pointers, and will use them in subsequent
      * operation.
-     * Usually, GL context APIs do this for you (e.g. with glXGetProcAddressARB
-     * or wglGetProcAddress), but some APIs do not always return pointers for
-     * all standard functions (even if present); in this case you have to
-     * compensate by looking up these functions yourself and returning them
-     * from this callback.
+     * Usually, you can simply call the GL context APIs from this callback (e.g.
+     * glXGetProcAddressARB or wglGetProcAddress), but some APIs do not always
+     * return pointers for all standard functions (even if present); in this
+     * case you have to compensate by looking up these functions yourself when
+     * libmpv wants to resolve them through this callback.
+     * libmpv will not normally attempt to resolve GL functions on its own, nor
+     * does it link to GL libraries directly.
      */
     void *(*get_proc_address)(void *ctx, const char *name);
     /**
@@ -147,9 +149,33 @@
     int internal_format;
 } mpv_opengl_fbo;
 
+/**
+ * Deprecated. For MPV_RENDER_PARAM_DRM_DISPLAY.
+ */
 typedef struct mpv_opengl_drm_params {
+    int fd;
+    int crtc_id;
+    int connector_id;
+    struct _drmModeAtomicReq **atomic_request_ptr;
+    int render_fd;
+} mpv_opengl_drm_params;
+
+/**
+ * For MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE.
+ */
+typedef struct mpv_opengl_drm_draw_surface_size {
+    /**
+     * size of the draw plane surface in pixels.
+     */
+    int width, height;
+} mpv_opengl_drm_draw_surface_size;
+
+/**
+ * For MPV_RENDER_PARAM_DRM_DISPLAY_V2.
+ */
+typedef struct mpv_opengl_drm_params_v2 {
     /**
-     * DRM fd (int). Set to a negative number if invalid.
+     * DRM fd (int). Set to -1 if invalid.
      */
     int fd;
 
@@ -172,17 +198,16 @@
 
     /**
      * DRM render node. Used for VAAPI interop.
-     * Set to a negative number if invalid.
+     * Set to -1 if invalid.
      */
     int render_fd;
-} mpv_opengl_drm_params;
+} mpv_opengl_drm_params_v2;
 
-typedef struct mpv_opengl_drm_osd_size {
-    /**
-     * size of the OSD in pixels.
-     */
-    int width, height;
-} mpv_opengl_drm_osd_size;
+
+/**
+ * For backwards compatibility with the old naming of mpv_opengl_drm_draw_surface_size
+ */
+#define mpv_opengl_drm_osd_size mpv_opengl_drm_draw_surface_size
 
 #ifdef __cplusplus
 }
diff -ruN mpv-0.29.1/libmpv/stream_cb.h mpv-master/libmpv/stream_cb.h
--- mpv-0.29.1/libmpv/stream_cb.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/libmpv/stream_cb.h	2019-09-19 04:02:03.000000000 +0700
@@ -112,7 +112,7 @@
  * is used to test whether the stream is seekable (since seekability might
  * depend on the URI contents, not just the protocol). Return
  * MPV_ERROR_UNSUPPORTED if seeking is not implemented for this stream. This
- * seek also servies to establish the fact that streams start at position 0.
+ * seek also serves to establish the fact that streams start at position 0.
  *
  * This callback can be NULL, in which it behaves as if always returning
  * MPV_ERROR_UNSUPPORTED.
diff -ruN mpv-0.29.1/misc/json.c mpv-master/misc/json.c
--- mpv-0.29.1/misc/json.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/misc/json.c	2019-09-19 04:02:03.000000000 +0700
@@ -22,9 +22,14 @@
  * doesn't verify what's passed to strtod(), and also prefers parsing numbers
  * as integers with stroll() if possible).
  *
- * Does not support extensions like unquoted string literals.
+ * It has some non-standard extensions which shouldn't conflict with JSON:
+ *  - a list or object item can have a trailing ","
+ *  - object syntax accepts "=" in addition of ":"
+ *  - object keys can be unquoted, if they start with a character in [A-Za-z_]
+ *    and contain only characters in [A-Za-z0-9_]
+ *  - byte escapes with "\xAB" are allowed (with AB being a 2 digit hex number)
  *
- * Also see: http://tools.ietf.org/html/rfc4627
+ * Also see: http://tools.ietf.org/html/rfc8259
  *
  * JSON writer:
  *
@@ -34,9 +39,6 @@
  * to deal with somehow: either by using byte-strings for JSON, or by running
  * a "fixup" pass on the input data. The latter could for example change
  * invalid UTF-8 sequences to replacement characters.
- *
- * Currently, will insert \u literals for characters 0-31, '"', '\', and write
- * everything else literally.
  */
 
 #include <stdlib.h>
@@ -48,6 +50,7 @@
 
 #include "common/common.h"
 #include "misc/bstr.h"
+#include "misc/ctype.h"
 
 #include "json.h"
 
@@ -75,6 +78,24 @@
     eat_ws(src);
 }
 
+static int read_id(void *ta_parent, struct mpv_node *dst, char **src)
+{
+    char *start = *src;
+    if (!mp_isalpha(**src) && **src != '_')
+        return -1;
+    while (mp_isalnum(**src) || **src == '_')
+        *src += 1;
+    if (**src == ' ') {
+        **src = '\0'; // we're allowed to mutate it => can avoid the strndup
+        *src += 1;
+    } else {
+        start = talloc_strndup(ta_parent, start, *src - start);
+    }
+    dst->format = MPV_FORMAT_STRING;
+    dst->u.string = start;
+    return 0;
+}
+
 static int read_str(void *ta_parent, struct mpv_node *dst, char **src)
 {
     if (!eat_c(src, '"'))
@@ -125,12 +146,18 @@
         if (list->num > 0 && !eat_c(src, ','))
             return -1; // missing ','
         eat_ws(src);
+        // non-standard extension: allow a trailing ","
+        if (eat_c(src, term))
+            break;
         if (is_obj) {
             struct mpv_node keynode;
-            if (read_str(list, &keynode, src) < 0)
+            // non-standard extension: allow unquoted strings as keys
+            if (read_id(list, &keynode, src) < 0 &&
+                read_str(list, &keynode, src) < 0)
                 return -1; // key is not a string
             eat_ws(src);
-            if (!eat_c(src, ':'))
+            // non-standard extension: allow "=" instead of ":"
+            if (!eat_c(src, ':') && !eat_c(src, '='))
                 return -1; // ':' missing
             eat_ws(src);
             MP_TARRAY_GROW(list, list->keys, list->num);
@@ -218,6 +245,14 @@
 
 #define APPEND(b, s) bstr_xappend(NULL, (b), bstr0(s))
 
+static const char special_escape[] = {
+    ['\b'] = 'b',
+    ['\f'] = 'f',
+    ['\n'] = 'n',
+    ['\r'] = 'r',
+    ['\t'] = 't',
+};
+
 static void write_json_str(bstr *b, unsigned char *str)
 {
     APPEND(b, "\"");
@@ -228,7 +263,15 @@
         if (!cur[0])
             break;
         bstr_xappend(NULL, b, (bstr){str, cur - str});
-        bstr_xappend_asprintf(NULL, b, "\\u%04x", (unsigned char)cur[0]);
+        if (cur[0] == '\"') {
+            bstr_xappend(NULL, b, (bstr){"\\\"", 2});
+        } else if (cur[0] == '\\') {
+            bstr_xappend(NULL, b, (bstr){"\\\\", 2});
+        } else if (cur[0] < sizeof(special_escape) && special_escape[cur[0]]) {
+            bstr_xappend_asprintf(NULL, b, "\\%c", special_escape[cur[0]]);
+        } else {
+            bstr_xappend_asprintf(NULL, b, "\\u%04x", (unsigned char)cur[0]);
+        }
         str = cur + 1;
     }
     APPEND(b, str);
diff -ruN mpv-0.29.1/misc/linked_list.h mpv-master/misc/linked_list.h
--- mpv-0.29.1/misc/linked_list.h	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/misc/linked_list.h	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,107 @@
+#pragma once
+
+#include <stddef.h>
+
+/*
+ * Doubly linked list macros. All of these require that each list item is a
+ * struct, that contains a field, that is another struct with prev/next fields:
+ *
+ *  struct example_item {
+ *      struct {
+ *          struct example_item *prev, *next;
+ *      } mylist;
+ *  };
+ *
+ * And a struct somewhere that represents the "list" and has head/tail fields:
+ *
+ *  struct {
+ *      struct example_item *head, *tail;
+ *  } mylist_var;
+ *
+ * Then you can e.g. insert elements like this:
+ *
+ *  struct example_item item;
+ *  LL_APPEND(mylist, &mylist_var, &item);
+ *
+ * The first macro argument is always the name if the field in the item that
+ * contains the prev/next pointers, in this case struct example_item.mylist.
+ * This was done so that a single item can be in multiple lists.
+ *
+ * The list is started/terminated with NULL. Nothing ever points _to_ the
+ * list head, so the list head memory location can be safely moved.
+ *
+ * General rules are:
+ *  - list head is initialized by setting head/tail to NULL
+ *  - list items do not need to be initialized before inserting them
+ *  - next/prev fields of list items are not cleared when they are removed
+ *  - there's no way to know whether an item is in the list or not (unless
+ *    you clear prev/next on init/removal, _and_ check whether items with
+ *    prev/next==NULL are referenced by head/tail)
+ */
+
+// Insert item at the end of the list (list->tail == item).
+// Undefined behavior if item is already in the list.
+#define LL_APPEND(field, list, item)  do {                              \
+    (item)->field.prev = (list)->tail;                                  \
+    (item)->field.next = NULL;                                          \
+    LL_RELINK_(field, list, item)                                       \
+} while (0)
+
+// Insert item enew after eprev (i.e. eprev->next == enew). If eprev is NULL,
+// then insert it as head (list->head == enew).
+// Undefined behavior if enew is already in the list, or eprev isn't.
+#define LL_INSERT_AFTER(field, list, eprev, enew) do {                  \
+    (enew)->field.prev = (eprev);                                       \
+    (enew)->field.next = (eprev) ? (eprev)->field.next : (list)->head;  \
+    LL_RELINK_(field, list, enew)                                       \
+} while (0)
+
+// Insert item at the start of the list (list->head == item).
+// Undefined behavior if item is already in the list.
+#define LL_PREPEND(field, list, item)  do {                             \
+    (item)->field.prev = NULL;                                          \
+    (item)->field.next = (list)->head;                                  \
+    LL_RELINK_(field, list, item)                                       \
+} while (0)
+
+// Insert item enew before enext (i.e. enew->next == enext). If enext is NULL,
+// then insert it as tail (list->tail == enew).
+// Undefined behavior if enew is already in the list, or enext isn't.
+#define LL_INSERT_BEFORE(field, list, enext, enew) do {                 \
+    (enew)->field.prev = (enext) ? (enext)->field.prev : (list)->tail;  \
+    (enew)->field.next = (enext);                                       \
+    LL_RELINK_(field, list, enew)                                       \
+} while (0)
+
+// Remove the item from the list.
+// Undefined behavior if item is not in the list.
+#define LL_REMOVE(field, list, item) do {                               \
+    if ((item)->field.prev) {                                           \
+        (item)->field.prev->field.next = (item)->field.next;            \
+    } else {                                                            \
+        (list)->head = (item)->field.next;                              \
+    }                                                                   \
+    if ((item)->field.next) {                                           \
+        (item)->field.next->field.prev = (item)->field.prev;            \
+    } else {                                                            \
+        (list)->tail = (item)->field.prev;                              \
+    }                                                                   \
+} while (0)
+
+// Remove all items from the list.
+#define LL_CLEAR(field, list) do {                                      \
+    (list)->head = (list)->tail = NULL;                                 \
+} while (0)
+
+// Internal helper.
+#define LL_RELINK_(field, list, item)                                   \
+    if ((item)->field.prev) {                                           \
+        (item)->field.prev->field.next = (item);                        \
+    } else {                                                            \
+        (list)->head = (item);                                          \
+    }                                                                   \
+    if ((item)->field.next) {                                           \
+        (item)->field.next->field.prev = (item);                        \
+    } else {                                                            \
+        (list)->tail = (item);                                          \
+    }
diff -ruN mpv-0.29.1/misc/node.c mpv-master/misc/node.c
--- mpv-0.29.1/misc/node.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/misc/node.c	2019-09-19 04:02:03.000000000 +0700
@@ -81,3 +81,68 @@
 {
     node_map_add(dst, key, MPV_FORMAT_FLAG)->u.flag = v;
 }
+
+mpv_node *node_map_get(mpv_node *src, const char *key)
+{
+    if (src->format != MPV_FORMAT_NODE_MAP)
+        return NULL;
+
+    for (int i = 0; i < src->u.list->num; i++) {
+        if (strcmp(key, src->u.list->keys[i]) == 0)
+            return &src->u.list->values[i];
+    }
+
+    return NULL;
+}
+
+// Note: for MPV_FORMAT_NODE_MAP, this (incorrectly) takes the order into
+//       account, instead of treating it as set.
+bool equal_mpv_value(const void *a, const void *b, mpv_format format)
+{
+    switch (format) {
+    case MPV_FORMAT_NONE:
+        return true;
+    case MPV_FORMAT_STRING:
+    case MPV_FORMAT_OSD_STRING:
+        return strcmp(*(char **)a, *(char **)b) == 0;
+    case MPV_FORMAT_FLAG:
+        return *(int *)a == *(int *)b;
+    case MPV_FORMAT_INT64:
+        return *(int64_t *)a == *(int64_t *)b;
+    case MPV_FORMAT_DOUBLE:
+        return *(double *)a == *(double *)b;
+    case MPV_FORMAT_NODE:
+        return equal_mpv_node(a, b);
+    case MPV_FORMAT_BYTE_ARRAY: {
+        const struct mpv_byte_array *a_r = a, *b_r = b;
+        if (a_r->size != b_r->size)
+            return false;
+        return memcmp(a_r->data, b_r->data, a_r->size) == 0;
+    }
+    case MPV_FORMAT_NODE_ARRAY:
+    case MPV_FORMAT_NODE_MAP:
+    {
+        mpv_node_list *l_a = *(mpv_node_list **)a, *l_b = *(mpv_node_list **)b;
+        if (l_a->num != l_b->num)
+            return false;
+        for (int n = 0; n < l_a->num; n++) {
+            if (format == MPV_FORMAT_NODE_MAP) {
+                if (strcmp(l_a->keys[n], l_b->keys[n]) != 0)
+                    return false;
+            }
+            if (!equal_mpv_node(&l_a->values[n], &l_b->values[n]))
+                return false;
+        }
+        return true;
+    }
+    }
+    abort(); // supposed to be able to handle all defined types
+}
+
+// Remarks see equal_mpv_value().
+bool equal_mpv_node(const struct mpv_node *a, const struct mpv_node *b)
+{
+    if (a->format != b->format)
+        return false;
+    return equal_mpv_value(&a->u, &b->u, a->format);
+}
diff -ruN mpv-0.29.1/misc/node.h mpv-master/misc/node.h
--- mpv-0.29.1/misc/node.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/misc/node.h	2019-09-19 04:02:03.000000000 +0700
@@ -10,5 +10,8 @@
 void node_map_add_int64(struct mpv_node *dst, const char *key, int64_t v);
 void node_map_add_double(struct mpv_node *dst, const char *key, double v);
 void node_map_add_flag(struct mpv_node *dst, const char *key, bool v);
+mpv_node *node_map_get(mpv_node *src, const char *key);
+bool equal_mpv_value(const void *a, const void *b, mpv_format format);
+bool equal_mpv_node(const struct mpv_node *a, const struct mpv_node *b);
 
 #endif
diff -ruN mpv-0.29.1/misc/rendezvous.c mpv-master/misc/rendezvous.c
--- mpv-0.29.1/misc/rendezvous.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/misc/rendezvous.c	2019-09-19 04:02:03.000000000 +0700
@@ -16,7 +16,7 @@
 /* A barrier for 2 threads, which can exchange a value when they meet.
  * The first thread to call this function will block. As soon as two threads
  * are calling this function with the same tag value, they will unblock, and
- * on each thread the call return the value parameter of the _other_ thread.
+ * on each thread the call returns the value parameter of the _other_ thread.
  *
  * tag is an arbitrary value, but it must be an unique pointer. If there are
  * more than 2 threads using the same tag, things won't work. Typically, it
diff -ruN mpv-0.29.1/misc/thread_pool.c mpv-master/misc/thread_pool.c
--- mpv-0.29.1/misc/thread_pool.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/misc/thread_pool.c	2019-09-19 04:02:03.000000000 +0700
@@ -1,40 +1,51 @@
-/*
- * This file is part of mpv.
+/* Copyright (C) 2018 the mpv developers
  *
- * mpv is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
  *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
 #include <pthread.h>
 
 #include "common/common.h"
+#include "osdep/threads.h"
+#include "osdep/timer.h"
 
 #include "thread_pool.h"
 
+// Threads destroy themselves after this many seconds, if there's no new work
+// and the thread count is above the configured minimum.
+#define DESTROY_TIMEOUT 10
+
 struct work {
     void (*fn)(void *ctx);
     void *fn_ctx;
 };
 
 struct mp_thread_pool {
-    pthread_t *threads;
-    int num_threads;
+    int min_threads, max_threads;
 
     pthread_mutex_t lock;
     pthread_cond_t wakeup;
 
     // --- the following fields are protected by lock
+
+    pthread_t *threads;
+    int num_threads;
+
+    // Number of threads which have taken up work and are still processing it.
+    int busy_threads;
+
     bool terminate;
+
     struct work *work;
     int num_work;
 };
@@ -43,25 +54,61 @@
 {
     struct mp_thread_pool *pool = arg;
 
+    mpthread_set_name("worker");
+
     pthread_mutex_lock(&pool->lock);
-    while (1) {
-        while (!pool->num_work && !pool->terminate)
-            pthread_cond_wait(&pool->wakeup, &pool->lock);
 
-        if (!pool->num_work && pool->terminate)
-            break;
+    struct timespec ts = {0};
+    bool got_timeout = false;
+    while (1) {
+        struct work work = {0};
+        if (pool->num_work > 0) {
+            work = pool->work[pool->num_work - 1];
+            pool->num_work -= 1;
+        }
 
-        assert(pool->num_work > 0);
-        struct work work = pool->work[pool->num_work - 1];
-        pool->num_work -= 1;
+        if (!work.fn) {
+            if (got_timeout || pool->terminate)
+                break;
+
+            if (pool->num_threads > pool->min_threads) {
+                if (!ts.tv_sec && !ts.tv_nsec)
+                    ts = mp_rel_time_to_timespec(DESTROY_TIMEOUT);
+                if (pthread_cond_timedwait(&pool->wakeup, &pool->lock, &ts))
+                    got_timeout = pool->num_threads > pool->min_threads;
+            } else {
+                pthread_cond_wait(&pool->wakeup, &pool->lock);
+            }
+            continue;
+        }
 
+        pool->busy_threads += 1;
         pthread_mutex_unlock(&pool->lock);
+
         work.fn(work.fn_ctx);
+
         pthread_mutex_lock(&pool->lock);
+        pool->busy_threads -= 1;
+
+        ts = (struct timespec){0};
+        got_timeout = false;
+    }
+
+    // If no termination signal was given, it must mean we died because of a
+    // timeout, and nobody is waiting for us. We have to remove ourselves.
+    if (!pool->terminate) {
+        for (int n = 0; n < pool->num_threads; n++) {
+            if (pthread_equal(pool->threads[n], pthread_self())) {
+                pthread_detach(pthread_self());
+                MP_TARRAY_REMOVE_AT(pool->threads, pool->num_threads, n);
+                pthread_mutex_unlock(&pool->lock);
+                return NULL;
+            }
+        }
+        assert(0);
     }
-    assert(pool->num_work == 0);
-    pthread_mutex_unlock(&pool->lock);
 
+    pthread_mutex_unlock(&pool->lock);
     return NULL;
 }
 
@@ -69,27 +116,46 @@
 {
     struct mp_thread_pool *pool = ctx;
 
+
     pthread_mutex_lock(&pool->lock);
+
     pool->terminate = true;
     pthread_cond_broadcast(&pool->wakeup);
+
+    pthread_t *threads = pool->threads;
+    int num_threads = pool->num_threads;
+
+    pool->threads = NULL;
+    pool->num_threads = 0;
+
     pthread_mutex_unlock(&pool->lock);
 
-    for (int n = 0; n < pool->num_threads; n++)
-        pthread_join(pool->threads[n], NULL);
+    for (int n = 0; n < num_threads; n++)
+        pthread_join(threads[n], NULL);
 
     assert(pool->num_work == 0);
+    assert(pool->num_threads == 0);
     pthread_cond_destroy(&pool->wakeup);
     pthread_mutex_destroy(&pool->lock);
 }
 
-// Create a thread pool with the given number of worker threads. This can return
-// NULL if the worker threads could not be created. The thread pool can be
-// destroyed with talloc_free(pool), or indirectly with talloc_free(ta_parent).
-// If there are still work items on freeing, it will block until all work items
-// are done, and the threads terminate.
-struct mp_thread_pool *mp_thread_pool_create(void *ta_parent, int threads)
+static bool add_thread(struct mp_thread_pool *pool)
 {
-    assert(threads > 0);
+    pthread_t thread;
+
+    if (pthread_create(&thread, NULL, worker_thread, pool) != 0)
+        return false;
+
+    MP_TARRAY_APPEND(pool, pool->threads, pool->num_threads, thread);
+    return true;
+}
+
+struct mp_thread_pool *mp_thread_pool_create(void *ta_parent, int init_threads,
+                                             int min_threads, int max_threads)
+{
+    assert(min_threads >= 0);
+    assert(init_threads <= min_threads);
+    assert(max_threads > 0 && max_threads >= min_threads);
 
     struct mp_thread_pool *pool = talloc_zero(ta_parent, struct mp_thread_pool);
     talloc_set_destructor(pool, thread_pool_dtor);
@@ -97,29 +163,61 @@
     pthread_mutex_init(&pool->lock, NULL);
     pthread_cond_init(&pool->wakeup, NULL);
 
-    for (int n = 0; n < threads; n++) {
-        pthread_t thread;
-        if (pthread_create(&thread, NULL, worker_thread, pool)) {
-            talloc_free(pool);
-            return NULL;
-        }
-        MP_TARRAY_APPEND(pool, pool->threads, pool->num_threads, thread);
-    }
+    pool->min_threads = min_threads;
+    pool->max_threads = max_threads;
+
+    pthread_mutex_lock(&pool->lock);
+    for (int n = 0; n < init_threads; n++)
+        add_thread(pool);
+    bool ok = pool->num_threads >= init_threads;
+    pthread_mutex_unlock(&pool->lock);
+
+    if (!ok)
+        TA_FREEP(&pool);
 
     return pool;
 }
 
-// Queue a function to be run on a worker thread: fn(fn_ctx)
-// If no worker thread is currently available, it's appended to a list in memory
-// with unbounded size. This function always returns immediately.
-// Concurrent queue calls are allowed, as long as it does not overlap with
-// pool destruction.
-void mp_thread_pool_queue(struct mp_thread_pool *pool, void (*fn)(void *ctx),
-                          void *fn_ctx)
+static bool thread_pool_add(struct mp_thread_pool *pool, void (*fn)(void *ctx),
+                            void *fn_ctx, bool allow_queue)
 {
+    bool ok = true;
+
+    assert(fn);
+
     pthread_mutex_lock(&pool->lock);
     struct work work = {fn, fn_ctx};
-    MP_TARRAY_INSERT_AT(pool, pool->work, pool->num_work, 0, work);
-    pthread_cond_signal(&pool->wakeup);
+
+    // If there are not enough threads to process all at once, but we can
+    // create a new thread, then do so. If work is queued quickly, it can
+    // happen that not all available threads have picked up work yet (up to
+    // num_threads - busy_threads threads), which has to be accounted for.
+    if (pool->busy_threads + pool->num_work + 1 > pool->num_threads &&
+        pool->num_threads < pool->max_threads)
+    {
+        if (!add_thread(pool)) {
+            // If we can queue it, it'll get done as long as there is 1 thread.
+            ok = allow_queue && pool->num_threads > 0;
+        }
+    }
+
+    if (ok) {
+        MP_TARRAY_INSERT_AT(pool, pool->work, pool->num_work, 0, work);
+        pthread_cond_signal(&pool->wakeup);
+    }
+
     pthread_mutex_unlock(&pool->lock);
+    return ok;
+}
+
+bool mp_thread_pool_queue(struct mp_thread_pool *pool, void (*fn)(void *ctx),
+                          void *fn_ctx)
+{
+    return thread_pool_add(pool, fn, fn_ctx, true);
+}
+
+bool mp_thread_pool_run(struct mp_thread_pool *pool, void (*fn)(void *ctx),
+                        void *fn_ctx)
+{
+    return thread_pool_add(pool, fn, fn_ctx, false);
 }
diff -ruN mpv-0.29.1/misc/thread_pool.h mpv-master/misc/thread_pool.h
--- mpv-0.29.1/misc/thread_pool.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/misc/thread_pool.h	2019-09-19 04:02:03.000000000 +0700
@@ -3,8 +3,32 @@
 
 struct mp_thread_pool;
 
-struct mp_thread_pool *mp_thread_pool_create(void *ta_parent, int threads);
-void mp_thread_pool_queue(struct mp_thread_pool *pool, void (*fn)(void *ctx),
+// Create a thread pool with the given number of worker threads. This can return
+// NULL if the worker threads could not be created. The thread pool can be
+// destroyed with talloc_free(pool), or indirectly with talloc_free(ta_parent).
+// If there are still work items on freeing, it will block until all work items
+// are done, and the threads terminate.
+// init_threads is the number of threads created in this function (and it fails
+// if it could not be done). min_threads must be >=, if it's >, then the
+// remaining threads will be created on demand, but never destroyed.
+// If init_threads > 0, then mp_thread_pool_queue() can never fail.
+// If init_threads == 0, mp_thread_pool_create() itself can never fail.
+struct mp_thread_pool *mp_thread_pool_create(void *ta_parent, int init_threads,
+                                             int min_threads, int max_threads);
+
+// Queue a function to be run on a worker thread: fn(fn_ctx)
+// If no worker thread is currently available, it's appended to a list in memory
+// with unbounded size. This function always returns immediately.
+// Concurrent queue calls are allowed, as long as it does not overlap with
+// pool destruction.
+// This function is explicitly thread-safe.
+// Cannot fail if thread pool was created with at least 1 thread.
+bool mp_thread_pool_queue(struct mp_thread_pool *pool, void (*fn)(void *ctx),
                           void *fn_ctx);
 
+// Like mp_thread_pool_queue(), but only queue the item and succeed if a thread
+// can be reserved for the item (i.e. minimal wait time instead of unbounded).
+bool mp_thread_pool_run(struct mp_thread_pool *pool, void (*fn)(void *ctx),
+                        void *fn_ctx);
+
 #endif
diff -ruN mpv-0.29.1/misc/thread_tools.c mpv-master/misc/thread_tools.c
--- mpv-0.29.1/misc/thread_tools.c	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/misc/thread_tools.c	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,269 @@
+/* Copyright (C) 2018 the mpv developers
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <assert.h>
+#include <string.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <errno.h>
+
+#ifdef __MINGW32__
+#include <windows.h>
+#else
+#include <poll.h>
+#endif
+
+#include "common/common.h"
+#include "misc/linked_list.h"
+#include "osdep/atomic.h"
+#include "osdep/io.h"
+#include "osdep/timer.h"
+
+#include "thread_tools.h"
+
+uintptr_t mp_waiter_wait(struct mp_waiter *waiter)
+{
+    pthread_mutex_lock(&waiter->lock);
+    while (!waiter->done)
+        pthread_cond_wait(&waiter->wakeup, &waiter->lock);
+    pthread_mutex_unlock(&waiter->lock);
+
+    uintptr_t ret = waiter->value;
+
+    // We document that after mp_waiter_wait() the waiter object becomes
+    // invalid. (It strictly returns only after mp_waiter_wakeup() has returned,
+    // and the object is "single-shot".) So destroy it here.
+
+    // Normally, we expect that the system uses futexes, in which case the
+    // following functions will do nearly nothing. This is true for Windows
+    // and Linux. But some lesser OSes still might allocate kernel objects
+    // when initializing mutexes, so destroy them here.
+    pthread_mutex_destroy(&waiter->lock);
+    pthread_cond_destroy(&waiter->wakeup);
+
+    memset(waiter, 0xCA, sizeof(*waiter)); // for debugging
+
+    return ret;
+}
+
+void mp_waiter_wakeup(struct mp_waiter *waiter, uintptr_t value)
+{
+    pthread_mutex_lock(&waiter->lock);
+    assert(!waiter->done);
+    waiter->done = true;
+    waiter->value = value;
+    pthread_cond_signal(&waiter->wakeup);
+    pthread_mutex_unlock(&waiter->lock);
+}
+
+bool mp_waiter_poll(struct mp_waiter *waiter)
+{
+    pthread_mutex_lock(&waiter->lock);
+    bool r = waiter->done;
+    pthread_mutex_unlock(&waiter->lock);
+    return r;
+}
+
+struct mp_cancel {
+    pthread_mutex_t lock;
+    pthread_cond_t wakeup;
+
+    // Semaphore state and "mirrors".
+    atomic_bool triggered;
+    void (*cb)(void *ctx);
+    void *cb_ctx;
+    int wakeup_pipe[2];
+    void *win32_event; // actually HANDLE
+
+    // Slave list. These are automatically notified as well.
+    struct {
+        struct mp_cancel *head, *tail;
+    } slaves;
+
+    // For slaves. Synchronization is managed by parent.lock!
+    struct mp_cancel *parent;
+    struct {
+        struct mp_cancel *next, *prev;
+    } siblings;
+};
+
+static void cancel_destroy(void *p)
+{
+    struct mp_cancel *c = p;
+
+    assert(!c->slaves.head); // API user error
+
+    mp_cancel_set_parent(c, NULL);
+
+    if (c->wakeup_pipe[0] >= 0) {
+        close(c->wakeup_pipe[0]);
+        close(c->wakeup_pipe[1]);
+    }
+
+#ifdef __MINGW32__
+    if (c->win32_event)
+        CloseHandle(c->win32_event);
+#endif
+
+    pthread_mutex_destroy(&c->lock);
+    pthread_cond_destroy(&c->wakeup);
+}
+
+struct mp_cancel *mp_cancel_new(void *talloc_ctx)
+{
+    struct mp_cancel *c = talloc_ptrtype(talloc_ctx, c);
+    talloc_set_destructor(c, cancel_destroy);
+    *c = (struct mp_cancel){
+        .triggered = ATOMIC_VAR_INIT(false),
+        .wakeup_pipe = {-1, -1},
+    };
+    pthread_mutex_init(&c->lock, NULL);
+    pthread_cond_init(&c->wakeup, NULL);
+    return c;
+}
+
+static void trigger_locked(struct mp_cancel *c)
+{
+    atomic_store(&c->triggered, true);
+
+    pthread_cond_broadcast(&c->wakeup); // condition bound to c->triggered
+
+    if (c->cb)
+        c->cb(c->cb_ctx);
+
+    for (struct mp_cancel *sub = c->slaves.head; sub; sub = sub->siblings.next)
+        mp_cancel_trigger(sub);
+
+    if (c->wakeup_pipe[1] >= 0)
+        (void)write(c->wakeup_pipe[1], &(char){0}, 1);
+
+#ifdef __MINGW32__
+    if (c->win32_event)
+        SetEvent(c->win32_event);
+#endif
+}
+
+void mp_cancel_trigger(struct mp_cancel *c)
+{
+    pthread_mutex_lock(&c->lock);
+    trigger_locked(c);
+    pthread_mutex_unlock(&c->lock);
+}
+
+void mp_cancel_reset(struct mp_cancel *c)
+{
+    pthread_mutex_lock(&c->lock);
+
+    atomic_store(&c->triggered, false);
+
+    if (c->wakeup_pipe[0] >= 0) {
+        // Flush it fully.
+        while (1) {
+            int r = read(c->wakeup_pipe[0], &(char[256]){0}, 256);
+            if (r <= 0 && !(r < 0 && errno == EINTR))
+                break;
+        }
+    }
+
+#ifdef __MINGW32__
+    if (c->win32_event)
+        ResetEvent(c->win32_event);
+#endif
+
+    pthread_mutex_unlock(&c->lock);
+}
+
+bool mp_cancel_test(struct mp_cancel *c)
+{
+    return c ? atomic_load_explicit(&c->triggered, memory_order_relaxed) : false;
+}
+
+bool mp_cancel_wait(struct mp_cancel *c, double timeout)
+{
+    struct timespec ts = mp_rel_time_to_timespec(timeout);
+    pthread_mutex_lock(&c->lock);
+    while (!mp_cancel_test(c)) {
+        if (pthread_cond_timedwait(&c->wakeup, &c->lock, &ts))
+            break;
+    }
+    pthread_mutex_unlock(&c->lock);
+
+    return mp_cancel_test(c);
+}
+
+// If a new notification mechanism was added, and the mp_cancel state was
+// already triggered, make sure the newly added mechanism is also triggered.
+static void retrigger_locked(struct mp_cancel *c)
+{
+    if (mp_cancel_test(c))
+        trigger_locked(c);
+}
+
+void mp_cancel_set_cb(struct mp_cancel *c, void (*cb)(void *ctx), void *ctx)
+{
+    pthread_mutex_lock(&c->lock);
+    c->cb = cb;
+    c->cb_ctx = ctx;
+    retrigger_locked(c);
+    pthread_mutex_unlock(&c->lock);
+}
+
+void mp_cancel_set_parent(struct mp_cancel *slave, struct mp_cancel *parent)
+{
+    // We can access c->parent without synchronization, because:
+    //  - concurrent mp_cancel_set_parent() calls to slave are not allowed
+    //  - slave->parent needs to stay valid as long as the slave exists
+    if (slave->parent == parent)
+        return;
+    if (slave->parent) {
+        pthread_mutex_lock(&slave->parent->lock);
+        LL_REMOVE(siblings, &slave->parent->slaves, slave);
+        pthread_mutex_unlock(&slave->parent->lock);
+    }
+    slave->parent = parent;
+    if (slave->parent) {
+        pthread_mutex_lock(&slave->parent->lock);
+        LL_APPEND(siblings, &slave->parent->slaves, slave);
+        retrigger_locked(slave->parent);
+        pthread_mutex_unlock(&slave->parent->lock);
+    }
+}
+
+int mp_cancel_get_fd(struct mp_cancel *c)
+{
+    pthread_mutex_lock(&c->lock);
+    if (c->wakeup_pipe[0] < 0) {
+        mp_make_wakeup_pipe(c->wakeup_pipe);
+        retrigger_locked(c);
+    }
+    pthread_mutex_unlock(&c->lock);
+
+
+    return c->wakeup_pipe[0];
+}
+
+#ifdef __MINGW32__
+void *mp_cancel_get_event(struct mp_cancel *c)
+{
+    pthread_mutex_lock(&c->lock);
+    if (!c->win32_event) {
+        c->win32_event = CreateEventW(NULL, TRUE, FALSE, NULL);
+        retrigger_locked(c);
+    }
+    pthread_mutex_unlock(&c->lock);
+
+    return c->win32_event;
+}
+#endif
diff -ruN mpv-0.29.1/misc/thread_tools.h mpv-master/misc/thread_tools.h
--- mpv-0.29.1/misc/thread_tools.h	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/misc/thread_tools.h	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,82 @@
+#pragma once
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <pthread.h>
+
+// This is basically a single-shot semaphore, intended as light-weight solution
+// for just making a thread wait for another thread.
+struct mp_waiter {
+    // All fields are considered private. Use MP_WAITER_INITIALIZER to init.
+    pthread_mutex_t lock;
+    pthread_cond_t wakeup;
+    bool done;
+    uintptr_t value;
+};
+
+// Initialize a mp_waiter object for use with mp_waiter_*().
+#define MP_WAITER_INITIALIZER { \
+    .lock = PTHREAD_MUTEX_INITIALIZER, \
+    .wakeup = PTHREAD_COND_INITIALIZER, \
+    }
+
+// Block until some other thread calls mp_waiter_wakeup(). The function returns
+// the value argument of that wakeup call. After this, the waiter object must
+// not be used anymore. Although you can reinit it with MP_WAITER_INITIALIZER
+// (then you must make sure nothing calls mp_waiter_wakeup() before this).
+uintptr_t mp_waiter_wait(struct mp_waiter *waiter);
+
+// Unblock the thread waiting with mp_waiter_wait(), and make it return the
+// provided value. If the other thread did not enter that call yet, it will
+// return immediately once it does (mp_waiter_wakeup() always returns
+// immediately). Calling this more than once is not allowed.
+void mp_waiter_wakeup(struct mp_waiter *waiter, uintptr_t value);
+
+// Query whether the waiter was woken up. If true, mp_waiter_wait() will return
+// immediately. This is useful if you want to use another way to block and
+// wakeup (in parallel to mp_waiter).
+// You still need to call mp_waiter_wait() to free resources.
+bool mp_waiter_poll(struct mp_waiter *waiter);
+
+// Basically a binary semaphore that supports signaling the semaphore value to
+// a bunch of other complicated mechanisms (such as wakeup pipes). It was made
+// for aborting I/O and thus has according naming.
+struct mp_cancel;
+
+struct mp_cancel *mp_cancel_new(void *talloc_ctx);
+
+// Request abort.
+void mp_cancel_trigger(struct mp_cancel *c);
+
+// Return whether the caller should abort.
+// For convenience, c==NULL is allowed.
+bool mp_cancel_test(struct mp_cancel *c);
+
+// Wait until the even is signaled. If the timeout (in seconds) expires, return
+// false. timeout==0 polls, timeout<0 waits forever.
+bool mp_cancel_wait(struct mp_cancel *c, double timeout);
+
+// Restore original state. (Allows reusing a mp_cancel.)
+void mp_cancel_reset(struct mp_cancel *c);
+
+// Add a callback to invoke when mp_cancel gets triggered. If it's already
+// triggered, call it from mp_cancel_add_cb() directly. May be called multiple
+// times even if the trigger state changes; not called if it resets. In all
+// cases, this may be called with internal locks held (either in mp_cancel, or
+// other locks held by whoever calls mp_cancel_trigger()).
+// There is only one callback. Create a slave mp_cancel to get a private one.
+void mp_cancel_set_cb(struct mp_cancel *c, void (*cb)(void *ctx), void *ctx);
+
+// If parent gets triggered, automatically trigger slave. There is only 1
+// parent; setting NULL clears the parent. Freeing slave also automatically
+// ends the parent link, but the parent mp_cancel must remain valid until the
+// slave is manually removed or destroyed. Destroying a mp_cancel that still
+// has slaves is an error.
+void mp_cancel_set_parent(struct mp_cancel *slave, struct mp_cancel *parent);
+
+// win32 "Event" HANDLE that indicates the current mp_cancel state.
+void *mp_cancel_get_event(struct mp_cancel *c);
+
+// The FD becomes readable if mp_cancel_test() would return true.
+// Don't actually read from it, just use it for poll().
+int mp_cancel_get_fd(struct mp_cancel *c);
diff -ruN mpv-0.29.1/options/m_config.c mpv-master/options/m_config.c
--- mpv-0.29.1/options/m_config.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/options/m_config.c	2019-09-19 04:02:03.000000000 +0700
@@ -55,19 +55,42 @@
 
 // For use with m_config_cache.
 struct m_config_shadow {
-    pthread_mutex_t lock;
     struct m_config *root;
-    char *data;
+    pthread_mutex_t lock;
+    // -- protected by lock
+    struct m_config_data *data; // protected shadow copy of the option data
     struct m_config_cache **listeners;
     int num_listeners;
 };
 
 // Represents a sub-struct (OPT_SUBSTRUCT()).
 struct m_config_group {
-    const struct m_sub_options *group; // or NULL for top-level options
-    int parent_group;   // index of parent group in m_config.groups
-    void *opts;         // pointer to group user option struct
-    atomic_llong ts;    // incremented on every write access
+    const struct m_sub_options *group;
+    int group_count;    // 1 + number of all sub groups owned by this (so
+                        // m_config.groups[idx..idx+group_count] is used by the
+                        // entire tree of sub groups included by this group)
+    int parent_group;   // index of parent group into m_config.groups[], or
+                        // -1 for group 0
+    int parent_ptr;     // ptr offset in the parent group's data, or -1 if
+                        // none
+    int co_index;       // index of the first group opt into m_config.opts[]
+    int co_end_index;   // index of the last group opt + 1 (i.e. exclusive)
+};
+
+// A copy of option data. Used for the main option struct, the shadow data,
+// and copies for m_config_cache.
+struct m_config_data {
+    struct m_config *root;          // root config (with up-to-date data)
+    int group_index;                // start index into m_config.groups[]
+    struct m_group_data *gdata;     // user struct allocation (our copy of data)
+    int num_gdata;                  // (group_index+num_gdata = end index)
+    atomic_llong ts;                // last change timestamp we've seen
+};
+
+// Per m_config_data state for each m_config_group.
+struct m_group_data {
+    char *udata;        // pointer to group user option struct
+    long long ts;       // incremented on every write access
 };
 
 struct m_profile {
@@ -86,6 +109,20 @@
     void *backup;
 };
 
+static void add_sub_group(struct m_config *config, const char *name_prefix,
+                          int parent_group_index, int parent_ptr,
+                          const struct m_sub_options *subopts);
+
+static struct m_group_data *m_config_gdata(struct m_config_data *data,
+                                           int group_index)
+{
+    if (group_index < data->group_index ||
+        group_index >= data->group_index + data->num_gdata)
+        return NULL;
+
+    return &data->gdata[group_index - data->group_index];
+}
+
 static int show_profile(struct m_config *config, bstr param)
 {
     struct m_profile *p;
@@ -140,30 +177,129 @@
     memcpy(ptr, &src, sizeof(src));
 }
 
-static void add_options(struct m_config *config,
-                        struct m_config_option *parent,
-                        void *optstruct,
-                        const void *optstruct_def,
-                        const struct m_option *defs);
+// Initialize a field with a given value. In case this is dynamic data, it has
+// to be allocated and copied. src can alias dst.
+static void init_opt_inplace(const struct m_option *opt, void *dst,
+                             const void *src)
+{
+    // The option will use dynamic memory allocation iff it has a free callback.
+    if (opt->type->free) {
+        union m_option_value temp;
+        memcpy(&temp, src, opt->type->size);
+        memset(dst, 0, opt->type->size);
+        m_option_copy(opt, dst, &temp);
+    } else if (src != dst) {
+        memcpy(dst, src, opt->type->size);
+    }
+}
 
-static void config_destroy(void *p)
+static void alloc_group(struct m_config_data *data, int group_index,
+                        struct m_config_data *copy)
 {
-    struct m_config *config = p;
-    m_config_restore_backups(config);
-    for (int n = 0; n < config->num_opts; n++) {
-        struct m_config_option *co = &config->opts[n];
+    assert(group_index == data->group_index + data->num_gdata);
+    assert(group_index < data->root->num_groups);
+    struct m_config_group *group = &data->root->groups[group_index];
+    const struct m_sub_options *opts = group->group;
+
+    MP_TARRAY_GROW(data, data->gdata, data->num_gdata);
+    struct m_group_data *gdata = &data->gdata[data->num_gdata++];
+
+    struct m_group_data *copy_gdata =
+        copy ? m_config_gdata(copy, group_index) : NULL;
+
+    *gdata = (struct m_group_data){
+        .udata = talloc_zero_size(data, opts->size),
+        .ts = copy_gdata ? copy_gdata->ts : 0,
+    };
+
+    if (opts->defaults)
+        memcpy(gdata->udata, opts->defaults, opts->size);
+
+    char *copy_src = copy_gdata ? copy_gdata->udata : NULL;
+
+    for (int n = group->co_index; n < group->co_end_index; n++) {
+        assert(n >= 0 && n < data->root->num_opts);
+        struct m_config_option *co = &data->root->opts[n];
+
+        if (co->opt->offset < 0 || co->opt->type->size == 0)
+            continue;
+
+        void *dst = gdata->udata + co->opt->offset;
+        const void *defptr = co->opt->defval ? co->opt->defval : dst;
+        if (copy_src)
+            defptr = copy_src + co->opt->offset;
+
+        init_opt_inplace(co->opt, dst, defptr);
+    }
+
+    // If there's a parent, update its pointer to the new struct.
+    if (group->parent_group >= data->group_index && group->parent_ptr >= 0) {
+        struct m_group_data *parent_gdata =
+            m_config_gdata(data, group->parent_group);
+        assert(parent_gdata);
+
+        substruct_write_ptr(parent_gdata->udata + group->parent_ptr, gdata->udata);
+    }
+}
+
+static void free_option_data(void *p)
+{
+    struct m_config_data *data = p;
+
+    for (int i = 0; i < data->num_gdata; i++) {
+        struct m_group_data *gdata = &data->gdata[i];
+        struct m_config_group *group = &data->root->groups[data->group_index + i];
 
-        m_option_free(co->opt, co->data);
+        for (int n = group->co_index; n < group->co_end_index; n++) {
+            struct m_config_option *co = &data->root->opts[n];
 
-        if (config->shadow && co->shadow_offset >= 0)
-            m_option_free(co->opt, config->shadow->data + co->shadow_offset);
+            if (co->opt->offset >= 0 && co->opt->type->size > 0)
+                m_option_free(co->opt, gdata->udata + co->opt->offset);
+        }
     }
+}
+
+// Allocate data using the option description in root, starting at group_index
+// (index into m_config.groups[]).
+// If copy is not NULL, copy all data from there (for groups which are in both
+// m_config_data instances), in all other cases init the data with the defaults.
+static struct m_config_data *allocate_option_data(void *ta_parent,
+                                                  struct m_config *root,
+                                                  int group_index,
+                                                  struct m_config_data *copy)
+{
+    assert(group_index >= 0 && group_index < root->num_groups);
+    struct m_config_data *data = talloc_zero(ta_parent, struct m_config_data);
+    talloc_set_destructor(data, free_option_data);
+
+    data->root = root;
+    data->group_index = group_index;
+
+    struct m_config_group *root_group = &root->groups[group_index];
+    assert(root_group->group_count > 0);
+
+    for (int n = group_index; n < group_index + root_group->group_count; n++)
+        alloc_group(data, n, copy);
+
+    if (copy)
+        data->ts = copy->ts;
+
+    return data;
+}
+
+static void config_destroy(void *p)
+{
+    struct m_config *config = p;
+    m_config_restore_backups(config);
 
     if (config->shadow) {
         // must all have been unregistered
         assert(config->shadow->num_listeners == 0);
         pthread_mutex_destroy(&config->shadow->lock);
+        talloc_free(config->shadow);
     }
+
+    talloc_free(config->data);
 }
 
 struct m_config *m_config_new(void *talloc_ctx, struct mp_log *log,
@@ -172,25 +308,29 @@
 {
     struct m_config *config = talloc(talloc_ctx, struct m_config);
     talloc_set_destructor(config, config_destroy);
-    *config = (struct m_config)
-        {.log = log, .size = size, .defaults = defaults, .options = options};
+    *config = (struct m_config){.log = log,};
 
-    // size==0 means a dummy object is created
-    if (size) {
-        config->optstruct = talloc_zero_size(config, size);
-        if (defaults)
-            memcpy(config->optstruct, defaults, size);
-    }
-
-    config->num_groups = 1;
-    MP_TARRAY_GROW(config, config->groups, 1);
-    config->groups[0] = (struct m_config_group){
-        .parent_group = -1,
-        .opts = config->optstruct,
+    struct m_sub_options *subopts = talloc_ptrtype(config, subopts);
+    *subopts = (struct m_sub_options){
+        .opts = options,
+        .size = size,
+        .defaults = defaults,
     };
+    add_sub_group(config, NULL, -1, -1, subopts);
+
+    if (!size)
+        return config;
+
+    config->data = allocate_option_data(config, config, 0, NULL);
+    config->optstruct = config->data->gdata[0].udata;
+
+    for (int n = 0; n < config->num_opts; n++) {
+        struct m_config_option *co = &config->opts[n];
+        struct m_group_data *gdata = m_config_gdata(config->data, co->group_index);
+        if (gdata && co->opt->offset >= 0)
+            co->data = gdata->udata + co->opt->offset;
+    }
 
-    if (options)
-        add_options(config, NULL, config->optstruct, defaults, options);
     return config;
 }
 
@@ -216,14 +356,14 @@
     return m_config_new(talloc_ctx, log, 0, desc->priv_defaults, desc->options);
 }
 
-static struct m_config_group *find_group(struct mpv_global *global,
-                                         const struct m_option *cfg)
+static const struct m_config_group *find_group(struct mpv_global *global,
+                                               const struct m_option *cfg)
 {
     struct m_config_shadow *shadow = global->config;
     struct m_config *root = shadow->root;
 
     for (int n = 0; n < root->num_groups; n++) {
-        if (cfg && root->groups[n].group && root->groups[n].group->opts == cfg)
+        if (root->groups[n].group->opts == cfg)
             return &root->groups[n];
     }
 
@@ -238,7 +378,7 @@
 void *m_config_group_from_desc(void *ta_parent, struct mp_log *log,
         struct mpv_global *global, struct m_obj_desc *desc, const char *name)
 {
-    struct m_config_group *group = find_group(global, desc->options);
+    const struct m_config_group *group = find_group(global, desc->options);
     if (group) {
         return mp_get_config_group(ta_parent, global, group->group);
     } else {
@@ -335,211 +475,109 @@
         ensure_backup(config, &config->opts[n]);
 }
 
-static void m_config_add_option(struct m_config *config,
-                                struct m_config_option *parent,
-                                void *optstruct,
-                                const void *optstruct_def,
-                                const struct m_option *arg);
-
-static void add_options(struct m_config *config,
-                        struct m_config_option *parent,
-                        void *optstruct,
-                        const void *optstruct_def,
-                        const struct m_option *defs)
-{
-    for (int i = 0; defs && defs[i].name; i++)
-        m_config_add_option(config, parent, optstruct, optstruct_def, &defs[i]);
-}
-
-static void add_sub_options(struct m_config *config,
-                            struct m_config_option *parent,
-                            const struct m_sub_options *subopts)
-{
-    // Can't be used multiple times.
-    for (int n = 0; n < config->num_groups; n++)
-        assert(config->groups[n].group != subopts);
-
-    // You can only use UPDATE_ flags here.
-    assert(!(subopts->change_flags & ~(unsigned)UPDATE_OPTS_MASK));
-
-    void *new_optstruct = NULL;
-    if (config->optstruct) { // only if not noalloc
-        new_optstruct = talloc_zero_size(config, subopts->size);
-        if (subopts->defaults)
-            memcpy(new_optstruct, subopts->defaults, subopts->size);
-    }
-    if (parent && parent->data)
-        substruct_write_ptr(parent->data, new_optstruct);
-
-    const void *new_optstruct_def = NULL;
-    if (parent && parent->default_data)
-        new_optstruct_def = substruct_read_ptr(parent->default_data);
-    if (!new_optstruct_def)
-        new_optstruct_def = subopts->defaults;
-
-    int group = config->num_groups++;
-    MP_TARRAY_GROW(config, config->groups, group);
-    config->groups[group] = (struct m_config_group){
-        .group = subopts,
-        .parent_group = parent ? parent->group : 0,
-        .opts = new_optstruct,
-    };
-
-    struct m_config_option next = {
-        .name = "",
-        .group = group,
-    };
-    if (parent && parent->name && parent->name[0])
-        next.name = parent->name;
-    if (subopts->prefix && subopts->prefix[0]) {
-        assert(next.name);
-        next.name = subopts->prefix;
-    }
-    add_options(config, &next, new_optstruct, new_optstruct_def, subopts->opts);
-}
-
-#define MAX_VO_AO 16
-
-struct group_entry {
-    const struct m_obj_list *entry;
-    struct m_sub_options subs[MAX_VO_AO];
-    bool initialized;
-};
-
-static struct group_entry g_groups[2]; // limited by max. m_obj_list overall
-static int g_num_groups = 0;
-static pthread_mutex_t g_group_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-static const struct m_sub_options *get_cached_group(const struct m_obj_list *list,
-                                                    int n, struct m_sub_options *v)
-{
-    pthread_mutex_lock(&g_group_mutex);
-
-    struct group_entry *group = NULL;
-    for (int i = 0; i < g_num_groups; i++) {
-        if (g_groups[i].entry == list) {
-            group = &g_groups[i];
-            break;
-        }
-    }
-    if (!group) {
-        assert(g_num_groups < MP_ARRAY_SIZE(g_groups));
-        group = &g_groups[g_num_groups++];
-        group->entry = list;
-    }
-
-    if (!group->initialized) {
-        if (!v) {
-            n = -1;
-            group->initialized = true;
-        } else {
-            assert(n < MAX_VO_AO); // simply increase this if it fails
-            group->subs[n] = *v;
-        }
-    }
-
-    pthread_mutex_unlock(&g_group_mutex);
-
-    return n >= 0 ? &group->subs[n] : NULL;
-}
-
 static void init_obj_settings_list(struct m_config *config,
+                                   int parent_group_index,
                                    const struct m_obj_list *list)
 {
     struct m_obj_desc desc;
     for (int n = 0; ; n++) {
-        if (!list->get_desc(&desc, n)) {
-            if (list->use_global_options)
-                get_cached_group(list, n, NULL);
+        if (!list->get_desc(&desc, n))
             break;
+        if (desc.global_opts) {
+            add_sub_group(config, NULL, parent_group_index, -1,
+                          desc.global_opts);
         }
-        if (desc.global_opts)
-            add_sub_options(config, NULL, desc.global_opts);
         if (list->use_global_options && desc.options) {
-            struct m_sub_options conf = {
+            struct m_sub_options *conf = talloc_ptrtype(config, conf);
+            *conf = (struct m_sub_options){
                 .prefix = desc.options_prefix,
                 .opts = desc.options,
                 .defaults = desc.priv_defaults,
                 .size = desc.priv_size,
             };
-            add_sub_options(config, NULL, get_cached_group(list, n, &conf));
+            add_sub_group(config, NULL, parent_group_index, -1, conf);
         }
     }
 }
 
-// Initialize a field with a given value. In case this is dynamic data, it has
-// to be allocated and copied. src can alias dst, also can be NULL.
-static void init_opt_inplace(const struct m_option *opt, void *dst,
-                             const void *src)
+static const char *concat_name(void *ta_parent, const char *a, const char *b)
 {
-    union m_option_value temp = {0};
-    if (src)
-        memcpy(&temp, src, opt->type->size);
-    memset(dst, 0, opt->type->size);
-    m_option_copy(opt, dst, &temp);
+    assert(a);
+    assert(b);
+    if (!a[0])
+        return b;
+    if (!b[0])
+        return a;
+    return talloc_asprintf(ta_parent, "%s-%s", a, b);
 }
 
-static void m_config_add_option(struct m_config *config,
-                                struct m_config_option *parent,
-                                void *optstruct,
-                                const void *optstruct_def,
-                                const struct m_option *arg)
+static void add_sub_group(struct m_config *config, const char *name_prefix,
+                          int parent_group_index, int parent_ptr,
+                          const struct m_sub_options *subopts)
 {
-    assert(config != NULL);
-    assert(arg != NULL);
+        // Can't be used multiple times.
+    for (int n = 0; n < config->num_groups; n++)
+        assert(config->groups[n].group != subopts);
 
-    const char *parent_name = parent ? parent->name : "";
+    // You can only use UPDATE_ flags here.
+    assert(!(subopts->change_flags & ~(unsigned)UPDATE_OPTS_MASK));
+
+    assert(parent_group_index >= -1 && parent_group_index < config->num_groups);
 
-    struct m_config_option co = {
-        .opt = arg,
-        .name = arg->name,
-        .shadow_offset = -1,
-        .group = parent ? parent->group : 0,
-        .default_data = &default_value,
-        .is_hidden = !!arg->deprecation_message,
+    int group_index = config->num_groups++;
+    MP_TARRAY_GROW(config, config->groups, group_index);
+    config->groups[group_index] = (struct m_config_group){
+        .group = subopts,
+        .parent_group = parent_group_index,
+        .parent_ptr = parent_ptr,
+        .co_index = config->num_opts,
     };
 
-    if (arg->offset >= 0) {
-        if (optstruct)
-            co.data = (char *)optstruct + arg->offset;
-        if (optstruct_def)
-            co.default_data = (char *)optstruct_def + arg->offset;
-    }
-
-    if (arg->defval)
-        co.default_data = arg->defval;
-
-    // Fill in the full name
-    if (!co.name[0]) {
-        co.name = parent_name;
-    } else if (parent_name[0]) {
-        co.name = talloc_asprintf(config, "%s-%s", parent_name, co.name);
-    }
-
-    if (arg->type == &m_option_type_subconfig) {
-        const struct m_sub_options *subopts = arg->priv;
-        add_sub_options(config, &co, subopts);
-    } else {
-        int size = arg->type->size;
-        if (optstruct && size) {
-            // The required alignment is unknown, so go with the maximum C
-            // could require. Slightly wasteful, but not that much.
-            int align = (size - config->shadow_size % size) % size;
-            int offset = config->shadow_size + align;
-            assert(offset <= INT16_MAX);
-            co.shadow_offset = offset;
-            config->shadow_size = co.shadow_offset + size;
-        }
+    if (subopts->prefix && subopts->prefix[0])
+        name_prefix = subopts->prefix;
+    if (!name_prefix)
+        name_prefix = "";
+
+    for (int i = 0; subopts->opts && subopts->opts[i].name; i++) {
+        const struct m_option *opt = &subopts->opts[i];
 
-        // Initialize options
-        if (co.data && co.default_data)
-            init_opt_inplace(arg, co.data, co.default_data);
+        if (opt->type == &m_option_type_subconfig)
+            continue;
 
+        struct m_config_option co = {
+            .name = concat_name(config, name_prefix, opt->name),
+            .opt = opt,
+            .group_index = group_index,
+            .is_hidden = !!opt->deprecation_message,
+        };
         MP_TARRAY_APPEND(config, config->opts, config->num_opts, co);
+    }
+
+    config->groups[group_index].co_end_index = config->num_opts;
 
-        if (arg->type == &m_option_type_obj_settings_list)
-            init_obj_settings_list(config, (const struct m_obj_list *)arg->priv);
+    // Initialize sub-structs. These have to come after, because co_index and
+    // co_end_index must strictly be for a single struct only.
+    for (int i = 0; subopts->opts && subopts->opts[i].name; i++) {
+        const struct m_option *opt = &subopts->opts[i];
+
+        if (opt->type == &m_option_type_subconfig) {
+            const struct m_sub_options *new_subopts = opt->priv;
+
+            // Providing default structs in-place is not allowed.
+            if (opt->offset >= 0 && subopts->defaults) {
+                void *ptr = (char *)subopts->defaults + opt->offset;
+                assert(!substruct_read_ptr(ptr));
+            }
+
+            const char *prefix = concat_name(config, name_prefix, opt->name);
+            add_sub_group(config, prefix, group_index, opt->offset, new_subopts);
+        } else if (opt->type == &m_option_type_obj_settings_list) {
+            const struct m_obj_list *objlist = opt->priv;
+            init_obj_settings_list(config, group_index, objlist);
+        }
     }
+
+    config->groups[group_index].group_count = config->num_groups - group_index;
 }
 
 struct m_config_option *m_config_get_co_raw(const struct m_config *config,
@@ -627,6 +665,19 @@
     return &config->opts[index];
 }
 
+const void *m_config_get_co_default(const struct m_config *config,
+                                    struct m_config_option *co)
+{
+    if (co->opt->defval)
+        return co->opt->defval;
+
+    const struct m_sub_options *subopt = config->groups[co->group_index].group;
+    if (co->opt->offset >= 0 && subopt->defaults)
+        return (char *)subopt->defaults + co->opt->offset;
+
+    return NULL;
+}
+
 const char *m_config_get_positional_option(const struct m_config *config, int p)
 {
     int pos = 0;
@@ -753,7 +804,6 @@
     return M_OPT_UNKNOWN;
 }
 
-
 // Unlike m_config_set_option_raw() this does not go through the property layer
 // via config.option_set_callback.
 int m_config_set_option_raw_direct(struct m_config *config,
@@ -1033,8 +1083,11 @@
             MP_INFO(config, " (%s to %s)", min, max);
         }
         char *def = NULL;
-        if (co->default_data)
-            def = m_option_pretty_print(opt, co->default_data);
+        const void *defptr = m_config_get_co_default(config, co);
+        if (!defptr)
+            defptr = &default_value;
+        if (defptr)
+            def = m_option_pretty_print(opt, defptr);
         if (def) {
             MP_INFO(config, " (default: %s)", def);
             talloc_free(def);
@@ -1188,36 +1241,16 @@
 
 void m_config_create_shadow(struct m_config *config)
 {
-    assert(config->global && config->options && config->size);
+    assert(config->global);
     assert(!config->shadow && !config->global->config);
 
-    config->shadow = talloc_zero(config, struct m_config_shadow);
-    config->shadow->data = talloc_zero_size(config->shadow, config->shadow_size);
-
+    config->shadow = talloc_zero(NULL, struct m_config_shadow);
+    config->shadow->data =
+        allocate_option_data(config->shadow, config, 0, config->data);
     config->shadow->root = config;
     pthread_mutex_init(&config->shadow->lock, NULL);
 
     config->global->config = config->shadow;
-
-    for (int n = 0; n < config->num_opts; n++) {
-        struct m_config_option *co = &config->opts[n];
-        if (co->shadow_offset < 0)
-            continue;
-        m_option_copy(co->opt, config->shadow->data + co->shadow_offset, co->data);
-    }
-}
-
-// Return whether parent is a parent of group. Also returns true if they're equal.
-static bool is_group_included(struct m_config *config, int group, int parent)
-{
-    for (;;) {
-        if (group == parent)
-            return true;
-        if (group < 0)
-            break;
-        group = config->groups[group].parent_group;
-    }
-    return false;
 }
 
 static void cache_destroy(void *p)
@@ -1236,58 +1269,64 @@
 {
     struct m_config_shadow *shadow = global->config;
     struct m_config *root = shadow->root;
+    int group_index = -1;
+
+    for (int n = 0; n < root->num_groups; n++) {
+        // group==NULL is special cased to root group.
+        if (root->groups[n].group == group || (!group && !n)) {
+            group_index = n;
+            break;
+        }
+    }
+
+    assert(group_index >= 0); // invalid group (or not in option tree)
 
     struct m_config_cache *cache = talloc_zero(ta_parent, struct m_config_cache);
     talloc_set_destructor(cache, cache_destroy);
     cache->shadow = shadow;
-    cache->shadow_config = m_config_new(cache, mp_null_log, root->size,
-                                        root->defaults, root->options);
 
-    struct m_config *config = cache->shadow_config;
+    pthread_mutex_lock(&shadow->lock);
+    cache->data = allocate_option_data(cache, root, group_index, shadow->data);
+    pthread_mutex_unlock(&shadow->lock);
 
-    assert(config->num_opts == root->num_opts);
-    for (int n = 0; n < root->num_opts; n++) {
-        assert(config->opts[n].opt->type == root->opts[n].opt->type);
-        assert(config->opts[n].shadow_offset == root->opts[n].shadow_offset);
-    }
+    cache->opts = cache->data->gdata[0].udata;
 
-    cache->ts = -1;
-    cache->group = -1;
+    return cache;
+}
 
-    for (int n = 0; n < config->num_groups; n++) {
-        if (config->groups[n].group == group) {
-            cache->opts = config->groups[n].opts;
-            cache->group = n;
-            break;
-        }
-    }
+static bool update_options(struct m_config_data *dst, struct m_config_data *src)
+{
+    assert(dst->root == src->root);
 
-    assert(cache->group >= 0);
-    assert(cache->opts);
+    bool res = false;
+    dst->ts = src->ts;
 
-    // If we're not on the top-level, restrict set of options to the sub-group
-    // to reduce update costs. (It would be better not to add them in the first
-    // place.)
-    if (cache->group > 0) {
-        int num_opts = config->num_opts;
-        config->num_opts = 0;
-        for (int n = 0; n < num_opts; n++) {
-            struct m_config_option *co = &config->opts[n];
-            if (is_group_included(config, co->group, cache->group)) {
-                config->opts[config->num_opts++] = *co;
-            } else {
-                m_option_free(co->opt, co->data);
+    // Must be from same root, but they can have arbitrary overlap.
+    int group_s = MPMAX(dst->group_index, src->group_index);
+    int group_e = MPMIN(dst->group_index + dst->num_gdata,
+                        src->group_index + src->num_gdata);
+    assert(group_s >= 0 && group_e <= dst->root->num_groups);
+    for (int n = group_s; n < group_e; n++) {
+        struct m_config_group *g = &dst->root->groups[n];
+        struct m_group_data *gsrc = m_config_gdata(src, n);
+        struct m_group_data *gdst = m_config_gdata(dst, n);
+        assert(gsrc && gdst);
+
+        if (gdst->ts >= gsrc->ts)
+            continue;
+        gdst->ts = gsrc->ts;
+        res = true;
+
+        for (int i = g->co_index; i < g->co_end_index; i++) {
+            struct m_config_option *co = &dst->root->opts[i];
+            if (co->opt->offset >= 0 && co->opt->type->size) {
+                m_option_copy(co->opt, gdst->udata + co->opt->offset,
+                                       gsrc->udata + co->opt->offset);
             }
         }
-        for (int n = 0; n < config->num_groups; n++) {
-            if (!is_group_included(config, n, cache->group))
-                TA_FREEP(&config->groups[n].opts);
-        }
     }
 
-    m_config_cache_update(cache);
-
-    return cache;
+    return res;
 }
 
 bool m_config_cache_update(struct m_config_cache *cache)
@@ -1296,53 +1335,50 @@
 
     // Using atomics and checking outside of the lock - it's unknown whether
     // this makes it faster or slower. Just cargo culting it.
-    if (atomic_load(&shadow->root->groups[cache->group].ts) <= cache->ts)
+    if (atomic_load_explicit(&cache->data->ts, memory_order_relaxed) >=
+        atomic_load(&shadow->data->ts))
         return false;
 
     pthread_mutex_lock(&shadow->lock);
-    cache->ts = atomic_load(&shadow->root->groups[cache->group].ts);
-    for (int n = 0; n < cache->shadow_config->num_opts; n++) {
-        struct m_config_option *co = &cache->shadow_config->opts[n];
-        if (co->shadow_offset >= 0)
-            m_option_copy(co->opt, co->data, shadow->data + co->shadow_offset);
-    }
+    bool res = update_options(cache->data, shadow->data);
     pthread_mutex_unlock(&shadow->lock);
-    return true;
+    return res;
 }
 
 void m_config_notify_change_co(struct m_config *config,
                                struct m_config_option *co)
 {
     struct m_config_shadow *shadow = config->shadow;
+    assert(co->data);
 
     if (shadow) {
         pthread_mutex_lock(&shadow->lock);
-        if (co->shadow_offset >= 0)
-            m_option_copy(co->opt, shadow->data + co->shadow_offset, co->data);
-        pthread_mutex_unlock(&shadow->lock);
-    }
 
-    int changed = co->opt->flags & UPDATE_OPTS_MASK;
+        struct m_config_data *data = shadow->data;
+        struct m_group_data *gdata = m_config_gdata(data, co->group_index);
+        assert(gdata);
 
-    int group = co->group;
-    while (group >= 0) {
-        struct m_config_group *g = &config->groups[group];
-        atomic_fetch_add(&g->ts, 1);
-        if (g->group)
-            changed |= g->group->change_flags;
-        group = g->parent_group;
-    }
+        gdata->ts = atomic_fetch_add(&data->ts, 1) + 1;
+
+        m_option_copy(co->opt, gdata->udata + co->opt->offset, co->data);
 
-    if (shadow) {
-        pthread_mutex_lock(&shadow->lock);
         for (int n = 0; n < shadow->num_listeners; n++) {
             struct m_config_cache *cache = shadow->listeners[n];
-            if (cache->wakeup_cb)
+            if (cache->wakeup_cb && m_config_gdata(cache->data, co->group_index))
                 cache->wakeup_cb(cache->wakeup_cb_ctx);
         }
+
         pthread_mutex_unlock(&shadow->lock);
     }
 
+    int changed = co->opt->flags & UPDATE_OPTS_MASK;
+    int group_index = co->group_index;
+    while (group_index >= 0) {
+        struct m_config_group *g = &config->groups[group_index];
+        changed |= g->group->change_flags;
+        group_index = g->parent_group;
+    }
+
     if (config->option_change_callback) {
         config->option_change_callback(config->option_change_callback_ctx, co,
                                        changed);
@@ -1441,11 +1477,14 @@
     struct m_config_shadow *shadow = global->config;
     struct m_config_option *co = m_config_get_co_raw(shadow->root, bstr0(name));
     assert(co);
-    assert(co->shadow_offset >= 0);
+    assert(co->opt->offset >= 0);
     assert(co->opt->type == type);
 
+    struct m_group_data *gdata = m_config_gdata(shadow->data, co->group_index);
+    assert(gdata);
+
     memset(dst, 0, co->opt->type->size);
-    m_option_copy(co->opt, dst, shadow->data + co->shadow_offset);
+    m_option_copy(co->opt, dst, gdata->udata + co->opt->offset);
 }
 
 struct m_config *mp_get_root_config(struct mpv_global *global)
diff -ruN mpv-0.29.1/options/m_config.h mpv-master/options/m_config.h
--- mpv-0.29.1/options/m_config.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/options/m_config.h	2019-09-19 04:02:03.000000000 +0700
@@ -43,12 +43,10 @@
     bool is_set_from_config : 1;    // Set by a config file
     bool is_set_locally : 1;        // Has a backup entry
     bool warning_was_printed : 1;
-    int16_t shadow_offset;          // Offset into m_config_shadow.data
-    int16_t group;                  // Index into m_config.groups
+    int16_t group_index;            // Index into m_config.groups
     const char *name;               // Full name (ie option-subopt)
     const struct m_option *opt;     // Option description
     void *data;                     // Raw value of the option
-    const void *default_data;       // Raw default value
 };
 
 // Config object
@@ -61,11 +59,6 @@
     struct m_config_option *opts; // all options, even suboptions
     int num_opts;
 
-    // Creation parameters
-    size_t size;
-    const void *defaults;
-    const struct m_option *options;
-
     // List of defined profiles.
     struct m_profile *profiles;
     // Depth when recursively including profiles.
@@ -94,14 +87,17 @@
 
     void *optstruct; // struct mpopts or other
 
-    int shadow_size;
-
-    // List of m_sub_options instances.
+    // Private. List of m_sub_options instances.
     // Index 0 is the top-level and is always present.
+    // Immutable after init.
+    // Invariant: a parent is always at a lower index than any of its children.
     struct m_config_group *groups;
     int num_groups;
 
-    // Thread-safe shadow memory; only set for the main m_config.
+    // Private. Non-NULL if data was allocated. m_config_option.data uses it.
+    struct m_config_data *data;
+
+    // Private. Thread-safe shadow memory; only set for the main m_config.
     struct m_config_shadow *shadow;
 } m_config_t;
 
@@ -182,6 +178,8 @@
 
 int m_config_get_co_count(struct m_config *config);
 struct m_config_option *m_config_get_co_index(struct m_config *config, int index);
+const void *m_config_get_co_default(const struct m_config *config,
+                                    struct m_config_option *co);
 
 // Return the n-th option by position. n==0 is the first option. If there are
 // less than (n + 1) options, return NULL.
@@ -264,14 +262,13 @@
 // the cache itself is allowed.
 struct m_config_cache {
     // The struct as indicated by m_config_cache_alloc's group parameter.
+    // (Internally the same as data->gdata[0]->udata.)
     void *opts;
 
     // Internal.
-    struct m_config_shadow *shadow;
-    struct m_config *shadow_config;
-    long long ts;
-    int group;
-    bool in_list;
+    struct m_config_shadow *shadow; // real data
+    struct m_config_data *data;     // copy for the cache user
+    bool in_list;                   // registered as listener with root config
     // --- Implicitly synchronized by setting/unsetting wakeup_cb.
     struct mp_dispatch_queue *wakeup_dispatch_queue;
     void (*wakeup_dispatch_cb)(void *ctx);
@@ -281,15 +278,17 @@
     void *wakeup_cb_ctx;
 };
 
+#define GLOBAL_CONFIG NULL
+
 // Create a mirror copy from the global options.
 // Keep in mind that a m_config_cache object is not thread-safe; it merely
 // provides thread-safe access to the global options. All API functions for
 // the same m_config_cache object must synchronized, unless otherwise noted.
 //  ta_parent: parent for the returned allocation
 //  global: option data source
-//  group: the option group to return. This can be NULL for the global option
-//         struct (MPOpts), or m_sub_options used in a certain OPT_SUBSTRUCT()
-//         item.
+//  group: the option group to return. This can be GLOBAL_CONFIG for the global
+//         option struct (MPOpts), or m_sub_options used in a certain
+//         OPT_SUBSTRUCT() item.
 struct m_config_cache *m_config_cache_alloc(void *ta_parent,
                                             struct mpv_global *global,
                                             const struct m_sub_options *group);
@@ -320,6 +319,7 @@
 // Like m_config_cache_alloc(), but return the struct (m_config_cache->opts)
 // directly, with no way to update the config. Basically this returns a copy
 // with a snapshot of the current option values.
+// group==GLOBAL_CONFIG is a special case, and always returns the root group.
 void *mp_get_config_group(void *ta_parent, struct mpv_global *global,
                           const struct m_sub_options *group);
 
diff -ruN mpv-0.29.1/options/m_option.h mpv-master/options/m_option.h
--- mpv-0.29.1/options/m_option.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/options/m_option.h	2019-09-19 04:02:03.000000000 +0700
@@ -564,6 +564,7 @@
 
 #define OPTDEF_STR(s)     .defval = (void *)&(char * const){s}
 #define OPTDEF_INT(i)     .defval = (void *)&(const int){i}
+#define OPTDEF_INT64(i)   .defval = (void *)&(const int64_t){i}
 #define OPTDEF_FLOAT(f)   .defval = (void *)&(const float){f}
 #define OPTDEF_DOUBLE(d)  .defval = (void *)&(const double){d}
 
diff -ruN mpv-0.29.1/options/options.c mpv-master/options/options.c
--- mpv-0.29.1/options/options.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/options/options.c	2019-09-19 04:02:03.000000000 +0700
@@ -59,7 +59,6 @@
 extern const struct m_sub_options stream_cdda_conf;
 extern const struct m_sub_options stream_dvb_conf;
 extern const struct m_sub_options stream_lavf_conf;
-extern const struct m_sub_options stream_cache_conf;
 extern const struct m_sub_options sws_conf;
 extern const struct m_sub_options drm_conf;
 extern const struct m_sub_options demux_rawaudio_conf;
@@ -78,7 +77,8 @@
 extern const struct m_obj_list vf_obj_list;
 extern const struct m_obj_list af_obj_list;
 extern const struct m_obj_list vo_obj_list;
-extern const struct m_obj_list ao_obj_list;
+
+extern const struct m_sub_options ao_conf;
 
 extern const struct m_sub_options opengl_conf;
 extern const struct m_sub_options vulkan_conf;
@@ -386,11 +386,9 @@
 
 // ------------------------- stream options --------------------
 
-    OPT_SUBSTRUCT("", stream_cache, stream_cache_conf, 0),
-
-#if HAVE_DVDREAD || HAVE_DVDNAV
+#if HAVE_DVDNAV
     OPT_SUBSTRUCT("", dvd_opts, dvd_conf, 0),
-#endif /* HAVE_DVDREAD */
+#endif
     OPT_INTPAIR("chapter", chapterrange, 0, .deprecation_message = "instead of "
         "--chapter=A-B use --start=#A --end=#B+1"),
     OPT_CHOICE_OR_INT("edition", edition_id, 0, 0, 8190,
@@ -461,6 +459,7 @@
     OPT_STRING("audio-demuxer", audio_demuxer_name, 0),
     OPT_STRING("sub-demuxer", sub_demuxer_name, 0),
     OPT_FLAG("demuxer-thread", demuxer_thread, 0),
+    OPT_DOUBLE("demuxer-termination-timeout", demux_termination_timeout, 0),
     OPT_FLAG("prefetch-playlist", prefetch_open, 0),
     OPT_FLAG("cache-pause", cache_pause, 0),
     OPT_FLAG("cache-pause-initial", cache_pause_initial, 0),
@@ -468,9 +467,6 @@
 
     OPT_DOUBLE("mf-fps", mf_fps, 0),
     OPT_STRING("mf-type", mf_type, 0),
-#if HAVE_TV
-    OPT_SUBSTRUCT("tv", tv_params, tv_params_conf, 0),
-#endif /* HAVE_TV */
 #if HAVE_DVBIN
     OPT_SUBSTRUCT("dvbin", stream_dvb_opts, stream_dvb_conf, 0),
 #endif
@@ -509,18 +505,13 @@
 
     OPT_STRING("audio-spdif", audio_spdif, 0),
 
-    OPT_STRING_VALIDATE("hwdec", hwdec_api, M_OPT_OPTIONAL_PARAM,
-                        hwdec_validate_opt),
-    OPT_STRING("hwdec-codecs", hwdec_codecs, 0),
-    OPT_IMAGEFORMAT("hwdec-image-format", hwdec_image_format, 0, .min = -1),
-
     // -1 means auto aspect (prefer container size until aspect change)
     //  0 means square pixels
     OPT_ASPECT("video-aspect", movie_aspect, UPDATE_IMGPAR, -1.0, 10.0),
     OPT_CHOICE("video-aspect-method", aspect_method, UPDATE_IMGPAR,
                ({"bitstream", 1}, {"container", 2})),
 
-    OPT_SUBSTRUCT("vd-lavc", vd_lavc_params, vd_lavc_conf, 0),
+    OPT_SUBSTRUCT("", vd_lavc_params, vd_lavc_conf, 0),
     OPT_SUBSTRUCT("ad-lavc", ad_lavc_params, ad_lavc_conf, 0),
 
     OPT_SUBSTRUCT("", demux_lavf, demux_lavf_conf, 0),
@@ -548,10 +539,8 @@
     OPT_FLAG("osd-bar", osd_bar_visible, UPDATE_OSD),
 
 //---------------------- libao/libvo options ------------------------
-    OPT_SETTINGSLIST("ao", audio_driver_list, 0, &ao_obj_list, ),
-    OPT_STRING("audio-device", audio_device, UPDATE_AUDIO),
+    OPT_SUBSTRUCT("", ao_opts, ao_conf, 0),
     OPT_FLAG("audio-exclusive", audio_exclusive, UPDATE_AUDIO),
-    OPT_STRING("audio-client-name", audio_client_name, UPDATE_AUDIO),
     OPT_FLAG("audio-fallback-to-null", ao_null_fallback, 0),
     OPT_FLAG("audio-stream-silence", audio_stream_silence, 0),
     OPT_FLOATRANGE("audio-wait-open", audio_wait_open, 0, 0, 60),
@@ -576,8 +565,6 @@
                ({"no", 0},
                 {"yes", 1},
                 {"weak", -1})),
-    OPT_DOUBLE("audio-buffer", audio_buffer, M_OPT_MIN | M_OPT_MAX,
-               .min = 0, .max = 10),
 
     OPT_STRING("title", wintitle, 0),
     OPT_STRING("force-media-title", media_title, 0),
@@ -740,7 +727,7 @@
     OPT_SUBSTRUCT("", macos_opts, macos_conf, 0),
 #endif
 
-#if HAVE_ANDROID
+#if HAVE_EGL_ANDROID
     OPT_SUBSTRUCT("", android_opts, android_conf, 0),
 #endif
 
@@ -871,6 +858,7 @@
     OPT_REPLACED("sub-paths", "sub-file-paths"),
     OPT_REMOVED("heartbeat-cmd", "use Lua scripting instead"),
     OPT_REMOVED("no-ometadata", "use --no-ocopy-metadata"),
+    OPT_REMOVED("video-stereo-mode", "removed, try --vf=stereo3d"),
 
     {0}
 };
@@ -878,16 +866,12 @@
 const struct MPOpts mp_default_opts = {
     .use_terminal = 1,
     .msg_color = 1,
-    .audio_driver_list = NULL,
     .audio_decoders = NULL,
     .video_decoders = NULL,
     .softvol_max = 130,
     .softvol_volume = 100,
     .softvol_mute = 0,
     .gapless_audio = -1,
-    .audio_buffer = 0.2,
-    .audio_device = "auto",
-    .audio_client_name = "mpv",
     .wintitle = "${?media-title:${media-title}}${!media-title:No file} - mpv",
     .stop_screensaver = 1,
     .cursor_autohide_delay = 1000,
@@ -915,6 +899,7 @@
     .position_resume = 1,
     .autoload_files = 1,
     .demuxer_thread = 1,
+    .demux_termination_timeout = 0.1,
     .hls_bitrate = INT_MAX,
     .cache_pause = 1,
     .cache_pause_wait = 1.0,
@@ -952,9 +937,6 @@
     .osd_bar_visible = 1,
     .screenshot_template = "mpv-shot%n",
 
-    .hwdec_api = HAVE_RPI ? "mmal" : "no",
-    .hwdec_codecs = "h264,vc1,wmv3,hevc,mpeg2video,vp9",
-
     .audio_output_channels = {
         .set = 1,
         .auto_safe = 1,
diff -ruN mpv-0.29.1/options/options.h mpv-master/options/options.h
--- mpv-0.29.1/options/options.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/options/options.h	2019-09-19 04:02:03.000000000 +0700
@@ -59,16 +59,6 @@
     struct drm_opts *drm_opts;
 } mp_vo_opts;
 
-struct mp_cache_opts {
-    int size;
-    int def_size;
-    int initial;
-    int seek_min;
-    int back_buffer;
-    char *file;
-    int file_max;
-};
-
 // Subtitle options needed by the subtitle decoders/renderers.
 struct mp_subtitle_opts {
     int sub_visibility;
@@ -144,10 +134,7 @@
 
     int auto_load_scripts;
 
-    struct m_obj_settings *audio_driver_list;
-    char *audio_device;
     int audio_exclusive;
-    char *audio_client_name;
     int ao_null_fallback;
     int audio_stream_silence;
     float audio_wait_open;
@@ -160,9 +147,9 @@
     int softvol_mute;
     float softvol_max;
     int gapless_audio;
-    double audio_buffer;
 
     mp_vo_opts *vo;
+    struct ao_opts *ao_opts;
 
     char *wintitle;
     char *media_title;
@@ -207,7 +194,6 @@
     char *force_configdir;
     int use_filedir_conf;
     int hls_bitrate;
-    struct mp_cache_opts *stream_cache;
     int chapterrange[2];
     int edition_id;
     int correct_pts;
@@ -261,6 +247,7 @@
     char **audio_files;
     char *demuxer_name;
     int demuxer_thread;
+    double demux_termination_timeout;
     int prefetch_open;
     char *audio_demuxer_name;
     char *sub_demuxer_name;
@@ -295,14 +282,8 @@
     int audiofile_auto;
     int osd_bar_visible;
 
-    char *hwdec_api;
-    char *hwdec_codecs;
-    int hwdec_image_format;
-
     int w32_priority;
 
-    struct tv_params *tv_params;
-    struct pvr_params *stream_pvr_opts;
     struct cdda_params *stream_cdda_opts;
     struct dvb_params *stream_dvb_opts;
     struct stream_lavf_params *stream_lavf_opts;
@@ -364,14 +345,10 @@
 extern const m_option_t mp_opts[];
 extern const struct MPOpts mp_default_opts;
 extern const struct m_sub_options vo_sub_opts;
-extern const struct m_sub_options stream_cache_conf;
 extern const struct m_sub_options dvd_conf;
 extern const struct m_sub_options mp_subtitle_sub_opts;
 extern const struct m_sub_options mp_osd_render_sub_opts;
 extern const struct m_sub_options filter_conf;
 extern const struct m_sub_options resample_conf;
 
-int hwdec_validate_opt(struct mp_log *log, const m_option_t *opt,
-                       struct bstr name, struct bstr param);
-
 #endif
diff -ruN mpv-0.29.1/options/parse_commandline.c mpv-master/options/parse_commandline.c
--- mpv-0.29.1/options/parse_commandline.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/options/parse_commandline.c	2019-09-19 04:02:03.000000000 +0700
@@ -199,7 +199,7 @@
             if (bstrcmp0(p.arg, "playlist") == 0) {
                 // append the playlist to the local args
                 char *param0 = bstrdup0(NULL, p.param);
-                struct playlist *pl = playlist_parse_file(param0, global);
+                struct playlist *pl = playlist_parse_file(param0, NULL, global);
                 talloc_free(param0);
                 if (!pl) {
                     MP_FATAL(config, "Error reading playlist '%.*s'\n",
@@ -218,43 +218,8 @@
         } else {
             // filename
             void *tmp = talloc_new(NULL);
-            bstr file = p.arg;
             char *file0 = bstrdup0(tmp, p.arg);
-#if HAVE_GPL
-            // expand DVD filename entries like dvd://1-3 into component titles
-            if (bstr_startswith0(file, "dvd://")) {
-                int offset = 6;
-                char *splitpos = strstr(file0 + offset, "-");
-                if (splitpos != NULL) {
-                    char *endpos;
-                    int start_title = strtol(file0 + offset, &endpos, 10);
-                    int end_title;
-                    //entries like dvd://-2 imply start at title 1
-                    if (start_title < 0) {
-                        end_title = abs(start_title);
-                        start_title = 1;
-                    } else
-                        end_title = strtol(splitpos + 1, &endpos, 10);
-
-                    #define dvd_range(a)  (a >= 0 && a < 255)
-                    if (dvd_range(start_title) && dvd_range(end_title)
-                            && (start_title < end_title)) {
-                        for (int j = start_title; j <= end_title; j++) {
-                            char *f = talloc_asprintf(tmp, "dvd://%d%s", j,
-                                                      endpos);
-                            playlist_add_file(files, f);
-                        }
-                    } else
-                        MP_ERR(config, "Invalid play entry %s\n", file0);
-
-                } else // dvd:// or dvd://x entry
-                    playlist_add_file(files, file0);
-            } else {
-                process_non_option(files, file0);
-            }
-#else
             process_non_option(files, file0);
-#endif
             talloc_free(tmp);
         }
     }
@@ -281,10 +246,8 @@
  * during normal options parsing.
  */
 void m_config_preparse_command_line(m_config_t *config, struct mpv_global *global,
-                                    char **argv)
+                                    int *verbose, char **argv)
 {
-    struct MPOpts *opts = global->opts;
-
     struct parse_state p = {config, argv};
     while (split_opt_silent(&p) == 0) {
         if (p.is_opt) {
@@ -293,7 +256,7 @@
             int flags = M_SETOPT_FROM_CMDLINE | M_SETOPT_PRE_PARSE_ONLY;
             m_config_set_option_cli(config, p.arg, p.param, flags);
             if (bstrcmp0(p.arg, "v") == 0)
-                opts->verbose++;
+                (*verbose)++;
         }
     }
 
diff -ruN mpv-0.29.1/options/parse_commandline.h mpv-master/options/parse_commandline.h
--- mpv-0.29.1/options/parse_commandline.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/options/parse_commandline.h	2019-09-19 04:02:03.000000000 +0700
@@ -27,6 +27,6 @@
 int m_config_parse_mp_command_line(m_config_t *config, struct playlist *files,
                                    struct mpv_global *global, char **argv);
 void m_config_preparse_command_line(m_config_t *config, struct mpv_global *global,
-                                    char **argv);
+                                    int *verbose, char **argv);
 
 #endif /* MPLAYER_PARSER_MPCMD_H */
diff -ruN mpv-0.29.1/options/path.c mpv-master/options/path.c
--- mpv-0.29.1/options/path.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/options/path.c	2019-09-19 04:02:03.000000000 +0700
@@ -37,6 +37,7 @@
 #include "mpv_talloc.h"
 #include "osdep/io.h"
 #include "osdep/path.h"
+#include "misc/ctype.h"
 
 // In order of decreasing priority: the first has highest priority.
 static const mp_get_platform_path_cb path_resolvers[] = {
@@ -61,6 +62,19 @@
     "global",
 };
 
+void mp_init_paths(struct mpv_global *global, struct MPOpts *opts)
+{
+    TA_FREEP(&global->configdir);
+
+    const char *force_configdir = getenv("MPV_HOME");
+    if (opts->force_configdir && opts->force_configdir[0])
+        force_configdir = opts->force_configdir;
+    if (!opts->load_config)
+        force_configdir = "";
+
+    global->configdir = talloc_strdup(global, force_configdir);
+}
+
 // Return a platform specific path using a path type as defined in osdep/path.h.
 // Keep in mind that the only way to free the return value is freeing talloc_ctx
 // (or its children), as this function can return a statically allocated string.
@@ -70,15 +84,10 @@
 {
     assert(talloc_ctx);
 
-    const char *force_configdir = getenv("MPV_HOME");
-    if (global->opts->force_configdir && global->opts->force_configdir[0])
-        force_configdir = global->opts->force_configdir;
-    if (!global->opts->load_config)
-        force_configdir = "";
-    if (force_configdir) {
+    if (global->configdir) {
         for (int n = 0; n < MP_ARRAY_SIZE(config_dirs); n++) {
             if (strcmp(config_dirs[n], type) == 0)
-                return (n == 0 && force_configdir[0]) ? force_configdir : NULL;
+                return (n == 0 && global->configdir[0]) ? global->configdir : NULL;
         }
     }
 
@@ -315,12 +324,15 @@
     int proto = bstr_find0(path, "://");
     if (proto < 1)
         return false;
-    // The protocol part must be alphanumeric, otherwise it's not an URL.
+    // Per RFC3986, the first character of the protocol must be alphabetic.
+    // The rest must be alphanumeric plus -, + and .
     for (int i = 0; i < proto; i++) {
         unsigned char c = path.start[i];
-        if (!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z') &&
-            !(c >= '0' && c <= '9') && c != '_')
+        if ((i == 0 && !mp_isalpha(c)) ||
+            (!mp_isalnum(c) && c != '.' && c != '-' && c != '+'))
+        {
             return false;
+        }
     }
     return true;
 }
diff -ruN mpv-0.29.1/options/path.h mpv-master/options/path.h
--- mpv-0.29.1/options/path.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/options/path.h	2019-09-19 04:02:03.000000000 +0700
@@ -24,6 +24,9 @@
 #include "misc/bstr.h"
 
 struct mpv_global;
+struct MPOpts;
+
+void mp_init_paths(struct mpv_global *global, struct MPOpts *opts);
 
 // Search for the input filename in several paths. These include user and global
 // config locations by default. Some platforms may implement additional platform
diff -ruN mpv-0.29.1/osdep/compiler.h mpv-master/osdep/compiler.h
--- mpv-0.29.1/osdep/compiler.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/compiler.h	2019-09-19 04:02:03.000000000 +0700
@@ -17,5 +17,10 @@
 #define PRINTF_ATTRIBUTE(a1, a2) __attribute__ ((format (gnu_printf, a1, a2)))
 #endif
 
+#if __STDC_VERSION__ >= 201112L
+#include <stdalign.h>
+#else
+#define alignof(x) (offsetof(struct {char unalign_; x u;}, u))
+#endif
 
 #endif
diff -ruN mpv-0.29.1/osdep/io.h mpv-master/osdep/io.h
--- mpv-0.29.1/osdep/io.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/io.h	2019-09-19 04:02:03.000000000 +0700
@@ -33,7 +33,7 @@
 #include <glob.h>
 #endif
 
-#ifdef __ANDROID__
+#if HAVE_ANDROID
 #  include <unistd.h>
 #  include <stdio.h>
 
@@ -58,7 +58,7 @@
 }
 #define fseeko(f,p,w) mp_fseeko((f), (p), (w))
 
-#endif // __ANDROID__
+#endif // HAVE_ANDROID
 
 #ifndef O_BINARY
 #define O_BINARY 0
@@ -196,6 +196,7 @@
 // These are stubs since there is not anything that helps with this on Windows.
 #define locale_t int
 #define LC_ALL_MASK 0
+#define LC_CTYPE_MASK 0
 locale_t newlocale(int, const char *, locale_t);
 locale_t uselocale(locale_t);
 void freelocale(locale_t);
diff -ruN mpv-0.29.1/osdep/macOS_mpv_helper.swift mpv-master/osdep/macOS_mpv_helper.swift
--- mpv-0.29.1/osdep/macOS_mpv_helper.swift	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/macOS_mpv_helper.swift	2019-09-19 04:02:03.000000000 +0700
@@ -34,30 +34,44 @@
     var mpvLog: OpaquePointer?
     var inputContext: OpaquePointer?
     var mpctx: UnsafeMutablePointer<MPContext>?
+    var vo: UnsafeMutablePointer<vo>?
     var macOpts: macos_opts?
     var fbo: GLint = 1
+    let deinitLock = NSLock()
 
     init(_ mpv: OpaquePointer) {
         super.init()
         mpvHandle = mpv
         mpvLog = mp_log_new(UnsafeMutablePointer<MPContext>(mpvHandle),
                             mp_client_get_log(mpvHandle), "cocoacb")
-        mpctx = UnsafeMutablePointer<MPContext>(mp_client_get_core(mpvHandle))
-        inputContext = mpctx!.pointee.input
+        guard let mpctx = UnsafeMutablePointer<MPContext>(mp_client_get_core(mpvHandle)) else {
+            sendError("No MPContext available")
+            exit(1)
+        }
 
-        if let app = NSApp as? Application {
-            let ptr = mp_get_config_group(mpctx!, mp_client_get_global(mpvHandle),
-                                          app.getMacOSConf())
-            macOpts = UnsafeMutablePointer<macos_opts>(OpaquePointer(ptr))!.pointee
+        self.mpctx = mpctx
+        inputContext = mpctx.pointee.input
+        guard let app = NSApp as? Application,
+              let ptr = mp_get_config_group(mpctx,
+                                            mp_client_get_global(mpvHandle),
+                                            app.getMacOSConf()) else
+        {
+            sendError("macOS config group couldn't be retrieved'")
+            exit(1)
         }
+        macOpts = UnsafeMutablePointer<macos_opts>(OpaquePointer(ptr)).pointee
 
         mpv_observe_property(mpvHandle, 0, "ontop", MPV_FORMAT_FLAG)
         mpv_observe_property(mpvHandle, 0, "border", MPV_FORMAT_FLAG)
         mpv_observe_property(mpvHandle, 0, "keepaspect-window", MPV_FORMAT_FLAG)
         mpv_observe_property(mpvHandle, 0, "macos-title-bar-style", MPV_FORMAT_STRING)
+        mpv_observe_property(mpvHandle, 0, "macos-title-bar-appearance", MPV_FORMAT_STRING)
+        mpv_observe_property(mpvHandle, 0, "macos-title-bar-material", MPV_FORMAT_STRING)
+        mpv_observe_property(mpvHandle, 0, "macos-title-bar-color", MPV_FORMAT_STRING)
     }
 
     func initRender() {
+        var advanced: CInt = 1
         let api = UnsafeMutableRawPointer(mutating: (MPV_RENDER_API_TYPE_OPENGL as NSString).utf8String)
         var pAddress = mpv_opengl_init_params(get_proc_address: getProcAddress,
                                               get_proc_address_ctx: nil,
@@ -65,6 +79,7 @@
         var params: [mpv_render_param] = [
             mpv_render_param(type: MPV_RENDER_PARAM_API_TYPE, data: api),
             mpv_render_param(type: MPV_RENDER_PARAM_OPENGL_INIT_PARAMS, data: &pAddress),
+            mpv_render_param(type: MPV_RENDER_PARAM_ADVANCED_CONTROL, data: &advanced),
             mpv_render_param()
         ]
 
@@ -76,7 +91,7 @@
     }
 
     let getProcAddress: (@convention(c) (UnsafeMutableRawPointer?, UnsafePointer<Int8>?)
-                        -> UnsafeMutableRawPointer?)! =
+                        -> UnsafeMutableRawPointer?) =
     {
         (ctx: UnsafeMutableRawPointer?, name: UnsafePointer<Int8>?)
                         -> UnsafeMutableRawPointer? in
@@ -110,13 +125,26 @@
 
     func reportRenderFlip() {
         if mpvRenderContext == nil { return }
-            mpv_render_context_report_swap(mpvRenderContext)
+        mpv_render_context_report_swap(mpvRenderContext)
+    }
+
+    func isRenderUpdateFrame() -> Bool {
+        deinitLock.lock()
+        if mpvRenderContext == nil {
+            deinitLock.unlock()
+            return false
+        }
+        let flags: UInt64 = mpv_render_context_update(mpvRenderContext)
+        deinitLock.unlock()
+        return flags & UInt64(MPV_RENDER_UPDATE_FRAME.rawValue) > 0
     }
 
-    func drawRender(_ surface: NSSize) {
+    func drawRender(_ surface: NSSize, _ ctx: CGLContextObj, skip: Bool = false) {
+        deinitLock.lock()
         if mpvRenderContext != nil {
             var i: GLint = 0
             var flip: CInt = 1
+            var skip: CInt = skip ? 1 : 0
             glGetIntegerv(GLenum(GL_DRAW_FRAMEBUFFER_BINDING), &i)
             // CAOpenGLLayer has ownership of FBO zero yet can return it to us,
             // so only utilize a newly received FBO ID if it is nonzero.
@@ -129,6 +157,7 @@
             var params: [mpv_render_param] = [
                 mpv_render_param(type: MPV_RENDER_PARAM_OPENGL_FBO, data: &data),
                 mpv_render_param(type: MPV_RENDER_PARAM_FLIP_Y, data: &flip),
+                mpv_render_param(type: MPV_RENDER_PARAM_SKIP_RENDERING, data: &skip),
                 mpv_render_param()
             ]
             mpv_render_context_render(mpvRenderContext, &params);
@@ -136,6 +165,10 @@
             glClearColor(0, 0, 0, 1)
             glClear(GLbitfield(GL_COLOR_BUFFER_BIT))
         }
+
+        if !skip { CGLFlushDrawable(ctx) }
+
+        deinitLock.unlock()
     }
 
     func setRenderICCProfile(_ profile: NSColorSpace) {
@@ -144,9 +177,11 @@
             sendWarning("Invalid ICC profile data.")
             return
         }
-        let iccSize = iccData.count
-        iccData.withUnsafeMutableBytes { (u8Ptr: UnsafeMutablePointer<UInt8>) in
-            let iccBstr = bstrdup(nil, bstr(start: u8Ptr, len: iccSize))
+        iccData.withUnsafeMutableBytes { (ptr: UnsafeMutableRawBufferPointer) in
+            guard let baseAddress = ptr.baseAddress, ptr.count > 0 else { return }
+
+            let u8Ptr = baseAddress.assumingMemoryBound(to: UInt8.self)
+            let iccBstr = bstrdup(nil, bstr(start: u8Ptr, len: ptr.count))
             var icc = mpv_byte_array(data: iccBstr.start, size: iccBstr.len)
             let params = mpv_render_param(type: MPV_RENDER_PARAM_ICC_PROFILE, data: &icc)
             mpv_render_context_set_parameter(mpvRenderContext, params)
@@ -189,27 +224,31 @@
     }
 
     func getStringProperty(_ name: String) -> String? {
-        if mpvHandle == nil { return nil }
-        let value = mpv_get_property_string(mpvHandle, name)
-        let str = value == nil ? nil : String(cString: value!)
+        guard let mpv = mpvHandle,
+              let value = mpv_get_property_string(mpv, name) else
+        {
+            return nil
+        }
+
+        let str = String(cString: value)
         mpv_free(value)
         return str
     }
 
     func canBeDraggedAt(_ pos: NSPoint) -> Bool {
-        if inputContext == nil { return false }
-        let canDrag = !mp_input_test_dragging(inputContext!, Int32(pos.x), Int32(pos.y))
+        guard let input = inputContext else { return false }
+        let canDrag = !mp_input_test_dragging(input, Int32(pos.x), Int32(pos.y))
         return canDrag
     }
 
     func setMousePosition(_ pos: NSPoint) {
-        if inputContext == nil { return }
-        mp_input_set_mouse_pos(inputContext!, Int32(pos.x), Int32(pos.y))
+        guard let input = inputContext else { return }
+        mp_input_set_mouse_pos(input, Int32(pos.x), Int32(pos.y))
     }
 
     func putAxis(_ mpkey: Int32, delta: Double) {
-        if inputContext == nil { return }
-        mp_input_put_wheel(inputContext!, mpkey, delta)
+        guard let input = inputContext else { return }
+        mp_input_put_wheel(input, mpkey, delta)
     }
 
     func sendVerbose(_ msg: String) {
@@ -232,7 +271,7 @@
         if mpvLog == nil {
             sendFallback(message: msg, type: t)
         } else {
-            let args: [CVarArg] = [ (msg as NSString).utf8String! ]
+            let args: [CVarArg] = [ (msg as NSString).utf8String ?? "NO MESSAGE"]
             mp_msg_va(mpvLog, Int32(t), "%s\n", getVaList(args))
         }
     }
@@ -258,8 +297,10 @@
     func deinitRender() {
         mpv_render_context_set_update_callback(mpvRenderContext, nil, nil)
         mp_render_context_set_control_callback(mpvRenderContext, nil, nil)
+        deinitLock.lock()
         mpv_render_context_free(mpvRenderContext)
         mpvRenderContext = nil
+        deinitLock.unlock()
     }
 
     func deinitMPV(_ destroy: Bool = false) {
diff -ruN mpv-0.29.1/osdep/macOS_swift_bridge.h mpv-master/osdep/macOS_swift_bridge.h
--- mpv-0.29.1/osdep/macOS_swift_bridge.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/macOS_swift_bridge.h	2019-09-19 04:02:03.000000000 +0700
@@ -49,3 +49,11 @@
 static int SWIFT_KEY_MOUSE_ENTER = MP_KEY_MOUSE_ENTER;
 static int SWIFT_KEY_STATE_DOWN  = MP_KEY_STATE_DOWN;
 static int SWIFT_KEY_STATE_UP    = MP_KEY_STATE_UP;
+
+// only used from Swift files and therefore seen as unused by the c compiler
+static void SWIFT_TARRAY_STRING_APPEND(void *t, char ***a, int *i, char *s) __attribute__ ((unused));
+
+static void SWIFT_TARRAY_STRING_APPEND(void *t, char ***a, int *i, char *s)
+{
+    MP_TARRAY_APPEND(t, *a, *i, s);
+}
diff -ruN mpv-0.29.1/osdep/macOS_swift_compat.swift mpv-master/osdep/macOS_swift_compat.swift
--- mpv-0.29.1/osdep/macOS_swift_compat.swift	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/osdep/macOS_swift_compat.swift	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,83 @@
+/*
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#if !HAVE_MACOS_10_14_FEATURES
+extension NSAppearance.Name {
+    static let darkAqua: NSAppearance.Name = NSAppearance.Name(rawValue: "NSAppearanceNameDarkAqua")
+    static let accessibilityHighContrastAqua: NSAppearance.Name = NSAppearance.Name(rawValue: "NSAppearanceNameAccessibilityAqua")
+    static let accessibilityHighContrastDarkAqua: NSAppearance.Name = NSAppearance.Name(rawValue: "NSAppearanceNameAccessibilityDarkAqua")
+    static let accessibilityHighContrastVibrantLight: NSAppearance.Name = NSAppearance.Name(rawValue: "NSAppearanceNameAccessibilityVibrantLight")
+    static let accessibilityHighContrastVibrantDark: NSAppearance.Name = NSAppearance.Name(rawValue: "NSAppearanceNameAccessibilityVibrantDark")
+}
+#endif
+
+extension NSPasteboard.PasteboardType {
+
+    static let fileURLCompat: NSPasteboard.PasteboardType = {
+        if #available(OSX 10.13, *) {
+            return .fileURL
+        } else {
+            return NSPasteboard.PasteboardType(kUTTypeURL as String)
+        }
+    } ()
+
+    static let URLCompat: NSPasteboard.PasteboardType = {
+        if #available(OSX 10.13, *) {
+            return .URL
+        } else {
+            return NSPasteboard.PasteboardType(kUTTypeFileURL as String)
+        }
+    } ()
+}
+
+#if !swift(>=5.0)
+extension Data {
+
+    mutating func withUnsafeMutableBytes<Type>(_ body: (UnsafeMutableRawBufferPointer) throws -> Type) rethrows -> Type {
+        let dataCount = count
+        return try withUnsafeMutableBytes { (ptr: UnsafeMutablePointer<UInt8>) throws -> Type in
+            try body(UnsafeMutableRawBufferPointer(start: ptr, count: dataCount))
+        }
+    }
+}
+#endif
+
+#if !swift(>=4.2)
+extension NSDraggingInfo {
+
+    var draggingPasteboard: NSPasteboard {
+        get { return draggingPasteboard() }
+    }
+}
+#endif
+
+#if !swift(>=4.1)
+extension Array {
+
+    func compactMap<ElementOfResult>(_ transform: (Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult] {
+        return try self.flatMap(transform)
+    }
+}
+
+extension NSWindow.Level {
+
+    static func +(left: NSWindow.Level, right: Int) -> NSWindow.Level {
+        return NSWindow.Level(left.rawValue + right)
+    }
+}
+#endif
+
diff -ruN mpv-0.29.1/osdep/macOS_swift_extensions.swift mpv-master/osdep/macOS_swift_extensions.swift
--- mpv-0.29.1/osdep/macOS_swift_extensions.swift	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/osdep/macOS_swift_extensions.swift	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,75 @@
+/*
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+import Cocoa
+
+extension NSDeviceDescriptionKey {
+    static let screenNumber = NSDeviceDescriptionKey("NSScreenNumber")
+}
+
+extension NSScreen {
+
+    public var displayID: CGDirectDisplayID {
+        get {
+            return deviceDescription[.screenNumber] as? CGDirectDisplayID ?? 0
+        }
+    }
+
+    public var displayName: String? {
+        get {
+            var name: String? = nil
+            var object: io_object_t
+            var iter = io_iterator_t()
+            let matching = IOServiceMatching("IODisplayConnect")
+            let result = IOServiceGetMatchingServices(kIOMasterPortDefault, matching, &iter)
+
+            if result != KERN_SUCCESS || iter == 0 { return nil }
+
+            repeat {
+                object = IOIteratorNext(iter)
+                if let info = IODisplayCreateInfoDictionary(object, IOOptionBits(kIODisplayOnlyPreferredName)).takeRetainedValue() as? [String:AnyObject],
+                    (info[kDisplayVendorID] as? UInt32 == CGDisplayVendorNumber(displayID) &&
+                    info[kDisplayProductID] as? UInt32 == CGDisplayModelNumber(displayID) &&
+                    info[kDisplaySerialNumber] as? UInt32 ?? 0 == CGDisplaySerialNumber(displayID))
+                {
+                    if let productNames = info["DisplayProductName"] as? [String:String],
+                       let productName = productNames.first?.value
+                    {
+                        name = productName
+                        break
+                    }
+                }
+            } while object != 0
+
+            IOObjectRelease(iter)
+            return name
+        }
+    }
+}
+
+extension NSColor {
+
+    convenience init(hex: String) {
+        let int = Int(hex.dropFirst(), radix: 16) ?? 0
+        let alpha = CGFloat((int >> 24) & 0x000000FF)/255
+        let red   = CGFloat((int >> 16) & 0x000000FF)/255
+        let green = CGFloat((int >> 8)  & 0x000000FF)/255
+        let blue  = CGFloat((int)       & 0x000000FF)/255
+
+        self.init(calibratedRed: red, green: green, blue: blue, alpha: alpha)
+    }
+}
diff -ruN mpv-0.29.1/osdep/macosx_application.h mpv-master/osdep/macosx_application.h
--- mpv-0.29.1/osdep/macosx_application.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/macosx_application.h	2019-09-19 04:02:03.000000000 +0700
@@ -19,9 +19,13 @@
 #define MPV_MACOSX_APPLICATION
 
 #include "osdep/macosx_menubar.h"
+#include "options/m_option.h"
 
 struct macos_opts {
     int macos_title_bar_style;
+    int macos_title_bar_appearance;
+    int macos_title_bar_material;
+    struct m_color macos_title_bar_color;
     int macos_fs_animation_duration;
     int cocoa_cb_sw_renderer;
 };
diff -ruN mpv-0.29.1/osdep/macosx_application.m mpv-master/osdep/macosx_application.m
--- mpv-0.29.1/osdep/macosx_application.m	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/macosx_application.m	2019-09-19 04:02:03.000000000 +0700
@@ -43,18 +43,33 @@
 #define OPT_BASE_STRUCT struct macos_opts
 const struct m_sub_options macos_conf = {
     .opts = (const struct m_option[]) {
-        OPT_CHOICE("macos-title-bar-style", macos_title_bar_style, 0,
-                   ({"dark", 0}, {"ultradark", 1}, {"light", 2},
-                    {"mediumlight", 3}, {"auto", 4})),
+        OPT_CHOICE("macos-title-bar-appearance", macos_title_bar_appearance, 0,
+                   ({"auto", 0}, {"aqua", 1}, {"darkAqua", 2},
+                    {"vibrantLight", 3}, {"vibrantDark", 4},
+                    {"aquaHighContrast", 5}, {"darkAquaHighContrast", 6},
+                    {"vibrantLightHighContrast", 7},
+                    {"vibrantDarkHighContrast", 8})),
+        OPT_CHOICE("macos-title-bar-material", macos_title_bar_material, 0,
+                   ({"titlebar", 0}, {"selection", 1}, {"menu", 2},
+                    {"popover", 3}, {"sidebar", 4}, {"headerView", 5},
+                    {"sheet", 6}, {"windowBackground", 7}, {"hudWindow", 8},
+                    {"fullScreen", 9}, {"toolTip", 10}, {"contentBackground", 11},
+                    {"underWindowBackground", 12}, {"underPageBackground", 13},
+                    {"dark", 14}, {"light", 15}, {"mediumLight", 16},
+                    {"ultraDark", 17})),
+        OPT_COLOR("macos-title-bar-color", macos_title_bar_color, 0),
         OPT_CHOICE_OR_INT("macos-fs-animation-duration",
                           macos_fs_animation_duration, 0, 0, 1000,
                           ({"default", -1})),
         OPT_CHOICE("cocoa-cb-sw-renderer", cocoa_cb_sw_renderer, 0,
                    ({"auto", -1}, {"no", 0}, {"yes", 1})),
+        OPT_REMOVED("macos-title-bar-style", "Split into --macos-title-bar-appearance "
+                     "and --macos-title-bar-material"),
         {0}
     },
     .size = sizeof(struct macos_opts),
     .defaults = &(const struct macos_opts){
+        .macos_title_bar_color = {0, 0, 0, 0},
         .macos_fs_animation_duration = -1,
         .cocoa_cb_sw_renderer = -1,
     },
diff -ruN mpv-0.29.1/osdep/macosx_compat.h mpv-master/osdep/macosx_compat.h
--- mpv-0.29.1/osdep/macosx_compat.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/macosx_compat.h	2019-09-19 04:02:03.000000000 +0700
@@ -55,7 +55,7 @@
 
 #if (MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_9)
 typedef NSUInteger NSModalResponse;
-static const NSModalResponse NSModalResponseOK = NSFileHandlingPanelOKButton
+static const NSModalResponse NSModalResponseOK = NSFileHandlingPanelOKButton;
 #endif
 
 #endif
diff -ruN mpv-0.29.1/osdep/macosx_events.m mpv-master/osdep/macosx_events.m
--- mpv-0.29.1/osdep/macosx_events.m	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/macosx_events.m	2019-09-19 04:02:03.000000000 +0700
@@ -340,8 +340,10 @@
     switch (event->event_id) {
     case MPV_EVENT_SHUTDOWN: {
         #if HAVE_MACOS_COCOA_CB
-        if ([(Application *)NSApp cocoaCB].isShuttingDown)
+        if ([(Application *)NSApp cocoaCB].isShuttingDown) {
+            _ctx = nil;
             return;
+        }
         #endif
         mpv_destroy(_ctx);
         _ctx = nil;
diff -ruN mpv-0.29.1/osdep/posix-spawn.h mpv-master/osdep/posix-spawn.h
--- mpv-0.29.1/osdep/posix-spawn.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/posix-spawn.h	2019-09-19 04:02:03.000000000 +0700
@@ -19,7 +19,9 @@
 
 #pragma once
 
-#ifdef __ANDROID__
+#include "config.h"
+
+#if HAVE_ANDROID
 // posix_spawn(p) does not exist at all on Android
 #include "osdep/android/posix-spawn.h"
 #else
diff -ruN mpv-0.29.1/osdep/strnlen.h mpv-master/osdep/strnlen.h
--- mpv-0.29.1/osdep/strnlen.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/strnlen.h	2019-09-19 04:02:03.000000000 +0700
@@ -20,7 +20,9 @@
 #ifndef MP_OSDEP_STRNLEN
 #define MP_OSDEP_STRNLEN
 
-#ifdef __ANDROID__
+#include "config.h"
+
+#if HAVE_ANDROID
 // strnlen is broken on current android ndk, see https://code.google.com/p/android/issues/detail?id=74741
 #include "osdep/android/strnlen.h"
 #define strnlen freebsd_strnlen
diff -ruN mpv-0.29.1/osdep/subprocess-posix.c mpv-master/osdep/subprocess-posix.c
--- mpv-0.29.1/osdep/subprocess-posix.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/subprocess-posix.c	2019-09-19 04:02:03.000000000 +0700
@@ -26,8 +26,9 @@
 
 #include "osdep/subprocess.h"
 
-#include "osdep/io.h"
 #include "common/common.h"
+#include "misc/thread_tools.h"
+#include "osdep/io.h"
 #include "stream/stream.h"
 
 extern char **environ;
diff -ruN mpv-0.29.1/osdep/subprocess-win.c mpv-master/osdep/subprocess-win.c
--- mpv-0.29.1/osdep/subprocess-win.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/subprocess-win.c	2019-09-19 04:02:03.000000000 +0700
@@ -27,6 +27,7 @@
 #include "common/common.h"
 #include "stream/stream.h"
 #include "misc/bstr.h"
+#include "misc/thread_tools.h"
 
 static void write_arg(bstr *cmdline, char *arg)
 {
diff -ruN mpv-0.29.1/osdep/timer.c mpv-master/osdep/timer.c
--- mpv-0.29.1/osdep/timer.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/timer.c	2019-09-19 04:02:03.000000000 +0700
@@ -59,16 +59,6 @@
     return mp_time_us() / (double)(1000 * 1000);
 }
 
-int64_t mp_time_relative_us(int64_t *t)
-{
-    int64_t r = 0;
-    int64_t now = mp_time_us();
-    if (*t)
-        r = now - *t;
-    *t = now;
-    return r;
-}
-
 int64_t mp_add_timeout(int64_t time_us, double timeout_sec)
 {
     assert(time_us > 0); // mp_time_us() returns strictly positive values
diff -ruN mpv-0.29.1/osdep/timer.h mpv-master/osdep/timer.h
--- mpv-0.29.1/osdep/timer.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/timer.h	2019-09-19 04:02:03.000000000 +0700
@@ -39,11 +39,8 @@
 
 #define MP_START_TIME 10000000
 
-// Return the amount of time that has passed since the last call, in
-// microseconds. *t is used to calculate the time that has passed by storing
-// the current time in it. If *t is 0, the call will return 0. (So that the
-// first call will return 0, instead of the absolute current time.)
-int64_t mp_time_relative_us(int64_t *t);
+// Duration of a second in mpv time.
+#define MP_SECOND_US (1000 * 1000)
 
 // Add a time in seconds to the given time in microseconds, and return it.
 // Takes care of possible overflows. Never returns a negative or 0 time.
diff -ruN mpv-0.29.1/osdep/win32-console-wrapper.c mpv-master/osdep/win32-console-wrapper.c
--- mpv-0.29.1/osdep/win32-console-wrapper.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/osdep/win32-console-wrapper.c	2019-09-19 04:02:03.000000000 +0700
@@ -19,7 +19,9 @@
 #include <stdio.h>
 #include <windows.h>
 
-void cr_perror(const wchar_t *prefix)
+int wmain(int argc, wchar_t **argv, wchar_t **envp);
+
+static void cr_perror(const wchar_t *prefix)
 {
     wchar_t *error;
 
@@ -34,7 +36,7 @@
     LocalFree(error);
 }
 
-int cr_runproc(wchar_t *name, wchar_t *cmdline)
+static int cr_runproc(wchar_t *name, wchar_t *cmdline)
 {
     STARTUPINFOW si;
     STARTUPINFOW our_si;
diff -ruN mpv-0.29.1/player/audio.c mpv-master/player/audio.c
--- mpv-0.29.1/player/audio.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/audio.c	2019-09-19 04:02:03.000000000 +0700
@@ -403,7 +403,7 @@
     mp_audio_buffer_reinit_fmt(ao_c->ao_buffer, ao_format, &ao_channels,
                                 ao_rate);
 
-    char tmp[80];
+    char tmp[192];
     MP_INFO(mpctx, "AO: [%s] %s\n", ao_get_name(mpctx->ao),
             audio_config_to_str_buf(tmp, sizeof(tmp), ao_rate, ao_format,
                                     ao_channels));
diff -ruN mpv-0.29.1/player/client.c mpv-master/player/client.c
--- mpv-0.29.1/player/client.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/client.c	2019-09-19 04:02:03.000000000 +0700
@@ -31,7 +31,9 @@
 #include "input/cmd.h"
 #include "misc/ctype.h"
 #include "misc/dispatch.h"
+#include "misc/node.h"
 #include "misc/rendezvous.h"
+#include "misc/thread_tools.h"
 #include "options/m_config.h"
 #include "options/m_option.h"
 #include "options/m_property.h"
@@ -370,6 +372,30 @@
     pthread_mutex_unlock(&ctx->lock);
 }
 
+// Send abort signal to all matching work items.
+// If type==0, destroy all of the matching ctx.
+// If ctx==0, destroy all.
+static void abort_async(struct MPContext *mpctx, mpv_handle *ctx,
+                        int type, uint64_t id)
+{
+    pthread_mutex_lock(&mpctx->abort_lock);
+
+    // Destroy all => ensure any newly appearing work is aborted immediately.
+    if (ctx == NULL)
+        mpctx->abort_all = true;
+
+    for (int n = 0; n < mpctx->num_abort_list; n++) {
+        struct mp_abort_entry *abort = mpctx->abort_list[n];
+        if (!ctx || (abort->client == ctx && (!type ||
+            (abort->client_work_type == type && abort->client_work_id == id))))
+        {
+            mp_abort_trigger_locked(mpctx, abort);
+        }
+    }
+
+    pthread_mutex_unlock(&mpctx->abort_lock);
+}
+
 static void get_thread(void *ptr)
 {
     *(pthread_t *)ptr = pthread_self();
@@ -388,6 +414,8 @@
     if (terminate)
         mpv_command(ctx, (const char*[]){"quit", NULL});
 
+    abort_async(mpctx, ctx, 0, 0);
+
     // reserved_events equals the number of asynchronous requests that weren't
     // yet replied. In order to avoid that trying to reply to a removed client
     // causes a crash, block until all asynchronous requests were served.
@@ -483,32 +511,52 @@
     mp_destroy_client(ctx, true);
 }
 
-static bool can_terminate(struct MPContext *mpctx)
-{
-    struct mp_client_api *clients = mpctx->clients;
-
-    pthread_mutex_lock(&clients->lock);
-    bool ok = clients->num_clients == 0 && mpctx->outstanding_async == 0 &&
-              (mpctx->is_cli || clients->terminate_core_thread);
-    pthread_mutex_unlock(&clients->lock);
-
-    return ok;
-}
-
 // Can be called on the core thread only. Idempotent.
+// Also happens to take care of shutting down any async work.
 void mp_shutdown_clients(struct MPContext *mpctx)
 {
     struct mp_client_api *clients = mpctx->clients;
 
-    // Prevent that new clients can appear.
+    // Forcefully abort async work after 2 seconds of waiting.
+    double abort_time = mp_time_sec() + 2;
+
     pthread_mutex_lock(&clients->lock);
+
+    // Prevent that new clients can appear.
     clients->shutting_down = true;
-    pthread_mutex_unlock(&clients->lock);
 
-    while (!can_terminate(mpctx)) {
+    // Wait until we can terminate.
+    while (clients->num_clients || mpctx->outstanding_async ||
+           !(mpctx->is_cli || clients->terminate_core_thread))
+    {
+        pthread_mutex_unlock(&clients->lock);
+
+        double left = abort_time - mp_time_sec();
+        if (left >= 0) {
+            mp_set_timeout(mpctx, left);
+        } else {
+            // Forcefully abort any ongoing async work. This is quite rude and
+            // probably not what everyone wants, so it happens only after a
+            // timeout.
+            abort_async(mpctx, NULL, 0, 0);
+        }
+
         mp_client_broadcast_event(mpctx, MPV_EVENT_SHUTDOWN, NULL);
         mp_wait_events(mpctx);
+
+        pthread_mutex_lock(&clients->lock);
     }
+
+    pthread_mutex_unlock(&clients->lock);
+}
+
+bool mp_is_shutting_down(struct MPContext *mpctx)
+{
+    struct mp_client_api *clients = mpctx->clients;
+    pthread_mutex_lock(&clients->lock);
+    bool res = clients->shutting_down;
+    pthread_mutex_unlock(&clients->lock);
+    return res;
 }
 
 static void *core_thread(void *p)
@@ -677,16 +725,6 @@
     pthread_mutex_unlock(&ctx->lock);
 }
 
-static void status_reply(struct mpv_handle *ctx, int event,
-                         uint64_t userdata, int status)
-{
-    struct mpv_event reply = {
-        .event_id = event,
-        .error = status,
-    };
-    send_reply(ctx, userdata, &reply);
-}
-
 // Return whether there's any client listening to this event.
 // If false is returned, the core doesn't need to send it.
 bool mp_client_event_is_registered(struct MPContext *mpctx, int event)
@@ -905,54 +943,6 @@
     return false;
 }
 
-// Note: for MPV_FORMAT_NODE_MAP, this (incorrectly) takes the order into
-//       account, instead of treating it as set.
-static bool compare_value(void *a, void *b, mpv_format format)
-{
-    switch (format) {
-    case MPV_FORMAT_NONE:
-        return true;
-    case MPV_FORMAT_STRING:
-    case MPV_FORMAT_OSD_STRING:
-        return strcmp(*(char **)a, *(char **)b) == 0;
-    case MPV_FORMAT_FLAG:
-        return *(int *)a == *(int *)b;
-    case MPV_FORMAT_INT64:
-        return *(int64_t *)a == *(int64_t *)b;
-    case MPV_FORMAT_DOUBLE:
-        return *(double *)a == *(double *)b;
-    case MPV_FORMAT_NODE: {
-        struct mpv_node *a_n = a, *b_n = b;
-        if (a_n->format != b_n->format)
-            return false;
-        return compare_value(&a_n->u, &b_n->u, a_n->format);
-    }
-    case MPV_FORMAT_BYTE_ARRAY: {
-        struct mpv_byte_array *a_r = a, *b_r = b;
-        if (a_r->size != b_r->size)
-            return false;
-        return memcmp(a_r->data, b_r->data, a_r->size) == 0;
-    }
-    case MPV_FORMAT_NODE_ARRAY:
-    case MPV_FORMAT_NODE_MAP:
-    {
-        mpv_node_list *l_a = *(mpv_node_list **)a, *l_b = *(mpv_node_list **)b;
-        if (l_a->num != l_b->num)
-            return false;
-        for (int n = 0; n < l_a->num; n++) {
-            if (!compare_value(&l_a->values[n], &l_b->values[n], MPV_FORMAT_NODE))
-                return false;
-            if (format == MPV_FORMAT_NODE_MAP) {
-                if (strcmp(l_a->keys[n], l_b->keys[n]) != 0)
-                    return false;
-            }
-        }
-        return true;
-    }
-    }
-    abort();
-}
-
 void mpv_free_node_contents(mpv_node *node)
 {
     static const struct m_option type = { .type = CONF_TYPE_NODE };
@@ -1017,40 +1007,40 @@
         talloc_free(fn_data);
         return err;
     }
-    mp_dispatch_enqueue_autofree(ctx->mpctx->dispatch, fn, fn_data);
+    mp_dispatch_enqueue(ctx->mpctx->dispatch, fn, fn_data);
     return 0;
 }
 
 struct cmd_request {
     struct MPContext *mpctx;
     struct mp_cmd *cmd;
-    struct mpv_node *res;
     int status;
-    struct mpv_handle *reply_ctx;
-    uint64_t userdata;
+    struct mpv_node *res;
+    struct mp_waiter completion;
 };
 
-static void cmd_fn(void *data)
+static void cmd_complete(struct mp_cmd_ctx *cmd)
 {
-    struct cmd_request *req = data;
-    int r = run_command(req->mpctx, req->cmd, req->res);
-    req->status = r >= 0 ? 0 : MPV_ERROR_COMMAND;
-    talloc_free(req->cmd);
-    if (req->reply_ctx) {
-        status_reply(req->reply_ctx, MPV_EVENT_COMMAND_REPLY,
-                     req->userdata, req->status);
+    struct cmd_request *req = cmd->on_completion_priv;
+
+    req->status = cmd->success ? 0 : MPV_ERROR_COMMAND;
+    if (req->res) {
+        *req->res = cmd->result;
+        cmd->result = (mpv_node){0};
     }
+
+    // Unblock the waiting thread (especially for async commands).
+    mp_waiter_wakeup(&req->completion, 0);
 }
 
 static int run_client_command(mpv_handle *ctx, struct mp_cmd *cmd, mpv_node *res)
 {
-    if (!ctx->mpctx->initialized)
-        return MPV_ERROR_UNINITIALIZED;
     if (!cmd)
         return MPV_ERROR_INVALID_PARAMETER;
-
-    if (mp_input_is_abort_cmd(cmd))
-        mp_abort_playback_async(ctx->mpctx);
+    if (!ctx->mpctx->initialized) {
+        talloc_free(cmd);
+        return MPV_ERROR_UNINITIALIZED;
+    }
 
     cmd->sender = ctx->name;
 
@@ -1058,8 +1048,27 @@
         .mpctx = ctx->mpctx,
         .cmd = cmd,
         .res = res,
+        .completion = MP_WAITER_INITIALIZER,
     };
-    run_locked(ctx, cmd_fn, &req);
+
+    bool async = cmd->flags & MP_ASYNC_CMD;
+
+    lock_core(ctx);
+    if (async) {
+        run_command(ctx->mpctx, cmd, NULL, NULL, NULL);
+    } else {
+        struct mp_abort_entry *abort = NULL;
+        if (cmd->def->can_abort) {
+            abort = talloc_zero(NULL, struct mp_abort_entry);
+            abort->client = ctx;
+        }
+        run_command(ctx->mpctx, cmd, abort, cmd_complete, &req);
+    }
+    unlock_core(ctx);
+
+    if (!async)
+        mp_waiter_wait(&req.completion);
+
     return req.status;
 }
 
@@ -1083,33 +1092,87 @@
         mp_input_parse_cmd(ctx->mpctx->input, bstr0((char*)args), ctx->name), NULL);
 }
 
-static int run_cmd_async(mpv_handle *ctx, uint64_t ud, struct mp_cmd *cmd)
+struct async_cmd_request {
+    struct MPContext *mpctx;
+    struct mp_cmd *cmd;
+    struct mpv_handle *reply_ctx;
+    uint64_t userdata;
+};
+
+static void async_cmd_complete(struct mp_cmd_ctx *cmd)
+{
+    struct async_cmd_request *req = cmd->on_completion_priv;
+
+    struct mpv_event_command *data = talloc_zero(NULL, struct mpv_event_command);
+    data->result = cmd->result;
+    cmd->result = (mpv_node){0};
+    talloc_steal(data, node_get_alloc(&data->result));
+
+    struct mpv_event reply = {
+        .event_id = MPV_EVENT_COMMAND_REPLY,
+        .data = data,
+        .error = cmd->success ? 0 : MPV_ERROR_COMMAND,
+    };
+    send_reply(req->reply_ctx, req->userdata, &reply);
+
+    talloc_free(req);
+}
+
+static void async_cmd_fn(void *data)
+{
+    struct async_cmd_request *req = data;
+
+    struct mp_cmd *cmd = req->cmd;
+    ta_xset_parent(cmd, NULL);
+    req->cmd = NULL;
+
+    struct mp_abort_entry *abort = NULL;
+    if (cmd->def->can_abort) {
+        abort = talloc_zero(NULL, struct mp_abort_entry);
+        abort->client = req->reply_ctx;
+        abort->client_work_type = MPV_EVENT_COMMAND_REPLY;
+        abort->client_work_id = req->userdata;
+    }
+
+    // This will synchronously or asynchronously call cmd_complete (depending
+    // on the command).
+    run_command(req->mpctx, cmd, abort, async_cmd_complete, req);
+}
+
+static int run_async_cmd(mpv_handle *ctx, uint64_t ud, struct mp_cmd *cmd)
 {
-    if (!ctx->mpctx->initialized)
-        return MPV_ERROR_UNINITIALIZED;
     if (!cmd)
         return MPV_ERROR_INVALID_PARAMETER;
+    if (!ctx->mpctx->initialized) {
+        talloc_free(cmd);
+        return MPV_ERROR_UNINITIALIZED;
+    }
 
     cmd->sender = ctx->name;
 
-    struct cmd_request *req = talloc_ptrtype(NULL, req);
-    *req = (struct cmd_request){
+    struct async_cmd_request *req = talloc_ptrtype(NULL, req);
+    *req = (struct async_cmd_request){
         .mpctx = ctx->mpctx,
-        .cmd = cmd,
+        .cmd = talloc_steal(req, cmd),
         .reply_ctx = ctx,
         .userdata = ud,
     };
-    return run_async(ctx, cmd_fn, req);
+    return run_async(ctx, async_cmd_fn, req);
 }
 
 int mpv_command_async(mpv_handle *ctx, uint64_t ud, const char **args)
 {
-    return run_cmd_async(ctx, ud, mp_input_parse_cmd_strv(ctx->log, args));
+    return run_async_cmd(ctx, ud, mp_input_parse_cmd_strv(ctx->log, args));
 }
 
 int mpv_command_node_async(mpv_handle *ctx, uint64_t ud, mpv_node *args)
 {
-    return run_cmd_async(ctx, ud, mp_input_parse_cmd_node(ctx->log, args));
+    return run_async_cmd(ctx, ud, mp_input_parse_cmd_node(ctx->log, args));
+}
+
+void mpv_abort_async_command(mpv_handle *ctx, uint64_t reply_userdata)
+{
+    abort_async(ctx->mpctx, ctx, MPV_EVENT_COMMAND_REPLY, reply_userdata);
 }
 
 static int translate_property_error(int errc)
@@ -1156,8 +1219,12 @@
     req->status = translate_property_error(err);
 
     if (req->reply_ctx) {
-        status_reply(req->reply_ctx, MPV_EVENT_SET_PROPERTY_REPLY,
-                     req->userdata, req->status);
+        struct mpv_event reply = {
+            .event_id = MPV_EVENT_SET_PROPERTY_REPLY,
+            .error = req->status,
+        };
+        send_reply(req->reply_ctx, req->userdata, &reply);
+        talloc_free(req);
     }
 }
 
@@ -1313,6 +1380,7 @@
             .error = req->status,
         };
         send_reply(req->reply_ctx, req->userdata, &reply);
+        talloc_free(req);
     }
 }
 
@@ -1508,7 +1576,7 @@
     if (prop->user_value_valid != prop->new_value_valid) {
         prop->changed = true;
     } else if (prop->user_value_valid && prop->new_value_valid) {
-        if (!compare_value(&prop->user_value, &prop->new_value, prop->format))
+        if (!equal_mpv_value(&prop->user_value, &prop->new_value, prop->format))
             prop->changed = true;
     }
     if (prop->dead)
diff -ruN mpv-0.29.1/player/client.h mpv-master/player/client.h
--- mpv-0.29.1/player/client.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/client.h	2019-09-19 04:02:03.000000000 +0700
@@ -20,6 +20,7 @@
 void mp_clients_init(struct MPContext *mpctx);
 void mp_clients_destroy(struct MPContext *mpctx);
 void mp_shutdown_clients(struct MPContext *mpctx);
+bool mp_is_shutting_down(struct MPContext *mpctx);
 bool mp_clients_all_initialized(struct MPContext *mpctx);
 
 bool mp_client_exists(struct MPContext *mpctx, const char *client_name);
diff -ruN mpv-0.29.1/player/command.c mpv-master/player/command.c
--- mpv-0.29.1/player/command.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/command.c	2019-09-19 04:02:03.000000000 +0700
@@ -60,7 +60,9 @@
 #include "video/out/bitmap_packer.h"
 #include "options/path.h"
 #include "screenshot.h"
+#include "misc/dispatch.h"
 #include "misc/node.h"
+#include "misc/thread_pool.h"
 
 #include "osdep/io.h"
 #include "osdep/subprocess.h"
@@ -451,10 +453,10 @@
     double speed = mpctx->opts->playback_speed;
     switch (action) {
     case M_PROPERTY_SET: {
-        mpctx->opts->playback_speed = *(double *)arg;
+        int r = mp_property_generic_option(mpctx, prop, action, arg);
         update_playback_speed(mpctx);
         mp_wakeup_core(mpctx);
-        return M_PROPERTY_OK;
+        return r;
     }
     case M_PROPERTY_PRINT:
         *(char **)arg = talloc_asprintf(NULL, "%.2f", speed);
@@ -899,39 +901,6 @@
     return property_time(action, arg, get_playback_time(mpctx));
 }
 
-/// Current BD/DVD title (RW)
-static int mp_property_disc_title(void *ctx, struct m_property *prop,
-                                  int action, void *arg)
-{
-    MPContext *mpctx = ctx;
-    struct demuxer *d = mpctx->demuxer;
-    if (!d)
-        return M_PROPERTY_UNAVAILABLE;
-    unsigned int title = -1;
-    switch (action) {
-    case M_PROPERTY_GET:
-        if (demux_stream_control(d, STREAM_CTRL_GET_CURRENT_TITLE, &title) < 0)
-            return M_PROPERTY_UNAVAILABLE;
-        *(int*)arg = title;
-        return M_PROPERTY_OK;
-    case M_PROPERTY_GET_TYPE:
-        *(struct m_option *)arg = (struct m_option){
-            .type = CONF_TYPE_INT,
-            .flags = M_OPT_MIN,
-            .min = -1,
-        };
-        return M_PROPERTY_OK;
-    case M_PROPERTY_SET:
-        title = *(int*)arg;
-        if (demux_stream_control(d, STREAM_CTRL_SET_CURRENT_TITLE, &title) < 0)
-            return M_PROPERTY_NOT_IMPLEMENTED;
-        if (!mpctx->stop_play)
-            mpctx->stop_play = PT_CURRENT_ENTRY;
-        return M_PROPERTY_OK;
-    }
-    return M_PROPERTY_NOT_IMPLEMENTED;
-}
-
 /// Current chapter (RW)
 static int mp_property_chapter(void *ctx, struct m_property *prop,
                                int action, void *arg)
@@ -1141,11 +1110,10 @@
     case M_PROPERTY_SET: {
         edition = *(int *)arg;
         if (edition != demuxer->edition) {
-            mpctx->opts->edition_id = edition;
             if (!mpctx->stop_play)
                 mpctx->stop_play = PT_CURRENT_ENTRY;
             mp_wakeup_core(mpctx);
-            break; // make it accessible to the demuxer via option change notify
+            break; // write value, trigger option change notify
         }
         return M_PROPERTY_OK;
     }
@@ -1215,51 +1183,6 @@
                                 get_edition_entry, mpctx);
 }
 
-/// Number of titles in BD/DVD
-static int mp_property_disc_titles(void *ctx, struct m_property *prop,
-                                   int action, void *arg)
-{
-    MPContext *mpctx = ctx;
-    struct demuxer *demuxer = mpctx->demuxer;
-    unsigned int num_titles;
-    if (!demuxer || demux_stream_control(demuxer, STREAM_CTRL_GET_NUM_TITLES,
-                                         &num_titles) < 1)
-        return M_PROPERTY_UNAVAILABLE;
-    return m_property_int_ro(action, arg, num_titles);
-}
-
-static int get_disc_title_entry(int item, int action, void *arg, void *ctx)
-{
-    struct MPContext *mpctx = ctx;
-    struct demuxer *demuxer = mpctx->demuxer;
-
-    double len = item;
-    if (demux_stream_control(demuxer, STREAM_CTRL_GET_TITLE_LENGTH, &len) < 1)
-        len = -1;
-
-    struct m_sub_property props[] = {
-        {"id",          SUB_PROP_INT(item)},
-        {"length",      {.type = CONF_TYPE_TIME}, {.time = len},
-                        .unavailable = len < 0},
-        {0}
-    };
-
-    return m_property_read_sub(props, action, arg);
-}
-
-static int mp_property_list_disc_titles(void *ctx, struct m_property *prop,
-                                        int action, void *arg)
-{
-    MPContext *mpctx = ctx;
-    struct demuxer *demuxer = mpctx->demuxer;
-    unsigned int num_titles;
-    if (!demuxer || demux_stream_control(demuxer, STREAM_CTRL_GET_NUM_TITLES,
-                                         &num_titles) < 1)
-        return M_PROPERTY_UNAVAILABLE;
-    return m_property_read_list(action, arg, num_titles,
-                                get_disc_title_entry, mpctx);
-}
-
 /// Number of chapters in file
 static int mp_property_chapters(void *ctx, struct m_property *prop,
                                 int action, void *arg)
@@ -1283,67 +1206,6 @@
     return m_property_int_ro(action, arg, demuxer->num_editions);
 }
 
-/// Current dvd angle (RW)
-static int mp_property_angle(void *ctx, struct m_property *prop,
-                             int action, void *arg)
-{
-    MPContext *mpctx = ctx;
-    struct demuxer *demuxer = mpctx->demuxer;
-    if (!demuxer)
-        return M_PROPERTY_UNAVAILABLE;
-
-    int ris, angles = -1, angle = 1;
-
-    ris = demux_stream_control(demuxer, STREAM_CTRL_GET_NUM_ANGLES, &angles);
-    if (ris == STREAM_UNSUPPORTED)
-        return M_PROPERTY_UNAVAILABLE;
-
-    ris = demux_stream_control(demuxer, STREAM_CTRL_GET_ANGLE, &angle);
-    if (ris == STREAM_UNSUPPORTED)
-        return -1;
-
-    if (angle < 0 || angles <= 1)
-        return M_PROPERTY_UNAVAILABLE;
-
-    switch (action) {
-    case M_PROPERTY_GET:
-        *(int *) arg = angle;
-        return M_PROPERTY_OK;
-    case M_PROPERTY_PRINT: {
-        *(char **) arg = talloc_asprintf(NULL, "%d/%d", angle, angles);
-        return M_PROPERTY_OK;
-    }
-    case M_PROPERTY_SET:
-        angle = *(int *)arg;
-        if (angle < 0 || angle > angles)
-            return M_PROPERTY_ERROR;
-
-        demux_flush(demuxer);
-        ris = demux_stream_control(demuxer, STREAM_CTRL_SET_ANGLE, &angle);
-        if (ris == STREAM_OK) {
-            demux_control(demuxer, DEMUXER_CTRL_RESYNC, NULL);
-            demux_flush(demuxer);
-        }
-
-        reset_audio_state(mpctx);
-        reset_video_state(mpctx);
-        mp_wakeup_core(mpctx);
-
-        return ris == STREAM_OK ? M_PROPERTY_OK : M_PROPERTY_ERROR;
-    case M_PROPERTY_GET_TYPE: {
-        struct m_option opt = {
-            .type = CONF_TYPE_INT,
-            .flags = CONF_RANGE,
-            .min = 1,
-            .max = angles,
-        };
-        *(struct m_option *)arg = opt;
-        return M_PROPERTY_OK;
-    }
-    }
-    return M_PROPERTY_NOT_IMPLEMENTED;
-}
-
 static int get_tag_entry(int item, int action, void *arg, void *ctx)
 {
     struct mp_tags *tags = ctx;
@@ -1556,103 +1418,6 @@
     return m_property_flag_ro(action, arg, !mpctx->playing || mpctx->stop_play);
 }
 
-static int mp_property_cache(void *ctx, struct m_property *prop,
-                             int action, void *arg)
-{
-    MPContext *mpctx = ctx;
-    float cache = mp_get_cache_percent(mpctx);
-    if (cache < 0)
-        return M_PROPERTY_UNAVAILABLE;
-
-    if (action == M_PROPERTY_PRINT) {
-        *(char **)arg = talloc_asprintf(NULL, "%d", (int)cache);
-        return M_PROPERTY_OK;
-    }
-
-    return m_property_float_ro(action, arg, cache);
-}
-
-static int property_int_kb_size(int kb_size, int action, void *arg)
-{
-    switch (action) {
-    case M_PROPERTY_GET:
-        *(int *)arg = kb_size;
-        return M_PROPERTY_OK;
-    case M_PROPERTY_PRINT:
-        *(char **)arg = format_file_size(kb_size * 1024LL);
-        return M_PROPERTY_OK;
-    case M_PROPERTY_GET_TYPE:
-        *(struct m_option *)arg = (struct m_option){.type = CONF_TYPE_INT};
-        return M_PROPERTY_OK;
-    }
-    return M_PROPERTY_NOT_IMPLEMENTED;
-}
-
-static int mp_property_cache_size(void *ctx, struct m_property *prop,
-                                  int action, void *arg)
-{
-    MPContext *mpctx = ctx;
-    struct demuxer *demuxer = mpctx->demuxer;
-    if (!demuxer)
-        return M_PROPERTY_UNAVAILABLE;
-    switch (action) {
-    case M_PROPERTY_GET:
-    case M_PROPERTY_PRINT: {
-        struct stream_cache_info info = {0};
-        demux_stream_control(demuxer, STREAM_CTRL_GET_CACHE_INFO, &info);
-        if (info.size <= 0)
-            break;
-        return property_int_kb_size(info.size / 1024, action, arg);
-    }
-    case M_PROPERTY_GET_TYPE:
-        *(struct m_option *)arg = (struct m_option){
-            .type = CONF_TYPE_INT,
-            .flags = M_OPT_MIN,
-            .min = 0,
-        };
-        return M_PROPERTY_OK;
-    case M_PROPERTY_SET: {
-        int64_t size = *(int *)arg * 1024LL;
-        int r = demux_stream_control(demuxer, STREAM_CTRL_SET_CACHE_SIZE, &size);
-        if (r == STREAM_UNSUPPORTED)
-            break;
-        if (r == STREAM_OK)
-            return M_PROPERTY_OK;
-        return M_PROPERTY_ERROR;
-    }
-    }
-    return M_PROPERTY_NOT_IMPLEMENTED;
-}
-
-static int mp_property_cache_used(void *ctx, struct m_property *prop,
-                                  int action, void *arg)
-{
-    MPContext *mpctx = ctx;
-    if (!mpctx->demuxer)
-        return M_PROPERTY_UNAVAILABLE;
-
-    struct stream_cache_info info = {0};
-    demux_stream_control(mpctx->demuxer, STREAM_CTRL_GET_CACHE_INFO, &info);
-    if (info.size <= 0)
-        return M_PROPERTY_UNAVAILABLE;
-    return property_int_kb_size(info.fill / 1024, action, arg);
-}
-
-static int mp_property_cache_free(void *ctx, struct m_property *prop,
-                                  int action, void *arg)
-{
-    MPContext *mpctx = ctx;
-    if (!mpctx->demuxer)
-        return M_PROPERTY_UNAVAILABLE;
-
-    struct stream_cache_info info = {0};
-    demux_stream_control(mpctx->demuxer, STREAM_CTRL_GET_CACHE_INFO, &info);
-    if (info.size <= 0)
-        return M_PROPERTY_UNAVAILABLE;
-
-    return property_int_kb_size((info.size - info.fill) / 1024, action, arg);
-}
-
 static int mp_property_cache_speed(void *ctx, struct m_property *prop,
                                    int action, void *arg)
 {
@@ -1660,28 +1425,17 @@
     if (!mpctx->demuxer)
         return M_PROPERTY_UNAVAILABLE;
 
-    struct stream_cache_info info = {0};
-    demux_stream_control(mpctx->demuxer, STREAM_CTRL_GET_CACHE_INFO, &info);
-    if (info.size <= 0)
+    struct demux_ctrl_reader_state s;
+    if (demux_control(mpctx->demuxer, DEMUXER_CTRL_GET_READER_STATE, &s) < 1)
         return M_PROPERTY_UNAVAILABLE;
 
+    uint64_t val = s.bytes_per_second;
+
     if (action == M_PROPERTY_PRINT) {
-        *(char **)arg = talloc_strdup_append(format_file_size(info.speed), "/s");
+        *(char **)arg = talloc_strdup_append(format_file_size(val), "/s");
         return M_PROPERTY_OK;
     }
-    return m_property_int64_ro(action, arg, info.speed);
-}
-
-static int mp_property_cache_idle(void *ctx, struct m_property *prop,
-                                  int action, void *arg)
-{
-    MPContext *mpctx = ctx;
-    struct stream_cache_info info = {0};
-    if (mpctx->demuxer)
-        demux_stream_control(mpctx->demuxer, STREAM_CTRL_GET_CACHE_INFO, &info);
-    if (info.size <= 0)
-        return M_PROPERTY_UNAVAILABLE;
-    return m_property_flag_ro(action, arg, info.idle);
+    return m_property_int64_ro(action, arg, val);
 }
 
 static int mp_property_demuxer_cache_duration(void *ctx, struct m_property *prop,
@@ -2004,14 +1758,21 @@
     if (action == M_PROPERTY_PRINT) {
         create_hotplug(mpctx);
 
+        char *name = NULL;
+        if (mp_property_generic_option(mpctx, prop, M_PROPERTY_GET, &name) < 1)
+            name = NULL;
+
         struct ao_device_list *list = ao_hotplug_get_device_list(cmd->hotplug);
         for (int n = 0; n < list->num_devices; n++) {
             struct ao_device_desc *dev = &list->devices[n];
-            if (dev->name && strcmp(dev->name, mpctx->opts->audio_device) == 0) {
+            if (dev->name && name && strcmp(dev->name, name) == 0) {
                 *(char **)arg = talloc_strdup(NULL, dev->desc ? dev->desc : "?");
+                talloc_free(name);
                 return M_PROPERTY_OK;
             }
         }
+
+        talloc_free(name);
     }
     return mp_property_generic_option(mpctx, prop, action, arg);
 }
@@ -2045,12 +1806,13 @@
     case M_PROPERTY_PRINT:
         *(char **)arg = format_delay(delay);
         return M_PROPERTY_OK;
-    case M_PROPERTY_SET:
-        mpctx->opts->audio_delay = *(float *)arg;
+    case M_PROPERTY_SET: {
+        int r = mp_property_generic_option(mpctx, prop, action, arg);
         if (mpctx->ao_chain && mpctx->vo_chain)
             mpctx->delay += mpctx->opts->audio_delay - delay;
         mp_wakeup_core(mpctx);
-        return M_PROPERTY_OK;
+        return r;
+    }
     }
     return mp_property_generic_option(mpctx, prop, action, arg);
 }
@@ -2250,6 +2012,8 @@
         {"default",     SUB_PROP_FLAG(track->default_track)},
         {"forced",      SUB_PROP_FLAG(track->forced_track)},
         {"dependent",   SUB_PROP_FLAG(track->dependent_track)},
+        {"visual-impaired",  SUB_PROP_FLAG(track->visual_impaired_track)},
+        {"hearing-impaired", SUB_PROP_FLAG(track->hearing_impaired_track)},
         {"external",    SUB_PROP_FLAG(track->is_external)},
         {"selected",    SUB_PROP_FLAG(track->selected)},
         {"external-filename", SUB_PROP_STR(track->external_filename),
@@ -2349,81 +2113,26 @@
     return property_switch_track(prop, action, arg, ctx, 0, STREAM_VIDEO);
 }
 
-static struct track *find_track_by_demuxer_id(MPContext *mpctx,
-                                              enum stream_type type,
-                                              int demuxer_id)
-{
-    for (int n = 0; n < mpctx->num_tracks; n++) {
-        struct track *track = mpctx->tracks[n];
-        if (track->type == type && track->demuxer_id == demuxer_id)
-            return track;
-    }
-    return NULL;
-}
-
-static int mp_property_program(void *ctx, struct m_property *prop,
-                               int action, void *arg)
-{
-    MPContext *mpctx = ctx;
-    demux_program_t prog = {0};
-
-    struct demuxer *demuxer = mpctx->demuxer;
-    if (!demuxer || !mpctx->playback_initialized)
-        return M_PROPERTY_UNAVAILABLE;
-
-    switch (action) {
-    case M_PROPERTY_SWITCH:
-    case M_PROPERTY_SET:
-        if (action == M_PROPERTY_SET && arg)
-            prog.progid = *((int *) arg);
-        else
-            prog.progid = -1;
-        if (demux_control(demuxer, DEMUXER_CTRL_IDENTIFY_PROGRAM, &prog) ==
-            CONTROL_UNKNOWN)
-            return M_PROPERTY_ERROR;
-
-        if (prog.aid < 0 && prog.vid < 0) {
-            MP_ERR(mpctx, "Selected program contains no audio or video streams!\n");
-            return M_PROPERTY_ERROR;
-        }
-        mp_switch_track(mpctx, STREAM_VIDEO,
-                find_track_by_demuxer_id(mpctx, STREAM_VIDEO, prog.vid), 0);
-        mp_switch_track(mpctx, STREAM_AUDIO,
-                find_track_by_demuxer_id(mpctx, STREAM_AUDIO, prog.aid), 0);
-        mp_switch_track(mpctx, STREAM_SUB,
-                find_track_by_demuxer_id(mpctx, STREAM_VIDEO, prog.sid), 0);
-        print_track_list(mpctx, "Program switched:");
-        return M_PROPERTY_OK;
-    case M_PROPERTY_GET_TYPE:
-        *(struct m_option *)arg = (struct m_option){
-            .type = CONF_TYPE_INT,
-            .flags = CONF_RANGE,
-            .min = -1,
-            .max = (1 << 16) - 1,
-        };
-        return M_PROPERTY_OK;
-    }
-    return M_PROPERTY_NOT_IMPLEMENTED;
-}
-
 static int mp_property_hwdec(void *ctx, struct m_property *prop,
                              int action, void *arg)
 {
     MPContext *mpctx = ctx;
     struct track *track = mpctx->current_track[0][STREAM_VIDEO];
     struct mp_decoder_wrapper *dec = track ? track->dec : NULL;
-    struct MPOpts *opts = mpctx->opts;
 
     if (action == M_PROPERTY_SET) {
         char *new = *(char **)arg;
+        char *old = NULL;
+        if (mp_property_generic_option(mpctx, prop, M_PROPERTY_GET, &old) < 1)
+            old = NULL;
 
-        if (strcmp(opts->hwdec_api, new) == 0)
-            return M_PROPERTY_OK;
+        bool same = bstr_equals(bstr0(old), bstr0(new));
 
-        talloc_free(opts->hwdec_api);
-        opts->hwdec_api = talloc_strdup(NULL, new);
+        mp_property_generic_option(mpctx, prop, M_PROPERTY_SET, &new);
 
-        if (!dec)
+        talloc_free(old);
+
+        if (!dec || same)
             return M_PROPERTY_OK;
 
         mp_decoder_wrapper_control(dec, VDCTRL_REINIT, NULL);
@@ -3113,163 +2822,6 @@
     return r;
 }
 
-static int prop_stream_ctrl(struct MPContext *mpctx, int ctrl, void *arg)
-{
-    if (!mpctx->demuxer)
-        return M_PROPERTY_UNAVAILABLE;
-    int r = demux_stream_control(mpctx->demuxer, ctrl, arg);
-    switch (r) {
-    case STREAM_OK: return M_PROPERTY_OK;
-    case STREAM_UNSUPPORTED: return M_PROPERTY_UNAVAILABLE;
-    default: return M_PROPERTY_ERROR;
-    }
-}
-
-static int mp_property_tv_norm(void *ctx, struct m_property *prop,
-                               int action, void *arg)
-{
-    switch (action) {
-    case M_PROPERTY_SET:
-        return prop_stream_ctrl(ctx, STREAM_CTRL_TV_SET_NORM, *(char **)arg);
-    case M_PROPERTY_SWITCH:
-        return prop_stream_ctrl(ctx, STREAM_CTRL_TV_STEP_NORM, NULL);
-    case M_PROPERTY_GET_TYPE:
-        *(struct m_option *)arg = (struct m_option){.type = CONF_TYPE_STRING};
-        return M_PROPERTY_OK;
-    }
-    return M_PROPERTY_NOT_IMPLEMENTED;
-}
-
-static int mp_property_tv_scan(void *ctx, struct m_property *prop,
-                               int action, void *arg)
-{
-    switch (action) {
-    case M_PROPERTY_SET:
-        return prop_stream_ctrl(ctx, STREAM_CTRL_TV_SET_SCAN, arg);
-    case M_PROPERTY_GET_TYPE:
-        *(struct m_option *)arg = (struct m_option){.type = CONF_TYPE_FLAG};
-        return M_PROPERTY_OK;
-    }
-    return M_PROPERTY_NOT_IMPLEMENTED;
-}
-
-/// TV color settings (RW)
-static int mp_property_tv_color(void *ctx, struct m_property *prop,
-                                int action, void *arg)
-{
-    int req[2] = {(intptr_t)prop->priv};
-    switch (action) {
-    case M_PROPERTY_SET:
-        req[1] = *(int *)arg;
-        return prop_stream_ctrl(ctx, STREAM_CTRL_SET_TV_COLORS, req);
-    case M_PROPERTY_GET: {
-        int r = prop_stream_ctrl(ctx, STREAM_CTRL_GET_TV_COLORS, req);
-        if (r == M_PROPERTY_OK)
-            *(int *)arg = req[1];
-        return r;
-    }
-    case M_PROPERTY_GET_TYPE:
-        *(struct m_option *)arg = (struct m_option){
-            .type = CONF_TYPE_INT,
-            .flags = M_OPT_RANGE,
-            .min = -100,
-            .max = 100,
-        };
-        return M_PROPERTY_OK;
-    }
-    return M_PROPERTY_NOT_IMPLEMENTED;
-}
-
-static int mp_property_tv_freq(void *ctx, struct m_property *prop,
-                               int action, void *arg)
-{
-    switch (action) {
-    case M_PROPERTY_SET:
-        return prop_stream_ctrl(ctx, STREAM_CTRL_SET_TV_FREQ, arg);
-    case M_PROPERTY_GET:
-        return prop_stream_ctrl(ctx, STREAM_CTRL_GET_TV_FREQ, arg);
-    case M_PROPERTY_GET_TYPE:
-        *(struct m_option *)arg = (struct m_option){.type = CONF_TYPE_FLOAT};
-        return M_PROPERTY_OK;
-    }
-    return M_PROPERTY_NOT_IMPLEMENTED;
-}
-
-static int mp_property_tv_channel(void *ctx, struct m_property *prop,
-                                  int action, void *arg)
-{
-    switch (action) {
-    case M_PROPERTY_GET_TYPE:
-        *(struct m_option *)arg = (struct m_option){.type = CONF_TYPE_STRING};
-        return M_PROPERTY_OK;
-    case M_PROPERTY_SET:
-        return prop_stream_ctrl(ctx, STREAM_CTRL_TV_SET_CHAN, *(char **)arg);
-    case M_PROPERTY_GET:
-        return prop_stream_ctrl(ctx, STREAM_CTRL_TV_GET_CHAN, arg);
-    case M_PROPERTY_SWITCH: {
-        struct m_property_switch_arg *sa = arg;
-        int dir = sa->inc >= 0 ? 1 : -1;
-        return prop_stream_ctrl(ctx, STREAM_CTRL_TV_STEP_CHAN, &dir);
-    }
-    }
-    return M_PROPERTY_NOT_IMPLEMENTED;
-}
-
-static int mp_property_dvb_channel(void *ctx, struct m_property *prop,
-                                   int action, void *arg)
-{
-    MPContext *mpctx = ctx;
-    int r;
-    switch (action) {
-    case M_PROPERTY_SET:
-        r = prop_stream_ctrl(mpctx, STREAM_CTRL_DVB_SET_CHANNEL, arg);
-        if (r == M_PROPERTY_OK && !mpctx->stop_play)
-            mpctx->stop_play = PT_CURRENT_ENTRY;
-        return r;
-    case M_PROPERTY_SWITCH: {
-        struct m_property_switch_arg *sa = arg;
-        int dir = sa->inc >= 0 ? 1 : -1;
-        r = prop_stream_ctrl(mpctx, STREAM_CTRL_DVB_STEP_CHANNEL, &dir);
-        if (r == M_PROPERTY_OK && !mpctx->stop_play)
-            mpctx->stop_play = PT_CURRENT_ENTRY;
-        return r;
-    }
-    case M_PROPERTY_GET_TYPE:
-        *(struct m_option *)arg = (struct m_option){.type = &m_option_type_intpair};
-        return M_PROPERTY_OK;
-    }
-    return M_PROPERTY_NOT_IMPLEMENTED;
-}
-
-static int mp_property_dvb_channel_name(void *ctx, struct m_property *prop,
-                                        int action, void *arg)
-{
-    MPContext *mpctx = ctx;
-    int r;
-    switch (action) {
-    case M_PROPERTY_SET:
-        r = prop_stream_ctrl(mpctx, STREAM_CTRL_DVB_SET_CHANNEL_NAME, arg);
-        if (r == M_PROPERTY_OK && !mpctx->stop_play)
-            mpctx->stop_play = PT_CURRENT_ENTRY;
-        return r;
-    case M_PROPERTY_SWITCH: {
-        struct m_property_switch_arg *sa = arg;
-        int dir = sa->inc >= 0 ? 1 : -1;
-        r = prop_stream_ctrl(mpctx, STREAM_CTRL_DVB_STEP_CHANNEL, &dir);
-        if (r == M_PROPERTY_OK && !mpctx->stop_play)
-            mpctx->stop_play = PT_CURRENT_ENTRY;
-        return r;
-    }
-    case M_PROPERTY_GET: {
-        return prop_stream_ctrl(mpctx, STREAM_CTRL_DVB_GET_CHANNEL_NAME, arg);
-    }
-    case M_PROPERTY_GET_TYPE:
-        *(struct m_option *)arg = (struct m_option){.type = CONF_TYPE_STRING};
-        return M_PROPERTY_OK;
-    }
-    return M_PROPERTY_NOT_IMPLEMENTED;
-}
-
 static int mp_property_playlist_pos_x(void *ctx, struct m_property *prop,
                                       int action, void *arg, int base)
 {
@@ -3728,12 +3280,13 @@
         struct m_config_option *co = m_config_get_co(mpctx->mconfig, key);
         if (!co)
             return M_PROPERTY_UNKNOWN;
+        const struct m_option *opt = co->opt;
 
         union m_option_value def = {0};
-        if (co->default_data)
-            memcpy(&def, co->default_data, co->opt->type->size);
+        const void *def_ptr = m_config_get_co_default(mpctx->mconfig, co);
+        if (def_ptr && opt->type->size > 0)
+            memcpy(&def, def_ptr, opt->type->size);
 
-        const struct m_option *opt = co->opt;
         bool has_minmax =
             opt->type == &m_option_type_int ||
             opt->type == &m_option_type_int64 ||
@@ -3866,13 +3419,10 @@
     {"audio-pts", mp_property_audio_pts},
     {"playtime-remaining", mp_property_playtime_remaining},
     {"playback-time", mp_property_playback_time},
-    {"disc-title", mp_property_disc_title},
     {"chapter", mp_property_chapter},
     {"edition", mp_property_edition},
-    {"disc-titles", mp_property_disc_titles},
     {"chapters", mp_property_chapters},
     {"editions", mp_property_editions},
-    {"angle", mp_property_angle},
     {"metadata", mp_property_metadata},
     {"filtered-metadata", mp_property_filtered_metadata},
     {"chapter-metadata", mp_property_chapter_metadata},
@@ -3883,11 +3433,6 @@
     {"eof-reached", mp_property_eof_reached},
     {"seeking", mp_property_seeking},
     {"playback-abort", mp_property_playback_abort},
-    {"cache-percent", mp_property_cache},
-    {"cache-free", mp_property_cache_free},
-    {"cache-used", mp_property_cache_used},
-    {"cache-size", mp_property_cache_size},
-    {"cache-idle", mp_property_cache_idle},
     {"cache-speed", mp_property_cache_speed},
     {"demuxer-cache-duration", mp_property_demuxer_cache_duration},
     {"demuxer-cache-time", mp_property_demuxer_cache_time},
@@ -3905,7 +3450,6 @@
     {"chapter-list", mp_property_list_chapters},
     {"track-list", property_list_tracks},
     {"edition-list", property_list_editions},
-    {"disc-title-list", mp_property_list_disc_titles},
 
     {"playlist", mp_property_playlist},
     {"playlist-pos", mp_property_playlist_pos},
@@ -3952,7 +3496,6 @@
     {"estimated-vf-fps", mp_property_vf_fps},
     {"video-aspect", mp_property_aspect},
     {"vid", mp_property_video},
-    {"program", mp_property_program},
     {"hwdec", mp_property_hwdec},
     {"hwdec-current", mp_property_hwdec_current},
     {"hwdec-interop", mp_property_hwdec_interop},
@@ -3991,19 +3534,6 @@
     PROPERTY_BITRATE("audio-bitrate", false, STREAM_AUDIO),
     PROPERTY_BITRATE("sub-bitrate", false, STREAM_SUB),
 
-#define PROPERTY_TV_COLOR(name, type) \
-    {name, mp_property_tv_color, (void *)(intptr_t)type}
-    PROPERTY_TV_COLOR("tv-brightness", TV_COLOR_BRIGHTNESS),
-    PROPERTY_TV_COLOR("tv-contrast", TV_COLOR_CONTRAST),
-    PROPERTY_TV_COLOR("tv-saturation", TV_COLOR_SATURATION),
-    PROPERTY_TV_COLOR("tv-hue", TV_COLOR_HUE),
-    {"tv-freq", mp_property_tv_freq},
-    {"tv-norm", mp_property_tv_norm},
-    {"tv-scan", mp_property_tv_scan},
-    {"tv-channel", mp_property_tv_channel},
-    {"dvb-channel", mp_property_dvb_channel},
-    {"dvb-channel-name", mp_property_dvb_channel_name},
-
     {"cursor-autohide", mp_property_cursor_autohide},
 
     {"window-minimized", mp_property_win_minimized},
@@ -4149,6 +3679,7 @@
     case M_PROPERTY_SWITCH:
     case M_PROPERTY_SET_STRING:
     case M_PROPERTY_SET_NODE:
+    case M_PROPERTY_MULTIPLY:
         return true;
     case M_PROPERTY_KEY_ACTION: {
         struct m_property_action_arg *key = val;
@@ -4825,19 +4356,165 @@
     change_property_cmd(cmd, name, M_PROPERTY_SET_STRING, cmd->args[current].v.s);
 }
 
-int run_command(struct MPContext *mpctx, struct mp_cmd *cmd, struct mpv_node *res)
+struct cmd_list_ctx {
+    struct MPContext *mpctx;
+
+    // actual list command
+    struct mp_cmd_ctx *parent;
+
+    bool current_valid;
+    pthread_t current;
+    bool completed_recursive;
+
+    // list of sub commands yet to run
+    struct mp_cmd **sub;
+    int num_sub;
+};
+
+static void continue_cmd_list(struct cmd_list_ctx *list);
+
+static void on_cmd_list_sub_completion(struct mp_cmd_ctx *cmd)
 {
-    struct mpv_node dummy_node = {0};
-    struct mp_cmd_ctx *ctx = &(struct mp_cmd_ctx){
+    struct cmd_list_ctx *list = cmd->on_completion_priv;
+
+    if (list->current_valid && pthread_equal(list->current, pthread_self())) {
+        list->completed_recursive = true;
+    } else {
+        continue_cmd_list(list);
+    }
+}
+
+static void continue_cmd_list(struct cmd_list_ctx *list)
+{
+    while (list->parent->args[0].v.p) {
+        struct mp_cmd *sub = list->parent->args[0].v.p;
+        list->parent->args[0].v.p = sub->queue_next;
+
+        ta_xset_parent(sub, NULL);
+
+        if (sub->flags & MP_ASYNC_CMD) {
+            // We run it "detached" (fire & forget)
+            run_command(list->mpctx, sub, NULL, NULL, NULL);
+        } else {
+            // Run the next command once this one completes.
+
+            list->completed_recursive = false;
+            list->current_valid = true;
+            list->current = pthread_self();
+
+            run_command(list->mpctx, sub, NULL, on_cmd_list_sub_completion, list);
+
+            list->current_valid = false;
+
+            // run_command() either recursively calls the completion function,
+            // or lets the command continue run in the background. If it was
+            // completed recursively, we can just continue our loop. Otherwise
+            // the completion handler will invoke this loop again elsewhere.
+            // We could unconditionally call continue_cmd_list() in the handler
+            // instead, but then stack depth would grow with list length.
+            if (!list->completed_recursive)
+                return;
+        }
+    }
+
+    mp_cmd_ctx_complete(list->parent);
+    talloc_free(list);
+}
+
+static void cmd_list(void *p)
+{
+    struct mp_cmd_ctx *cmd = p;
+
+    cmd->completed = false;
+
+    struct cmd_list_ctx *list = talloc_zero(NULL, struct cmd_list_ctx);
+    list->mpctx = cmd->mpctx;
+    list->parent = p;
+
+    continue_cmd_list(list);
+}
+
+const struct mp_cmd_def mp_cmd_list = { "list", cmd_list, .exec_async = true };
+
+// Signal that the command is complete now. This also deallocates cmd.
+// You must call this function in a state where the core is locked for the
+// current thread (e.g. from the main thread, or from within mp_dispatch_lock()).
+// Completion means the command is finished, even if it errored or never ran.
+// Keep in mind that calling this can execute further user command that can
+// change arbitrary state (due to cmd_list).
+void mp_cmd_ctx_complete(struct mp_cmd_ctx *cmd)
+{
+    cmd->completed = true;
+    if (!cmd->success)
+        mpv_free_node_contents(&cmd->result);
+    if (cmd->on_completion)
+        cmd->on_completion(cmd);
+    if (cmd->abort)
+        mp_abort_remove(cmd->mpctx, cmd->abort);
+    mpv_free_node_contents(&cmd->result);
+    talloc_free(cmd);
+}
+
+static void run_command_on_worker_thread(void *p)
+{
+    struct mp_cmd_ctx *ctx = p;
+    struct MPContext *mpctx = ctx->mpctx;
+
+    mp_core_lock(mpctx);
+
+    bool exec_async = ctx->cmd->def->exec_async;
+    ctx->cmd->def->handler(ctx);
+    if (!exec_async)
+        mp_cmd_ctx_complete(ctx);
+
+    mpctx->outstanding_async -= 1;
+    if (!mpctx->outstanding_async && mp_is_shutting_down(mpctx))
+        mp_wakeup_core(mpctx);
+
+    mp_core_unlock(mpctx);
+}
+
+// Run the given command. Upon command completion, on_completion is called. This
+// can happen within the function, or for async commands, some time after the
+// function returns (the caller is supposed to be able to handle both cases). In
+// both cases, the callback will be called while the core is locked (i.e. you
+// can access the core freely).
+// If abort is non-NULL, then the caller creates the abort object. It must have
+// been allocated with talloc. run_command() will register/unregister/destroy
+// it. Must not be set if cmd->def->can_abort==false.
+// on_completion_priv is copied to mp_cmd_ctx.on_completion_priv and can be
+// accessed from the completion callback.
+// The completion callback is invoked exactly once. If it's NULL, it's ignored.
+// Ownership of cmd goes to the caller.
+void run_command(struct MPContext *mpctx, struct mp_cmd *cmd,
+                 struct mp_abort_entry *abort,
+                 void (*on_completion)(struct mp_cmd_ctx *cmd),
+                 void *on_completion_priv)
+{
+    struct mp_cmd_ctx *ctx = talloc(NULL, struct mp_cmd_ctx);
+    *ctx = (struct mp_cmd_ctx){
         .mpctx = mpctx,
-        .cmd = cmd,
+        .cmd = talloc_steal(ctx, cmd),
         .args = cmd->args,
         .num_args = cmd->nargs,
         .priv = cmd->def->priv,
+        .abort = talloc_steal(ctx, abort),
         .success = true,
-        .result = res ? res : &dummy_node,
+        .completed = true,
+        .on_completion = on_completion,
+        .on_completion_priv = on_completion_priv,
     };
 
+    if (!ctx->abort && cmd->def->can_abort)
+        ctx->abort = talloc_zero(ctx, struct mp_abort_entry);
+
+    assert(cmd->def->can_abort == !!ctx->abort);
+
+    if (ctx->abort) {
+        ctx->abort->coupled_to_playback |= cmd->def->abort_on_playback_end;
+        mp_abort_add(mpctx, ctx->abort);
+    }
+
     struct MPOpts *opts = mpctx->opts;
     ctx->on_osd = cmd->flags & MP_ON_OSD_FLAGS;
     bool auto_osd = ctx->on_osd == MP_ON_OSD_AUTO;
@@ -4853,28 +4530,32 @@
         for (int n = 0; n < cmd->nargs; n++) {
             if (cmd->args[n].type->type == CONF_TYPE_STRING) {
                 char *s = mp_property_expand_string(mpctx, cmd->args[n].v.s);
-                if (!s)
-                    return -1;
+                if (!s) {
+                    ctx->success = false;
+                    mp_cmd_ctx_complete(ctx);
+                    return;
+                }
                 talloc_free(cmd->args[n].v.s);
                 cmd->args[n].v.s = s;
             }
         }
     }
 
-    if (cmd->def == &mp_cmd_list) {
-        for (struct mp_cmd *sub = cmd->args[0].v.p; sub; sub = sub->queue_next)
-            run_command(mpctx, sub, NULL);
+    if (cmd->def->spawn_thread) {
+        mpctx->outstanding_async += 1; // prevent that core disappears
+        if (!mp_thread_pool_queue(mpctx->thread_pool,
+                                  run_command_on_worker_thread, ctx))
+        {
+            mpctx->outstanding_async -= 1;
+            ctx->success = false;
+            mp_cmd_ctx_complete(ctx);
+        }
     } else {
-        assert(cmd->def->handler);
+        bool exec_async = cmd->def->exec_async;
         cmd->def->handler(ctx);
+        if (!exec_async)
+            mp_cmd_ctx_complete(ctx);
     }
-
-    if (!ctx->success)
-        mpv_free_node_contents(ctx->result);
-
-    mpv_free_node_contents(&dummy_node);
-
-    return ctx->success ? 0 : -1;
 }
 
 static void cmd_seek(void *p)
@@ -5195,7 +4876,7 @@
     struct mp_cmd_ctx *cmd = p;
     struct MPContext *mpctx = cmd->mpctx;
 
-    *cmd->result = (mpv_node){
+    cmd->result = (mpv_node){
         .format = MPV_FORMAT_STRING,
         .u.string = mp_property_expand_string(mpctx, cmd->args[0].v.s)
     };
@@ -5235,7 +4916,8 @@
     char *filename = cmd->args[0].v.s;
     bool append = cmd->args[1].v.i;
 
-    struct playlist *pl = playlist_parse_file(filename, mpctx->global);
+    struct playlist *pl = playlist_parse_file(filename, cmd->abort->cancel,
+                                              mpctx->global);
     if (pl) {
         prepare_playlist(mpctx, pl);
         struct playlist_entry *new = pl->current;
@@ -5348,26 +5030,13 @@
     mp_wakeup_core(mpctx);
 }
 
-static void cmd_tv_last_channel(void *p)
-{
-    struct mp_cmd_ctx *cmd = p;
-    struct MPContext *mpctx = cmd->mpctx;
-
-    if (!mpctx->demuxer) {
-        cmd->success = false;
-        return;
-    }
-
-    demux_stream_control(mpctx->demuxer, STREAM_CTRL_TV_LAST_CHAN, NULL);
-}
-
 static void cmd_track_add(void *p)
 {
     struct mp_cmd_ctx *cmd = p;
     struct MPContext *mpctx = cmd->mpctx;
     int type = *(int *)cmd->priv;
 
-    if (!mpctx->playing) {
+    if (mpctx->stop_play) {
         cmd->success = false;
         return;
     }
@@ -5384,7 +5053,8 @@
             return;
         }
     }
-    int first = mp_add_external_file(mpctx, cmd->args[0].v.s, type);
+    int first = mp_add_external_file(mpctx, cmd->args[0].v.s, type,
+                                     cmd->abort->cancel);
     if (first < 0) {
         cmd->success = false;
         return;
@@ -5448,7 +5118,7 @@
     if (t && t->is_external && t->external_filename) {
         char *filename = talloc_strdup(NULL, t->external_filename);
         mp_remove_track(mpctx, t);
-        nt_num = mp_add_external_file(mpctx, filename, type);
+        nt_num = mp_add_external_file(mpctx, filename, type, cmd->abort->cancel);
         talloc_free(filename);
     }
 
@@ -5467,13 +5137,13 @@
     struct mp_cmd_ctx *cmd = p;
     struct MPContext *mpctx = cmd->mpctx;
 
-    if (!mpctx->playing) {
+    if (mpctx->stop_play) {
         cmd->success = false;
         return;
     }
 
-    autoload_external_files(mpctx);
-    if (cmd->args[0].v.i && mpctx->playback_initialized) {
+    autoload_external_files(mpctx, cmd->abort->cancel);
+    if (!cmd->args[0].v.i && mpctx->playback_initialized) {
         // somewhat fuzzy and not ideal
         struct track *a = select_default_track(mpctx, 0, STREAM_AUDIO);
         if (a && a->is_external)
@@ -5486,60 +5156,101 @@
     }
 }
 
-static void cmd_screenshot(void *p)
+static void cmd_run(void *p)
 {
     struct mp_cmd_ctx *cmd = p;
     struct MPContext *mpctx = cmd->mpctx;
-    bool async = cmd->cmd->flags & MP_ASYNC_CMD;
-    int mode = cmd->args[0].v.i & 3;
-    int freq = (cmd->args[0].v.i | cmd->args[1].v.i) >> 3;
-    screenshot_request(mpctx, mode, freq, cmd->msg_osd, async);
+    char **args = talloc_zero_array(NULL, char *, cmd->num_args + 1);
+    for (int n = 0; n < cmd->num_args; n++)
+        args[n] = cmd->args[n].v.s;
+    mp_subprocess_detached(mpctx->log, args);
+    talloc_free(args);
 }
 
-static void cmd_screenshot_to_file(void *p)
+struct subprocess_cb_ctx {
+    struct mp_log *log;
+    void* talloc_ctx;
+    int64_t max_size;
+    bool capture[3];
+    bstr output[3];
+};
+
+static void subprocess_output(struct subprocess_cb_ctx *ctx, int fd,
+                              char *data, size_t size)
 {
-    struct mp_cmd_ctx *cmd = p;
-    struct MPContext *mpctx = cmd->mpctx;
-    bool async = cmd->cmd->flags & MP_ASYNC_CMD;
-    screenshot_to_file(mpctx, cmd->args[0].v.s, cmd->args[1].v.i, cmd->msg_osd,
-                       async);
+    if (ctx->capture[fd]) {
+        if (ctx->output[fd].len < ctx->max_size)
+            bstr_xappend(ctx->talloc_ctx, &ctx->output[fd], (bstr){data, size});
+    } else {
+        int msgl = fd == 2 ? MSGL_ERR : MSGL_INFO;
+        mp_msg(ctx->log, msgl, "%.*s", (int)size, data);
+    }
+}
+
+static void subprocess_stdout(void *p, char *data, size_t size)
+{
+    struct subprocess_cb_ctx *ctx = p;
+    subprocess_output(ctx, 1, data, size);
 }
 
-static void cmd_screenshot_raw(void *p)
+static void subprocess_stderr(void *p, char *data, size_t size)
+{
+    struct subprocess_cb_ctx *ctx = p;
+    subprocess_output(ctx, 2, data, size);
+}
+
+static void cmd_subprocess(void *p)
 {
     struct mp_cmd_ctx *cmd = p;
     struct MPContext *mpctx = cmd->mpctx;
-    struct mpv_node *res = cmd->result;
+    char **args = cmd->args[0].v.str_list;
+    bool playback_only = cmd->args[1].v.i;
 
-    struct mp_image *img = screenshot_get_rgb(mpctx, cmd->args[0].v.i);
-    if (!img) {
+    if (!args || !args[0]) {
+        MP_ERR(mpctx, "program name missing\n");
         cmd->success = false;
         return;
     }
 
-    node_init(res, MPV_FORMAT_NODE_MAP, NULL);
-    node_map_add_int64(res, "w", img->w);
-    node_map_add_int64(res, "h", img->h);
-    node_map_add_int64(res, "stride", img->stride[0]);
-    node_map_add_string(res, "format", "bgr0");
-    struct mpv_byte_array *ba =
-        node_map_add(res, "data", MPV_FORMAT_BYTE_ARRAY)->u.ba;
-    *ba = (struct mpv_byte_array){
-        .data = img->planes[0],
-        .size = img->stride[0] * img->h,
+    void *tmp = talloc_new(NULL);
+    struct subprocess_cb_ctx ctx = {
+        .log = mp_log_new(tmp, mpctx->log, cmd->cmd->sender),
+        .talloc_ctx = tmp,
+        .max_size = cmd->args[2].v.i,
+        .capture = {0, cmd->args[3].v.i, cmd->args[4].v.i},
     };
-    talloc_steal(ba, img);
-}
 
-static void cmd_run(void *p)
-{
-    struct mp_cmd_ctx *cmd = p;
-    struct MPContext *mpctx = cmd->mpctx;
-    char **args = talloc_zero_array(NULL, char *, cmd->num_args + 1);
-    for (int n = 0; n < cmd->num_args; n++)
-        args[n] = cmd->args[n].v.s;
-    mp_subprocess_detached(mpctx->log, args);
-    talloc_free(args);
+    pthread_mutex_lock(&mpctx->abort_lock);
+    cmd->abort->coupled_to_playback = playback_only;
+    mp_abort_recheck_locked(mpctx, cmd->abort);
+    pthread_mutex_unlock(&mpctx->abort_lock);
+
+    mp_core_unlock(mpctx);
+
+    char *error = NULL;
+    int status = mp_subprocess(args, cmd->abort->cancel, &ctx,
+                               subprocess_stdout, subprocess_stderr, &error);
+
+    mp_core_lock(mpctx);
+
+    struct mpv_node *res = &cmd->result;
+    node_init(res, MPV_FORMAT_NODE_MAP, NULL);
+    node_map_add_int64(res, "status", status);
+    node_map_add_flag(res, "killed_by_us", status == MP_SUBPROCESS_EKILLED_BY_US);
+    node_map_add_string(res, "error_string", error ? error : "");
+    const char *sname[] = {NULL, "stdout", "stderr"};
+    for (int n = 1; n < 3; n++) {
+        if (!ctx.capture[n])
+            continue;
+        struct mpv_byte_array *ba =
+            node_map_add(res, sname[n], MPV_FORMAT_BYTE_ARRAY)->u.ba;
+        *ba = (struct mpv_byte_array){
+            .data = talloc_steal(ba, ctx.output[n].start),
+            .size = ctx.output[n].len,
+        };
+    }
+
+    talloc_free(tmp);
 }
 
 static void cmd_enable_input_section(void *p)
@@ -5561,7 +5272,7 @@
     struct mp_cmd_ctx *cmd = p;
     struct MPContext *mpctx = cmd->mpctx;
     mp_input_define_section(mpctx->input, cmd->args[0].v.s, "<api>",
-                            cmd->args[1].v.s, !!cmd->args[2].v.i,
+                            cmd->args[1].v.s, !cmd->args[2].v.i,
                             cmd->cmd->sender);
 }
 
@@ -5814,239 +5525,329 @@
         cmd->success = false;
 }
 
-// This does not specify the real destination of the command parameter values,
-// it just provides a dummy for the OPT_ macros.
-#define OPT_BASE_STRUCT struct mp_cmd_arg
-#define ARG(t) "", v. t
-
 /* This array defines all known commands.
- * The first field is an id used to recognize the command.
- * The second is the command name used in slave mode and input.conf.
- * Then comes the definition of each argument, first mandatory arguments
- * (ARG_INT, ARG_FLOAT, ARG_STRING) if any, then optional arguments
- * (OARG_INT(default), etc) if any. The command will be given the default
- * argument value if the user didn't give enough arguments to specify it.
- * A command can take a maximum of MP_CMD_DEF_MAX_ARGS arguments, or more
- * if the command uses varargs.
+ * The first field the command name used in libmpv and input.conf.
+ * The second field is the handler function (see mp_cmd_def.handler and
+ * run_command()).
+ * Then comes the definition of each argument. They are defined like options,
+ * except that the result is parsed into mp_cmd.args[] (thus the option variable
+ * is a field in the mp_cmd_arg union field). Arguments are optional if either
+ * defval is set (usually via OPTDEF_ macros), or the MP_CMD_OPT_ARG flag is
+ * set, or if it's the last argument and .vararg is set. If .vararg is set, the
+ * command has an arbitrary number of arguments, all using the type indicated by
+ * the last argument (they are appended to mp_cmd.args[] starting at the last
+ * argument's index).
+ * Arguments have named, which can be used by named argument functions, e.g. in
+ * Lua with mp.command_native().
  */
 
-#define ARG_INT                 OPT_INT(ARG(i), 0)
-#define ARG_FLOAT               OPT_FLOAT(ARG(f), 0)
-#define ARG_DOUBLE              OPT_DOUBLE(ARG(d), 0)
-#define ARG_STRING              OPT_STRING(ARG(s), 0)
-#define ARG_CHOICE(c)           OPT_CHOICE(ARG(i), 0, c)
-#define ARG_CHOICE_OR_INT(...)  OPT_CHOICE_OR_INT(ARG(i), 0, __VA_ARGS__)
-#define ARG_TIME                OPT_TIME(ARG(d), 0)
-#define OARG_DOUBLE(def)        OPT_DOUBLE(ARG(d), 0, OPTDEF_DOUBLE(def))
-#define OARG_INT(def)           OPT_INT(ARG(i), 0, OPTDEF_INT(def))
-#define OARG_CHOICE(def, c)     OPT_CHOICE(ARG(i), 0, c, OPTDEF_INT(def))
-#define OARG_FLAGS(def, c)      OPT_FLAGS(ARG(i), 0, c, OPTDEF_INT(def))
-#define OARG_STRING(def)        OPT_STRING(ARG(s), 0, OPTDEF_STR(def))
-
-#define OARG_CYCLEDIR(def)      OPT_CYCLEDIR(ARG(d), 0, OPTDEF_DOUBLE(def))
+// This does not specify the real destination of the command parameter values,
+// it just provides a dummy for the OPT_ macros. The real destination is an
+// array item  in mp_cmd.args[], using the index of the option definition.
+#define OPT_BASE_STRUCT struct mp_cmd_arg
 
 const struct mp_cmd_def mp_cmds[] = {
     { "ignore", cmd_ignore, .is_ignore = true },
 
-    { "seek", cmd_seek, {
-        ARG_TIME,
-        OARG_FLAGS(4|0, ({"relative", 4|0}, {"-", 4|0},
-                         {"absolute-percent", 4|1},
-                         {"absolute", 4|2},
-                         {"relative-percent", 4|3},
-                         {"keyframes", 32|8},
-                         {"exact", 32|16})),
-        // backwards compatibility only
-        OARG_CHOICE(0, ({"unused", 0}, {"default-precise", 0},
+    { "seek", cmd_seek,
+        {
+            OPT_TIME("target", v.d, 0),
+            OPT_FLAGS("flags", v.i, 0,
+                      ({"relative", 4|0}, {"-", 4|0},
+                       {"absolute-percent", 4|1},
+                       {"absolute", 4|2},
+                       {"relative-percent", 4|3},
+                       {"keyframes", 32|8},
+                       {"exact", 32|16}),
+                      OPTDEF_INT(4|0)),
+            // backwards compatibility only
+            OPT_CHOICE("legacy", v.i, MP_CMD_OPT_ARG,
+                       ({"unused", 0}, {"default-precise", 0},
                         {"keyframes", 32|8},
                         {"exact", 32|16})),
         },
         .allow_auto_repeat = true,
         .scalable = true,
     },
-    { "revert-seek", cmd_revert_seek, {
-        OARG_FLAGS(0, ({"mark", 1})),
-    }},
-    { "quit", cmd_quit, { OARG_INT(0) },
-        .priv = &(const bool){0}, .is_abort = true },
-    { "quit-watch-later", cmd_quit, { OARG_INT(0) },
-        .priv = &(const bool){1}, .is_abort = true },
-    { "stop", cmd_stop, .is_abort = true },
+    { "revert-seek", cmd_revert_seek,
+        {OPT_FLAGS("flags", v.i, MP_CMD_OPT_ARG, ({"mark", 1}))},
+    },
+    { "quit", cmd_quit, { OPT_INT("code", v.i, MP_CMD_OPT_ARG) },
+        .priv = &(const bool){0} },
+    { "quit-watch-later", cmd_quit, { OPT_INT("code", v.i, MP_CMD_OPT_ARG) },
+        .priv = &(const bool){1} },
+    { "stop", cmd_stop, },
     { "frame-step", cmd_frame_step, .allow_auto_repeat = true,
         .on_updown = true },
     { "frame-back-step", cmd_frame_back_step, .allow_auto_repeat = true },
-    { "playlist-next", cmd_playlist_next_prev, {
-            OARG_CHOICE(0, ({"weak", 0},
-                            {"force", 1})),
+    { "playlist-next", cmd_playlist_next_prev,
+        {
+            OPT_CHOICE("flags", v.i, MP_CMD_OPT_ARG, ({"weak", 0},
+                                                      {"force", 1})),
         },
-        .is_soft_abort = true, .priv = &(const int){1},
+        .priv = &(const int){1},
     },
-    { "playlist-prev", cmd_playlist_next_prev, {
-            OARG_CHOICE(0, ({"weak", 0},
-                            {"force", 1})),
+    { "playlist-prev", cmd_playlist_next_prev,
+        {
+            OPT_CHOICE("flags", v.i, MP_CMD_OPT_ARG, ({"weak", 0},
+                                                      {"force", 1})),
         },
-        .is_soft_abort = true, .priv = &(const int){-1},
+        .priv = &(const int){-1},
     },
     { "playlist-shuffle", cmd_playlist_shuffle, },
-    { "sub-step", cmd_sub_step_seek, { ARG_INT }, .allow_auto_repeat = true,
-        .priv = &(const bool){true} },
-    { "sub-seek", cmd_sub_step_seek, { ARG_INT }, .allow_auto_repeat = true,
-        .priv = &(const bool){false} },
-    { "print-text", cmd_print_text, { ARG_STRING }, .allow_auto_repeat = true },
-    { "show-text", cmd_show_text, { ARG_STRING, OARG_INT(-1), OARG_INT(0) },
+    { "sub-step", cmd_sub_step_seek, { OPT_INT("skip", v.i, 0) },
+        .allow_auto_repeat = true, .priv = &(const bool){true} },
+    { "sub-seek", cmd_sub_step_seek, { OPT_INT("skip", v.i, 0) },
+        .allow_auto_repeat = true, .priv = &(const bool){false} },
+    { "print-text", cmd_print_text, { OPT_STRING("text", v.s, 0) },
+        .allow_auto_repeat = true },
+    { "show-text", cmd_show_text, { OPT_STRING("text", v.s, 0),
+                                    OPT_INT("duration", v.i, 0, OPTDEF_INT(-1)),
+                                    OPT_INT("level", v.i, MP_CMD_OPT_ARG), },
         .allow_auto_repeat = true},
-    { "expand-text", cmd_expand_text, { ARG_STRING } },
+    { "expand-text", cmd_expand_text, { OPT_STRING("text", v.s, 0) } },
     { "show-progress", cmd_show_progress, .allow_auto_repeat = true},
-    { "sub-add", cmd_track_add, {
-            ARG_STRING,
-            OARG_CHOICE(0, ({"select", 0}, {"auto", 1}, {"cached", 2})),
-            OARG_STRING(""), OARG_STRING(""),
+
+    { "sub-add", cmd_track_add,
+        {
+            OPT_STRING("url", v.s, 0),
+            OPT_CHOICE("flags", v.i, MP_CMD_OPT_ARG,
+                       ({"select", 0}, {"auto", 1}, {"cached", 2})),
+            OPT_STRING("title", v.s, MP_CMD_OPT_ARG),
+            OPT_STRING("lang", v.s, MP_CMD_OPT_ARG),
         },
         .priv = &(const int){STREAM_SUB},
+        .spawn_thread = true,
+        .can_abort = true,
+        .abort_on_playback_end = true,
     },
-    { "sub-remove", cmd_track_remove, { OARG_INT(-1) },
-        .priv = &(const int){STREAM_SUB}, },
-    { "sub-reload", cmd_track_reload, { OARG_INT(-1) },
+    { "audio-add", cmd_track_add,
+        {
+            OPT_STRING("url", v.s, 0),
+            OPT_CHOICE("flags", v.i, MP_CMD_OPT_ARG,
+                       ({"select", 0}, {"auto", 1}, {"cached", 2})),
+            OPT_STRING("title", v.s, MP_CMD_OPT_ARG),
+            OPT_STRING("lang", v.s, MP_CMD_OPT_ARG),
+        },
+        .priv = &(const int){STREAM_AUDIO},
+        .spawn_thread = true,
+        .can_abort = true,
+        .abort_on_playback_end = true,
+    },
+
+    { "sub-remove", cmd_track_remove, { OPT_INT("id", v.i, 0, OPTDEF_INT(-1)) },
         .priv = &(const int){STREAM_SUB}, },
+    { "audio-remove", cmd_track_remove, { OPT_INT("id", v.i, 0, OPTDEF_INT(-1)) },
+        .priv = &(const int){STREAM_AUDIO}, },
+
+    { "sub-reload", cmd_track_reload, { OPT_INT("id", v.i, 0, OPTDEF_INT(-1)) },
+        .priv = &(const int){STREAM_SUB},
+        .spawn_thread = true,
+        .can_abort = true,
+        .abort_on_playback_end = true,
+    },
+    { "audio-reload", cmd_track_reload, { OPT_INT("id", v.i, 0, OPTDEF_INT(-1)) },
+        .priv = &(const int){STREAM_AUDIO},
+        .spawn_thread = true,
+        .can_abort = true,
+        .abort_on_playback_end = true,
+    },
 
-    { "tv-last-channel", cmd_tv_last_channel, },
+    { "rescan-external-files", cmd_rescan_external_files,
+        {
+            OPT_CHOICE("flags", v.i, MP_CMD_OPT_ARG,
+                       ({"keep-selection", 1},
+                        {"reselect", 0})),
+        },
+        .spawn_thread = true,
+        .can_abort = true,
+        .abort_on_playback_end = true,
+    },
 
-    { "screenshot", cmd_screenshot, {
-        OARG_FLAGS(4|2, ({"video", 4|0}, {"-", 4|0},
-                         {"window", 4|1},
-                         {"subtitles", 4|2},
-                         {"each-frame", 8})),
-        // backwards compatibility
-        OARG_CHOICE(0, ({"unused", 0}, {"single", 0},
-                        {"each-frame", 8})),
-    }},
-    { "screenshot-to-file", cmd_screenshot_to_file, {
-        ARG_STRING,
-        OARG_CHOICE(2, ({"video", 0},
+    { "screenshot", cmd_screenshot,
+        {
+            OPT_FLAGS("flags", v.i, 0,
+                      ({"video", 4|0}, {"-", 4|0},
+                       {"window", 4|1},
+                       {"subtitles", 4|2},
+                       {"each-frame", 8}),
+                      OPTDEF_INT(4|2)),
+            // backwards compatibility
+            OPT_CHOICE("legacy", v.i, MP_CMD_OPT_ARG,
+                      ({"unused", 0}, {"single", 0},
+                       {"each-frame", 8})),
+        },
+        .spawn_thread = true,
+    },
+    { "screenshot-to-file", cmd_screenshot_to_file,
+        {
+            OPT_STRING("filename", v.s, 0),
+            OPT_CHOICE("flags", v.i, 0,
+                       ({"video", 0},
                         {"window", 1},
-                        {"subtitles", 2})),
-    }},
-    { "screenshot-raw", cmd_screenshot_raw, {
-        OARG_CHOICE(2, ({"video", 0},
+                        {"subtitles", 2}),
+                       OPTDEF_INT(2)),
+        },
+        .spawn_thread = true,
+    },
+    { "screenshot-raw", cmd_screenshot_raw,
+        {
+            OPT_CHOICE("flags", v.i, 0,
+                       ({"video", 0},
                         {"window", 1},
-                        {"subtitles", 2})),
-    }},
-    { "loadfile", cmd_loadfile, {
-        ARG_STRING,
-        OARG_CHOICE(0, ({"replace", 0},
+                        {"subtitles", 2}),
+                       OPTDEF_INT(2)),
+        },
+    },
+    { "loadfile", cmd_loadfile,
+        {
+            OPT_STRING("url", v.s, 0),
+            OPT_CHOICE("flags", v.i, MP_CMD_OPT_ARG,
+                       ({"replace", 0},
                         {"append", 1},
                         {"append-play", 2})),
-        OPT_KEYVALUELIST(ARG(str_list), MP_CMD_OPT_ARG),
-    }},
-    { "loadlist", cmd_loadlist, {
-        ARG_STRING,
-        OARG_CHOICE(0, ({"replace", 0},
-                        {"append", 1})),
-    }},
+            OPT_KEYVALUELIST("options", v.str_list, MP_CMD_OPT_ARG),
+        },
+    },
+    { "loadlist", cmd_loadlist, { OPT_STRING("url", v.s, 0),
+                                  OPT_CHOICE("flags", v.i, MP_CMD_OPT_ARG,
+                                             ({"replace", 0}, {"append", 1})), },
+        .spawn_thread = true,
+        .can_abort = true,
+    },
     { "playlist-clear", cmd_playlist_clear },
-    { "playlist-remove", cmd_playlist_remove, {
-        ARG_CHOICE_OR_INT(0, INT_MAX, ({"current", -1})),
-    }},
-    { "playlist-move", cmd_playlist_move, { ARG_INT, ARG_INT } },
-    { "run", cmd_run, { ARG_STRING, ARG_STRING }, .vararg = true },
-
-    { "set", cmd_set, { ARG_STRING,  ARG_STRING } },
-    { "change-list", cmd_change_list, { ARG_STRING, ARG_STRING, ARG_STRING } },
-    { "add", cmd_add_cycle, { ARG_STRING, OARG_DOUBLE(1) },
+    { "playlist-remove", cmd_playlist_remove,
+        {OPT_CHOICE_OR_INT("index", v.i, MP_CMD_OPT_ARG, 0, INT_MAX,
+                           ({"current", -1}))},
+    },
+    { "playlist-move", cmd_playlist_move,  { OPT_INT("index1", v.i, 0),
+                                             OPT_INT("index2", v.i, 0), }},
+    { "run", cmd_run, { OPT_STRING("command", v.s, 0),
+                        OPT_STRING("args", v.s, 0), },
+        .vararg = true,
+    },
+    { "subprocess", cmd_subprocess,
+        {
+            OPT_STRINGLIST("args", v.str_list, 0),
+            OPT_FLAG("playback_only", v.i, 0, OPTDEF_INT(1)),
+            OPT_BYTE_SIZE("capture_size", v.i64, 0, 0, INT_MAX,
+                          OPTDEF_INT64(64 * 1024 * 1024)),
+            OPT_FLAG("capture_stdout", v.i, MP_CMD_OPT_ARG),
+            OPT_FLAG("capture_stderr", v.i, MP_CMD_OPT_ARG),
+        },
+        .spawn_thread = true,
+        .can_abort = true,
+    },
+
+    { "set", cmd_set, {OPT_STRING("name", v.s, 0), OPT_STRING("value", v.s, 0)}},
+    { "change-list", cmd_change_list, { OPT_STRING("name", v.s, 0),
+                                        OPT_STRING("operation", v.s, 0),
+                                        OPT_STRING("value", v.s, 0) }},
+    { "add", cmd_add_cycle, { OPT_STRING("name", v.s, 0),
+                              OPT_DOUBLE("value", v.d, 0, OPTDEF_DOUBLE(1)), },
         .allow_auto_repeat = true,
         .scalable = true,
     },
-    { "cycle", cmd_add_cycle, {
-            ARG_STRING,
-            OARG_CYCLEDIR(1),
-        },
+    { "cycle", cmd_add_cycle, { OPT_STRING("name", v.s, 0),
+                                OPT_CYCLEDIR("value", v.d, 0, OPTDEF_DOUBLE(1)), },
         .allow_auto_repeat = true,
         .scalable = true,
         .priv = "",
     },
-    { "multiply", cmd_multiply, { ARG_STRING, ARG_DOUBLE },
+    { "multiply", cmd_multiply, { OPT_STRING("name", v.s, 0),
+                                  OPT_DOUBLE("value", v.d, 0)},
         .allow_auto_repeat = true},
 
-    { "cycle-values", cmd_cycle_values, { ARG_STRING, ARG_STRING, ARG_STRING },
+    { "cycle-values", cmd_cycle_values, { OPT_STRING("arg0", v.s, 0),
+                                          OPT_STRING("arg1", v.s, 0),
+                                          OPT_STRING("argN", v.s, 0), },
         .vararg = true},
 
-    { "enable-section", cmd_enable_input_section, {
-        ARG_STRING,
-        OARG_FLAGS(0, ({"default", 0},
+    { "enable-section", cmd_enable_input_section,
+        {
+            OPT_STRING("name", v.s, 0),
+            OPT_FLAGS("flags", v.i, MP_CMD_OPT_ARG,
+                      ({"default", 0},
                        {"exclusive", MP_INPUT_EXCLUSIVE},
                        {"allow-hide-cursor", MP_INPUT_ALLOW_HIDE_CURSOR},
                        {"allow-vo-dragging", MP_INPUT_ALLOW_VO_DRAGGING})),
-    }},
-    { "disable-section", cmd_disable_input_section, { ARG_STRING } },
-    { "define-section", cmd_define_input_section, {
-        ARG_STRING,
-        ARG_STRING,
-        OARG_CHOICE(1, ({"default", 1},
-                        {"force", 0})),
-    }},
+        }
+    },
+    { "disable-section", cmd_disable_input_section,
+        {OPT_STRING("name", v.s, 0) }},
+    { "define-section", cmd_define_input_section,
+        {
+            OPT_STRING("name", v.s, 0),
+            OPT_STRING("contents", v.s, 0),
+            OPT_CHOICE("flags", v.i, MP_CMD_OPT_ARG,
+                       ({"default", 0}, {"force", 1})),
+        },
+    },
 
     { "ab-loop", cmd_ab_loop },
 
     { "drop-buffers", cmd_drop_buffers, },
 
-    { "af", cmd_filter, { ARG_STRING, ARG_STRING },
-        .priv = &(const int){STREAM_AUDIO}, },
-    { "af-command", cmd_filter_command, { ARG_STRING, ARG_STRING, ARG_STRING },
-        .priv = &(const int){STREAM_AUDIO}, },
-    { "ao-reload", cmd_ao_reload },
+    { "af", cmd_filter, { OPT_STRING("operation", v.s, 0),
+                          OPT_STRING("value", v.s, 0), },
+        .priv = &(const int){STREAM_AUDIO} },
+    { "vf", cmd_filter, { OPT_STRING("operation", v.s, 0),
+                          OPT_STRING("value", v.s, 0), },
+        .priv = &(const int){STREAM_VIDEO} },
+
+    { "af-command", cmd_filter_command, { OPT_STRING("label", v.s, 0),
+                                          OPT_STRING("command", v.s, 0),
+                                          OPT_STRING("argument", v.s, 0), },
+        .priv = &(const int){STREAM_AUDIO} },
+    { "vf-command", cmd_filter_command, { OPT_STRING("label", v.s, 0),
+                                          OPT_STRING("command", v.s, 0),
+                                          OPT_STRING("argument", v.s, 0), },
+        .priv = &(const int){STREAM_VIDEO} },
 
-    { "vf", cmd_filter, { ARG_STRING, ARG_STRING },
-        .priv = &(const int){STREAM_VIDEO}, },
-    { "vf-command", cmd_filter_command, { ARG_STRING, ARG_STRING, ARG_STRING },
-        .priv = &(const int){STREAM_VIDEO}, },
+    { "ao-reload", cmd_ao_reload },
 
-    { "script-binding", cmd_script_binding, { ARG_STRING },
+    { "script-binding", cmd_script_binding, { OPT_STRING("name", v.s, 0) },
         .allow_auto_repeat = true, .on_updown = true},
 
-    { "script-message", cmd_script_message, { ARG_STRING }, .vararg = true },
-    { "script-message-to", cmd_script_message_to, { ARG_STRING, ARG_STRING },
+    { "script-message", cmd_script_message, { OPT_STRING("args", v.s, 0) },
+        .vararg = true },
+    { "script-message-to", cmd_script_message_to, { OPT_STRING("target", v.s, 0),
+                                                    OPT_STRING("args", v.s, 0) },
         .vararg = true },
 
-    { "overlay-add", cmd_overlay_add,
-        { ARG_INT, ARG_INT, ARG_INT, ARG_STRING, ARG_INT, ARG_STRING, ARG_INT,
-            ARG_INT, ARG_INT }},
-    { "overlay-remove", cmd_overlay_remove, { ARG_INT } },
+    { "overlay-add", cmd_overlay_add, { OPT_INT("id", v.i, 0),
+                                        OPT_INT("x", v.i, 0),
+                                        OPT_INT("y", v.i, 0),
+                                        OPT_STRING("file", v.s, 0),
+                                        OPT_INT("offset", v.i, 0),
+                                        OPT_STRING("fmt", v.s, 0),
+                                        OPT_INT("w", v.i, 0),
+                                        OPT_INT("h", v.i, 0),
+                                        OPT_INT("stride", v.i, 0), }},
+    { "overlay-remove", cmd_overlay_remove, { OPT_INT("id", v.i, 0) } },
 
     { "write-watch-later-config", cmd_write_watch_later_config },
 
-    { "hook-add", cmd_hook_add, { ARG_STRING, ARG_INT, ARG_INT } },
-    { "hook-ack", cmd_hook_ack, { ARG_INT } },
-
-    { "mouse", cmd_mouse, {
-        ARG_INT, ARG_INT, // coordinate (x, y)
-        OARG_INT(-1),     // button number
-        OARG_CHOICE(0, ({"single", 0},
-                        {"double", 1})),
-    }},
-    { "keypress", cmd_key, { ARG_STRING }, .priv = &(const int){0}},
-    { "keydown", cmd_key, { ARG_STRING }, .priv = &(const int){MP_KEY_STATE_DOWN}},
-    { "keyup", cmd_key, { OARG_STRING("") }, .priv = &(const int){MP_KEY_STATE_UP}},
-
-    { "audio-add", cmd_track_add, {
-            ARG_STRING,
-            OARG_CHOICE(0, ({"select", 0}, {"auto", 1}, {"cached", 2})),
-            OARG_STRING(""), OARG_STRING(""),
-        },
-        .priv = &(const int){STREAM_AUDIO},
-    },
-    { "audio-remove", cmd_track_remove, { OARG_INT(-1) },
-        .priv = &(const int){STREAM_AUDIO}, },
-    { "audio-reload", cmd_track_reload, { OARG_INT(-1) },
-        .priv = &(const int){STREAM_AUDIO}, },
-
-    { "rescan-external-files", cmd_rescan_external_files, {
-        OARG_CHOICE(1, ({"keep-selection", 0},
-                        {"reselect", 1})),
-    }},
+    { "hook-add", cmd_hook_add, { OPT_STRING("arg0", v.s, 0),
+                                  OPT_INT("arg1", v.i, 0),
+                                  OPT_INT("arg2", v.i, 0) }},
+    { "hook-ack", cmd_hook_ack, { OPT_INT("arg0", v.i, 0) }},
+
+    { "mouse", cmd_mouse, { OPT_INT("x", v.i, 0),
+                            OPT_INT("y", v.i, 0),
+                            OPT_INT("button", v.i, 0, OPTDEF_INT(-1)),
+                            OPT_CHOICE("mode", v.i, MP_CMD_OPT_ARG,
+                                       ({"single", 0}, {"double", 1})), }},
+    { "keypress", cmd_key, { OPT_STRING("name", v.s, 0) },
+        .priv = &(const int){0}},
+    { "keydown", cmd_key, { OPT_STRING("name", v.s, 0) },
+        .priv = &(const int){MP_KEY_STATE_DOWN}},
+    { "keyup", cmd_key, { OPT_STRING("name", v.s, MP_CMD_OPT_ARG) },
+        .priv = &(const int){MP_KEY_STATE_UP}},
 
-    { "apply-profile", cmd_apply_profile, {ARG_STRING } },
+    { "apply-profile", cmd_apply_profile, {OPT_STRING("name", v.s, 0)} },
 
-    { "load-script", cmd_load_script, {ARG_STRING} },
+    { "load-script", cmd_load_script, {OPT_STRING("filename", v.s, 0)} },
 
     {0}
 };
diff -ruN mpv-0.29.1/player/command.h mpv-master/player/command.h
--- mpv-0.29.1/player/command.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/command.h	2019-09-19 04:02:03.000000000 +0700
@@ -20,6 +20,8 @@
 
 #include <stdbool.h>
 
+#include "libmpv/client.h"
+
 struct MPContext;
 struct mp_cmd;
 struct mp_log;
@@ -43,12 +45,31 @@
     bool bar_osd;       // OSD bar requested
     bool seek_msg_osd;  // same as above, but for seek commands
     bool seek_bar_osd;
-    // Return values
+    // If mp_cmd_def.can_abort is set, this will be set.
+    struct mp_abort_entry *abort;
+    // Return values (to be set by command implementation, read by the
+    // completion callback).
     bool success;       // true by default
-    struct mpv_node *result;
+    struct mpv_node result;
+    // Command handlers can set this to false if returning from the command
+    // handler does not complete the command. It stops the common command code
+    // from signaling the completion automatically, and you can call
+    // mp_cmd_ctx_complete() to invoke on_completion() properly (including all
+    // the bookkeeping).
+    /// (Note that in no case you can call mp_cmd_ctx_complete() from within
+    // the command handler, because it frees the mp_cmd_ctx.)
+    bool completed;     // true by default
+    // This is managed by the common command code. For rules about how and where
+    // this is called see run_command() comments.
+    void (*on_completion)(struct mp_cmd_ctx *cmd);
+    void *on_completion_priv; // for free use by on_completion callback
 };
 
-int run_command(struct MPContext *mpctx, struct mp_cmd *cmd, struct mpv_node *res);
+void run_command(struct MPContext *mpctx, struct mp_cmd *cmd,
+                 struct mp_abort_entry *abort,
+                 void (*on_completion)(struct mp_cmd_ctx *cmd),
+                 void *on_completion_priv);
+void mp_cmd_ctx_complete(struct mp_cmd_ctx *cmd);
 char *mp_property_expand_string(struct MPContext *mpctx, const char *str);
 char *mp_property_expand_escaped_string(struct MPContext *mpctx, const char *str);
 void property_print_help(struct MPContext *mpctx);
diff -ruN mpv-0.29.1/player/configfiles.c mpv-master/player/configfiles.c
--- mpv-0.29.1/player/configfiles.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/configfiles.c	2019-09-19 04:02:03.000000000 +0700
@@ -174,11 +174,6 @@
             realpath = mp_path_join(tmp, cwd, fname);
         }
     }
-    if (bstr_startswith0(bfname, "dvd://") && opts->dvd_opts && opts->dvd_opts->device)
-        realpath = talloc_asprintf(tmp, "%s - %s", realpath, opts->dvd_opts->device);
-    if ((bstr_startswith0(bfname, "br://") || bstr_startswith0(bfname, "bd://") ||
-         bstr_startswith0(bfname, "bluray://")) && opts->bluray_device)
-        realpath = talloc_asprintf(tmp, "%s - %s", realpath, opts->bluray_device);
     uint8_t md5[16];
     av_md5_sum(md5, realpath, strlen(realpath));
     char *conf = talloc_strdup(tmp, "");
diff -ruN mpv-0.29.1/player/core.h mpv-master/player/core.h
--- mpv-0.29.1/player/core.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/core.h	2019-09-19 04:02:03.000000000 +0700
@@ -37,12 +37,13 @@
 // definitions used internally by the core player code
 
 enum stop_play_reason {
-    KEEP_PLAYING = 0,   // must be 0, numeric values of others do not matter
+    KEEP_PLAYING = 0,   // playback of a file is actually going on
+                        // must be 0, numeric values of others do not matter
     AT_END_OF_FILE,     // file has ended, prepare to play next
                         // also returned on unrecoverable playback errors
     PT_NEXT_ENTRY,      // prepare to play next entry in playlist
     PT_CURRENT_ENTRY,   // prepare to play mpctx->playlist->current
-    PT_STOP,            // stop playback, clear playlist
+    PT_STOP,            // stop playback, or transient state when going to next
     PT_QUIT,            // stop playback, quit player
     PT_ERROR,           // play next playlist entry (due to an error)
 };
@@ -134,6 +135,7 @@
 
     char *title;
     bool default_track, forced_track, dependent_track;
+    bool visual_impaired_track, hearing_impaired_track;
     bool attached_picture;
     char *lang;
 
@@ -242,6 +244,8 @@
     // mp_dispatch_lock must be called to change it.
     int64_t outstanding_async;
 
+    struct mp_thread_pool *thread_pool; // for coarse I/O, often during loading
+
     struct mp_log *statusline;
     struct osd_state *osd;
     char *term_osd_text;
@@ -293,6 +297,8 @@
     struct track **tracks;
     int num_tracks;
 
+    int64_t death_hack; // don't fucking ask, just don't
+
     char *track_layout_hash;
 
     // Selected tracks. NULL if no track selected.
@@ -433,10 +439,12 @@
 
     struct mp_ipc_ctx *ipc_ctx;
 
-    pthread_mutex_t lock;
+    pthread_mutex_t abort_lock;
 
-    // --- The following fields are protected by lock
-    struct mp_cancel *demuxer_cancel; // cancel handle for MPContext.demuxer
+    // --- The following fields are protected by abort_lock
+    struct mp_abort_entry **abort_list;
+    int num_abort_list;
+    bool abort_all; // during final termination
 
     // --- Owned by MPContext
     pthread_t open_thread;
@@ -454,6 +462,20 @@
     int open_res_error;
 } MPContext;
 
+// Contains information about an asynchronous work item, how it can be aborted,
+// and when. All fields are protected by MPContext.abort_lock.
+struct mp_abort_entry {
+    // General conditions.
+    bool coupled_to_playback;   // trigger when playback is terminated
+    // Actual trigger to abort the work.
+    struct mp_cancel *cancel;
+    // For client API.
+    struct mpv_handle *client;  // non-NULL if done by a client API user
+    int client_work_type;       // client API type, e.h. MPV_EVENT_COMMAND_REPLY
+    uint64_t client_work_id;    // client API user reply_userdata value
+                                // (only valid if client_work_type set)
+};
+
 // audio.c
 void reset_audio_state(struct MPContext *mpctx);
 void reinit_audio_chain(struct MPContext *mpctx);
@@ -483,9 +505,15 @@
 
 // loadfile.c
 void mp_abort_playback_async(struct MPContext *mpctx);
+void mp_abort_add(struct MPContext *mpctx, struct mp_abort_entry *abort);
+void mp_abort_remove(struct MPContext *mpctx, struct mp_abort_entry *abort);
+void mp_abort_recheck_locked(struct MPContext *mpctx,
+                             struct mp_abort_entry *abort);
+void mp_abort_trigger_locked(struct MPContext *mpctx,
+                             struct mp_abort_entry *abort);
 void uninit_player(struct MPContext *mpctx, unsigned int mask);
 int mp_add_external_file(struct MPContext *mpctx, char *filename,
-                         enum stream_type filter);
+                         enum stream_type filter, struct mp_cancel *cancel);
 #define FLAG_MARK_SELECTION 1
 void mp_switch_track(struct MPContext *mpctx, enum stream_type type,
                      struct track *track, int flags);
@@ -504,7 +532,7 @@
 void print_track_list(struct MPContext *mpctx, const char *msg);
 void reselect_demux_stream(struct MPContext *mpctx, struct track *track);
 void prepare_playlist(struct MPContext *mpctx, struct playlist *pl);
-void autoload_external_files(struct MPContext *mpctx);
+void autoload_external_files(struct MPContext *mpctx, struct mp_cancel *cancel);
 struct track *select_default_track(struct MPContext *mpctx, int order,
                                    enum stream_type type);
 void prefetch_next(struct MPContext *mpctx);
@@ -527,8 +555,6 @@
 double get_play_start_pts(struct MPContext *mpctx);
 double get_ab_loop_start_time(struct MPContext *mpctx);
 void merge_playlist_files(struct playlist *pl);
-float mp_get_cache_percent(struct MPContext *mpctx);
-bool mp_get_cache_idle(struct MPContext *mpctx);
 void update_vo_playback_state(struct MPContext *mpctx);
 void update_window_title(struct MPContext *mpctx, bool force);
 void error_on_track(struct MPContext *mpctx, struct track *track);
@@ -550,6 +576,8 @@
 void mp_set_timeout(struct MPContext *mpctx, double sleeptime);
 void mp_wakeup_core(struct MPContext *mpctx);
 void mp_wakeup_core_cb(void *ctx);
+void mp_core_lock(struct MPContext *mpctx);
+void mp_core_unlock(struct MPContext *mpctx);
 void mp_process_input(struct MPContext *mpctx);
 double get_relative_time(struct MPContext *mpctx);
 void reset_playback_state(struct MPContext *mpctx);
diff -ruN mpv-0.29.1/player/external_files.c mpv-master/player/external_files.c
--- mpv-0.29.1/player/external_files.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/external_files.c	2019-09-19 04:02:03.000000000 +0700
@@ -34,7 +34,7 @@
 
 static const char *const sub_exts[] = {"utf", "utf8", "utf-8", "idx", "sub",
                                        "srt", "rt", "ssa", "ass", "mks", "vtt",
-                                       "sup", "scc", "smi",
+                                       "sup", "scc", "smi", "lrc",
                                        NULL};
 
 static const char *const audio_exts[] = {"mp3", "aac", "mka", "dts", "flac",
@@ -104,13 +104,12 @@
     return (struct bstr){name.start + i + 1, n};
 }
 
-static void append_dir_subtitles(struct mpv_global *global,
+static void append_dir_subtitles(struct mpv_global *global, struct MPOpts *opts,
                                  struct subfn **slist, int *nsub,
                                  struct bstr path, const char *fname,
                                  int limit_fuzziness, int limit_type)
 {
     void *tmpmem = talloc_new(NULL);
-    struct MPOpts *opts = global->opts;
     struct mp_log *log = mp_log_new(tmpmem, global->log, "find_files");
 
     struct bstr f_fbname = bstr0(mp_basename(fname));
@@ -253,16 +252,16 @@
     }
 }
 
-static void load_paths(struct mpv_global *global, struct subfn **slist,
-                       int *nsubs, const char *fname, char **paths,
-                       char *cfg_path, int type)
+static void load_paths(struct mpv_global *global, struct MPOpts *opts,
+                       struct subfn **slist, int *nsubs, const char *fname,
+                       char **paths, char *cfg_path, int type)
 {
     for (int i = 0; paths && paths[i]; i++) {
         char *expanded_path = mp_get_user_path(NULL, global, paths[i]);
         char *path = mp_path_join_bstr(
             *slist, mp_dirname(fname),
             bstr0(expanded_path ? expanded_path : paths[i]));
-        append_dir_subtitles(global, slist, nsubs, bstr0(path),
+        append_dir_subtitles(global, opts, slist, nsubs, bstr0(path),
                              fname, 0, type);
         talloc_free(expanded_path);
     }
@@ -270,32 +269,32 @@
     // Load subtitles in ~/.mpv/sub (or similar) limiting sub fuzziness
     char *mp_subdir = mp_find_config_file(NULL, global, cfg_path);
     if (mp_subdir) {
-        append_dir_subtitles(global, slist, nsubs, bstr0(mp_subdir), fname, 1,
-                             type);
+        append_dir_subtitles(global, opts, slist, nsubs, bstr0(mp_subdir),
+                             fname, 1, type);
     }
     talloc_free(mp_subdir);
 }
 
 // Return a list of subtitles and audio files found, sorted by priority.
 // Last element is terminated with a fname==NULL entry.
-struct subfn *find_external_files(struct mpv_global *global, const char *fname)
+struct subfn *find_external_files(struct mpv_global *global, const char *fname,
+                                  struct MPOpts *opts)
 {
-    struct MPOpts *opts = global->opts;
     struct subfn *slist = talloc_array_ptrtype(NULL, slist, 1);
     int n = 0;
 
     // Load subtitles from current media directory
-    append_dir_subtitles(global, &slist, &n, mp_dirname(fname), fname, 0, -1);
+    append_dir_subtitles(global, opts, &slist, &n, mp_dirname(fname), fname, 0, -1);
 
     // Load subtitles in dirs specified by sub-paths option
     if (opts->sub_auto >= 0) {
-        load_paths(global, &slist, &n, fname, opts->sub_paths, "sub",
+        load_paths(global, opts, &slist, &n, fname, opts->sub_paths, "sub",
                    STREAM_SUB);
     }
 
     if (opts->audiofile_auto >= 0) {
-        load_paths(global, &slist, &n, fname, opts->audiofile_paths, "audio",
-                   STREAM_AUDIO);
+        load_paths(global, opts, &slist, &n, fname, opts->audiofile_paths,
+                   "audio", STREAM_AUDIO);
     }
 
     // Sort by name for filter_subidx()
diff -ruN mpv-0.29.1/player/external_files.h mpv-master/player/external_files.h
--- mpv-0.29.1/player/external_files.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/external_files.h	2019-09-19 04:02:03.000000000 +0700
@@ -28,7 +28,9 @@
 };
 
 struct mpv_global;
-struct subfn *find_external_files(struct mpv_global *global, const char *fname);
+struct MPOpts;
+struct subfn *find_external_files(struct mpv_global *global, const char *fname,
+                                  struct MPOpts *opts);
 
 bool mp_might_be_subtitle_file(const char *filename);
 
diff -ruN mpv-0.29.1/player/javascript/defaults.js mpv-master/player/javascript/defaults.js
--- mpv-0.29.1/player/javascript/defaults.js	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/javascript/defaults.js	2019-09-19 04:02:03.000000000 +0700
@@ -17,7 +17,7 @@
 }
 
 /**********************************************************************
- *  event handlers, property observers, idle, client messages, hooks
+ *  event handlers, property observers, idle, client messages, hooks, async
  *********************************************************************/
 var ehandlers = new_cache() // items of event-name: array of {maybe cb: fn}
 
@@ -138,6 +138,38 @@
     return mp._hook_add(name, pri - 50, hooks.length);
 }
 
+// ----- async commands -----
+var async_callbacks = new_cache();  // items of id: fn
+var async_next_id = 1;
+
+mp.command_native_async = function command_native_async(node, cb) {
+    var id = async_next_id++;
+    cb = cb || function dummy() {};
+    if (!mp._command_native_async(id, node)) {
+        var le = mp.last_error();
+        setTimeout(cb, 0, false, undefined, le);  /* callback async */
+        mp._set_last_error(le);
+        return undefined;
+    }
+    async_callbacks[id] = cb;
+    return id;
+}
+
+function async_command_handler(ev) {
+    var cb = async_callbacks[ev.id];
+    delete async_callbacks[ev.id];
+    if (ev.error)
+        cb(false, undefined, ev.error);
+    else
+        cb(true, ev.result, "");
+}
+
+mp.abort_async_command = function abort_async_command(id) {
+    // cb will be invoked regardless, possibly with the abort result
+    if (async_callbacks[id])
+        mp._abort_async_command(id);
+}
+
 /**********************************************************************
  *  key bindings
  *********************************************************************/
@@ -519,6 +551,25 @@
     mp.commandv("show_text", text, Math.round(1000 * (duration || -1)));
 }
 
+mp.utils.subprocess = function subprocess(t) {
+    var cmd = { name: "subprocess", capture_stdout: true };
+    var new_names = { cancellable: "playback_only", max_size: "capture_size" };
+    for (var k in t)
+        cmd[new_names[k] || k] = t[k];
+
+    var rv = mp.command_native(cmd);
+    if (mp.last_error())  /* typically on missing/incorrect args */
+        rv = { error_string: mp.last_error(), status: -1 };
+    if (rv.error_string)
+        rv.error = rv.error_string;
+    return rv;
+}
+
+mp.utils.subprocess_detached = function subprocess_detached(t) {
+    return mp.commandv.apply(null, ["run"].concat(t.args));
+}
+
+
 // ----- dump: like print, but expands objects/arrays recursively -----
 function replacer(k, v) {
     var t = typeof v;
@@ -557,6 +608,7 @@
 mp.register_event("shutdown", g.exit);
 mp.register_event("property-change", notify_observer);
 mp.register_event("hook", run_hook);
+mp.register_event("command-reply", async_command_handler);
 mp.register_event("client-message", dispatch_message);
 mp.register_script_message("key-binding", dispatch_key_binding);
 
diff -ruN mpv-0.29.1/player/javascript.c mpv-master/player/javascript.c
--- mpv-0.29.1/player/javascript.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/javascript.c	2019-09-19 04:02:03.000000000 +0700
@@ -37,7 +37,6 @@
 #include "input/input.h"
 #include "options/path.h"
 #include "misc/bstr.h"
-#include "osdep/subprocess.h"
 #include "osdep/timer.h"
 #include "osdep/threads.h"
 #include "osdep/getpid.h"
@@ -76,6 +75,11 @@
     return jctx(J)->client;
 }
 
+static void pushnode(js_State *J, mpv_node *node);
+static void makenode(void *ta_ctx, mpv_node *dst, js_State *J, int idx);
+static int jsL_checkint(js_State *J, int idx);
+static uint64_t jsL_checkuint64(js_State *J, int idx);
+
 /**********************************************************************
  *  conventions, MuJS notes and vm errors
  *********************************************************************/
@@ -372,7 +376,7 @@
 // utils.read_file(..). args: fname [,max]. returns [up to max] bytes as string.
 static void script_read_file(js_State *J)
 {
-    int limit = js_isundefined(J, 2) ? -1 : js_tonumber(J, 2);
+    int limit = js_isundefined(J, 2) ? -1 : jsL_checkint(J, 2);
     push_file_content(J, js_tostring(J, 1), limit);
 }
 
@@ -501,11 +505,6 @@
 /**********************************************************************
  *  Main mp.* scripting APIs and helpers
  *********************************************************************/
-static void pushnode(js_State *J, mpv_node *node);
-static void makenode(void *ta_ctx, mpv_node *dst, js_State *J, int idx);
-static int jsL_checkint(js_State *J, int idx);
-static int64_t jsL_checkint64(js_State *J, int idx);
-
 // Return the index in opts of stack[idx] (or of def if undefined), else throws.
 static int checkopt(js_State *J, int idx, const char *def, const char *opts[],
                     const char *desc)
@@ -686,7 +685,7 @@
                              MPV_FORMAT_STRING, MPV_FORMAT_DOUBLE};
 
     mpv_format f = mf[checkopt(J, 3, "none", fmts, "observe type")];
-    int e = mpv_observe_property(jclient(J), js_tonumber(J, 1),
+    int e = mpv_observe_property(jclient(J), jsL_checkuint64(J, 1),
                                              js_tostring(J, 2),
                                              f);
     push_status(J, e);
@@ -695,7 +694,7 @@
 // args: id
 static void script__unobserve_property(js_State *J)
 {
-    int e = mpv_unobserve_property(jclient(J), js_tonumber(J, 1));
+    int e = mpv_unobserve_property(jclient(J), jsL_checkuint64(J, 1));
     push_status(J, e);
 }
 
@@ -710,6 +709,22 @@
         pushnode(J, presult_node);
 }
 
+// args: async-command-id, native-command
+static void script__command_native_async(js_State *J, void *af)
+{
+    uint64_t id = jsL_checkuint64(J, 1);
+    struct mpv_node node;
+    makenode(af, &node, J, 2);
+    push_status(J, mpv_command_node_async(jclient(J), id, &node));
+}
+
+// args: async-command-id
+static void script__abort_async_command(js_State *J)
+{
+    mpv_abort_async_command(jclient(J), jsL_checkuint64(J, 1));
+    push_success(J);
+}
+
 // args: none, result in millisec
 static void script_get_time_ms(js_State *J)
 {
@@ -719,8 +734,8 @@
 static void script_set_osd_ass(js_State *J)
 {
     struct script_ctx *ctx = jctx(J);
-    int res_x = js_tonumber(J, 1);
-    int res_y = js_tonumber(J, 2);
+    int res_x = jsL_checkint(J, 1);
+    int res_y = jsL_checkint(J, 2);
     const char *text = js_tostring(J, 3);
     osd_set_external(ctx->mpctx->osd, ctx->client, res_x, res_y, (char *)text);
     mp_wakeup_core(ctx->mpctx);
@@ -772,8 +787,8 @@
 {
     char *section = (char *)js_tostring(J, 1);
     mp_input_set_section_mouse_area(jctx(J)->mpctx->input, section,
-        js_tonumber(J, 2), js_tonumber(J, 3),   // x0, y0
-        js_tonumber(J, 4), js_tonumber(J, 5));  // x1, y1
+        jsL_checkint(J, 2), jsL_checkint(J, 3),   // x0, y0
+        jsL_checkint(J, 4), jsL_checkint(J, 5));  // x1, y1
     push_success(J);
 }
 
@@ -799,14 +814,14 @@
 {
     const char *name = js_tostring(J, 1);
     int pri = jsL_checkint(J, 2);
-    uint64_t id = jsL_checkint64(J, 3);
+    uint64_t id = jsL_checkuint64(J, 3);
     push_status(J, mpv_hook_add(jclient(J), id, name, pri));
 }
 
 // args: id (uint)
 static void script__hook_continue(js_State *J)
 {
-    push_status(J, mpv_hook_continue(jclient(J), jsL_checkint64(J, 1)));
+    push_status(J, mpv_hook_continue(jclient(J), jsL_checkuint64(J, 1)));
 }
 
 /**********************************************************************
@@ -911,103 +926,6 @@
     js_pushstring(J, mp_get_user_path(af, jctx(J)->mpctx->global, path));
 }
 
-struct subprocess_cb_ctx {
-    struct mp_log *log;
-    void *talloc_ctx;
-    int64_t max_size;
-    bstr output;
-    bstr err;
-};
-
-static void subprocess_stdout(void *p, char *data, size_t size)
-{
-    struct subprocess_cb_ctx *ctx = p;
-    if (ctx->output.len < ctx->max_size)
-        bstr_xappend(ctx->talloc_ctx, &ctx->output, (bstr){data, size});
-}
-
-static void subprocess_stderr(void *p, char *data, size_t size)
-{
-    struct subprocess_cb_ctx *ctx = p;
-    if (ctx->err.len < ctx->max_size)
-        bstr_xappend(ctx->talloc_ctx, &ctx->err, (bstr){data, size});
-    MP_INFO(ctx, "%.*s", (int)size, data);
-}
-
-// args: client invocation args object. TODO: use common backend for js/lua
-static void af_subprocess_common(js_State *J, int detach, void *af)
-{
-    struct script_ctx *ctx = jctx(J);
-    if (!js_isobject(J, 1))
-        js_error(J, "argument must be an object");
-
-    js_getproperty(J, 1, "args"); // args
-    int num_args = js_getlength(J, -1);
-    if (!num_args) // not using js_isarray to also accept array-like objects
-        js_error(J, "args must be an non-empty array");
-    char *args[256];
-    if (num_args > MP_ARRAY_SIZE(args) - 1) // last needs to be NULL
-        js_error(J, "too many arguments");
-    if (num_args < 1)
-        js_error(J, "program name missing");
-
-    for (int n = 0; n < num_args; n++) {
-        js_getindex(J, -1, n);
-        if (js_isundefined(J, -1))
-            js_error(J, "program arguments must be strings");
-        args[n] = talloc_strdup(af, js_tostring(J, -1));
-        js_pop(J, 1); // args
-    }
-    args[num_args] = NULL;
-
-    if (detach) {
-        mp_subprocess_detached(ctx->log, args);
-        push_success(J);
-        return;
-    }
-
-    struct mp_cancel *cancel = NULL;
-    if (js_hasproperty(J, 1, "cancellable") ? js_toboolean(J, -1) : true)
-        cancel = ctx->mpctx->playback_abort;
-
-    int64_t max_size = js_hasproperty(J, 1, "max_size") ? js_tointeger(J, -1)
-                                                        : 16 * 1024 * 1024;
-    struct subprocess_cb_ctx cb_ctx = {
-        .log = ctx->log,
-        .talloc_ctx = af,
-        .max_size = max_size,
-    };
-
-    char *error = NULL;
-    int status = mp_subprocess(args, cancel, &cb_ctx, subprocess_stdout,
-                               subprocess_stderr, &error);
-
-    js_newobject(J); // res
-    if (error) {
-        js_pushstring(J, error); // res e
-        js_setproperty(J, -2, "error"); // res
-    }
-    js_pushnumber(J, status); // res s
-    js_setproperty(J, -2, "status"); // res
-    js_pushlstring(J, cb_ctx.output.start, cb_ctx.output.len); // res d
-    js_setproperty(J, -2, "stdout"); // res
-    js_pushlstring(J, cb_ctx.err.start, cb_ctx.err.len);
-    js_setproperty(J, -2, "stderr");
-    js_pushboolean(J, status == MP_SUBPROCESS_EKILLED_BY_US); // res b
-    js_setproperty(J, -2, "killed_by_us"); // res
-}
-
-// args: client invocation args object (same also for _detached)
-static void script_subprocess(js_State *J, void *af)
-{
-    af_subprocess_common(J, 0, af);
-}
-
-static void script_subprocess_detached(js_State *J, void *af)
-{
-    af_subprocess_common(J, 1, af);
-}
-
 // args: none
 static void script_getpid(js_State *J)
 {
@@ -1075,6 +993,9 @@
     case MPV_FORMAT_INT64:  js_pushnumber(J, node->u.int64); break;
     case MPV_FORMAT_DOUBLE: js_pushnumber(J, node->u.double_); break;
     case MPV_FORMAT_FLAG:   js_pushboolean(J, node->u.flag); break;
+    case MPV_FORMAT_BYTE_ARRAY:
+        js_pushlstring(J, node->u.ba->data, node->u.ba->size);
+        break;
     case MPV_FORMAT_NODE_ARRAY:
         js_newarray(J);
         len = node->u.list->num;
@@ -1124,15 +1045,15 @@
 {
     double d = js_tonumber(J, idx);
     if (!(d >= INT_MIN && d <= INT_MAX))
-        js_error(J, "integer out of range at index %d", idx);
+        js_error(J, "int out of range at index %d", idx);
     return d;
 }
 
-static int64_t jsL_checkint64(js_State *J, int idx)
+static uint64_t jsL_checkuint64(js_State *J, int idx)
 {
     double d = js_tonumber(J, idx);
-    if (!(d >= INT64_MIN && d <= INT64_MAX))
-        js_error(J, "integer out of range at index %d", idx);
+    if (!(d >= 0 && d <= UINT64_MAX))
+        js_error(J, "uint64 out of range at index %d", idx);
     return d;
 }
 
@@ -1283,6 +1204,13 @@
         js_setproperty(J, -2, "hook_id");  // reply.hook_id (is a number)
         break;
     }
+
+    case MPV_EVENT_COMMAND_REPLY: {
+        mpv_event_command *cmd = event->data;
+        pushnode(J, &cmd->result);
+        js_setproperty(J, -2, "result");  // reply.result (mpv node)
+        break;
+    }
     }  // switch (event->event_id)
 
     assert(top == js_gettop(J) - 1);
@@ -1310,6 +1238,8 @@
     FN_ENTRY(command, 1),
     FN_ENTRY(commandv, 0),
     AF_ENTRY(command_native, 2),
+    AF_ENTRY(_command_native_async, 2),
+    FN_ENTRY(_abort_async_command, 1),
     FN_ENTRY(get_property_bool, 2),
     FN_ENTRY(get_property_number, 2),
     AF_ENTRY(get_property_native, 2),
@@ -1343,8 +1273,6 @@
     FN_ENTRY(split_path, 1),
     AF_ENTRY(join_path, 2),
     AF_ENTRY(get_user_path, 1),
-    AF_ENTRY(subprocess, 1),
-    AF_ENTRY(subprocess_detached, 1),
     FN_ENTRY(getpid, 0),
 
     FN_ENTRY(read_file, 2),
diff -ruN mpv-0.29.1/player/loadfile.c mpv-master/player/loadfile.c
--- mpv-0.29.1/player/loadfile.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/loadfile.c	2019-09-19 04:02:03.000000000 +0700
@@ -26,6 +26,8 @@
 #include "config.h"
 #include "mpv_talloc.h"
 
+#include "misc/thread_pool.h"
+#include "misc/thread_tools.h"
 #include "osdep/io.h"
 #include "osdep/terminal.h"
 #include "osdep/threads.h"
@@ -59,15 +61,132 @@
 #include "command.h"
 #include "libmpv/client.h"
 
+// Called from the demuxer thread if a new packet is available, or other changes.
+static void wakeup_demux(void *pctx)
+{
+    struct MPContext *mpctx = pctx;
+    mp_wakeup_core(mpctx);
+}
+
 // Called by foreign threads when playback should be stopped and such.
 void mp_abort_playback_async(struct MPContext *mpctx)
 {
     mp_cancel_trigger(mpctx->playback_abort);
 
-    pthread_mutex_lock(&mpctx->lock);
-    if (mpctx->demuxer_cancel)
-        mp_cancel_trigger(mpctx->demuxer_cancel);
-    pthread_mutex_unlock(&mpctx->lock);
+    pthread_mutex_lock(&mpctx->abort_lock);
+
+    for (int n = 0; n < mpctx->num_abort_list; n++) {
+        struct mp_abort_entry *abort = mpctx->abort_list[n];
+        if (abort->coupled_to_playback)
+            mp_abort_trigger_locked(mpctx, abort);
+    }
+
+    pthread_mutex_unlock(&mpctx->abort_lock);
+}
+
+// Add it to the global list, and allocate required data structures.
+void mp_abort_add(struct MPContext *mpctx, struct mp_abort_entry *abort)
+{
+    pthread_mutex_lock(&mpctx->abort_lock);
+    assert(!abort->cancel);
+    abort->cancel = mp_cancel_new(NULL);
+    MP_TARRAY_APPEND(NULL, mpctx->abort_list, mpctx->num_abort_list, abort);
+    mp_abort_recheck_locked(mpctx, abort);
+    pthread_mutex_unlock(&mpctx->abort_lock);
+}
+
+// Remove Add it to the global list, and free/clear required data structures.
+// Does not deallocate the abort value itself.
+void mp_abort_remove(struct MPContext *mpctx, struct mp_abort_entry *abort)
+{
+    pthread_mutex_lock(&mpctx->abort_lock);
+    for (int n = 0; n < mpctx->num_abort_list; n++) {
+        if (mpctx->abort_list[n] == abort) {
+            MP_TARRAY_REMOVE_AT(mpctx->abort_list, mpctx->num_abort_list, n);
+            TA_FREEP(&abort->cancel);
+            abort = NULL; // it's not free'd, just clear for the assert below
+            break;
+        }
+    }
+    assert(!abort); // should have been in the list
+    pthread_mutex_unlock(&mpctx->abort_lock);
+}
+
+// Verify whether the abort needs to be signaled after changing certain fields
+// in abort.
+void mp_abort_recheck_locked(struct MPContext *mpctx,
+                             struct mp_abort_entry *abort)
+{
+    if ((abort->coupled_to_playback && mp_cancel_test(mpctx->playback_abort)) ||
+        mpctx->abort_all)
+    {
+        mp_abort_trigger_locked(mpctx, abort);
+    }
+}
+
+void mp_abort_trigger_locked(struct MPContext *mpctx,
+                             struct mp_abort_entry *abort)
+{
+    mp_cancel_trigger(abort->cancel);
+}
+
+static void kill_demuxers_reentrant(struct MPContext *mpctx,
+                                    struct demuxer **demuxers, int num_demuxers)
+{
+    struct demux_free_async_state **items = NULL;
+    int num_items = 0;
+
+    for (int n = 0; n < num_demuxers; n++) {
+        struct demuxer *d = demuxers[n];
+
+        if (!demux_cancel_test(d)) {
+            // Make sure it is set if it wasn't yet.
+            demux_set_wakeup_cb(d, wakeup_demux, mpctx);
+
+            struct demux_free_async_state *item = demux_free_async(d);
+            if (item) {
+                MP_TARRAY_APPEND(NULL, items, num_items, item);
+                d = NULL;
+            }
+        }
+
+        demux_cancel_and_free(d);
+    }
+
+    if (!num_items)
+        return;
+
+    MP_DBG(mpctx, "Terminating demuxers...\n");
+
+    double end = mp_time_sec() + mpctx->opts->demux_termination_timeout;
+    bool force = false;
+    while (num_items) {
+        double wait = end - mp_time_sec();
+
+        for (int n = 0; n < num_items; n++) {
+            struct demux_free_async_state *item = items[n];
+            if (demux_free_async_finish(item)) {
+                items[n] = items[num_items - 1];
+                num_items -= 1;
+                n--;
+                goto repeat;
+            } else if (wait < 0) {
+                demux_free_async_force(item);
+                if (!force)
+                    MP_VERBOSE(mpctx, "Forcefully terminating demuxers...\n");
+                force = true;
+            }
+        }
+
+        if (wait >= 0)
+            mp_set_timeout(mpctx, wait);
+        mp_idle(mpctx);
+    repeat:;
+    }
+
+    talloc_free(items);
+
+    MP_DBG(mpctx, "Done terminating demuxers.\n");
 }
 
 static void uninit_demuxer(struct MPContext *mpctx)
@@ -76,28 +195,44 @@
         for (int t = 0; t < STREAM_TYPE_COUNT; t++)
             mpctx->current_track[r][t] = NULL;
     }
+    mpctx->seek_slave = NULL;
+
     talloc_free(mpctx->chapters);
     mpctx->chapters = NULL;
     mpctx->num_chapters = 0;
 
-    // close demuxers for external tracks
-    for (int n = mpctx->num_tracks - 1; n >= 0; n--) {
-        mpctx->tracks[n]->selected = false;
-        mp_remove_track(mpctx, mpctx->tracks[n]);
-    }
+    struct demuxer **demuxers = NULL;
+    int num_demuxers = 0;
+
+    if (mpctx->demuxer)
+        MP_TARRAY_APPEND(NULL, demuxers, num_demuxers, mpctx->demuxer);
+    mpctx->demuxer = NULL;
+
     for (int i = 0; i < mpctx->num_tracks; i++) {
-        sub_destroy(mpctx->tracks[i]->d_sub);
-        talloc_free(mpctx->tracks[i]);
+        struct track *track = mpctx->tracks[i];
+
+        assert(!track->dec && !track->d_sub);
+        assert(!track->vo_c && !track->ao_c);
+        assert(!track->sink);
+        assert(!track->remux_sink);
+
+        // Demuxers can be added in any order (if they appear mid-stream), and
+        // we can't know which tracks uses which, so here's some O(n^2) trash.
+        for (int n = 0; n < num_demuxers; n++) {
+            if (demuxers[n] == track->demuxer) {
+                track->demuxer = NULL;
+                break;
+            }
+        }
+        if (track->demuxer)
+            MP_TARRAY_APPEND(NULL, demuxers, num_demuxers, track->demuxer);
+
+        talloc_free(track);
     }
     mpctx->num_tracks = 0;
 
-    free_demuxer_and_stream(mpctx->demuxer);
-    mpctx->demuxer = NULL;
-
-    pthread_mutex_lock(&mpctx->lock);
-    talloc_free(mpctx->demuxer_cancel);
-    mpctx->demuxer_cancel = NULL;
-    pthread_mutex_unlock(&mpctx->lock);
+    kill_demuxers_reentrant(mpctx, demuxers, num_demuxers);
+    talloc_free(demuxers);
 }
 
 #define APPEND(s, ...) mp_snprintf_cat(s, sizeof(s), __VA_ARGS__)
@@ -227,20 +362,16 @@
     if (!track->stream)
         return;
     double pts = get_current_time(mpctx);
-    if (pts != MP_NOPTS_VALUE)
+    if (pts != MP_NOPTS_VALUE) {
         pts += get_track_seek_offset(mpctx, track);
+        if (track->type == STREAM_SUB)
+            pts -= 10.0;
+    }
     demuxer_select_track(track->demuxer, track->stream, pts, track->selected);
     if (track == mpctx->seek_slave)
         mpctx->seek_slave = NULL;
 }
 
-// Called from the demuxer thread if a new packet is available.
-static void wakeup_demux(void *pctx)
-{
-    struct MPContext *mpctx = pctx;
-    mp_wakeup_core(mpctx);
-}
-
 static void enable_demux_thread(struct MPContext *mpctx, struct demuxer *demux)
 {
     if (mpctx->opts->demuxer_thread && !demux->fully_read) {
@@ -279,6 +410,9 @@
         .title = stream->title,
         .default_track = stream->default_track,
         .forced_track = stream->forced_track,
+        .dependent_track = stream->dependent_track,
+        .visual_impaired_track = stream->visual_impaired_track,
+        .hearing_impaired_track = stream->hearing_impaired_track,
         .attached_picture = stream->attached_picture != NULL,
         .lang = stream->lang,
         .demuxer = demuxer,
@@ -551,8 +685,6 @@
 
     struct demuxer *d = track->demuxer;
 
-    sub_destroy(track->d_sub);
-
     if (mpctx->seek_slave == track)
         mpctx->seek_slave = NULL;
 
@@ -569,7 +701,7 @@
         in_use |= mpctx->tracks[n]->demuxer == d;
 
     if (!in_use)
-        free_demuxer_and_stream(d);
+        demux_cancel_and_free(d);
 
     mp_notify(mpctx, MPV_EVENT_TRACKS_CHANGED, NULL);
 
@@ -578,11 +710,14 @@
 
 // Add the given file as additional track. The filter argument controls how or
 // if tracks are auto-selected at any point.
+// To be run on a worker thread, locked (temporarily unlocks core).
+// cancel will generally be used to abort the loading process, but on success
+// the demuxer is changed to be slaved to mpctx->playback_abort instead.
 int mp_add_external_file(struct MPContext *mpctx, char *filename,
-                         enum stream_type filter)
+                         enum stream_type filter, struct mp_cancel *cancel)
 {
     struct MPOpts *opts = mpctx->opts;
-    if (!filename)
+    if (!filename || mp_cancel_test(cancel))
         return -1;
 
     char *disp_filename = filename;
@@ -600,13 +735,24 @@
         break;
     }
 
+    mp_core_unlock(mpctx);
+
     struct demuxer *demuxer =
-        demux_open_url(filename, &params, mpctx->playback_abort, mpctx->global);
+        demux_open_url(filename, &params, cancel, mpctx->global);
+    if (demuxer)
+        enable_demux_thread(mpctx, demuxer);
+
+    mp_core_lock(mpctx);
+
+    // The command could have overlapped with playback exiting. (We don't care
+    // if playback has started again meanwhile - weird, but not a problem.)
+    if (mpctx->stop_play)
+        goto err_out;
+
     if (!demuxer)
         goto err_out;
-    enable_demux_thread(mpctx, demuxer);
 
-    if (opts->rebase_start_time)
+    if (filter != STREAM_SUB && opts->rebase_start_time)
         demux_set_ts_offset(demuxer, -demuxer->start_time);
 
     bool has_any = false;
@@ -619,12 +765,11 @@
     }
 
     if (!has_any) {
-        free_demuxer_and_stream(demuxer);
         char *tname = mp_tprintf(20, "%s ", stream_type_name(filter));
         if (filter == STREAM_TYPE_COUNT)
             tname = "";
         MP_ERR(mpctx, "No %sstreams in file %s.\n", tname, disp_filename);
-        return -1;
+        goto err_out;
     }
 
     int first_num = -1;
@@ -640,22 +785,33 @@
             first_num = mpctx->num_tracks - 1;
     }
 
+    mp_cancel_set_parent(demuxer->cancel, mpctx->playback_abort);
+
     return first_num;
 
 err_out:
-    if (!mp_cancel_test(mpctx->playback_abort))
+    demux_cancel_and_free(demuxer);
+    if (!mp_cancel_test(cancel))
         MP_ERR(mpctx, "Can not open external file %s.\n", disp_filename);
     return -1;
 }
 
+// to be run on a worker thread, locked (temporarily unlocks core)
 static void open_external_files(struct MPContext *mpctx, char **files,
                                 enum stream_type filter)
 {
+    // Need a copy, because the option value could be mutated during iteration.
+    void *tmp = talloc_new(NULL);
+    files = mp_dup_str_array(tmp, files);
+
     for (int n = 0; files && files[n]; n++)
-        mp_add_external_file(mpctx, files[n], filter);
+        mp_add_external_file(mpctx, files[n], filter, mpctx->playback_abort);
+
+    talloc_free(tmp);
 }
 
-void autoload_external_files(struct MPContext *mpctx)
+// See mp_add_external_file() for meaning of cancel parameter.
+void autoload_external_files(struct MPContext *mpctx, struct mp_cancel *cancel)
 {
     if (mpctx->opts->sub_auto < 0 && mpctx->opts->audiofile_auto < 0)
         return;
@@ -670,7 +826,8 @@
                                     &stream_filename) > 0)
             base_filename = talloc_steal(tmp, stream_filename);
     }
-    struct subfn *list = find_external_files(mpctx->global, base_filename);
+    struct subfn *list = find_external_files(mpctx->global, base_filename,
+                                             mpctx->opts);
     talloc_steal(tmp, list);
 
     int sc[STREAM_TYPE_COUNT] = {0};
@@ -691,7 +848,7 @@
             goto skip;
         if (list[i].type == STREAM_AUDIO && !sc[STREAM_VIDEO])
             goto skip;
-        int first = mp_add_external_file(mpctx, filename, list[i].type);
+        int first = mp_add_external_file(mpctx, filename, list[i].type, cancel);
         if (first < 0)
             goto skip;
 
@@ -755,24 +912,35 @@
 {
     mp_hook_start(mpctx, name);
 
-    while (!mp_hook_test_completion(mpctx, name))
+    while (!mp_hook_test_completion(mpctx, name)) {
         mp_idle(mpctx);
+
+        // We have no idea what blocks a hook, so just do a full abort.
+        if (mpctx->stop_play)
+            mp_abort_playback_async(mpctx);
+    }
 }
 
+// to be run on a worker thread, locked (temporarily unlocks core)
 static void load_chapters(struct MPContext *mpctx)
 {
     struct demuxer *src = mpctx->demuxer;
     bool free_src = false;
     char *chapter_file = mpctx->opts->chapter_file;
     if (chapter_file && chapter_file[0]) {
+        chapter_file = talloc_strdup(NULL, chapter_file);
+        mp_core_unlock(mpctx);
         struct demuxer *demux = demux_open_url(chapter_file, NULL,
-                                        mpctx->playback_abort, mpctx->global);
+                                               mpctx->playback_abort,
+                                               mpctx->global);
+        mp_core_lock(mpctx);
         if (demux) {
             src = demux;
             free_src = true;
         }
         talloc_free(mpctx->chapters);
         mpctx->chapters = NULL;
+        talloc_free(chapter_file);
     }
     if (src && !mpctx->chapters) {
         talloc_free(mpctx->chapters);
@@ -784,7 +952,7 @@
         }
     }
     if (free_src)
-        free_demuxer_and_stream(src);
+        demux_cancel_and_free(src);
 }
 
 static void load_per_file_options(m_config_t *conf,
@@ -806,7 +974,7 @@
     struct demuxer_params p = {
         .force_format = mpctx->open_format,
         .stream_flags = mpctx->open_url_flags,
-        .initial_readahead = true,
+        .stream_record = true,
     };
     mpctx->open_res_demuxer =
         demux_open_url(mpctx->open_url, &p, mpctx->open_cancel, mpctx->global);
@@ -837,14 +1005,14 @@
         pthread_join(mpctx->open_thread, NULL);
     mpctx->open_active = false;
 
+    if (mpctx->open_res_demuxer)
+        demux_cancel_and_free(mpctx->open_res_demuxer);
+    mpctx->open_res_demuxer = NULL;
+
     TA_FREEP(&mpctx->open_cancel);
     TA_FREEP(&mpctx->open_url);
     TA_FREEP(&mpctx->open_format);
 
-    if (mpctx->open_res_demuxer)
-        free_demuxer_and_stream(mpctx->open_res_demuxer);
-    mpctx->open_res_demuxer = NULL;
-
     atomic_store(&mpctx->open_done, false);
 }
 
@@ -901,9 +1069,7 @@
         start_open(mpctx, url, mpctx->playing->stream_flags);
 
     // User abort should cancel the opener now.
-    pthread_mutex_lock(&mpctx->lock);
-    mpctx->demuxer_cancel = mpctx->open_cancel;
-    pthread_mutex_unlock(&mpctx->lock);
+    mp_cancel_set_parent(mpctx->open_cancel, mpctx->playback_abort);
 
     while (!atomic_load(&mpctx->open_done)) {
         mp_idle(mpctx);
@@ -913,15 +1079,11 @@
     }
 
     if (mpctx->open_res_demuxer) {
-        assert(mpctx->demuxer_cancel == mpctx->open_cancel);
         mpctx->demuxer = mpctx->open_res_demuxer;
         mpctx->open_res_demuxer = NULL;
-        mpctx->open_cancel = NULL;
+        mp_cancel_set_parent(mpctx->demuxer->cancel, mpctx->playback_abort);
     } else {
         mpctx->error_playing = mpctx->open_res_error;
-        pthread_mutex_lock(&mpctx->lock);
-        mpctx->demuxer_cancel = NULL;
-        pthread_mutex_unlock(&mpctx->lock);
     }
 
     cancel_open(mpctx); // cleanup
@@ -1131,6 +1293,48 @@
     }
 }
 
+
+// Worker thread for loading external files and such. This is needed to avoid
+// freezing the core when waiting for network while loading these.
+static void load_external_opts_thread(void *p)
+{
+    void **a = p;
+    struct MPContext *mpctx = a[0];
+    struct mp_waiter *waiter = a[1];
+
+    mp_core_lock(mpctx);
+
+    load_chapters(mpctx);
+    open_external_files(mpctx, mpctx->opts->audio_files, STREAM_AUDIO);
+    open_external_files(mpctx, mpctx->opts->sub_name, STREAM_SUB);
+    open_external_files(mpctx, mpctx->opts->external_files, STREAM_TYPE_COUNT);
+    autoload_external_files(mpctx, mpctx->playback_abort);
+
+    mp_waiter_wakeup(waiter, 0);
+    mp_wakeup_core(mpctx);
+    mp_core_unlock(mpctx);
+}
+
+static void load_external_opts(struct MPContext *mpctx)
+{
+    struct mp_waiter wait = MP_WAITER_INITIALIZER;
+
+    void *a[] = {mpctx, &wait};
+    if (!mp_thread_pool_queue(mpctx->thread_pool, load_external_opts_thread, a)) {
+        mpctx->stop_play = PT_ERROR;
+        return;
+    }
+
+    while (!mp_waiter_poll(&wait)) {
+        mp_idle(mpctx);
+
+        if (mpctx->stop_play)
+            mp_abort_playback_async(mpctx);
+    }
+
+    mp_waiter_wait(&wait);
+}
+
 // Start playing the current playlist entry.
 // Handle initialization and deinitialization.
 static void play_current_file(struct MPContext *mpctx)
@@ -1138,6 +1342,8 @@
     struct MPOpts *opts = mpctx->opts;
     double playback_start = -1e100;
 
+    assert(mpctx->stop_play);
+
     mp_notify(mpctx, MPV_EVENT_START_FILE, NULL);
 
     mp_cancel_reset(mpctx->playback_abort);
@@ -1158,15 +1364,14 @@
     mpctx->speed_factor_a = mpctx->speed_factor_v = 1.0;
     mpctx->display_sync_error = 0.0;
     mpctx->display_sync_active = false;
+    // let get_current_time() show 0 as start time (before playback_pts is set)
+    mpctx->last_seek_pts = 0.0;
     mpctx->seek = (struct seek_params){ 0 };
     mpctx->filter_root = mp_filter_create_root(mpctx->global);
     mp_filter_root_set_wakeup_cb(mpctx->filter_root, mp_wakeup_core_cb, mpctx);
 
     reset_playback_state(mpctx);
 
-    // let get_current_time() show 0 as start time (before playback_pts is set)
-    mpctx->last_seek_pts = 0.0;
-
     mpctx->playing = mpctx->playlist->current;
     if (!mpctx->playing || !mpctx->playing->filename)
         goto terminate_playback;
@@ -1248,13 +1453,11 @@
         demux_set_ts_offset(mpctx->demuxer, -mpctx->demuxer->start_time);
     enable_demux_thread(mpctx, mpctx->demuxer);
 
-    load_chapters(mpctx);
     add_demuxer_tracks(mpctx, mpctx->demuxer);
 
-    open_external_files(mpctx, opts->audio_files, STREAM_AUDIO);
-    open_external_files(mpctx, opts->sub_name, STREAM_SUB);
-    open_external_files(mpctx, opts->external_files, STREAM_TYPE_COUNT);
-    autoload_external_files(mpctx);
+    load_external_opts(mpctx);
+    if (mpctx->stop_play)
+        goto terminate_playback;
 
     check_previous_track_selection(mpctx);
 
@@ -1366,21 +1569,19 @@
 
 terminate_playback:
 
-    update_core_idle_state(mpctx);
-
-    process_hooks(mpctx, "on_unload");
-
-    if (mpctx->stop_play == KEEP_PLAYING)
-        mpctx->stop_play = AT_END_OF_FILE;
+    if (!mpctx->stop_play)
+        mpctx->stop_play = PT_ERROR;
 
     if (mpctx->stop_play != AT_END_OF_FILE)
         clear_audio_output_buffers(mpctx);
 
+    update_core_idle_state(mpctx);
+
+    process_hooks(mpctx, "on_unload");
+
     if (mpctx->step_frames)
         opts->pause = 1;
 
-    mp_abort_playback_async(mpctx);
-
     close_recorder(mpctx);
 
     // time to uninit all, except global stuff:
@@ -1388,12 +1589,16 @@
     uninit_audio_chain(mpctx);
     uninit_video_chain(mpctx);
     uninit_sub_all(mpctx);
-    uninit_demuxer(mpctx);
     if (!opts->gapless_audio && !mpctx->encode_lavc_ctx)
         uninit_audio_out(mpctx);
 
     mpctx->playback_initialized = false;
 
+    uninit_demuxer(mpctx);
+
+    // Possibly stop ongoing async commands.
+    mp_abort_playback_async(mpctx);
+
     m_config_restore_backups(mpctx->mconfig);
 
     TA_FREEP(&mpctx->filter_root);
@@ -1455,6 +1660,8 @@
     } else {
         mpctx->files_played++;
     }
+
+    assert(mpctx->stop_play);
 }
 
 // Determine the next file to play. Note that if this function returns non-NULL,
@@ -1520,6 +1727,7 @@
     prepare_playlist(mpctx, mpctx->playlist);
 
     for (;;) {
+        assert(mpctx->stop_play);
         idle_loop(mpctx);
         if (mpctx->stop_play == PT_QUIT)
             break;
@@ -1530,14 +1738,14 @@
 
         struct playlist_entry *new_entry = mpctx->playlist->current;
         if (mpctx->stop_play == PT_NEXT_ENTRY || mpctx->stop_play == PT_ERROR ||
-            mpctx->stop_play == AT_END_OF_FILE || !mpctx->stop_play)
+            mpctx->stop_play == AT_END_OF_FILE || mpctx->stop_play == PT_STOP)
         {
             new_entry = mp_next_file(mpctx, +1, false, true);
         }
 
         mpctx->playlist->current = new_entry;
         mpctx->playlist->current_was_replaced = false;
-        mpctx->stop_play = 0;
+        mpctx->stop_play = PT_STOP;
 
         if (!mpctx->playlist->current && mpctx->opts->player_idle_mode < 2)
             break;
@@ -1564,6 +1772,7 @@
     assert(!e || playlist_entry_to_index(mpctx->playlist, e) >= 0);
     mpctx->playlist->current = e;
     mpctx->playlist->current_was_replaced = false;
+    // Make it pick up the new entry.
     if (!mpctx->stop_play)
         mpctx->stop_play = PT_CURRENT_ENTRY;
     mp_wakeup_core(mpctx);
@@ -1640,8 +1849,10 @@
             break;
         // (We expect track->stream not to be reused on other tracks.)
         if (track->stream == streams[n_stream]) {
-            set_track_recorder_sink(track,
-                            mp_recorder_get_sink(mpctx->recorder, n_stream));
+            struct mp_recorder_sink * sink =
+                mp_recorder_get_sink(mpctx->recorder, n_stream);
+            assert(sink);
+            set_track_recorder_sink(track, sink);
             n_stream++;
         }
     }
diff -ruN mpv-0.29.1/player/lua/assdraw.lua mpv-master/player/lua/assdraw.lua
--- mpv-0.29.1/player/lua/assdraw.lua	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/lua/assdraw.lua	2019-09-19 04:02:03.000000000 +0700
@@ -1,5 +1,6 @@
 local ass_mt = {}
 ass_mt.__index = ass_mt
+local c = 0.551915024494 -- circle approximation
 
 local function ass_new()
     return setmetatable({ scale = 4, text = "" }, ass_mt)
@@ -75,24 +76,84 @@
     ass:line_to(x0, y1)
 end
 
-function ass_mt.round_rect_cw(ass, x0, y0, x1, y1, r)
-    local c = 0.551915024494 * r -- circle approximation
-    ass:move_to(x0 + r, y0)
-    ass:line_to(x1 - r, y0) -- top line
-    if r > 0 then
-        ass:bezier_curve(x1 - r + c, y0, x1, y0 + r - c, x1, y0 + r) -- top right corner
-    end
-    ass:line_to(x1, y1 - r) -- right line
-    if r > 0 then
-        ass:bezier_curve(x1, y1 - r + c, x1 - r + c, y1, x1 - r, y1) -- bottom right corner
-    end
-    ass:line_to(x0 + r, y1) -- bottom line
-    if r > 0 then
-        ass:bezier_curve(x0 + r - c, y1, x0, y1 - r + c, x0, y1 - r) -- bottom left corner
-    end
-    ass:line_to(x0, y0 + r) -- left line
-    if r > 0 then
-        ass:bezier_curve(x0, y0 + r - c, x0 + r - c, y0, x0 + r, y0) -- top left corner
+function ass_mt.hexagon_cw(ass, x0, y0, x1, y1, r1, r2)
+    if r2 == nil then
+        r2 = r1
+    end
+    ass:move_to(x0 + r1, y0)
+    if x0 ~= x1 then
+        ass:line_to(x1 - r2, y0)
+    end
+    ass:line_to(x1, y0 + r2)
+    if x0 ~= x1 then
+        ass:line_to(x1 - r2, y1)
+    end
+    ass:line_to(x0 + r1, y1)
+    ass:line_to(x0, y0 + r1)
+end
+
+function ass_mt.hexagon_ccw(ass, x0, y0, x1, y1, r1, r2)
+    if r2 == nil then
+        r2 = r1
+    end
+    ass:move_to(x0 + r1, y0)
+    ass:line_to(x0, y0 + r1)
+    ass:line_to(x0 + r1, y1)
+    if x0 ~= x1 then
+        ass:line_to(x1 - r2, y1)
+    end
+    ass:line_to(x1, y0 + r2)
+    if x0 ~= x1 then
+        ass:line_to(x1 - r2, y0)
+    end
+end
+
+function ass_mt.round_rect_cw(ass, x0, y0, x1, y1, r1, r2)
+    if r2 == nil then
+        r2 = r1
+    end
+    local c1 = c * r1 -- circle approximation
+    local c2 = c * r2 -- circle approximation
+    ass:move_to(x0 + r1, y0)
+    ass:line_to(x1 - r2, y0) -- top line
+    if r2 > 0 then
+        ass:bezier_curve(x1 - r2 + c2, y0, x1, y0 + r2 - c2, x1, y0 + r2) -- top right corner
+    end
+    ass:line_to(x1, y1 - r2) -- right line
+    if r2 > 0 then
+        ass:bezier_curve(x1, y1 - r2 + c2, x1 - r2 + c2, y1, x1 - r2, y1) -- bottom right corner
+    end
+    ass:line_to(x0 + r1, y1) -- bottom line
+    if r1 > 0 then
+        ass:bezier_curve(x0 + r1 - c1, y1, x0, y1 - r1 + c1, x0, y1 - r1) -- bottom left corner
+    end
+    ass:line_to(x0, y0 + r1) -- left line
+    if r1 > 0 then
+        ass:bezier_curve(x0, y0 + r1 - c1, x0 + r1 - c1, y0, x0 + r1, y0) -- top left corner
+    end
+end
+
+function ass_mt.round_rect_ccw(ass, x0, y0, x1, y1, r1, r2)
+    if r2 == nil then
+        r2 = r1
+    end
+    local c1 = c * r1 -- circle approximation
+    local c2 = c * r2 -- circle approximation
+    ass:move_to(x0 + r1, y0)
+    if r1 > 0 then
+        ass:bezier_curve(x0 + r1 - c1, y0, x0, y0 + r1 - c1, x0, y0 + r1) -- top left corner
+    end
+    ass:line_to(x0, y1 - r1) -- left line
+    if r1 > 0 then
+        ass:bezier_curve(x0, y1 - r1 + c1, x0 + r1 - c1, y1, x0 + r1, y1) -- bottom left corner
+    end
+    ass:line_to(x1 - r2, y1) -- bottom line
+    if r2 > 0 then
+        ass:bezier_curve(x1 - r2 + c2, y1, x1, y1 - r2 + c2, x1, y1 - r2) -- bottom right corner
+    end
+    ass:line_to(x1, y0 + r2) -- right line
+    if r2 > 0 then
+        ass:bezier_curve(x1, y0 + r2 - c2, x1 - r2 + c2, y0, x1 - r2, y0) -- top right corner
     end
 end
 
diff -ruN mpv-0.29.1/player/lua/defaults.lua mpv-master/player/lua/defaults.lua
--- mpv-0.29.1/player/lua/defaults.lua	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/lua/defaults.lua	2019-09-19 04:02:03.000000000 +0700
@@ -476,12 +476,9 @@
     while mp.keep_running do
         local wait = 0
         if not more_events then
-            wait = process_timers()
-            if wait == nil then
-                for _, handler in ipairs(idle_handlers) do
-                    handler()
-                end
-                wait = 1e20 -- infinity for all practical purposes
+            wait = process_timers() or 1e20 -- infinity for all practical purposes
+            for _, handler in ipairs(idle_handlers) do
+                handler()
             end
             -- Resume playloop - important especially if an error happened while
             -- suspended, and the error was handled, but no resume was done.
@@ -528,6 +525,41 @@
     mp.raw_hook_add(id, name, pri - 50)
 end
 
+local async_call_table = {}
+local async_next_id = 1
+
+function mp.command_native_async(node, cb)
+    local id = async_next_id
+    async_next_id = async_next_id + 1
+    local res, err = mp.raw_command_native_async(id, node)
+    if not res then
+        cb(false, nil, err)
+        return res, err
+    end
+    local t = {cb = cb, id = id}
+    async_call_table[id] = t
+    return t
+end
+
+mp.register_event("command-reply", function(ev)
+    local id = tonumber(ev.id)
+    local t = async_call_table[id]
+    local cb = t.cb
+    t.id = nil
+    async_call_table[id] = nil
+    if ev.error then
+        cb(false, nil, ev.error)
+    else
+        cb(true, ev.result, nil)
+    end
+end)
+
+function mp.abort_async_command(t)
+    if t.id ~= nil then
+        mp.raw_abort_async_command(t.id)
+    end
+end
+
 local mp_utils = package.loaded["mp.utils"]
 
 function mp_utils.format_table(t, set)
@@ -596,4 +628,31 @@
     return string.format("%0.2f %s", b, d[i] and d[i] or "*1024^" .. (i-1))
 end
 
+function mp_utils.subprocess(t)
+    local cmd = {}
+    cmd.name = "subprocess"
+    cmd.capture_stdout = true
+    for k, v in pairs(t) do
+        if k == "cancellable" then
+            k = "playback_only"
+        elseif k == "max_size" then
+            k = "capture_size"
+        end
+        cmd[k] = v
+    end
+    local res, err = mp.command_native(cmd)
+    if res == nil then
+        -- an error usually happens only if parsing failed (or no args passed)
+        res = {error_string = err, status = -1}
+    end
+    if res.error_string ~= "" then
+        res.error = res.error_string
+    end
+    return res
+end
+
+function mp_utils.subprocess_detached(t)
+    mp.commandv("run", unpack(t.args))
+end
+
 return {}
diff -ruN mpv-0.29.1/player/lua/osc.lua mpv-master/player/lua/osc.lua
--- mpv-0.29.1/player/lua/osc.lua	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/lua/osc.lua	2019-09-19 04:02:03.000000000 +0700
@@ -6,7 +6,6 @@
 --
 -- Parameters
 --
-
 -- default user option values
 -- do not touch, change them in osc.conf
 local user_opts = {
@@ -32,15 +31,17 @@
                                 -- internal track list management (and some
                                 -- functions that depend on it)
     layout = "bottombar",
-    seekbarstyle = "bar",       -- slider (diamond marker), knob (circle
-                                -- marker with guide), or bar (fill)
+    seekbarstyle = "bar",       -- bar, diamond or knob
+    seekbarhandlesize = 0.6,    -- size ratio of the diamond and knob handle
+    seekrangestyle = "inverted",-- bar, line, slider, inverted or none
+    seekrangeseparate = true,   -- wether the seekranges overlay on the bar-style seekbar
+    seekrangealpha = 200,       -- transparency of seekranges
     seekbarkeyframes = true,    -- use keyframes when dragging the seekbar
     title = "${media-title}",   -- string compatible with property-expansion
                                 -- to be shown as OSC title
     tooltipborder = 1,          -- border of tooltip in bottom/topbar
     timetotal = false,          -- display total time instead of remaining time?
     timems = false,             -- display timecodes with milliseconds?
-    seekranges = true,          -- display seek ranges?
     visibility = "auto",        -- only used at init to set visibility_mode(...)
     boxmaxchars = 80,           -- title crop threshold for box layout
 }
@@ -251,6 +252,37 @@
     table.insert(osc_param.areas[name], {x1=x1, y1=y1, x2=x2, y2=y2})
 end
 
+function ass_append_alpha(ass, alpha, modifier)
+    local ar = {}
+
+    for ai, av in pairs(alpha) do
+        av = mult_alpha(av, modifier)
+        if state.animation then
+            av = mult_alpha(av, state.animation)
+        end
+        ar[ai] = av
+    end
+
+    ass:append(string.format("{\\1a&H%X&\\2a&H%X&\\3a&H%X&\\4a&H%X&}",
+               ar[1], ar[2], ar[3], ar[4]))
+end
+
+function ass_draw_rr_h_cw(ass, x0, y0, x1, y1, r1, hexagon, r2)
+    if hexagon then
+        ass:hexagon_cw(x0, y0, x1, y1, r1, r2)
+    else
+        ass:round_rect_cw(x0, y0, x1, y1, r1, r2)
+    end
+end
+
+function ass_draw_rr_h_ccw(ass, x0, y0, x1, y1, r1, hexagon, r2)
+    if hexagon then
+        ass:hexagon_ccw(x0, y0, x1, y1, r1, r2)
+    else
+        ass:round_rect_ccw(x0, y0, x1, y1, r1, r2)
+    end
+end
+
 
 --
 -- Tracklist Management
@@ -395,25 +427,30 @@
         if (element.type == "box") then
             --draw box
             static_ass:draw_start()
-            static_ass:round_rect_cw(0, 0, elem_geo.w, elem_geo.h,
-                element.layout.box.radius)
+            ass_draw_rr_h_cw(static_ass, 0, 0, elem_geo.w, elem_geo.h,
+                             element.layout.box.radius, element.layout.box.hexagon)
             static_ass:draw_stop()
 
-
         elseif (element.type == "slider") then
             --draw static slider parts
 
+            local r1 = 0
+            local r2 = 0
             local slider_lo = element.layout.slider
             -- offset between element outline and drag-area
             local foV = slider_lo.border + slider_lo.gap
 
             -- calculate positions of min and max points
-            if (slider_lo.stype == "slider") or
-                (slider_lo.stype == "knob") then
+            if (slider_lo.stype ~= "bar") then
+                r1 = elem_geo.h / 2
                 element.slider.min.ele_pos = elem_geo.h / 2
                 element.slider.max.ele_pos = elem_geo.w - (elem_geo.h / 2)
-
-            elseif (slider_lo.stype == "bar") then
+                if (slider_lo.stype == "diamond") then
+                    r2 = (elem_geo.h - 2 * slider_lo.border) / 2
+                elseif (slider_lo.stype == "knob") then
+                    r2 = r1
+                end
+            else
                 element.slider.min.ele_pos =
                     slider_lo.border + slider_lo.gap
                 element.slider.max.ele_pos =
@@ -430,11 +467,12 @@
             static_ass:draw_start()
 
             -- the box
-            static_ass:rect_cw(0, 0, elem_geo.w, elem_geo.h);
+            ass_draw_rr_h_cw(static_ass, 0, 0, elem_geo.w, elem_geo.h, r1, slider_lo.stype == "diamond")
 
             -- the "hole"
-            static_ass:rect_ccw(slider_lo.border, slider_lo.border,
-                elem_geo.w - slider_lo.border, elem_geo.h - slider_lo.border)
+            ass_draw_rr_h_ccw(static_ass, slider_lo.border, slider_lo.border,
+                              elem_geo.w - slider_lo.border, elem_geo.h - slider_lo.border,
+                              r2, slider_lo.stype == "diamond")
 
             -- marker nibbles
             if not (element.slider.markerF == nil) and (slider_lo.gap > 0) then
@@ -510,18 +548,7 @@
 
         local style_ass = assdraw.ass_new()
         style_ass:merge(element.style_ass)
-
-        --alpha
-        local ar = element.layout.alpha
-        if not (state.animation == nil) then
-            ar = {}
-            for ai, av in pairs(element.layout.alpha) do
-                ar[ai] = mult_alpha(av, state.animation)
-            end
-        end
-
-        style_ass:append(string.format("{\\1a&H%X&\\2a&H%X&\\3a&H%X&\\4a&H%X&}",
-            ar[1], ar[2], ar[3], ar[4]))
+        ass_append_alpha(style_ass, element.layout.alpha, 0)
 
         if element.eventresponder and (state.active_element == n) then
 
@@ -562,48 +589,110 @@
             local s_max = element.slider.max.value
 
             -- draw pos marker
+            local foH, xp
             local pos = element.slider.posF()
+            local foV = slider_lo.border + slider_lo.gap
+            local innerH = elem_geo.h - (2 * foV)
+            local seekRanges = element.slider.seekRangesF()
+            local seekRangeLineHeight = innerH / 5
 
-            if not (pos == nil) then
+            if slider_lo.stype ~= "bar" then
+                foH = elem_geo.h / 2
+            else
+                foH = slider_lo.border + slider_lo.gap
+            end
 
-                local foV = slider_lo.border + slider_lo.gap
-                local foH = 0
-                if (slider_lo.stype == "slider") or
-                    (slider_lo.stype == "knob") then
-                    foH = elem_geo.h / 2
-                elseif (slider_lo.stype == "bar") then
-                    foH = slider_lo.border + slider_lo.gap
-                end
+            if pos then
+                xp = get_slider_ele_pos_for(element, pos)
 
-                local xp = get_slider_ele_pos_for(element, pos)
+                if slider_lo.stype ~= "bar" then
+                    local r = (user_opts.seekbarhandlesize * innerH) / 2
+                    ass_draw_rr_h_cw(elem_ass, xp - r, foH - r,
+                                     xp + r, foH + r,
+                                     r, slider_lo.stype == "diamond")
+                else
+                    local h = 0
+                    if seekRanges and user_opts.seekrangeseparate and slider_lo.rtype ~= "inverted" then
+                        h = seekRangeLineHeight
+                    end
+                    elem_ass:rect_cw(foH, foV, xp, elem_geo.h - foV - h)
 
-                -- the filling
-                local innerH = elem_geo.h - (2*foV)
+                    if seekRanges and not user_opts.seekrangeseparate and slider_lo.rtype ~= "inverted" then
+                        -- Punch holes for the seekRanges to be drawn later
+                        for _,range in pairs(seekRanges) do
+                            if range["start"] < pos then
+                                local pstart = get_slider_ele_pos_for(element, range["start"])
+                                local pend = xp
+
+                                if pos > range["end"] then
+                                    pend = get_slider_ele_pos_for(element, range["end"])
+                                end
+                                elem_ass:rect_ccw(pstart, elem_geo.h - foV - seekRangeLineHeight, pend, elem_geo.h - foV)
+                            end
+                        end
+                    end
+                end
 
-                if (slider_lo.stype == "bar") then
-                    elem_ass:rect_cw(foH, foV, xp, elem_geo.h - foV)
-                elseif (slider_lo.stype == "slider") then
-                    elem_ass:move_to(xp, foV)
-                    elem_ass:line_to(xp+(innerH/2), (innerH/2)+foV)
-                    elem_ass:line_to(xp, (innerH)+foV)
-                    elem_ass:line_to(xp-(innerH/2), (innerH/2)+foV)
-                elseif (slider_lo.stype == "knob") then
-                    elem_ass:rect_cw(xp, (9*innerH/20) + foV,
-                        elem_geo.w - foH, (11*innerH/20) + foV)
-                    elem_ass:rect_cw(foH, (3*innerH/8) + foV,
-                        xp, (5*innerH/8) + foV)
-                    elem_ass:round_rect_cw(xp - innerH/2, foV,
-                        xp + innerH/2, foV + innerH, innerH/2.0)
+                if slider_lo.rtype == "slider" then
+                    ass_draw_rr_h_cw(elem_ass, foH - innerH / 6, foH - innerH / 6,
+                                     xp, foH + innerH / 6,
+                                     innerH / 6, slider_lo.stype == "diamond", 0)
+                    ass_draw_rr_h_cw(elem_ass, xp, foH - innerH / 15,
+                                     elem_geo.w - foH + innerH / 15, foH + innerH / 15,
+                                     0, slider_lo.stype == "diamond", innerH / 15)
+                    for _,range in pairs(seekRanges or {}) do
+                        local pstart = get_slider_ele_pos_for(element, range["start"])
+                        local pend = get_slider_ele_pos_for(element, range["end"])
+                        ass_draw_rr_h_ccw(elem_ass, pstart, foH - innerH / 21,
+                                          pend, foH + innerH / 21,
+                                          innerH / 21, slider_lo.stype == "diamond")
+                    end
                 end
             end
 
-            -- seek ranges
-            local seekRanges = element.slider.seekRangesF()
-            if not (seekRanges == nil) then
+            if seekRanges then
+                if slider_lo.rtype ~= "inverted" then
+                    elem_ass:draw_stop()
+                    elem_ass:merge(element.style_ass)
+                    ass_append_alpha(elem_ass, element.layout.alpha, user_opts.seekrangealpha)
+                    elem_ass:merge(element.static_ass)
+                end
+
                 for _,range in pairs(seekRanges) do
                     local pstart = get_slider_ele_pos_for(element, range["start"])
                     local pend = get_slider_ele_pos_for(element, range["end"])
-                    elem_ass:rect_ccw(pstart, (elem_geo.h/2)-1, pend, (elem_geo.h/2) + 1)
+
+                    if slider_lo.rtype == "slider" then
+                        ass_draw_rr_h_cw(elem_ass, pstart, foH - innerH / 21,
+                                         pend, foH + innerH / 21,
+                                         innerH / 21, slider_lo.stype == "diamond")
+                    elseif slider_lo.rtype == "line" then
+                        if slider_lo.stype == "bar" then
+                            elem_ass:rect_cw(pstart, elem_geo.h - foV - seekRangeLineHeight, pend, elem_geo.h - foV)
+                        else
+                            ass_draw_rr_h_cw(elem_ass, pstart - innerH / 8, foH - innerH / 8,
+                                             pend + innerH / 8, foH + innerH / 8,
+                                             innerH / 8, slider_lo.stype == "diamond")
+                        end
+                    elseif slider_lo.rtype == "bar" then
+                        if slider_lo.stype ~= "bar" then
+                            ass_draw_rr_h_cw(elem_ass, pstart - innerH / 2, foV,
+                                             pend + innerH / 2, foV + innerH,
+                                             innerH / 2, slider_lo.stype == "diamond")
+                        elseif range["end"] >= (pos or 0) then
+                            elem_ass:rect_cw(pstart, foV, pend, elem_geo.h - foV)
+                        else
+                            elem_ass:rect_cw(pstart, elem_geo.h - foV - seekRangeLineHeight, pend, elem_geo.h - foV)
+                        end
+                    elseif slider_lo.rtype == "inverted" then
+                        if slider_lo.stype ~= "bar" then
+                            ass_draw_rr_h_ccw(elem_ass, pstart, (elem_geo.h / 2) - 1, pend,
+                                              (elem_geo.h / 2) + 1,
+                                              1, slider_lo.stype == "diamond")
+                        else
+                            elem_ass:rect_ccw(pstart, (elem_geo.h / 2) - 1, pend, (elem_geo.h / 2) + 1)
+                        end
+                    end
                 end
             end
 
@@ -648,18 +737,7 @@
                     elem_ass:pos(tx, ty)
                     elem_ass:an(an)
                     elem_ass:append(slider_lo.tooltip_style)
-
-                    --alpha
-                    local ar = slider_lo.alpha
-                    if not (state.animation == nil) then
-                        ar = {}
-                        for ai, av in pairs(slider_lo.alpha) do
-                            ar[ai] = mult_alpha(av, state.animation)
-                        end
-                    end
-                    elem_ass:append(string.format("{\\1a&H%X&\\2a&H%X&\\3a&H%X&\\4a&H%X&}",
-                        ar[1], ar[2], ar[3], ar[4]))
-
+                    ass_append_alpha(elem_ass, slider_lo.alpha, 0)
                     elem_ass:append(tooltiplabel)
 
                 end
@@ -862,7 +940,7 @@
                 alpha = {[1] = 0, [2] = 255, [3] = 88, [4] = 255},
             }
         elseif (elements[name].type == "box") then
-            elements[name].layout.box = {radius = 0}
+            elements[name].layout.box = {radius = 0, hexagon = false}
         end
 
         return elements[name].layout
@@ -1028,9 +1106,7 @@
     lo.style = osc_styles.timecodes
     lo.slider.tooltip_style = osc_styles.vidtitle
     lo.slider.stype = user_opts["seekbarstyle"]
-    if lo.slider.stype == "knob" then
-        lo.slider.border = 0
-    end
+    lo.slider.rtype = user_opts["seekrangestyle"]
 
     --
     -- Timecodes + Cache
@@ -1119,6 +1195,7 @@
     lo.alpha[3] = 0
     if not (user_opts["seekbarstyle"] == "bar") then
         lo.box.radius = osc_geo.r
+        lo.box.hexagon = user_opts["seekbarstyle"] == "diamond"
     end
 
 
@@ -1130,6 +1207,7 @@
     lo.slider.gap = 1.5
     lo.slider.tooltip_style = styles.tooltip
     lo.slider.stype = user_opts["seekbarstyle"]
+    lo.slider.rtype = user_opts["seekrangestyle"]
     lo.slider.adjust_tooltip = false
 
     --
@@ -1316,6 +1394,10 @@
     lo.style = osc_styles.timecodesBar
     lo.alpha[1] =
         math.min(255, user_opts.boxalpha + (255 - user_opts.boxalpha)*0.8)
+    if not (user_opts["seekbarstyle"] == "bar") then
+        lo.box.radius = geo.h / 2
+        lo.box.hexagon = user_opts["seekbarstyle"] == "diamond"
+    end
 
     lo = add_layout("seekbar")
     lo.geometry = geo
@@ -1325,6 +1407,7 @@
     lo.slider.tooltip_style = osc_styles.timePosBar
     lo.slider.tooltip_an = 5
     lo.slider.stype = user_opts["seekbarstyle"]
+    lo.slider.rtype = user_opts["seekrangestyle"]
 end
 
 layouts["topbar"] = function()
@@ -1450,6 +1533,10 @@
     lo.style = osc_styles.timecodesBar
     lo.alpha[1] =
         math.min(255, user_opts.boxalpha + (255 - user_opts.boxalpha)*0.8)
+    if not (user_opts["seekbarstyle"] == "bar") then
+        lo.box.radius = geo.h / 2
+        lo.box.hexagon = user_opts["seekbarstyle"] == "diamond"
+    end
 
     lo = add_layout("seekbar")
     lo.geometry = geo
@@ -1458,6 +1545,7 @@
     lo.slider.gap = 2
     lo.slider.tooltip_style = osc_styles.timePosBar
     lo.slider.stype = user_opts["seekbarstyle"]
+    lo.slider.rtype = user_opts["seekrangestyle"]
     lo.slider.tooltip_an = 5
 
 
@@ -1497,15 +1585,31 @@
 function validate_user_opts()
     if layouts[user_opts.layout] == nil then
         msg.warn("Invalid setting \""..user_opts.layout.."\" for layout")
-        user_opts.layout = "box"
+        user_opts.layout = "bottombar"
     end
 
-    if user_opts.seekbarstyle ~= "slider" and
-       user_opts.seekbarstyle ~= "bar" and
+    if user_opts.seekbarstyle ~= "bar" and
+       user_opts.seekbarstyle ~= "diamond" and
        user_opts.seekbarstyle ~= "knob" then
         msg.warn("Invalid setting \"" .. user_opts.seekbarstyle
             .. "\" for seekbarstyle")
-        user_opts.seekbarstyle = "slider"
+        user_opts.seekbarstyle = "bar"
+    end
+
+    if user_opts.seekrangestyle ~= "bar" and
+       user_opts.seekrangestyle ~= "line" and
+       user_opts.seekrangestyle ~= "slider" and
+       user_opts.seekrangestyle ~= "inverted" and
+       user_opts.seekrangestyle ~= "none" then
+        msg.warn("Invalid setting \"" .. user_opts.seekrangestyle
+            .. "\" for seekrangestyle")
+        user_opts.seekrangestyle = "inverted"
+    end
+
+    if user_opts.seekrangestyle == "slider" and
+       user_opts.seekbarstyle == "bar" then
+        msg.warn("Using \"slider\" seekrangestyle together with \"bar\" seekbarstyle is not supported")
+        user_opts.seekrangestyle = "inverted"
     end
 end
 
@@ -1762,7 +1866,7 @@
         end
     end
     ne.slider.seekRangesF = function()
-        if not (user_opts.seekranges) then
+        if user_opts.seekrangestyle == "none" then
             return nil
         end
         local cache_state = mp.get_property_native("demuxer-cache-state", nil)
@@ -1778,6 +1882,9 @@
             range["start"] = 100 * range["start"] / duration
             range["end"] = 100 * range["end"] / duration
         end
+        if #ranges == 0 then
+            return nil
+        end
         return ranges
     end
     ne.eventresponder["mouse_move"] = --keyframe seeking when mouse is dragged
diff -ruN mpv-0.29.1/player/lua/stats.lua mpv-master/player/lua/stats.lua
--- mpv-0.29.1/player/lua/stats.lua	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/lua/stats.lua	2019-09-19 04:02:03.000000000 +0700
@@ -430,6 +430,9 @@
         append_property(s, "media-title", {prefix="Title:"})
     end
 
+    local fs = append_property(s, "file-size", {prefix="Size:"})
+    append_property(s, "file-format", {prefix="Format/Protocol:", nl=fs and "" or o.nl})
+
     local ch_index = mp.get_property_number("chapter")
     if ch_index and ch_index >= 0 then
         append_property(s, "chapter-list/" .. tostring(ch_index) .. "/title", {prefix="Chapter:"})
@@ -445,20 +448,16 @@
         demuxer_cache = 0
     end
     local demuxer_secs = mp.get_property_number("demuxer-cache-duration", 0)
-    local stream_cache = mp.get_property_number("cache-used", 0) * 1024 -- returns KiB
-    if stream_cache + demuxer_cache + demuxer_secs > 0 then
-        append(s, utils.format_bytes_humanized(stream_cache + demuxer_cache), {prefix="Total Cache:"})
-        append(s, utils.format_bytes_humanized(demuxer_cache), {prefix="(Demuxer:",
-               suffix=",", nl="", no_prefix_markup=true, indent=o.prefix_sep})
-        append(s, format("%.1f", demuxer_secs), {suffix=" sec)", nl="", indent="",
-               no_prefix_markup=true})
+    if demuxer_cache + demuxer_secs > 0 then
+        append(s, utils.format_bytes_humanized(demuxer_cache), {prefix="Total Cache:"})
+        append(s, format("%.1f", demuxer_secs), {prefix="(", suffix=" sec)", nl="",
+               no_prefix_markup=true, prefix_sep="", indent=o.prefix_sep})
         local speed = mp.get_property_number("cache-speed", 0)
         if speed > 0 then
             append(s, utils.format_bytes_humanized(speed) .. "/s", {prefix="Speed:", nl="",
                    indent=o.prefix_sep, no_prefix_markup=true})
         end
     end
-    append_property(s, "file-size", {prefix="Size:"})
 end
 
 
@@ -537,9 +536,9 @@
 
     append(s, "", {prefix=o.nl .. o.nl .. "Audio:", nl="", indent=""})
     append_property(s, "audio-codec", {prefix_sep="", nl="", indent=""})
-    append(s, r["format"], {prefix="Format:"})
+    local cc = append(s, r["channel-count"], {prefix="Channels:"})
+    append(s, r["format"], {prefix="Format:", nl=cc and "" or o.nl})
     append(s, r["samplerate"], {prefix="Sample Rate:", suffix=" Hz"})
-    append(s, r["channel-count"], {prefix="Channels:"})
     append_property(s, "packet-audio-bitrate", {prefix="Bitrate:", suffix=" kbps"})
     append_filters(s, "af", "Filters:")
 end
diff -ruN mpv-0.29.1/player/lua.c mpv-master/player/lua.c
--- mpv-0.29.1/player/lua.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/lua.c	2019-09-19 04:02:03.000000000 +0700
@@ -562,6 +562,12 @@
         lua_setfield(L, -2, "hook_id");
         break;
     }
+    case MPV_EVENT_COMMAND_REPLY: {
+        mpv_event_command *cmd = event->data;
+        pushnode(L, &cmd->result);
+        lua_setfield(L, -2, "result");
+        break;
+    }
     default: ;
     }
 
@@ -967,6 +973,26 @@
     return 2;
 }
 
+static int script_raw_command_native_async(lua_State *L)
+{
+    struct script_ctx *ctx = get_ctx(L);
+    uint64_t id = luaL_checknumber(L, 1);
+    struct mpv_node node;
+    void *tmp = mp_lua_PITA(L);
+    makenode(tmp, &node, L, 2);
+    int res = mpv_command_node_async(ctx->client, id, &node);
+    talloc_free_children(tmp);
+    return check_error(L, res);
+}
+
+static int script_raw_abort_async_command(lua_State *L)
+{
+    struct script_ctx *ctx = get_ctx(L);
+    uint64_t id = luaL_checknumber(L, 1);
+    mpv_abort_async_command(ctx->client, id);
+    return 0;
+}
+
 static int script_set_osd_ass(lua_State *L)
 {
     struct script_ctx *ctx = get_ctx(L);
@@ -1169,112 +1195,6 @@
     return 1;
 }
 
-struct subprocess_cb_ctx {
-    struct mp_log *log;
-    void* talloc_ctx;
-    int64_t max_size;
-    bstr output;
-};
-
-static void subprocess_stdout(void *p, char *data, size_t size)
-{
-    struct subprocess_cb_ctx *ctx = p;
-    if (ctx->output.len < ctx->max_size)
-        bstr_xappend(ctx->talloc_ctx, &ctx->output, (bstr){data, size});
-}
-
-static void subprocess_stderr(void *p, char *data, size_t size)
-{
-    struct subprocess_cb_ctx *ctx = p;
-    MP_INFO(ctx, "%.*s", (int)size, data);
-}
-
-static int script_subprocess(lua_State *L)
-{
-    struct script_ctx *ctx = get_ctx(L);
-    luaL_checktype(L, 1, LUA_TTABLE);
-    void *tmp = mp_lua_PITA(L);
-
-    lua_getfield(L, 1, "args"); // args
-    int num_args = mp_lua_len(L, -1);
-    char *args[256];
-    if (num_args > MP_ARRAY_SIZE(args) - 1) // last needs to be NULL
-        luaL_error(L, "too many arguments");
-    if (num_args < 1)
-        luaL_error(L, "program name missing");
-    for (int n = 0; n < num_args; n++) {
-        lua_pushinteger(L, n + 1); // args n
-        lua_gettable(L, -2); // args arg
-        args[n] = talloc_strdup(tmp, lua_tostring(L, -1));
-        if (!args[n])
-            luaL_error(L, "program arguments must be strings");
-        lua_pop(L, 1); // args
-    }
-    args[num_args] = NULL;
-    lua_pop(L, 1); // -
-
-    lua_getfield(L, 1, "cancellable"); // c
-    struct mp_cancel *cancel = NULL;
-    if (lua_isnil(L, -1) ? true : lua_toboolean(L, -1))
-        cancel = ctx->mpctx->playback_abort;
-    lua_pop(L, 1); // -
-
-    lua_getfield(L, 1, "max_size"); // m
-    int64_t max_size = lua_isnil(L, -1) ? 64 * 1024 * 1024 : lua_tointeger(L, -1);
-
-    struct subprocess_cb_ctx cb_ctx = {
-        .log = ctx->log,
-        .talloc_ctx = tmp,
-        .max_size = max_size,
-    };
-
-    char *error = NULL;
-    int status = mp_subprocess(args, cancel, &cb_ctx, subprocess_stdout,
-                               subprocess_stderr, &error);
-
-    lua_newtable(L); // res
-    if (error) {
-        lua_pushstring(L, error); // res e
-        lua_setfield(L, -2, "error"); // res
-    }
-    lua_pushinteger(L, status); // res s
-    lua_setfield(L, -2, "status"); // res
-    lua_pushlstring(L, cb_ctx.output.start, cb_ctx.output.len); // res d
-    lua_setfield(L, -2, "stdout"); // res
-    lua_pushboolean(L, status == MP_SUBPROCESS_EKILLED_BY_US); // res b
-    lua_setfield(L, -2, "killed_by_us"); // res
-    return 1;
-}
-
-static int script_subprocess_detached(lua_State *L)
-{
-    struct script_ctx *ctx = get_ctx(L);
-    luaL_checktype(L, 1, LUA_TTABLE);
-    void *tmp = mp_lua_PITA(L);
-
-    lua_getfield(L, 1, "args"); // args
-    int num_args = mp_lua_len(L, -1);
-    char *args[256];
-    if (num_args > MP_ARRAY_SIZE(args) - 1) // last needs to be NULL
-        luaL_error(L, "too many arguments");
-    if (num_args < 1)
-        luaL_error(L, "program name missing");
-    for (int n = 0; n < num_args; n++) {
-        lua_pushinteger(L, n + 1); // args n
-        lua_gettable(L, -2); // args arg
-        args[n] = talloc_strdup(tmp, lua_tostring(L, -1));
-        if (!args[n])
-            luaL_error(L, "program arguments must be strings");
-        lua_pop(L, 1); // args
-    }
-    args[num_args] = NULL;
-    lua_pop(L, 1); // -
-
-    mp_subprocess_detached(ctx->log, args);
-    lua_pushnil(L);
-    return 1;
-}
-
 static int script_getpid(lua_State *L)
 {
     lua_pushnumber(L, mp_getpid());
@@ -1339,6 +1259,8 @@
     FN_ENTRY(command),
     FN_ENTRY(commandv),
     FN_ENTRY(command_native),
+    FN_ENTRY(raw_command_native_async),
+    FN_ENTRY(raw_abort_async_command),
     FN_ENTRY(get_property_bool),
     FN_ENTRY(get_property_number),
     FN_ENTRY(get_property_native),
@@ -1367,8 +1289,6 @@
     FN_ENTRY(file_info),
     FN_ENTRY(split_path),
     FN_ENTRY(join_path),
-    FN_ENTRY(subprocess),
-    FN_ENTRY(subprocess_detached),
     FN_ENTRY(getpid),
     FN_ENTRY(parse_json),
     FN_ENTRY(format_json),
diff -ruN mpv-0.29.1/player/main.c mpv-master/player/main.c
--- mpv-0.29.1/player/main.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/main.c	2019-09-19 04:02:03.000000000 +0700
@@ -28,6 +28,7 @@
 #include "mpv_talloc.h"
 
 #include "misc/dispatch.h"
+#include "misc/thread_pool.h"
 #include "osdep/io.h"
 #include "osdep/terminal.h"
 #include "osdep/timer.h"
@@ -53,7 +54,7 @@
 
 #include "audio/out/ao.h"
 #include "demux/demux.h"
-#include "stream/stream.h"
+#include "misc/thread_tools.h"
 #include "sub/osd.h"
 #include "video/out/vo.h"
 
@@ -116,7 +117,7 @@
 {
     bool had_log_file = mp_msg_has_log_file(mpctx->global);
 
-    mp_msg_update_msglevels(mpctx->global);
+    mp_msg_update_msglevels(mpctx->global, mpctx->opts);
 
     bool enable = mpctx->opts->use_terminal;
     bool enabled = cas_terminal_owner(mpctx, mpctx);
@@ -188,7 +189,9 @@
     uninit_libav(mpctx->global);
 
     mp_msg_uninit(mpctx->global);
-    pthread_mutex_destroy(&mpctx->lock);
+    assert(!mpctx->num_abort_list);
+    talloc_free(mpctx->abort_list);
+    pthread_mutex_destroy(&mpctx->abort_lock);
     talloc_free(mpctx);
 }
 
@@ -219,7 +222,9 @@
         MP_INFO(mpctx, "\n");
         return true;
     }
-    if (opts->audio_device && strcmp(opts->audio_device, "help") == 0) {
+    if (opts->ao_opts->audio_device &&
+        strcmp(opts->ao_opts->audio_device, "help") == 0)
+    {
         ao_print_devices(mpctx->global, log);
         return true;
     }
@@ -241,12 +246,6 @@
     return r;
 }
 
-static void abort_playback_cb(void *ctx)
-{
-    struct MPContext *mpctx = ctx;
-    mp_abort_playback_async(mpctx);
-}
-
 // We mostly care about LC_NUMERIC, and how "." vs. "," is treated,
 // Other locale stuff might break too, but probably isn't too bad.
 static bool check_locale(void)
@@ -279,9 +278,11 @@
         .playlist = talloc_struct(mpctx, struct playlist, {0}),
         .dispatch = mp_dispatch_create(mpctx),
         .playback_abort = mp_cancel_new(mpctx),
+        .thread_pool = mp_thread_pool_create(mpctx, 0, 1, 30),
+        .stop_play = PT_STOP,
     };
 
-    pthread_mutex_init(&mpctx->lock, NULL);
+    pthread_mutex_init(&mpctx->abort_lock, NULL);
 
     mpctx->global = talloc_zero(mpctx, struct mpv_global);
 
@@ -302,8 +303,6 @@
     m_config_parse(mpctx->mconfig, "", bstr0(def_config), NULL, 0);
     m_config_create_shadow(mpctx->mconfig);
 
-    mpctx->global->opts = mpctx->opts;
-
     mpctx->input = mp_input_init(mpctx->global, mp_wakeup_core_cb, mpctx);
     screenshot_init(mpctx);
     command_init(mpctx);
@@ -315,8 +314,6 @@
     cocoa_set_input_context(mpctx->input);
 #endif
 
-    mp_input_set_cancel(mpctx->input, abort_playback_cb, mpctx);
-
     char *verbose_env = getenv("MPV_VERBOSE");
     if (verbose_env)
         mpctx->opts->verbose = atoi(verbose_env);
@@ -336,9 +333,12 @@
     assert(!mpctx->initialized);
 
     // Preparse the command line, so we can init the terminal early.
-    if (options)
-        m_config_preparse_command_line(mpctx->mconfig, mpctx->global, options);
+    if (options) {
+        m_config_preparse_command_line(mpctx->mconfig, mpctx->global,
+                                       &opts->verbose, options);
+    }
 
+    mp_init_paths(mpctx->global, opts);
     mp_update_logging(mpctx, true);
 
     if (options) {
diff -ruN mpv-0.29.1/player/misc.c mpv-master/player/misc.c
--- mpv-0.29.1/player/misc.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/misc.c	2019-09-19 04:02:03.000000000 +0700
@@ -203,24 +203,6 @@
     queue_seek(mpctx, MPSEEK_ABSOLUTE, get_current_time(mpctx), min_prec, 0);
 }
 
-float mp_get_cache_percent(struct MPContext *mpctx)
-{
-    struct stream_cache_info info = {0};
-    if (mpctx->demuxer)
-        demux_stream_control(mpctx->demuxer, STREAM_CTRL_GET_CACHE_INFO, &info);
-    if (info.size > 0 && info.fill >= 0)
-        return info.fill / (info.size / 100.0);
-    return -1;
-}
-
-bool mp_get_cache_idle(struct MPContext *mpctx)
-{
-    struct stream_cache_info info = {0};
-    if (mpctx->demuxer)
-        demux_stream_control(mpctx->demuxer, STREAM_CTRL_GET_CACHE_INFO, &info);
-    return info.idle;
-}
-
 void update_vo_playback_state(struct MPContext *mpctx)
 {
     if (mpctx->video_out && mpctx->video_out->config_ok) {
diff -ruN mpv-0.29.1/player/osd.c mpv-master/player/osd.c
--- mpv-0.29.1/player/osd.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/osd.c	2019-09-19 04:02:03.000000000 +0700
@@ -229,27 +229,23 @@
         }
     }
 
-    if (mpctx->demuxer) {
-        struct stream_cache_info info = {0};
-        demux_stream_control(mpctx->demuxer, STREAM_CTRL_GET_CACHE_INFO, &info);
-        if (info.size > 0 || mpctx->demuxer->is_network) {
-            saddf(&line, " Cache: ");
+    if (mpctx->demuxer && demux_is_network_cached(mpctx->demuxer)) {
+        saddf(&line, " Cache: ");
 
-            struct demux_ctrl_reader_state s = {.ts_duration = -1};
-            demux_control(mpctx->demuxer, DEMUXER_CTRL_GET_READER_STATE, &s);
+        struct demux_ctrl_reader_state s = {.ts_duration = -1};
+        demux_control(mpctx->demuxer, DEMUXER_CTRL_GET_READER_STATE, &s);
 
-            if (s.ts_duration < 0) {
-                saddf(&line, "???");
+        if (s.ts_duration < 0) {
+            saddf(&line, "???");
+        } else {
+            saddf(&line, "%2ds", (int)s.ts_duration);
+        }
+        int64_t cache_size = s.fw_bytes;
+        if (cache_size > 0) {
+            if (cache_size >= 1024 * 1024) {
+                saddf(&line, "+%lldMB", (long long)(cache_size / 1024 / 1024));
             } else {
-                saddf(&line, "%2ds", (int)s.ts_duration);
-            }
-            int64_t cache_size = s.fw_bytes + info.fill;
-            if (cache_size > 0) {
-                if (cache_size >= 1024 * 1024) {
-                    saddf(&line, "+%lldMB", (long long)(cache_size / 1024 / 1024));
-                } else {
-                    saddf(&line, "+%lldKB", (long long)(cache_size / 1024));
-                }
+                saddf(&line, "+%lldKB", (long long)(cache_size / 1024));
             }
         }
     }
@@ -267,9 +263,13 @@
     if (!opts->use_terminal)
         return;
 
-    if (opts->quiet || !mpctx->playback_initialized || !mpctx->playing_msg_shown)
+    if (opts->quiet || !mpctx->playback_initialized ||
+        !mpctx->playing_msg_shown || mpctx->stop_play)
     {
-        term_osd_set_status_lazy(mpctx, "");
+        if (!mpctx->playing || mpctx->stop_play) {
+            mp_msg_flush_status_line(mpctx->log);
+            term_osd_set_status_lazy(mpctx, "");
+        }
         return;
     }
 
diff -ruN mpv-0.29.1/player/playloop.c mpv-master/player/playloop.c
--- mpv-0.29.1/player/playloop.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/playloop.c	2019-09-19 04:02:03.000000000 +0700
@@ -92,6 +92,16 @@
     mp_wakeup_core(mpctx);
 }
 
+void mp_core_lock(struct MPContext *mpctx)
+{
+    mp_dispatch_lock(mpctx->dispatch);
+}
+
+void mp_core_unlock(struct MPContext *mpctx)
+{
+    mp_dispatch_unlock(mpctx->dispatch);
+}
+
 // Process any queued input, whether it's user input, or requests from client
 // API threads. This also resets the "wakeup" flag used with mp_wait_events().
 void mp_process_input(struct MPContext *mpctx)
@@ -100,8 +110,7 @@
         mp_cmd_t *cmd = mp_input_read_cmd(mpctx->input);
         if (!cmd)
             break;
-        run_command(mpctx, cmd, NULL);
-        mp_cmd_free(cmd);
+        run_command(mpctx, cmd, NULL, NULL, NULL);
     }
     mp_set_timeout(mpctx, mp_input_get_delay(mpctx->input));
 }
@@ -118,8 +127,8 @@
 {
     bool eof = mpctx->video_status == STATUS_EOF &&
                mpctx->audio_status == STATUS_EOF;
-    bool active = !mpctx->paused && mpctx->restart_complete && mpctx->playing &&
-                  mpctx->in_playloop && !eof;
+    bool active = !mpctx->paused && mpctx->restart_complete &&
+                  !mpctx->stop_play && mpctx->in_playloop && !eof;
 
     if (mpctx->playback_active != active) {
         mpctx->playback_active = active;
@@ -219,7 +228,6 @@
     mpctx->hrseek_backstep = false;
     mpctx->current_seek = (struct seek_params){0};
     mpctx->playback_pts = MP_NOPTS_VALUE;
-    mpctx->last_seek_pts = MP_NOPTS_VALUE;
     mpctx->step_frames = 0;
     mpctx->ab_loop_clip = true;
     mpctx->restart_complete = false;
@@ -619,14 +627,11 @@
 
     double now = mp_time_sec();
 
-    struct stream_cache_info c = {.idle = true};
-    demux_stream_control(mpctx->demuxer, STREAM_CTRL_GET_CACHE_INFO, &c);
-
     struct demux_ctrl_reader_state s = {.idle = true, .ts_duration = -1};
     demux_control(mpctx->demuxer, DEMUXER_CTRL_GET_READER_STATE, &s);
 
     int cache_buffer = 100;
-    bool use_pause_on_low_cache = (c.size > 0 || mpctx->demuxer->is_network) &&
+    bool use_pause_on_low_cache = demux_is_network_cached(mpctx->demuxer) &&
                                   opts->cache_pause;
 
     if (!mpctx->restart_complete) {
@@ -661,7 +666,7 @@
     }
 
     // Also update cache properties.
-    bool busy = !s.idle || !c.idle;
+    bool busy = !s.idle;
     if (busy || mpctx->next_cache_update > 0) {
         if (mpctx->next_cache_update <= now) {
             mpctx->next_cache_update = busy ? now + 0.25 : 0;
@@ -841,8 +846,11 @@
                 seek_to_last_frame(mpctx);
             mpctx->playback_pts = mpctx->last_vo_pts;
         }
-        if (opts->keep_open_pause)
+        if (opts->keep_open_pause) {
+            if (mpctx->ao)
+                ao_drain(mpctx->ao);
             set_pause_state(mpctx, true);
+        }
     }
 }
 
@@ -865,7 +873,7 @@
 {
     // True if we're either in idle mode, or loading of the file has finished.
     // It's also set via force in some stages during file loading.
-    bool act = !mpctx->playing || mpctx->playback_initialized || force;
+    bool act = mpctx->stop_play || mpctx->playback_initialized || force;
 
     // On the other hand, if a video track is selected, but no video is ever
     // decoded on it, then create the window.
@@ -1055,7 +1063,7 @@
         mpctx->playing_msg_shown = true;
         mp_wakeup_core(mpctx);
         mpctx->ab_loop_clip = mpctx->playback_pts < opts->ab_loop[1];
-        MP_VERBOSE(mpctx, "playback restart complete\n");
+        MP_VERBOSE(mpctx, "playback restart complete @ %f\n", mpctx->playback_pts);
     }
 }
 
diff -ruN mpv-0.29.1/player/screenshot.c mpv-master/player/screenshot.c
--- mpv-0.29.1/player/screenshot.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/screenshot.c	2019-09-19 04:02:03.000000000 +0700
@@ -27,15 +27,18 @@
 #include "screenshot.h"
 #include "core.h"
 #include "command.h"
+#include "input/cmd.h"
 #include "misc/bstr.h"
 #include "misc/dispatch.h"
-#include "misc/thread_pool.h"
+#include "misc/node.h"
+#include "misc/thread_tools.h"
 #include "common/msg.h"
 #include "options/path.h"
 #include "video/mp_image.h"
 #include "video/mp_image_pool.h"
 #include "video/out/vo.h"
 #include "video/image_writer.h"
+#include "video/sws_utils.h"
 #include "sub/osd.h"
 
 #include "video/csputils.h"
@@ -46,13 +49,12 @@
 typedef struct screenshot_ctx {
     struct MPContext *mpctx;
 
-    int mode;
-    bool each_frame;
     bool osd;
 
-    int frameno;
+    // Command to repeat in each-frame mode.
+    struct mp_cmd *each_frame;
 
-    struct mp_thread_pool *thread_pool;
+    int frameno;
 } screenshot_ctx;
 
 void screenshot_init(struct MPContext *mpctx)
@@ -92,73 +94,27 @@
     return talloc_asprintf(talloc_ctx, "%.*s", (int)(end - s), s);
 }
 
-struct screenshot_item {
-    bool on_thread;
-    struct MPContext *mpctx;
-    const char *filename;
-    struct mp_image *img;
-    struct image_writer_opts opts;
-};
-
-#define LOCK(item) if (item->on_thread) mp_dispatch_lock(item->mpctx->dispatch);
-#define UNLOCK(item) if (item->on_thread) mp_dispatch_unlock(item->mpctx->dispatch);
-
-static void write_screenshot_thread(void *arg)
-{
-    struct screenshot_item *item = arg;
-    screenshot_ctx *ctx = item->mpctx->screenshot_ctx;
-
-    LOCK(item)
-    screenshot_msg(ctx, MSGL_INFO, "Screenshot: '%s'", item->filename);
-    UNLOCK(item)
-
-    if (!item->img || !write_image(item->img, &item->opts, item->filename,
-                                   item->mpctx->log))
-    {
-        LOCK(item)
-        screenshot_msg(ctx, MSGL_ERR, "Error writing screenshot!");
-        UNLOCK(item)
-    }
-
-    if (item->on_thread) {
-        mp_dispatch_lock(item->mpctx->dispatch);
-        screenshot_msg(ctx, MSGL_V, "Screenshot writing done.");
-        item->mpctx->outstanding_async -= 1;
-        mp_wakeup_core(item->mpctx);
-        mp_dispatch_unlock(item->mpctx->dispatch);
-    }
-
-    talloc_free(item);
-}
-
-static void write_screenshot(struct MPContext *mpctx, struct mp_image *img,
-                             const char *filename, struct image_writer_opts *opts,
-                             bool async)
+static bool write_screenshot(struct MPContext *mpctx, struct mp_image *img,
+                             const char *filename, struct image_writer_opts *opts)
 {
     screenshot_ctx *ctx = mpctx->screenshot_ctx;
     struct image_writer_opts *gopts = mpctx->opts->screenshot_image_opts;
+    struct image_writer_opts opts_copy = opts ? *opts : *gopts;
 
-    struct screenshot_item *item = talloc_zero(NULL, struct screenshot_item);
-    *item = (struct screenshot_item){
-        .mpctx = mpctx,
-        .filename = talloc_strdup(item, filename),
-        .img = talloc_steal(item, mp_image_new_ref(img)),
-        .opts = opts ? *opts : *gopts,
-    };
+    screenshot_msg(ctx, MSGL_V, "Starting screenshot: '%s'", filename);
 
-    if (async) {
-        if (!ctx->thread_pool)
-            ctx->thread_pool = mp_thread_pool_create(ctx, 1);
-        if (ctx->thread_pool) {
-            item->on_thread = true;
-            mpctx->outstanding_async += 1;
-            mp_thread_pool_queue(ctx->thread_pool, write_screenshot_thread, item);
-            item = NULL;
-        }
-    }
+    mp_core_unlock(mpctx);
 
-    if (item)
-        write_screenshot_thread(item);
+    bool ok = img && write_image(img, &opts_copy, filename, mpctx->log);
+
+    mp_core_lock(mpctx);
+
+    if (ok) {
+        screenshot_msg(ctx, MSGL_INFO, "Screenshot: '%s'", filename);
+    } else {
+        screenshot_msg(ctx, MSGL_ERR, "Error writing screenshot!");
+    }
+    return ok;
 }
 
 #ifdef _WIN32
@@ -432,7 +388,44 @@
     return image;
 }
 
-struct mp_image *screenshot_get_rgb(struct MPContext *mpctx, int mode)
+struct mp_image *convert_image(struct mp_image *image, int destfmt,
+                               struct mp_log *log)
+{
+    int d_w, d_h;
+    mp_image_params_get_dsize(&image->params, &d_w, &d_h);
+
+    struct mp_image_params p = {
+        .imgfmt = destfmt,
+        .w = d_w,
+        .h = d_h,
+        .p_w = 1,
+        .p_h = 1,
+    };
+    mp_image_params_guess_csp(&p);
+
+    if (mp_image_params_equal(&p, &image->params))
+        return mp_image_new_ref(image);
+
+    struct mp_image *dst = mp_image_alloc(p.imgfmt, p.w, p.h);
+    if (!dst) {
+        mp_err(log, "Out of memory.\n");
+        return NULL;
+    }
+    mp_image_copy_attributes(dst, image);
+
+    dst->params = p;
+
+    if (mp_image_swscale(dst, image, mp_sws_hq_flags) < 0) {
+        mp_err(log, "Error when converting image.\n");
+        talloc_free(dst);
+        return NULL;
+    }
+
+    return dst;
+}
+
+// mode is the same as in screenshot_get()
+static struct mp_image *screenshot_get_rgb(struct MPContext *mpctx, int mode)
 {
     struct mp_image *mpi = screenshot_get(mpctx, mode, false);
     if (!mpi)
@@ -442,9 +435,13 @@
     return res;
 }
 
-void screenshot_to_file(struct MPContext *mpctx, const char *filename, int mode,
-                        bool osd, bool async)
+void cmd_screenshot_to_file(void *p)
 {
+    struct mp_cmd_ctx *cmd = p;
+    struct MPContext *mpctx = cmd->mpctx;
+    const char *filename = cmd->args[0].v.s;
+    int mode = cmd->args[1].v.i;
+    bool osd = cmd->msg_osd;
     screenshot_ctx *ctx = mpctx->screenshot_ctx;
     struct image_writer_opts opts = *mpctx->opts->screenshot_image_opts;
     bool old_osd = ctx->osd;
@@ -456,34 +453,45 @@
         opts.format = format;
     bool high_depth = image_writer_high_depth(&opts);
     struct mp_image *image = screenshot_get(mpctx, mode, high_depth);
+    ctx->osd = old_osd;
     if (!image) {
         screenshot_msg(ctx, MSGL_ERR, "Taking screenshot failed.");
-        goto end;
+        cmd->success = false;
+        return;
     }
-    write_screenshot(mpctx, image, filename, &opts, async);
+    cmd->success = write_screenshot(mpctx, image, filename, &opts);
     talloc_free(image);
-
-end:
-    ctx->osd = old_osd;
 }
 
-void screenshot_request(struct MPContext *mpctx, int mode, bool each_frame,
-                        bool osd, bool async)
+void cmd_screenshot(void *p)
 {
+    struct mp_cmd_ctx *cmd = p;
+    struct MPContext *mpctx = cmd->mpctx;
+    int mode = cmd->args[0].v.i & 3;
+    bool each_frame_toggle = (cmd->args[0].v.i | cmd->args[1].v.i) & 8;
+    bool each_frame_mode = cmd->args[0].v.i & 16;
+    bool osd = cmd->msg_osd;
+
     screenshot_ctx *ctx = mpctx->screenshot_ctx;
 
     if (mode == MODE_SUBTITLES && osd_get_render_subs_in_filter(mpctx->osd))
         mode = 0;
 
-    if (each_frame) {
-        ctx->each_frame = !ctx->each_frame;
-        if (!ctx->each_frame)
-            return;
-    } else {
-        ctx->each_frame = false;
+    if (!each_frame_mode) {
+        if (each_frame_toggle) {
+            if (ctx->each_frame) {
+                TA_FREEP(&ctx->each_frame);
+                return;
+            }
+            ctx->each_frame = talloc_steal(ctx, mp_cmd_clone(cmd->cmd));
+            ctx->each_frame->args[0].v.i |= 16;
+        } else {
+            TA_FREEP(&ctx->each_frame);
+        }
     }
 
-    ctx->mode = mode;
+    cmd->success = false;
+
     ctx->osd = osd;
 
     struct image_writer_opts *opts = mpctx->opts->screenshot_image_opts;
@@ -494,7 +502,7 @@
     if (image) {
         char *filename = gen_fname(ctx, image_writer_file_ext(opts));
         if (filename)
-            write_screenshot(mpctx, image, filename, NULL, async);
+            cmd->success = write_screenshot(mpctx, image, filename, NULL);
         talloc_free(filename);
     } else {
         screenshot_msg(ctx, MSGL_ERR, "Taking screenshot failed.");
@@ -503,6 +511,42 @@
     talloc_free(image);
 }
 
+void cmd_screenshot_raw(void *p)
+{
+    struct mp_cmd_ctx *cmd = p;
+    struct MPContext *mpctx = cmd->mpctx;
+    struct mpv_node *res = &cmd->result;
+
+    struct mp_image *img = screenshot_get_rgb(mpctx, cmd->args[0].v.i);
+    if (!img) {
+        cmd->success = false;
+        return;
+    }
+
+    node_init(res, MPV_FORMAT_NODE_MAP, NULL);
+    node_map_add_int64(res, "w", img->w);
+    node_map_add_int64(res, "h", img->h);
+    node_map_add_int64(res, "stride", img->stride[0]);
+    node_map_add_string(res, "format", "bgr0");
+    struct mpv_byte_array *ba =
+        node_map_add(res, "data", MPV_FORMAT_BYTE_ARRAY)->u.ba;
+    *ba = (struct mpv_byte_array){
+        .data = img->planes[0],
+        .size = img->stride[0] * img->h,
+    };
+    talloc_steal(ba, img);
+}
+
+static void screenshot_fin(struct mp_cmd_ctx *cmd)
+{
+    void **a = cmd->on_completion_priv;
+    struct MPContext *mpctx = a[0];
+    struct mp_waiter *waiter = a[1];
+
+    mp_waiter_wakeup(waiter, 0);
+    mp_wakeup_core(mpctx);
+}
+
 void screenshot_flip(struct MPContext *mpctx)
 {
     screenshot_ctx *ctx = mpctx->screenshot_ctx;
@@ -510,6 +554,14 @@
     if (!ctx->each_frame)
         return;
 
-    ctx->each_frame = false;
-    screenshot_request(mpctx, ctx->mode, true, ctx->osd, false);
+    struct mp_waiter wait = MP_WAITER_INITIALIZER;
+    void *a[] = {mpctx, &wait};
+    run_command(mpctx, mp_cmd_clone(ctx->each_frame), NULL, screenshot_fin, a);
+
+    // Block (in a reentrant way) until he screenshot was written. Otherwise,
+    // we could pile up screenshot requests forever.
+    while (!mp_waiter_poll(&wait))
+        mp_idle(mpctx);
+
+    mp_waiter_wait(&wait);
 }
diff -ruN mpv-0.29.1/player/screenshot.h mpv-master/player/screenshot.h
--- mpv-0.29.1/player/screenshot.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/screenshot.h	2019-09-19 04:02:03.000000000 +0700
@@ -21,28 +21,24 @@
 #include <stdbool.h>
 
 struct MPContext;
+struct mp_image;
+struct mp_log;
 
 // One time initialization at program start.
 void screenshot_init(struct MPContext *mpctx);
 
-// Request a taking & saving a screenshot of the currently displayed frame.
-// mode: 0: -, 1: save the actual output window contents, 2: with subtitles.
-// each_frame: If set, this toggles per-frame screenshots, exactly like the
-//             screenshot slave command (MP_CMD_SCREENSHOT).
-// osd: show status on OSD
-void screenshot_request(struct MPContext *mpctx, int mode, bool each_frame,
-                        bool osd, bool async);
-
-// filename: where to store the screenshot; doesn't try to find an alternate
-//           name if the file already exists
-// mode, osd: same as in screenshot_request()
-void screenshot_to_file(struct MPContext *mpctx, const char *filename, int mode,
-                        bool osd, bool async);
-
-// mode is the same as in screenshot_request()
-struct mp_image *screenshot_get_rgb(struct MPContext *mpctx, int mode);
-
 // Called by the playback core code when a new frame is displayed.
 void screenshot_flip(struct MPContext *mpctx);
 
+/* Return the image converted to the given format. If the pixel aspect ratio is
+ * not 1:1, the image is scaled as well. Returns NULL on failure.
+ */
+struct mp_image *convert_image(struct mp_image *image, int destfmt,
+                               struct mp_log *log);
+
+// Handlers for the user-facing commands.
+void cmd_screenshot(void *p);
+void cmd_screenshot_to_file(void *p);
+void cmd_screenshot_raw(void *p);
+
 #endif /* MPLAYER_SCREENSHOT_H */
diff -ruN mpv-0.29.1/player/sub.c mpv-master/player/sub.c
--- mpv-0.29.1/player/sub.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/sub.c	2019-09-19 04:02:03.000000000 +0700
@@ -70,6 +70,8 @@
         sub_select(track->d_sub, false);
         int order = get_order(mpctx, track);
         osd_set_sub(mpctx->osd, order, NULL);
+        sub_destroy(track->d_sub);
+        track->d_sub = NULL;
     }
 }
 
@@ -182,7 +184,9 @@
     if (!track || !track->stream || track->stream->type != STREAM_SUB)
         return;
 
-    if (!track->d_sub && !init_subdec(mpctx, track)) {
+    assert(!track->d_sub);
+
+    if (!init_subdec(mpctx, track)) {
         error_on_track(mpctx, track);
         return;
     }
diff -ruN mpv-0.29.1/player/video.c mpv-master/player/video.c
--- mpv-0.29.1/player/video.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/player/video.c	2019-09-19 04:02:03.000000000 +0700
@@ -1169,7 +1169,6 @@
             MP_VERBOSE(mpctx, "first video frame after restart shown\n");
         }
     }
-    screenshot_flip(mpctx);
 
     mp_notify(mpctx, MPV_EVENT_TICK, NULL);
 
@@ -1188,6 +1187,8 @@
             mpctx->max_frames--;
     }
 
+    screenshot_flip(mpctx);
+
     mp_wakeup_core(mpctx);
     return;
 
diff -ruN mpv-0.29.1/stream/ai_alsa1x.c mpv-master/stream/ai_alsa1x.c
--- mpv-0.29.1/stream/ai_alsa1x.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/ai_alsa1x.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,199 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <sys/time.h>
-
-#include "config.h"
-
-#include <alsa/asoundlib.h>
-#include "audio_in.h"
-#include "common/msg.h"
-
-int ai_alsa_setup(audio_in_t *ai)
-{
-    snd_pcm_hw_params_t *params;
-    snd_pcm_sw_params_t *swparams;
-    snd_pcm_uframes_t buffer_size, period_size;
-    int err;
-    int dir;
-    unsigned int rate;
-
-    snd_pcm_hw_params_alloca(&params);
-    snd_pcm_sw_params_alloca(&swparams);
-
-    err = snd_pcm_hw_params_any(ai->alsa.handle, params);
-    if (err < 0) {
-        MP_ERR(ai, "Broken configuration for this PCM: no configurations available.\n");
-        return -1;
-    }
-
-    err = snd_pcm_hw_params_set_access(ai->alsa.handle, params,
-                                       SND_PCM_ACCESS_RW_INTERLEAVED);
-    if (err < 0) {
-        MP_ERR(ai, "Access type not available.\n");
-        return -1;
-    }
-
-    err = snd_pcm_hw_params_set_format(ai->alsa.handle, params, SND_PCM_FORMAT_S16);
-    if (err < 0) {
-        MP_ERR(ai, "Sample format not available.\n");
-        return -1;
-    }
-
-    err = snd_pcm_hw_params_set_channels(ai->alsa.handle, params, ai->req_channels);
-    if (err < 0) {
-        snd_pcm_hw_params_get_channels(params, &ai->channels);
-        MP_ERR(ai, "Channel count not available - reverting to default: %d\n",
-               ai->channels);
-    } else {
-        ai->channels = ai->req_channels;
-    }
-
-    dir = 0;
-    rate = ai->req_samplerate;
-    err = snd_pcm_hw_params_set_rate_near(ai->alsa.handle, params, &rate, &dir);
-    if (err < 0) {
-        MP_ERR(ai, "Cannot set samplerate.\n");
-    }
-    ai->samplerate = rate;
-
-    dir = 0;
-    ai->alsa.buffer_time = 1000000;
-    err = snd_pcm_hw_params_set_buffer_time_near(ai->alsa.handle, params,
-                                                 &ai->alsa.buffer_time, &dir);
-    if (err < 0) {
-        MP_ERR(ai, "Cannot set buffer time.\n");
-    }
-
-    dir = 0;
-    ai->alsa.period_time = ai->alsa.buffer_time / 4;
-    err = snd_pcm_hw_params_set_period_time_near(ai->alsa.handle, params,
-                                                 &ai->alsa.period_time, &dir);
-    if (err < 0) {
-        MP_ERR(ai, "Cannot set period time.\n");
-    }
-
-    err = snd_pcm_hw_params(ai->alsa.handle, params);
-    if (err < 0) {
-        MP_ERR(ai, "Unable to install hardware parameters: %s", snd_strerror(err));
-        snd_pcm_hw_params_dump(params, ai->alsa.log);
-        return -1;
-    }
-
-    dir = -1;
-    snd_pcm_hw_params_get_period_size(params, &period_size, &dir);
-    snd_pcm_hw_params_get_buffer_size(params, &buffer_size);
-    ai->alsa.chunk_size = period_size;
-    if (period_size == buffer_size) {
-        MP_ERR(ai, "Can't use period equal to buffer size (%u == %lu)\n", ai->alsa.chunk_size, (long)buffer_size);
-        return -1;
-    }
-
-    snd_pcm_sw_params_current(ai->alsa.handle, swparams);
-    err = snd_pcm_sw_params_set_avail_min(ai->alsa.handle, swparams, ai->alsa.chunk_size);
-
-    err = snd_pcm_sw_params_set_start_threshold(ai->alsa.handle, swparams, 0);
-    err = snd_pcm_sw_params_set_stop_threshold(ai->alsa.handle, swparams, buffer_size);
-
-    if (snd_pcm_sw_params(ai->alsa.handle, swparams) < 0) {
-        MP_ERR(ai, "Unable to install software parameters:\n");
-        snd_pcm_sw_params_dump(swparams, ai->alsa.log);
-        return -1;
-    }
-
-    if (mp_msg_test(ai->log, MSGL_V)) {
-        snd_pcm_dump(ai->alsa.handle, ai->alsa.log);
-    }
-
-    ai->alsa.bits_per_sample = snd_pcm_format_physical_width(SND_PCM_FORMAT_S16);
-    ai->alsa.bits_per_frame = ai->alsa.bits_per_sample * ai->channels;
-    ai->blocksize = ai->alsa.chunk_size * ai->alsa.bits_per_frame / 8;
-    ai->samplesize = ai->alsa.bits_per_sample;
-    ai->bytes_per_sample = ai->alsa.bits_per_sample/8;
-
-    return 0;
-}
-
-int ai_alsa_init(audio_in_t *ai)
-{
-    int err;
-
-    const char *device = ai->alsa.device;
-    if (!device)
-        device = "default";
-
-    err = snd_pcm_open(&ai->alsa.handle, device, SND_PCM_STREAM_CAPTURE, 0);
-    if (err < 0) {
-        MP_ERR(ai, "Error opening audio: %s\n", snd_strerror(err));
-        return -1;
-    }
-
-    err = snd_output_stdio_attach(&ai->alsa.log, stderr, 0);
-
-    if (err < 0) {
-        return -1;
-    }
-
-    err = ai_alsa_setup(ai);
-
-    return err;
-}
-
-#ifndef timersub
-#define timersub(a, b, result) \
-do { \
-        (result)->tv_sec = (a)->tv_sec - (b)->tv_sec; \
-        (result)->tv_usec = (a)->tv_usec - (b)->tv_usec; \
-        if ((result)->tv_usec < 0) { \
-                --(result)->tv_sec; \
-                (result)->tv_usec += 1000000; \
-        } \
-} while (0)
-#endif
-
-int ai_alsa_xrun(audio_in_t *ai)
-{
-    snd_pcm_status_t *status;
-    int res;
-
-    snd_pcm_status_alloca(&status);
-    if ((res = snd_pcm_status(ai->alsa.handle, status))<0) {
-        MP_ERR(ai, "ALSA status error: %s", snd_strerror(res));
-        return -1;
-    }
-    if (snd_pcm_status_get_state(status) == SND_PCM_STATE_XRUN) {
-        struct timeval now, diff, tstamp;
-        gettimeofday(&now, 0);
-        snd_pcm_status_get_trigger_tstamp(status, &tstamp);
-        timersub(&now, &tstamp, &diff);
-        MP_ERR(ai, "ALSA xrun!!! (at least %.3f ms long)\n",
-               diff.tv_sec * 1000 + diff.tv_usec / 1000.0);
-        if (mp_msg_test(ai->log, MSGL_V)) {
-            MP_ERR(ai, "ALSA Status:\n");
-            snd_pcm_status_dump(status, ai->alsa.log);
-        }
-        if ((res = snd_pcm_prepare(ai->alsa.handle))<0) {
-            MP_ERR(ai, "ALSA xrun: prepare error: %s", snd_strerror(res));
-            return -1;
-        }
-        return 0;               /* ok, data should be accepted again */
-    }
-    MP_ERR(ai, "ALSA read/write error");
-    return -1;
-}
diff -ruN mpv-0.29.1/stream/ai_oss.c mpv-master/stream/ai_oss.c
--- mpv-0.29.1/stream/ai_oss.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/ai_oss.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,153 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "config.h"
-
-#include <string.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <sys/ioctl.h>
-
-#include <sys/soundcard.h>
-
-#include "osdep/io.h"
-
-#include "audio_in.h"
-#include "common/common.h"
-#include "common/msg.h"
-
-int ai_oss_set_samplerate(audio_in_t *ai)
-{
-    int tmp = ai->req_samplerate;
-    if (ioctl(ai->oss.audio_fd, SNDCTL_DSP_SPEED, &tmp) == -1) return -1;
-    ai->samplerate = tmp;
-    return 0;
-}
-
-int ai_oss_set_channels(audio_in_t *ai)
-{
-    int err;
-    int ioctl_param;
-
-    if (ai->req_channels > 2)
-    {
-        ioctl_param = ai->req_channels;
-        MP_VERBOSE(ai, "ioctl dsp channels: %d\n",
-               err = ioctl(ai->oss.audio_fd, SNDCTL_DSP_CHANNELS, &ioctl_param));
-        if (err < 0) {
-            MP_ERR(ai, "Unable to set channel count: %d\n",
-                   ai->req_channels);
-            return -1;
-        }
-        ai->channels = ioctl_param;
-    }
-    else
-    {
-        ioctl_param = (ai->req_channels == 2);
-        MP_VERBOSE(ai, "ioctl dsp stereo: %d (req: %d)\n",
-               err = ioctl(ai->oss.audio_fd, SNDCTL_DSP_STEREO, &ioctl_param),
-               ioctl_param);
-        if (err < 0) {
-            MP_ERR(ai, "Unable to set stereo: %d\n",
-                   ai->req_channels == 2);
-            return -1;
-        }
-        ai->channels = ioctl_param ? 2 : 1;
-    }
-    return 0;
-}
-
-int ai_oss_init(audio_in_t *ai)
-{
-    int err;
-    int ioctl_param;
-
-    const char *device = ai->oss.device;
-    if (!device)
-        device = "/dev/dsp";
-
-    ai->oss.audio_fd = open(device, O_RDONLY | O_CLOEXEC);
-    if (ai->oss.audio_fd < 0)
-    {
-        MP_ERR(ai, "Unable to open '%s': %s\n", device, mp_strerror(errno));
-        return -1;
-    }
-
-    ioctl_param = 0 ;
-    MP_VERBOSE(ai, "ioctl dsp getfmt: %d\n",
-           ioctl(ai->oss.audio_fd, SNDCTL_DSP_GETFMTS, &ioctl_param));
-
-    MP_VERBOSE(ai, "Supported formats: %x\n", ioctl_param);
-    if (!(ioctl_param & AFMT_S16_NE))
-        MP_ERR(ai, "unsupported format\n");
-
-    ioctl_param = AFMT_S16_NE;
-    MP_VERBOSE(ai, "ioctl dsp setfmt: %d\n",
-           err = ioctl(ai->oss.audio_fd, SNDCTL_DSP_SETFMT, &ioctl_param));
-    if (err < 0) {
-        MP_ERR(ai, "Unable to set audio format.");
-        return -1;
-    }
-
-    if (ai_oss_set_channels(ai) < 0) return -1;
-
-    ioctl_param = ai->req_samplerate;
-    MP_VERBOSE(ai, "ioctl dsp speed: %d\n",
-           err = ioctl(ai->oss.audio_fd, SNDCTL_DSP_SPEED, &ioctl_param));
-    if (err < 0) {
-        MP_ERR(ai, "Unable to set samplerate: %d\n",
-               ai->req_samplerate);
-        return -1;
-    }
-    ai->samplerate = ioctl_param;
-
-    MP_VERBOSE(ai, "ioctl dsp trigger: %d\n",
-           ioctl(ai->oss.audio_fd, SNDCTL_DSP_GETTRIGGER, &ioctl_param));
-    MP_VERBOSE(ai, "trigger: %x\n", ioctl_param);
-    ioctl_param = PCM_ENABLE_INPUT;
-    MP_VERBOSE(ai, "ioctl dsp trigger: %d\n",
-           err = ioctl(ai->oss.audio_fd, SNDCTL_DSP_SETTRIGGER, &ioctl_param));
-    if (err < 0) {
-        MP_ERR(ai, "Unable to set trigger: %d\n",
-               PCM_ENABLE_INPUT);
-    }
-
-    ai->blocksize = 0;
-    MP_VERBOSE(ai, "ioctl dsp getblocksize: %d\n",
-           err = ioctl(ai->oss.audio_fd, SNDCTL_DSP_GETBLKSIZE, &ai->blocksize));
-    if (err < 0) {
-        MP_ERR(ai, "Unable to get block size!\n");
-    }
-    MP_VERBOSE(ai, "blocksize: %d\n", ai->blocksize);
-
-    // correct the blocksize to a reasonable value
-    if (ai->blocksize <= 0) {
-        ai->blocksize = 4096*ai->channels*2;
-        MP_ERR(ai, "Audio block size is zero, setting to %d!\n", ai->blocksize);
-    } else if (ai->blocksize < 4096*ai->channels*2) {
-        ai->blocksize *= 4096*ai->channels*2/ai->blocksize;
-        MP_ERR(ai, "Audio block size too low, setting to %d!\n", ai->blocksize);
-    }
-
-    ai->samplesize = 16;
-    ai->bytes_per_sample = 2;
-
-    return 0;
-}
diff -ruN mpv-0.29.1/stream/ai_sndio.c mpv-master/stream/ai_sndio.c
--- mpv-0.29.1/stream/ai_sndio.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/ai_sndio.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,52 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "config.h"
-
-#include <sndio.h>
-#include "audio_in.h"
-#include "common/msg.h"
-
-int ai_sndio_setup(audio_in_t *ai)
-{
-    struct sio_par par;
-
-    sio_initpar(&par);
-
-    par.bits = 16;
-    par.sig = 1;
-    par.le = SIO_LE_NATIVE;
-    par.rchan = ai->req_channels;
-    par.rate = ai->req_samplerate;
-    par.appbufsz = ai->req_samplerate;  /* 1 sec */
-
-   if (!sio_setpar(ai->sndio.hdl, &par) || !sio_getpar(ai->sndio.hdl, &par)) {
-        MP_ERR(ai, "could not configure sndio audio");
-        return -1;
-    }
-
-    ai->channels = par.rchan;
-    ai->samplerate = par.rate;
-    ai->samplesize = par.bits;
-    ai->bytes_per_sample = par.bps;
-    ai->blocksize = par.round * par.bps;
-
-    return 0;
-}
-
-int ai_sndio_init(audio_in_t *ai)
-{
-    int err;
-
-    const char *device = ai->sndio.device;
-    if (!device)
-        device = "default";
-    if ((ai->sndio.hdl = sio_open(device, SIO_REC, 0)) == NULL) {
-        MP_ERR(ai, "could not open sndio audio");
-        return -1;
-    }
-
-    err = ai_sndio_setup(ai);
-
-    return err;
-}
diff -ruN mpv-0.29.1/stream/audio_in.c mpv-master/stream/audio_in.c
--- mpv-0.29.1/stream/audio_in.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/audio_in.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,298 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-
-#include "config.h"
-
-#include "audio_in.h"
-#include "common/common.h"
-#include "common/msg.h"
-#include <string.h>
-#include <errno.h>
-
-// sanitizes ai structure before calling other functions
-int audio_in_init(audio_in_t *ai, struct mp_log *log, int type)
-{
-    ai->type = type;
-    ai->setup = 0;
-    ai->log = log;
-
-    ai->channels = -1;
-    ai->samplerate = -1;
-    ai->blocksize = -1;
-    ai->bytes_per_sample = -1;
-    ai->samplesize = -1;
-
-    switch (ai->type) {
-#if HAVE_ALSA
-    case AUDIO_IN_ALSA:
-        ai->alsa.handle = NULL;
-        ai->alsa.log = NULL;
-        ai->alsa.device = NULL;
-        return 0;
-#endif
-#if HAVE_OSS_AUDIO
-    case AUDIO_IN_OSS:
-        ai->oss.audio_fd = -1;
-        ai->oss.device = NULL;
-        return 0;
-#endif
-#if HAVE_SNDIO
-    case AUDIO_IN_SNDIO:
-        ai->sndio.hdl = NULL;
-        ai->sndio.device = NULL;
-        return 0;
-#endif
-    default:
-        return -1;
-    }
-}
-
-int audio_in_setup(audio_in_t *ai)
-{
-
-    switch (ai->type) {
-#if HAVE_ALSA
-    case AUDIO_IN_ALSA:
-        if (ai_alsa_init(ai) < 0) return -1;
-        ai->setup = 1;
-        return 0;
-#endif
-#if HAVE_OSS_AUDIO
-    case AUDIO_IN_OSS:
-        if (ai_oss_init(ai) < 0) return -1;
-        ai->setup = 1;
-        return 0;
-#endif
-#if HAVE_SNDIO
-    case AUDIO_IN_SNDIO:
-        if (ai_sndio_init(ai) < 0) return -1;
-        ai->setup = 1;
-        return 0;
-#endif
-    default:
-        return -1;
-    }
-}
-
-int audio_in_set_samplerate(audio_in_t *ai, int rate)
-{
-    switch (ai->type) {
-#if HAVE_ALSA
-    case AUDIO_IN_ALSA:
-        ai->req_samplerate = rate;
-        if (!ai->setup) return 0;
-        if (ai_alsa_setup(ai) < 0) return -1;
-        return ai->samplerate;
-#endif
-#if HAVE_OSS_AUDIO
-    case AUDIO_IN_OSS:
-        ai->req_samplerate = rate;
-        if (!ai->setup) return 0;
-        if (ai_oss_set_samplerate(ai) < 0) return -1;
-        return ai->samplerate;
-#endif
-#if HAVE_SNDIO
-    case AUDIO_IN_SNDIO:
-        ai->req_samplerate = rate;
-        if (!ai->setup) return 0;
-        if (ai_sndio_setup(ai) < 0) return -1;
-        return ai->samplerate;
-#endif
-    default:
-        return -1;
-    }
-}
-
-int audio_in_set_channels(audio_in_t *ai, int channels)
-{
-    switch (ai->type) {
-#if HAVE_ALSA
-    case AUDIO_IN_ALSA:
-        ai->req_channels = channels;
-        if (!ai->setup) return 0;
-        if (ai_alsa_setup(ai) < 0) return -1;
-        return ai->channels;
-#endif
-#if HAVE_OSS_AUDIO
-    case AUDIO_IN_OSS:
-        ai->req_channels = channels;
-        if (!ai->setup) return 0;
-        if (ai_oss_set_channels(ai) < 0) return -1;
-        return ai->channels;
-#endif
-#if HAVE_SNDIO
-    case AUDIO_IN_SNDIO:
-       ai->req_channels = channels;
-       if (!ai->setup) return 0;
-       if (ai_sndio_setup(ai) < 0) return -1;
-       return ai->channels;
-#endif
-    default:
-        return -1;
-    }
-}
-
-int audio_in_set_device(audio_in_t *ai, char *device)
-{
-#if HAVE_ALSA
-    int i;
-#endif
-    if (ai->setup) return -1;
-    switch (ai->type) {
-#if HAVE_ALSA
-    case AUDIO_IN_ALSA:
-        free(ai->alsa.device);
-        ai->alsa.device = strdup(device);
-        if (ai->alsa.device) {
-            /* mplayer could not handle colons in arguments */
-            for (i = 0; i < (int)strlen(ai->alsa.device); i++) {
-                if (ai->alsa.device[i] == '.') ai->alsa.device[i] = ':';
-            }
-        }
-        return 0;
-#endif
-#if HAVE_OSS_AUDIO
-    case AUDIO_IN_OSS:
-        free(ai->oss.device);
-        ai->oss.device = strdup(device);
-        return 0;
-#endif
-#if HAVE_SNDIO
-    case AUDIO_IN_SNDIO:
-       if (ai->sndio.device) free(ai->sndio.device);
-       ai->sndio.device = strdup(device);
-       return 0;
-#endif
-    default:
-        return -1;
-    }
-}
-
-int audio_in_uninit(audio_in_t *ai)
-{
-    if (ai->setup) {
-        switch (ai->type) {
-#if HAVE_ALSA
-        case AUDIO_IN_ALSA:
-            if (ai->alsa.log)
-                snd_output_close(ai->alsa.log);
-            if (ai->alsa.handle) {
-                snd_pcm_close(ai->alsa.handle);
-            }
-            ai->setup = 0;
-            return 0;
-#endif
-#if HAVE_OSS_AUDIO
-        case AUDIO_IN_OSS:
-            close(ai->oss.audio_fd);
-            ai->setup = 0;
-            return 0;
-#endif
-#if HAVE_SNDIO
-       case AUDIO_IN_SNDIO:
-           if (ai->sndio.hdl)
-               sio_close(ai->sndio.hdl);
-           ai->setup = 0;
-           return 0;
-#endif
-        }
-    }
-    return -1;
-}
-
-int audio_in_start_capture(audio_in_t *ai)
-{
-    switch (ai->type) {
-#if HAVE_ALSA
-    case AUDIO_IN_ALSA:
-        return snd_pcm_start(ai->alsa.handle);
-#endif
-#if HAVE_OSS_AUDIO
-    case AUDIO_IN_OSS:
-        return 0;
-#endif
-#if HAVE_SNDIO
-    case AUDIO_IN_SNDIO:
-       if (!sio_start(ai->sndio.hdl))
-           return -1;
-       return 0;
-#endif
-    default:
-        return -1;
-    }
-}
-
-int audio_in_read_chunk(audio_in_t *ai, unsigned char *buffer)
-{
-    int ret;
-
-    switch (ai->type) {
-#if HAVE_ALSA
-    case AUDIO_IN_ALSA:
-        ret = snd_pcm_readi(ai->alsa.handle, buffer, ai->alsa.chunk_size);
-        if (ret != ai->alsa.chunk_size) {
-            if (ret < 0) {
-                MP_ERR(ai, "\nError reading audio: %s\n", snd_strerror(ret));
-                if (ret == -EPIPE) {
-                    if (ai_alsa_xrun(ai) == 0) {
-                        MP_ERR(ai, "Recovered from cross-run, some frames may be left out!\n");
-                    } else {
-                        MP_ERR(ai, "Fatal error, cannot recover!\n");
-                    }
-                }
-            } else {
-                MP_ERR(ai, "\nNot enough audio samples!\n");
-            }
-            return -1;
-        }
-        return ret;
-#endif
-#if HAVE_OSS_AUDIO
-    case AUDIO_IN_OSS:
-        ret = read(ai->oss.audio_fd, buffer, ai->blocksize);
-       if (ret != ai->blocksize) {
-           if (ret < 0) {
-               MP_ERR(ai, "\nError reading audio: %s\n", mp_strerror(errno));
-
-           } else {
-               MP_ERR(ai, "\nNot enough audio samples!\n");
-           }
-           return -1;
-       }
-       return ret;
-#endif
-#if HAVE_SNDIO
-    case AUDIO_IN_SNDIO:
-       ret = sio_read(ai->sndio.hdl, buffer, ai->blocksize);
-        if (ret != ai->blocksize) {
-            if (ret < 0) {
-                MP_ERR(ai, "\nError reading audio: %s\n", mp_strerror(errno));
-            } else {
-                MP_ERR(ai, "\nNot enough audio samples!\n");
-            }
-            return -1;
-        }
-        return ret;
-#endif
-    default:
-        return -1;
-    }
-}
diff -ruN mpv-0.29.1/stream/audio_in.h mpv-master/stream/audio_in.h
--- mpv-0.29.1/stream/audio_in.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/audio_in.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,118 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef MPLAYER_AUDIO_IN_H
-#define MPLAYER_AUDIO_IN_H
-
-#define AUDIO_IN_ALSA 1
-#define AUDIO_IN_OSS 2
-#define AUDIO_IN_SNDIO 3
-
-#include "config.h"
-
-#if !HAVE_GPL
-#error GPL only
-#endif
-
-struct mp_log;
-
-#if HAVE_ALSA
-#include <alsa/asoundlib.h>
-
-typedef struct {
-    char *device;
-
-    snd_pcm_t *handle;
-    snd_output_t *log;
-    int buffer_time, period_time, chunk_size;
-    size_t bits_per_sample, bits_per_frame;
-} ai_alsa_t;
-#endif
-
-#if HAVE_OSS_AUDIO
-typedef struct {
-    char *device;
-
-    int audio_fd;
-} ai_oss_t;
-#endif
-
-#if HAVE_SNDIO
-#include <sndio.h>
-
-typedef struct {
-    char *device;
-
-    struct sio_hdl *hdl;
-} ai_sndio_t;
-#endif
-
-typedef struct
-{
-    struct mp_log *log;
-    int type;
-    int setup;
-
-    /* requested values */
-    int req_channels;
-    int req_samplerate;
-
-    /* real values read-only */
-    int channels;
-    int samplerate;
-    int blocksize;
-    int bytes_per_sample;
-    int samplesize;
-
-#if HAVE_ALSA
-    ai_alsa_t alsa;
-#endif
-#if HAVE_OSS_AUDIO
-    ai_oss_t oss;
-#endif
-#if HAVE_SNDIO
-    ai_sndio_t sndio;
-#endif
-} audio_in_t;
-
-int audio_in_init(audio_in_t *ai, struct mp_log *log, int type);
-int audio_in_setup(audio_in_t *ai);
-int audio_in_set_device(audio_in_t *ai, char *device);
-int audio_in_set_samplerate(audio_in_t *ai, int rate);
-int audio_in_set_channels(audio_in_t *ai, int channels);
-int audio_in_uninit(audio_in_t *ai);
-int audio_in_start_capture(audio_in_t *ai);
-int audio_in_read_chunk(audio_in_t *ai, unsigned char *buffer);
-
-#if HAVE_ALSA
-int ai_alsa_setup(audio_in_t *ai);
-int ai_alsa_init(audio_in_t *ai);
-int ai_alsa_xrun(audio_in_t *ai);
-#endif
-
-#if HAVE_OSS_AUDIO
-int ai_oss_set_samplerate(audio_in_t *ai);
-int ai_oss_set_channels(audio_in_t *ai);
-int ai_oss_init(audio_in_t *ai);
-#endif
-
-#if HAVE_SNDIO
-int ai_sndio_setup(audio_in_t *ai);
-int ai_sndio_init(audio_in_t *ai);
-#endif
-
-#endif /* MPLAYER_AUDIO_IN_H */
diff -ruN mpv-0.29.1/stream/cache.c mpv-master/stream/cache.c
--- mpv-0.29.1/stream/cache.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/cache.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,808 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-// Time in seconds the main thread waits for the cache thread. On wakeups, the
-// code checks for user requested aborts and also prints warnings that the
-// cache is being slow.
-#define CACHE_WAIT_TIME 1.0
-
-// The time the cache sleeps in idle mode. This controls how often the cache
-// retries reading from the stream after EOF has reached (in case the stream is
-// actually readable again, for example if data has been appended to a file).
-// Note that if this timeout is too low, the player will waste too much CPU
-// when player is paused.
-#define CACHE_IDLE_SLEEP_TIME 1.0
-
-// Time in seconds the cache updates "cached" controls. Note that idle mode
-// will block the cache from doing this, and this timeout is honored only if
-// the cache is active.
-#define CACHE_UPDATE_CONTROLS_TIME 2.0
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/types.h>
-#include <unistd.h>
-#include <errno.h>
-#include <assert.h>
-#include <pthread.h>
-#include <time.h>
-#include <math.h>
-#include <sys/time.h>
-
-#include <libavutil/common.h>
-
-#include "config.h"
-
-#include "osdep/timer.h"
-#include "osdep/threads.h"
-
-#include "common/msg.h"
-#include "common/tags.h"
-#include "options/options.h"
-
-#include "stream.h"
-#include "common/common.h"
-
-#define OPT_BASE_STRUCT struct mp_cache_opts
-
-const struct m_sub_options stream_cache_conf = {
-    .opts = (const struct m_option[]){
-        OPT_CHOICE_OR_INT("cache", size, 0, 32, 0x7fffffff,
-                          ({"no", 0},
-                           {"auto", -1},
-                           {"yes", -2})),
-        OPT_CHOICE_OR_INT("cache-default", def_size, 0, 32, 0x7fffffff,
-                          ({"no", 0})),
-        OPT_INTRANGE("cache-initial", initial, 0, 0, 0x7fffffff),
-        OPT_INTRANGE("cache-seek-min", seek_min, 0, 0, 0x7fffffff),
-        OPT_INTRANGE("cache-backbuffer", back_buffer, 0, 0, 0x7fffffff),
-        OPT_STRING("cache-file", file, M_OPT_FILE),
-        OPT_INTRANGE("cache-file-size", file_max, 0, 0, 0x7fffffff),
-        {0}
-    },
-    .size = sizeof(struct mp_cache_opts),
-    .defaults = &(const struct mp_cache_opts){
-        .size = -1,
-        .def_size = 10000,
-        .initial = 0,
-        .seek_min = 500,
-        .back_buffer = 10000,
-        .file_max = 1024 * 1024,
-    },
-};
-
-// Note: (struct priv*)(cache->priv)->cache == cache
-struct priv {
-    pthread_t cache_thread;
-    bool cache_thread_running;
-    pthread_mutex_t mutex;
-    pthread_cond_t wakeup;
-
-    // Constants (as long as cache thread is running)
-    // Some of these might actually be changed by a synced cache resize.
-    unsigned char *buffer;  // base pointer of the allocated buffer memory
-    int64_t buffer_size;    // size of the allocated buffer memory
-    int64_t back_size;      // keep back_size amount of old bytes for backward seek
-    int64_t seek_limit;     // keep filling cache if distance is less that seek limit
-    bool seekable;          // underlying stream is seekable
-
-    struct mp_log *log;
-
-    // Owned by the main thread
-    stream_t *cache;        // wrapper stream, used by demuxer etc.
-
-    // Owned by the cache thread
-    stream_t *stream;       // "real" stream, used to read from the source media
-    int64_t bytes_until_wakeup; // wakeup cache thread after this many bytes
-
-    // All the following members are shared between the threads.
-    // You must lock the mutex to access them.
-
-    // Ringbuffer
-    int64_t min_filepos;    // range of file that is cached in the buffer
-    int64_t max_filepos;    // ... max_filepos being the last read position
-    bool eof;               // true if max_filepos = EOF
-    int64_t offset;         // buffer[WRAP(s->max_filepos - offset)] corresponds
-                            // to the byte at max_filepos (must be wrapped by
-                            // buffer_size)
-
-    bool idle;              // cache thread has stopped reading
-    int64_t reads;          // number of actual read attempts performed
-    int64_t speed_start;    // start time (us) for calculating download speed
-    int64_t speed_amount;   // bytes read since speed_start
-    double speed;
-
-    bool enable_readahead;  // actively read beyond read() position
-    int64_t read_filepos;   // client read position (mirrors cache->pos)
-    int64_t read_min;       // file position until which the thread should
-                            // read even if readahead is disabled
-
-    int64_t eof_pos;
-
-    bool read_seek_failed;  // let a read fail because an async seek failed
-
-    int control;            // requested STREAM_CTRL_... or CACHE_CTRL_...
-    void *control_arg;      // temporary for executing STREAM_CTRLs
-    int control_res;
-    bool control_flush;
-
-    // Cached STREAM_CTRLs
-    double stream_time_length;
-    int64_t stream_size;
-    struct mp_tags *stream_metadata;
-    double start_pts;
-    bool has_avseek;
-};
-
-enum {
-    CACHE_CTRL_NONE = 0,
-    CACHE_CTRL_QUIT = -1,
-    CACHE_CTRL_PING = -2,
-    CACHE_CTRL_SEEK = -3,
-
-    // we should fill buffer only if space>=FILL_LIMIT
-    FILL_LIMIT = 16 * 1024,
-};
-
-// Used by the main thread to wakeup the cache thread, and to wait for the
-// cache thread. The cache mutex has to be locked when calling this function.
-// *retry_time should be set to 0 on the first call.
-// Return false if the stream has been aborted.
-static bool cache_wakeup_and_wait(struct priv *s, double *retry_time)
-{
-    double start = mp_time_sec();
-    if (*retry_time >= CACHE_WAIT_TIME) {
-        MP_VERBOSE(s, "Cache is not responding - slow/stuck network connection?\n");
-        *retry_time = -1; // do not warn again for this call
-    }
-
-    pthread_cond_signal(&s->wakeup);
-    struct timespec ts = mp_rel_time_to_timespec(CACHE_WAIT_TIME);
-    pthread_cond_timedwait(&s->wakeup, &s->mutex, &ts);
-
-    if (*retry_time >= 0)
-        *retry_time += mp_time_sec() - start;
-
-    return !mp_cancel_test(s->cache->cancel);
-}
-
-// Runs in the cache thread
-static void cache_drop_contents(struct priv *s)
-{
-    s->offset = s->min_filepos = s->max_filepos = s->read_filepos;
-    s->eof = false;
-    s->start_pts = MP_NOPTS_VALUE;
-}
-
-static void update_speed(struct priv *s)
-{
-    int64_t now = mp_time_us();
-    if (s->speed_start + 1000000 <= now) {
-        s->speed = s->speed_amount * 1e6 / (now - s->speed_start);
-        s->speed_amount = 0;
-        s->speed_start = now;
-    }
-}
-
-// Copy at most dst_size from the cache at the given absolute file position pos.
-// Return number of bytes that could actually be read.
-// Does not advance the file position, or change anything else.
-// Can be called from anywhere, as long as the mutex is held.
-static size_t read_buffer(struct priv *s, unsigned char *dst,
-                          size_t dst_size, int64_t pos)
-{
-    size_t read = 0;
-    while (read < dst_size) {
-        if (pos >= s->max_filepos || pos < s->min_filepos)
-            break;
-        int64_t newb = s->max_filepos - pos; // new bytes in the buffer
-
-        int64_t bpos = pos - s->offset; // file pos to buffer memory pos
-        if (bpos < 0) {
-            bpos += s->buffer_size;
-        } else if (bpos >= s->buffer_size) {
-            bpos -= s->buffer_size;
-        }
-
-        if (newb > s->buffer_size - bpos)
-            newb = s->buffer_size - bpos; // handle wrap...
-
-        newb = MPMIN(newb, dst_size - read);
-
-        assert(newb >= 0 && read + newb <= dst_size);
-        assert(bpos >= 0 && bpos + newb <= s->buffer_size);
-        memcpy(&dst[read], &s->buffer[bpos], newb);
-        read += newb;
-        pos += newb;
-    }
-    return read;
-}
-
-// Whether a seek will be needed to get to the position. This honors seek_limit,
-// which is a heuristic to prevent dropping the cache with small forward seeks.
-// This helps in situations where waiting for network a bit longer would quickly
-// reach the target position. Especially if the demuxer seeks back and forth,
-// not dropping the backwards cache will be a major performance win.
-static bool needs_seek(struct priv *s, int64_t pos)
-{
-    return pos < s->min_filepos || pos > s->max_filepos + s->seek_limit;
-}
-
-static bool cache_update_stream_position(struct priv *s)
-{
-    int64_t read = s->read_filepos;
-
-    s->read_seek_failed = false;
-
-    if (needs_seek(s, read)) {
-        MP_VERBOSE(s, "Dropping cache at pos %"PRId64", "
-                   "cached range: %"PRId64"-%"PRId64".\n", read,
-                   s->min_filepos, s->max_filepos);
-        cache_drop_contents(s);
-    }
-
-    if (stream_tell(s->stream) != s->max_filepos && s->seekable) {
-        MP_VERBOSE(s, "Seeking underlying stream: %"PRId64" -> %"PRId64"\n",
-                   stream_tell(s->stream), s->max_filepos);
-        if (!stream_seek(s->stream, s->max_filepos)) {
-            s->read_seek_failed = true;
-            return false;
-        }
-    }
-
-    return stream_tell(s->stream) == s->max_filepos;
-}
-
-// Runs in the cache thread.
-static void cache_fill(struct priv *s)
-{
-    int64_t read = s->read_filepos;
-    bool read_attempted = false;
-    int len = 0;
-
-    if (!cache_update_stream_position(s))
-        goto done;
-
-    if (!s->enable_readahead && s->read_min <= s->max_filepos)
-        goto done;
-
-    if (mp_cancel_test(s->cache->cancel))
-        goto done;
-
-    // number of buffer bytes which should be preserved in backwards direction
-    int64_t back = MPCLAMP(read - s->min_filepos, 0, s->back_size);
-
-    // limit maximum readahead so that the backbuffer space is reserved, even
-    // if the backbuffer is not used. limit it to ensure that we don't stall the
-    // network when starting a file, or we wouldn't download new data until we
-    // get new free space again. (unless everything fits in the cache.)
-    if (s->stream_size > s->buffer_size)
-        back = MPMAX(back, s->back_size);
-
-    // number of buffer bytes that are valid and can be read
-    int64_t newb = FFMAX(s->max_filepos - read, 0);
-
-    // max. number of bytes that can be written (starting from max_filepos)
-    int64_t space = s->buffer_size - (newb + back);
-
-    // offset into the buffer that maps to max_filepos
-    int64_t pos = s->max_filepos - s->offset;
-    if (pos >= s->buffer_size)
-        pos -= s->buffer_size; // wrap-around
-
-    if (space < FILL_LIMIT)
-        goto done;
-
-    // limit to end of buffer (without wrapping)
-    if (pos + space >= s->buffer_size)
-        space = s->buffer_size - pos;
-
-    // limit read size (or else would block and read the entire buffer in 1 call)
-    space = FFMIN(space, s->stream->read_chunk);
-
-    // back+newb+space <= buffer_size
-    int64_t back2 = s->buffer_size - (space + newb); // max back size
-    if (s->min_filepos < (read - back2))
-        s->min_filepos = read - back2;
-
-    // The read call might take a long time and block, so drop the lock.
-    pthread_mutex_unlock(&s->mutex);
-    len = stream_read_partial(s->stream, &s->buffer[pos], space);
-    pthread_mutex_lock(&s->mutex);
-
-    // Do this after reading a block, because at least libdvdnav updates the
-    // stream position only after actually reading something after a seek.
-    if (s->start_pts == MP_NOPTS_VALUE) {
-        double pts;
-        if (stream_control(s->stream, STREAM_CTRL_GET_CURRENT_TIME, &pts) > 0)
-            s->start_pts = pts;
-    }
-
-    s->max_filepos += len;
-    if (pos + len == s->buffer_size)
-        s->offset += s->buffer_size; // wrap...
-    s->speed_amount += len;
-
-    read_attempted = true;
-
-done: ;
-
-    bool prev_eof = s->eof;
-    if (read_attempted)
-        s->eof = len <= 0;
-    if (!prev_eof && s->eof) {
-        s->eof_pos = stream_tell(s->stream);
-        MP_VERBOSE(s, "EOF reached.\n");
-    }
-    s->idle = s->eof || !read_attempted;
-    s->reads++;
-
-    update_speed(s);
-
-    pthread_cond_signal(&s->wakeup);
-}
-
-// This is called both during init and at runtime.
-// The size argument is the readahead half only; s->back_size is the backbuffer.
-static int resize_cache(struct priv *s, int64_t size)
-{
-    int64_t min_size = FILL_LIMIT * 2;
-    int64_t max_size = ((size_t)-1) / 8;
-
-    if (s->stream_size > 0) {
-        size = MPMIN(size, s->stream_size);
-        if (size >= s->stream_size) {
-            MP_VERBOSE(s, "no backbuffer needed\n");
-            s->back_size = 0;
-        }
-    }
-
-    int64_t buffer_size = MPCLAMP(size, min_size, max_size);
-    s->back_size = MPCLAMP(s->back_size, min_size, max_size);
-    buffer_size += s->back_size;
-
-    unsigned char *buffer = malloc(buffer_size);
-    if (!buffer)
-        return STREAM_ERROR;
-
-    if (s->buffer) {
-        // Copy & free the old ringbuffer data.
-        // If the buffer is too small, prefer to copy these regions:
-        // 1. Data starting from read_filepos, until cache end
-        size_t read_1 = read_buffer(s, buffer, buffer_size, s->read_filepos);
-        // 2. then data from before read_filepos until cache start
-        //    (this one needs to be copied to the end of the ringbuffer)
-        size_t read_2 = 0;
-        if (s->min_filepos < s->read_filepos) {
-            size_t copy_len = buffer_size - read_1;
-            copy_len = MPMIN(copy_len, s->read_filepos - s->min_filepos);
-            assert(copy_len + read_1 <= buffer_size);
-            read_2 = read_buffer(s, buffer + buffer_size - copy_len, copy_len,
-                                 s->read_filepos - copy_len);
-            // This shouldn't happen, unless copy_len was computed incorrectly.
-            assert(read_2 == copy_len);
-        }
-        // Set it up such that read_1 is at buffer pos 0, and read_2 wraps
-        // around below it, so that it is located at the end of the buffer.
-        s->min_filepos = s->read_filepos - read_2;
-        s->max_filepos = s->read_filepos + read_1;
-        s->offset = s->max_filepos - read_1;
-    } else {
-        cache_drop_contents(s);
-    }
-
-    free(s->buffer);
-
-    s->buffer_size = buffer_size;
-    s->buffer = buffer;
-    s->idle = false;
-    s->eof = false;
-
-    //make sure that we won't wait from cache_fill
-    //more data than it is allowed to fill
-    if (s->seek_limit > s->buffer_size - FILL_LIMIT)
-        s->seek_limit = s->buffer_size - FILL_LIMIT;
-
-    MP_VERBOSE(s, "Cache size set to %lld KiB (%lld KiB backbuffer)\n",
-               (long long)(s->buffer_size / 1024),
-               (long long)(s->back_size / 1024));
-
-    assert(s->back_size < s->buffer_size);
-
-    return STREAM_OK;
-}
-
-static void update_cached_controls(struct priv *s)
-{
-    int64_t i64;
-    double d;
-    struct mp_tags *tags;
-    s->stream_time_length = 0;
-    if (stream_control(s->stream, STREAM_CTRL_GET_TIME_LENGTH, &d) == STREAM_OK)
-        s->stream_time_length = d;
-    if (stream_control(s->stream, STREAM_CTRL_GET_METADATA, &tags) == STREAM_OK) {
-        talloc_free(s->stream_metadata);
-        s->stream_metadata = talloc_steal(s, tags);
-    }
-    s->stream_size = s->eof_pos;
-    i64 = stream_get_size(s->stream);
-    if (i64 >= 0)
-        s->stream_size = i64;
-    s->has_avseek = stream_control(s->stream, STREAM_CTRL_HAS_AVSEEK, NULL) > 0;
-}
-
-// the core might call these every frame, so cache them...
-static int cache_get_cached_control(stream_t *cache, int cmd, void *arg)
-{
-    struct priv *s = cache->priv;
-    switch (cmd) {
-    case STREAM_CTRL_GET_CACHE_INFO:
-        *(struct stream_cache_info *)arg = (struct stream_cache_info) {
-            .size = s->buffer_size - s->back_size,
-            .fill = s->max_filepos - s->read_filepos,
-            .idle = s->idle,
-            .speed = llrint(s->speed),
-        };
-        return STREAM_OK;
-    case STREAM_CTRL_SET_READAHEAD:
-        s->enable_readahead = *(int *)arg;
-        pthread_cond_signal(&s->wakeup);
-        return STREAM_OK;
-    case STREAM_CTRL_GET_TIME_LENGTH:
-        *(double *)arg = s->stream_time_length;
-        return s->stream_time_length ? STREAM_OK : STREAM_UNSUPPORTED;
-    case STREAM_CTRL_GET_SIZE:
-        if (s->stream_size < 0)
-            return STREAM_UNSUPPORTED;
-        *(int64_t *)arg = s->stream_size;
-        return STREAM_OK;
-    case STREAM_CTRL_GET_CURRENT_TIME: {
-        if (s->start_pts == MP_NOPTS_VALUE)
-            return STREAM_UNSUPPORTED;
-        *(double *)arg = s->start_pts;
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_HAS_AVSEEK:
-        return s->has_avseek ? STREAM_OK : STREAM_UNSUPPORTED;
-    case STREAM_CTRL_GET_METADATA: {
-        if (s->stream_metadata) {
-            ta_set_parent(s->stream_metadata, NULL);
-            *(struct mp_tags **)arg = s->stream_metadata;
-            s->stream_metadata = NULL;
-            return STREAM_OK;
-        }
-        return STREAM_UNSUPPORTED;
-    }
-    case STREAM_CTRL_AVSEEK:
-        if (!s->has_avseek)
-            return STREAM_UNSUPPORTED;
-        break;
-    }
-    return STREAM_ERROR;
-}
-
-static bool control_needs_flush(int stream_ctrl)
-{
-    switch (stream_ctrl) {
-    case STREAM_CTRL_SEEK_TO_TIME:
-    case STREAM_CTRL_AVSEEK:
-    case STREAM_CTRL_SET_ANGLE:
-    case STREAM_CTRL_SET_CURRENT_TITLE:
-    case STREAM_CTRL_DVB_SET_CHANNEL:
-    case STREAM_CTRL_DVB_SET_CHANNEL_NAME:
-    case STREAM_CTRL_DVB_STEP_CHANNEL:
-        return true;
-    }
-    return false;
-}
-
-// Runs in the cache thread
-static void cache_execute_control(struct priv *s)
-{
-    uint64_t old_pos = stream_tell(s->stream);
-    s->control_flush = false;
-
-    switch (s->control) {
-    case STREAM_CTRL_SET_CACHE_SIZE:
-        s->control_res = resize_cache(s, *(int64_t *)s->control_arg);
-        break;
-    default:
-        s->control_res = stream_control(s->stream, s->control, s->control_arg);
-    }
-
-    bool pos_changed = old_pos != stream_tell(s->stream);
-    bool ok = s->control_res == STREAM_OK;
-    if (pos_changed && !ok) {
-        MP_ERR(s, "STREAM_CTRL changed stream pos but "
-               "returned error, this is not allowed!\n");
-    } else if (pos_changed || (ok && control_needs_flush(s->control))) {
-        MP_VERBOSE(s, "Dropping cache due to control()\n");
-        s->read_filepos = stream_tell(s->stream);
-        s->read_min = s->read_filepos;
-        s->control_flush = true;
-        cache_drop_contents(s);
-    }
-
-    update_cached_controls(s);
-    s->control = CACHE_CTRL_NONE;
-    pthread_cond_signal(&s->wakeup);
-}
-
-static void *cache_thread(void *arg)
-{
-    struct priv *s = arg;
-    mpthread_set_name("cache");
-    pthread_mutex_lock(&s->mutex);
-    update_cached_controls(s);
-    double last = mp_time_sec();
-    while (s->control != CACHE_CTRL_QUIT) {
-        if (mp_time_sec() - last > CACHE_UPDATE_CONTROLS_TIME) {
-            update_cached_controls(s);
-            last = mp_time_sec();
-        }
-        if (s->control > 0) {
-            cache_execute_control(s);
-        } else if (s->control == CACHE_CTRL_SEEK) {
-            s->control_res = cache_update_stream_position(s);
-            s->control = CACHE_CTRL_NONE;
-            pthread_cond_signal(&s->wakeup);
-        } else {
-            cache_fill(s);
-        }
-        if (s->control == CACHE_CTRL_PING) {
-            pthread_cond_signal(&s->wakeup);
-            s->control = CACHE_CTRL_NONE;
-        }
-        if (s->idle && s->control == CACHE_CTRL_NONE) {
-            struct timespec ts = mp_rel_time_to_timespec(CACHE_IDLE_SLEEP_TIME);
-            pthread_cond_timedwait(&s->wakeup, &s->mutex, &ts);
-        }
-    }
-    pthread_cond_signal(&s->wakeup);
-    pthread_mutex_unlock(&s->mutex);
-    MP_VERBOSE(s, "Cache exiting...\n");
-    return NULL;
-}
-
-static int cache_fill_buffer(struct stream *cache, char *buffer, int max_len)
-{
-    struct priv *s = cache->priv;
-    assert(s->cache_thread_running);
-
-    pthread_mutex_lock(&s->mutex);
-
-    if (cache->pos != s->read_filepos)
-        MP_ERR(s, "!!! read_filepos differs !!! report this bug...\n");
-
-    int readb = 0;
-    if (max_len > 0) {
-        double retry_time = 0;
-        int64_t retry = s->reads - 1; // try at least 1 read on EOF
-        while (1) {
-            s->read_min = s->read_filepos + max_len + 64 * 1024;
-            readb = read_buffer(s, buffer, max_len, s->read_filepos);
-            s->read_filepos += readb;
-            if (readb > 0)
-                break;
-            if (s->eof && s->read_filepos >= s->max_filepos && s->reads >= retry)
-                break;
-            s->idle = false;
-            if (!cache_wakeup_and_wait(s, &retry_time))
-                break;
-            if (s->read_seek_failed) {
-                MP_ERR(s, "error reading after async seek failed\n");
-                s->read_seek_failed = false;
-                break;
-            }
-        }
-    }
-
-    if (!s->eof) {
-        // wakeup the cache thread, possibly make it read more data ahead
-        // this is throttled to reduce excessive wakeups during normal reading
-        // (using the amount of bytes after which the cache thread most likely
-        // can actually read new data)
-        s->bytes_until_wakeup -= readb;
-        if (s->bytes_until_wakeup <= 0) {
-            s->bytes_until_wakeup = MPMAX(FILL_LIMIT, s->stream->read_chunk);
-            pthread_cond_signal(&s->wakeup);
-        }
-    }
-    pthread_mutex_unlock(&s->mutex);
-    return readb;
-}
-
-static int cache_seek(stream_t *cache, int64_t pos)
-{
-    struct priv *s = cache->priv;
-    assert(s->cache_thread_running);
-    int r = 1;
-
-    pthread_mutex_lock(&s->mutex);
-
-    MP_DBG(s, "request seek: %" PRId64 " <= to=%" PRId64
-           " (cur=%" PRId64 ") <= %" PRId64 "  \n",
-           s->min_filepos, pos, s->read_filepos, s->max_filepos);
-
-    if (!s->seekable && pos > s->max_filepos) {
-        MP_ERR(s, "Attempting to seek past cached data in unseekable stream.\n");
-        r = 0;
-    } else if (!s->seekable && pos < s->min_filepos) {
-        MP_ERR(s, "Attempting to seek before cached data in unseekable stream.\n");
-        r = 0;
-    } else {
-        cache->pos = s->read_filepos = s->read_min = pos;
-        // Is this seek likely to cause a stream-level seek?
-        // If it is, wait until that is complete and return its result.
-        // This check is not quite exact - if the reader thread is blocked in
-        // a read, the read might advance file position enough that a seek
-        // forward is no longer needed.
-        if (needs_seek(s, pos)) {
-            s->eof = false;
-            s->control = CACHE_CTRL_SEEK;
-            s->control_res = 0;
-            double retry = 0;
-            while (s->control != CACHE_CTRL_NONE) {
-                if (!cache_wakeup_and_wait(s, &retry))
-                    break;
-            }
-            r = s->control_res;
-        } else {
-            pthread_cond_signal(&s->wakeup);
-            r = 1;
-        }
-    }
-
-    s->bytes_until_wakeup = 0;
-
-    pthread_mutex_unlock(&s->mutex);
-
-    return r;
-}
-
-static int cache_control(stream_t *cache, int cmd, void *arg)
-{
-    struct priv *s = cache->priv;
-    int r = STREAM_ERROR;
-
-    assert(cmd > 0);
-
-    pthread_mutex_lock(&s->mutex);
-
-    r = cache_get_cached_control(cache, cmd, arg);
-    if (r != STREAM_ERROR)
-        goto done;
-
-    MP_VERBOSE(s, "blocking for STREAM_CTRL %d\n", cmd);
-
-    s->control = cmd;
-    s->control_arg = arg;
-    double retry = 0;
-    while (s->control != CACHE_CTRL_NONE) {
-        if (!cache_wakeup_and_wait(s, &retry)) {
-            s->eof = 1;
-            r = STREAM_UNSUPPORTED;
-            goto done;
-        }
-    }
-    r = s->control_res;
-    if (s->control_flush) {
-        stream_drop_buffers(cache);
-        cache->pos = s->read_filepos;
-    }
-
-done:
-    pthread_mutex_unlock(&s->mutex);
-    return r;
-}
-
-static void cache_uninit(stream_t *cache)
-{
-    struct priv *s = cache->priv;
-    if (s->cache_thread_running) {
-        MP_VERBOSE(s, "Terminating cache...\n");
-        pthread_mutex_lock(&s->mutex);
-        s->control = CACHE_CTRL_QUIT;
-        pthread_cond_signal(&s->wakeup);
-        pthread_mutex_unlock(&s->mutex);
-        pthread_join(s->cache_thread, NULL);
-    }
-    pthread_mutex_destroy(&s->mutex);
-    pthread_cond_destroy(&s->wakeup);
-    free(s->buffer);
-    talloc_free(s);
-}
-
-// return 1 on success, 0 if the cache is disabled/not needed, and -1 on error
-// or if the cache is disabled
-int stream_cache_init(stream_t *cache, stream_t *stream,
-                      struct mp_cache_opts *opts)
-{
-    if (opts->size < 1)
-        return 0;
-
-    struct priv *s = talloc_zero(NULL, struct priv);
-    s->log = cache->log;
-    s->eof_pos = -1;
-    s->enable_readahead = true;
-
-    cache_drop_contents(s);
-
-    s->speed_start = mp_time_us();
-
-    s->seek_limit = opts->seek_min * 1024ULL;
-    s->back_size = opts->back_buffer * 1024ULL;
-
-    s->stream_size = stream_get_size(stream);
-
-    if (resize_cache(s, opts->size * 1024ULL) != STREAM_OK) {
-        MP_ERR(s, "Failed to allocate cache buffer.\n");
-        talloc_free(s);
-        return -1;
-    }
-
-    pthread_mutex_init(&s->mutex, NULL);
-    pthread_cond_init(&s->wakeup, NULL);
-
-    cache->priv = s;
-    s->cache = cache;
-    s->stream = stream;
-
-    cache->seek = cache_seek;
-    cache->fill_buffer = cache_fill_buffer;
-    cache->control = cache_control;
-    cache->close = cache_uninit;
-
-    int64_t min = opts->initial * 1024ULL;
-    if (min > s->buffer_size - FILL_LIMIT)
-        min = s->buffer_size - FILL_LIMIT;
-
-    s->seekable = stream->seekable;
-
-    if (pthread_create(&s->cache_thread, NULL, cache_thread, s) != 0) {
-        MP_ERR(s, "Starting cache thread failed.\n");
-        return -1;
-    }
-    s->cache_thread_running = true;
-
-    // wait until cache is filled with at least min bytes
-    if (min < 1)
-        return 1;
-    for (;;) {
-        if (mp_cancel_test(cache->cancel))
-            return -1;
-        struct stream_cache_info info;
-        if (stream_control(s->cache, STREAM_CTRL_GET_CACHE_INFO, &info) < 0)
-            break;
-        mp_msg(s->log, MSGL_STATUS,  "Cache fill: %5.2f%% "
-               "(%" PRId64 " bytes)", 100.0 * info.fill / s->buffer_size,
-               info.fill);
-        if (info.fill >= min)
-            break;
-        if (info.idle)
-            break;    // file is smaller than prefill size
-        // Wake up if the cache is done reading some data (or on timeout/abort)
-        pthread_mutex_lock(&s->mutex);
-        s->control = CACHE_CTRL_PING;
-        pthread_cond_signal(&s->wakeup);
-        cache_wakeup_and_wait(s, &(double){0});
-        pthread_mutex_unlock(&s->mutex);
-    }
-    return 1;
-}
diff -ruN mpv-0.29.1/stream/cache_file.c mpv-master/stream/cache_file.c
--- mpv-0.29.1/stream/cache_file.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/cache_file.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,158 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdint.h>
-
-#include "osdep/io.h"
-
-#include "common/common.h"
-#include "common/msg.h"
-
-#include "options/options.h"
-
-#include "stream.h"
-
-#define BLOCK_SIZE 1024LL
-#define BLOCK_ALIGN(p) ((p) & ~(BLOCK_SIZE - 1))
-
-struct priv {
-    struct stream *original;
-    FILE *cache_file;
-    uint8_t *block_bits;    // 1 bit for each BLOCK_SIZE, whether block was read
-    int64_t size;           // currently known size
-    int64_t max_size;       // max. size for block_bits and cache_file
-};
-
-static bool test_bit(struct priv *p, int64_t pos)
-{
-    if (pos < 0 || pos >= p->size)
-        return false;
-    size_t block = pos / BLOCK_SIZE;
-    return p->block_bits[block / 8] & (1 << (block % 8));
-}
-
-static void set_bit(struct priv *p, int64_t pos, bool bit)
-{
-    if (pos < 0 || pos >= p->size)
-        return;
-    size_t block = pos / BLOCK_SIZE;
-    unsigned int m = (1 << (block % 8));
-    p->block_bits[block / 8] = (p->block_bits[block / 8] & ~m) | (bit ? m : 0);
-}
-
-static int fill_buffer(stream_t *s, char *buffer, int max_len)
-{
-    struct priv *p = s->priv;
-    if (s->pos < 0)
-        return -1;
-    if (s->pos >= p->max_size) {
-        if (stream_seek(p->original, s->pos) < 1)
-            return -1;
-        return stream_read(p->original, buffer, max_len);
-    }
-    // Size of file changes -> invalidate last block
-    if (s->pos >= p->size - BLOCK_SIZE) {
-        int64_t new_size = stream_get_size(s);
-        if (p->size >= 0 && new_size != p->size)
-            set_bit(p, BLOCK_ALIGN(p->size), 0);
-        p->size = MPMIN(p->max_size, new_size);
-    }
-    int64_t aligned = BLOCK_ALIGN(s->pos);
-    if (!test_bit(p, aligned)) {
-        char tmp[BLOCK_SIZE];
-        stream_seek(p->original, aligned);
-        int r = stream_read(p->original, tmp, BLOCK_SIZE);
-        if (r < BLOCK_SIZE) {
-            if (p->size < 0) {
-                MP_WARN(s, "suspected EOF\n");
-            } else if (aligned + r < p->size) {
-                MP_ERR(s, "unexpected EOF\n");
-                return -1;
-            }
-        }
-        if (fseeko(p->cache_file, aligned, SEEK_SET))
-            return -1;
-        if (fwrite(tmp, r, 1, p->cache_file) != 1)
-            return -1;
-        set_bit(p, aligned, 1);
-    }
-    if (fseeko(p->cache_file, s->pos, SEEK_SET))
-        return -1;
-    // align/limit to blocks
-    max_len = MPMIN(max_len, BLOCK_SIZE - (s->pos % BLOCK_SIZE));
-    // Limit to max. known file size
-    if (p->size >= 0)
-        max_len = MPMIN(max_len, p->size - s->pos);
-    return fread(buffer, 1, max_len, p->cache_file);
-}
-
-static int seek(stream_t *s, int64_t newpos)
-{
-    return 1;
-}
-
-static int control(stream_t *s, int cmd, void *arg)
-{
-    struct priv *p = s->priv;
-    return stream_control(p->original, cmd, arg);
-}
-
-static void s_close(stream_t *s)
-{
-    struct priv *p = s->priv;
-    if (p->cache_file)
-        fclose(p->cache_file);
-    talloc_free(p);
-}
-
-// return 1 on success, 0 if disabled, -1 on error
-int stream_file_cache_init(stream_t *cache, stream_t *stream,
-                           struct mp_cache_opts *opts)
-{
-    if (!opts->file || !opts->file[0] || opts->file_max < 1)
-        return 0;
-
-    if (!stream->seekable) {
-        MP_ERR(cache, "can't cache unseekable stream\n");
-        return -1;
-    }
-
-    bool use_anon_file = strcmp(opts->file, "TMP") == 0;
-    FILE *file = use_anon_file ? tmpfile() : fopen(opts->file, "wb+");
-    if (!file) {
-        MP_ERR(cache, "can't open cache file '%s'\n", opts->file);
-        return -1;
-    }
-
-    struct priv *p = talloc_zero(NULL, struct priv);
-
-    cache->priv = p;
-    p->original = stream;
-    p->cache_file = file;
-    p->max_size = opts->file_max * 1024LL;
-
-    // file_max can be INT_MAX, so this is at most about 256MB
-    p->block_bits = talloc_zero_size(p, (p->max_size / BLOCK_SIZE + 1) / 8 + 1);
-
-    cache->seek = seek;
-    cache->fill_buffer = fill_buffer;
-    cache->control = control;
-    cache->close = s_close;
-
-    return 1;
-}
diff -ruN mpv-0.29.1/stream/frequencies.c mpv-master/stream/frequencies.c
--- mpv-0.29.1/stream/frequencies.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/frequencies.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,1212 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-#include <sys/time.h>
-
-#include "frequencies.h"
-
-/* --------------------------------------------------------------------- */
-
-/* US broadcast */
-static const struct CHANLIST ntsc_bcast[] = {
-    { "2",       55250 },
-    { "3",       61250 },
-    { "4",       67250 },
-    { "5",       77250 },
-    { "6",       83250 },
-    { "7",      175250 },
-    { "8",      181250 },
-    { "9",      187250 },
-    { "10",     193250 },
-    { "11",     199250 },
-    { "12",     205250 },
-    { "13",     211250 },
-    { "14",     471250 },
-    { "15",     477250 },
-    { "16",     483250 },
-    { "17",     489250 },
-    { "18",     495250 },
-    { "19",     501250 },
-    { "20",     507250 },
-    { "21",     513250 },
-    { "22",     519250 },
-    { "23",     525250 },
-    { "24",     531250 },
-    { "25",     537250 },
-    { "26",     543250 },
-    { "27",     549250 },
-    { "28",     555250 },
-    { "29",     561250 },
-    { "30",     567250 },
-    { "31",     573250 },
-    { "32",     579250 },
-    { "33",     585250 },
-    { "34",     591250 },
-    { "35",     597250 },
-    { "36",     603250 },
-    { "37",     609250 },
-    { "38",     615250 },
-    { "39",     621250 },
-    { "40",     627250 },
-    { "41",     633250 },
-    { "42",     639250 },
-    { "43",     645250 },
-    { "44",     651250 },
-    { "45",     657250 },
-    { "46",     663250 },
-    { "47",     669250 },
-    { "48",     675250 },
-    { "49",     681250 },
-    { "50",     687250 },
-    { "51",     693250 },
-    { "52",     699250 },
-    { "53",     705250 },
-    { "54",     711250 },
-    { "55",     717250 },
-    { "56",     723250 },
-    { "57",     729250 },
-    { "58",     735250 },
-    { "59",     741250 },
-    { "60",     747250 },
-    { "61",     753250 },
-    { "62",     759250 },
-    { "63",     765250 },
-    { "64",     771250 },
-    { "65",     777250 },
-    { "66",     783250 },
-    { "67",     789250 },
-    { "68",     795250 },
-    { "69",     801250 },
-
-    { "70",     807250 },
-    { "71",     813250 },
-    { "72",     819250 },
-    { "73",     825250 },
-    { "74",     831250 },
-    { "75",     837250 },
-    { "76",     843250 },
-    { "77",     849250 },
-    { "78",     855250 },
-    { "79",     861250 },
-    { "80",     867250 },
-    { "81",     873250 },
-    { "82",     879250 },
-    { "83",     885250 },
-};
-
-/* US cable */
-static const struct CHANLIST ntsc_cable[] = {
-    { "1",       73250 },
-    { "2",       55250 },
-    { "3",       61250 },
-    { "4",       67250 },
-    { "5",       77250 },
-    { "6",       83250 },
-    { "7",      175250 },
-    { "8",      181250 },
-    { "9",      187250 },
-    { "10",     193250 },
-    { "11",     199250 },
-    { "12",     205250 },
-
-    { "13",     211250 },
-    { "14",     121250 },
-    { "15",     127250 },
-    { "16",     133250 },
-    { "17",     139250 },
-    { "18",     145250 },
-    { "19",     151250 },
-    { "20",     157250 },
-
-    { "21",     163250 },
-    { "22",     169250 },
-    { "23",     217250 },
-    { "24",     223250 },
-    { "25",     229250 },
-    { "26",     235250 },
-    { "27",     241250 },
-    { "28",     247250 },
-    { "29",     253250 },
-    { "30",     259250 },
-    { "31",     265250 },
-    { "32",     271250 },
-    { "33",     277250 },
-    { "34",     283250 },
-    { "35",     289250 },
-    { "36",     295250 },
-    { "37",     301250 },
-    { "38",     307250 },
-    { "39",     313250 },
-    { "40",     319250 },
-    { "41",     325250 },
-    { "42",     331250 },
-    { "43",     337250 },
-    { "44",     343250 },
-    { "45",     349250 },
-    { "46",     355250 },
-    { "47",     361250 },
-    { "48",     367250 },
-    { "49",     373250 },
-    { "50",     379250 },
-    { "51",     385250 },
-    { "52",     391250 },
-    { "53",     397250 },
-    { "54",     403250 },
-    { "55",     409250 },
-    { "56",     415250 },
-    { "57",     421250 },
-    { "58",     427250 },
-    { "59",     433250 },
-    { "60",     439250 },
-    { "61",     445250 },
-    { "62",     451250 },
-    { "63",     457250 },
-    { "64",     463250 },
-    { "65",     469250 },
-    { "66",     475250 },
-    { "67",     481250 },
-    { "68",     487250 },
-    { "69",     493250 },
-
-    { "70",     499250 },
-    { "71",     505250 },
-    { "72",     511250 },
-    { "73",     517250 },
-    { "74",     523250 },
-    { "75",     529250 },
-    { "76",     535250 },
-    { "77",     541250 },
-    { "78",     547250 },
-    { "79",     553250 },
-    { "80",     559250 },
-    { "81",     565250 },
-    { "82",     571250 },
-    { "83",     577250 },
-    { "84",     583250 },
-    { "85",     589250 },
-    { "86",     595250 },
-    { "87",     601250 },
-    { "88",     607250 },
-    { "89",     613250 },
-    { "90",     619250 },
-    { "91",     625250 },
-    { "92",     631250 },
-    { "93",     637250 },
-    { "94",     643250 },
-    { "95",      91250 },
-    { "96",      97250 },
-    { "97",     103250 },
-    { "98",     109250 },
-    { "99",     115250 },
-    { "100",    649250 },
-    { "101",    655250 },
-    { "102",    661250 },
-    { "103",    667250 },
-    { "104",    673250 },
-    { "105",    679250 },
-    { "106",    685250 },
-    { "107",    691250 },
-    { "108",    697250 },
-    { "109",    703250 },
-    { "110",    709250 },
-    { "111",    715250 },
-    { "112",    721250 },
-    { "113",    727250 },
-    { "114",    733250 },
-    { "115",    739250 },
-    { "116",    745250 },
-    { "117",    751250 },
-    { "118",    757250 },
-    { "119",    763250 },
-    { "120",    769250 },
-    { "121",    775250 },
-    { "122",    781250 },
-    { "123",    787250 },
-    { "124",    793250 },
-    { "125",    799250 },
-
-    { "T7",       8250 },
-    { "T8",      14250 },
-    { "T9",      20250 },
-    { "T10",     26250 },
-    { "T11",     32250 },
-    { "T12",     38250 },
-    { "T13",     44250 },
-    { "T14",     50250 }
-};
-
-/* US HRC */
-static const struct CHANLIST ntsc_hrc[] = {
-    { "1",        72000 },
-    { "2",        54000 },
-    { "3",        60000 },
-    { "4",        66000 },
-    { "5",        78000 },
-    { "6",        84000 },
-    { "7",       174000 },
-    { "8",       180000 },
-    { "9",       186000 },
-    { "10",      192000 },
-    { "11",      198000 },
-    { "12",      204000 },
-
-    { "13",      210000 },
-    { "14",      120000 },
-    { "15",      126000 },
-    { "16",      132000 },
-    { "17",      138000 },
-    { "18",      144000 },
-    { "19",      150000 },
-    { "20",      156000 },
-
-    { "21",      162000 },
-    { "22",      168000 },
-    { "23",      216000 },
-    { "24",      222000 },
-    { "25",      228000 },
-    { "26",      234000 },
-    { "27",      240000 },
-    { "28",      246000 },
-    { "29",      252000 },
-    { "30",      258000 },
-    { "31",      264000 },
-    { "32",      270000 },
-    { "33",      276000 },
-    { "34",      282000 },
-    { "35",      288000 },
-    { "36",      294000 },
-    { "37",      300000 },
-    { "38",      306000 },
-    { "39",      312000 },
-    { "40",      318000 },
-    { "41",      324000 },
-    { "42",      330000 },
-    { "43",      336000 },
-    { "44",      342000 },
-    { "45",      348000 },
-    { "46",      354000 },
-    { "47",      360000 },
-    { "48",      366000 },
-    { "49",      372000 },
-    { "50",      378000 },
-    { "51",      384000 },
-    { "52",      390000 },
-    { "53",      396000 },
-    { "54",      402000 },
-    { "55",      408000 },
-    { "56",      414000 },
-    { "57",      420000 },
-    { "58",      426000 },
-    { "59",      432000 },
-    { "60",      438000 },
-    { "61",      444000 },
-    { "62",      450000 },
-    { "63",      456000 },
-    { "64",      462000 },
-    { "65",      468000 },
-    { "66",      474000 },
-    { "67",      480000 },
-    { "68",      486000 },
-    { "69",      492000 },
-
-    { "70",      498000 },
-    { "71",      504000 },
-    { "72",      510000 },
-    { "73",      516000 },
-    { "74",      522000 },
-    { "75",      528000 },
-    { "76",      534000 },
-    { "77",      540000 },
-    { "78",      546000 },
-    { "79",      552000 },
-    { "80",      558000 },
-    { "81",      564000 },
-    { "82",      570000 },
-    { "83",      576000 },
-    { "84",      582000 },
-    { "85",      588000 },
-    { "86",      594000 },
-    { "87",      600000 },
-    { "88",      606000 },
-    { "89",      612000 },
-    { "90",      618000 },
-    { "91",      624000 },
-    { "92",      630000 },
-    { "93",      636000 },
-    { "94",      642000 },
-    { "95",      900000 },
-    { "96",      960000 },
-    { "97",      102000 },
-    { "98",      108000 },
-    { "99",      114000 },
-    { "100",     648000 },
-    { "101",     654000 },
-    { "102",     660000 },
-    { "103",     666000 },
-    { "104",     672000 },
-    { "105",     678000 },
-    { "106",     684000 },
-    { "107",     690000 },
-    { "108",     696000 },
-    { "109",     702000 },
-    { "110",     708000 },
-    { "111",     714000 },
-    { "112",     720000 },
-    { "113",     726000 },
-    { "114",     732000 },
-    { "115",     738000 },
-    { "116",     744000 },
-    { "117",     750000 },
-    { "118",     756000 },
-    { "119",     762000 },
-    { "120",     768000 },
-    { "121",     774000 },
-    { "122",     780000 },
-    { "123",     786000 },
-    { "124",     792000 },
-    { "125",     798000 },
-
-    { "T7",        7000 },
-    { "T8",       13000 },
-    { "T9",       19000 },
-    { "T10",      25000 },
-    { "T11",      31000 },
-    { "T12",      37000 },
-    { "T13",      43000 },
-    { "T14",      49000 },
-};
-
-/* --------------------------------------------------------------------- */
-
-/* JP broadcast */
-static const struct CHANLIST ntsc_bcast_jp[] = {
-    { "1",   91250 },
-    { "2",   97250 },
-    { "3",  103250 },
-    { "4",  171250 },
-    { "5",  177250 },
-    { "6",  183250 },
-    { "7",  189250 },
-    { "8",  193250 },
-    { "9",  199250 },
-    { "10", 205250 },
-    { "11", 211250 },
-    { "12", 217250 },
-
-    { "13", 471250 },
-    { "14", 477250 },
-    { "15", 483250 },
-    { "16", 489250 },
-    { "17", 495250 },
-    { "18", 501250 },
-    { "19", 507250 },
-    { "20", 513250 },
-    { "21", 519250 },
-    { "22", 525250 },
-    { "23", 531250 },
-    { "24", 537250 },
-    { "25", 543250 },
-    { "26", 549250 },
-    { "27", 555250 },
-    { "28", 561250 },
-    { "29", 567250 },
-    { "30", 573250 },
-    { "31", 579250 },
-    { "32", 585250 },
-    { "33", 591250 },
-    { "34", 597250 },
-    { "35", 603250 },
-    { "36", 609250 },
-    { "37", 615250 },
-    { "38", 621250 },
-    { "39", 627250 },
-    { "40", 633250 },
-    { "41", 639250 },
-    { "42", 645250 },
-    { "43", 651250 },
-    { "44", 657250 },
-
-    { "45", 663250 },
-    { "46", 669250 },
-    { "47", 675250 },
-    { "48", 681250 },
-    { "49", 687250 },
-    { "50", 693250 },
-    { "51", 699250 },
-    { "52", 705250 },
-    { "53", 711250 },
-    { "54", 717250 },
-    { "55", 723250 },
-    { "56", 729250 },
-    { "57", 735250 },
-    { "58", 741250 },
-    { "59", 747250 },
-    { "60", 753250 },
-    { "61", 759250 },
-    { "62", 765250 },
-};
-
-/* JP cable */
-static const struct CHANLIST ntsc_cable_jp[] = {
-    { "13",     109250 },
-    { "14",     115250 },
-    { "15",     121250 },
-    { "16",     127250 },
-    { "17",     133250 },
-    { "18",     139250 },
-    { "19",     145250 },
-    { "20",     151250 },
-
-    { "21",     157250 },
-    { "22",     165250 },
-    { "23",     223250 },
-    { "24",     231250 },
-    { "25",     237250 },
-    { "26",     243250 },
-    { "27",     249250 },
-    { "28",     253250 },
-    { "29",     259250 },
-    { "30",     265250 },
-    { "31",     271250 },
-    { "32",     277250 },
-    { "33",     283250 },
-    { "34",     289250 },
-    { "35",     295250 },
-    { "36",     301250 },
-    { "37",     307250 },
-    { "38",     313250 },
-    { "39",     319250 },
-    { "40",     325250 },
-    { "41",     331250 },
-    { "42",     337250 },
-    { "43",     343250 },
-    { "44",     349250 },
-    { "45",     355250 },
-    { "46",     361250 },
-    { "47",     367250 },
-    { "48",     373250 },
-    { "49",     379250 },
-    { "50",     385250 },
-    { "51",     391250 },
-    { "52",     397250 },
-    { "53",     403250 },
-    { "54",     409250 },
-    { "55",     415250 },
-    { "56",     421250 },
-    { "57",     427250 },
-    { "58",     433250 },
-    { "59",     439250 },
-    { "60",     445250 },
-    { "61",     451250 },
-    { "62",     457250 },
-    { "63",     463250 },
-};
-
-/* --------------------------------------------------------------------- */
-
-/* australia */
-static const struct CHANLIST pal_australia[] = {
-    { "0",       46250 },
-    { "1",       57250 },
-    { "2",       64250 },
-    { "3",       86250 },
-    { "4",       95250 },
-    { "5",      102250 },
-    { "5A",     138250 },
-    { "6",      175250 },
-    { "7",      182250 },
-    { "8",      189250 },
-    { "9",      196250 },
-    { "10",     209250 },
-    { "11",     216250 },
-    { "28",     527250 },
-    { "29",     534250 },
-    { "30",     541250 },
-    { "31",     548250 },
-    { "32",     555250 },
-    { "33",     562250 },
-    { "34",     569250 },
-    { "35",     576250 },
-    { "36",     591250 },
-    { "39",     604250 },
-    { "40",     611250 },
-    { "41",     618250 },
-    { "42",     625250 },
-    { "43",     632250 },
-    { "44",     639250 },
-    { "45",     646250 },
-    { "46",     653250 },
-    { "47",     660250 },
-    { "48",     667250 },
-    { "49",     674250 },
-    { "50",     681250 },
-    { "51",     688250 },
-    { "52",     695250 },
-    { "53",     702250 },
-    { "54",     709250 },
-    { "55",     716250 },
-    { "56",     723250 },
-    { "57",     730250 },
-    { "58",     737250 },
-    { "59",     744250 },
-    { "60",     751250 },
-    { "61",     758250 },
-    { "62",     765250 },
-    { "63",     772250 },
-    { "64",     779250 },
-    { "65",     786250 },
-    { "66",     793250 },
-    { "67",     800250 },
-    { "68",     807250 },
-    { "69",     814250 },
-};
-
-/* --------------------------------------------------------------------- */
-/* europe                                                                */
-
-/* CCIR frequencies */
-
-#define FREQ_CCIR_I_III         \
-    { "E2",       48250 },      \
-    { "E3",       55250 },      \
-    { "E4",       62250 },      \
-                                \
-    { "S01",      69250 },      \
-    { "S02",      76250 },      \
-    { "S03",      83250 },      \
-                                \
-    { "E5",      175250 },      \
-    { "E6",      182250 },      \
-    { "E7",      189250 },      \
-    { "E8",      196250 },      \
-    { "E9",      203250 },      \
-    { "E10",     210250 },      \
-    { "E11",     217250 },      \
-    { "E12",     224250 }
-
-#define FREQ_CCIR_SL_SH         \
-    { "SE1",     105250 },      \
-    { "SE2",     112250 },      \
-    { "SE3",     119250 },      \
-    { "SE4",     126250 },      \
-    { "SE5",     133250 },      \
-    { "SE6",     140250 },      \
-    { "SE7",     147250 },      \
-    { "SE8",     154250 },      \
-    { "SE9",     161250 },      \
-    { "SE10",    168250 },      \
-                                \
-    { "SE11",    231250 },      \
-    { "SE12",    238250 },      \
-    { "SE13",    245250 },      \
-    { "SE14",    252250 },      \
-    { "SE15",    259250 },      \
-    { "SE16",    266250 },      \
-    { "SE17",    273250 },      \
-    { "SE18",    280250 },      \
-    { "SE19",    287250 },      \
-    { "SE20",    294250 }
-
-#define FREQ_CCIR_H     \
-    { "S21", 303250 },  \
-    { "S22", 311250 },  \
-    { "S23", 319250 },  \
-    { "S24", 327250 },  \
-    { "S25", 335250 },  \
-    { "S26", 343250 },  \
-    { "S27", 351250 },  \
-    { "S28", 359250 },  \
-    { "S29", 367250 },  \
-    { "S30", 375250 },  \
-    { "S31", 383250 },  \
-    { "S32", 391250 },  \
-    { "S33", 399250 },  \
-    { "S34", 407250 },  \
-    { "S35", 415250 },  \
-    { "S36", 423250 },  \
-    { "S37", 431250 },  \
-    { "S38", 439250 },  \
-    { "S39", 447250 },  \
-    { "S40", 455250 },  \
-    { "S41", 463250 }
-
-/* OIRT frequencies */
-
-#define FREQ_OIRT_I_III         \
-    { "R1",       49750 },      \
-    { "R2",       59250 },      \
-                                \
-    { "R3",       77250 },      \
-    { "R4",       85250 },      \
-    { "R5",       93250 },      \
-                                \
-    { "R6",      175250 },      \
-    { "R7",      183250 },      \
-    { "R8",      191250 },      \
-    { "R9",      199250 },      \
-    { "R10",     207250 },      \
-    { "R11",     215250 },      \
-    { "R12",     223250 }
-
-#define FREQ_OIRT_SL_SH         \
-    { "SR1",     111250 },      \
-    { "SR2",     119250 },      \
-    { "SR3",     127250 },      \
-    { "SR4",     135250 },      \
-    { "SR5",     143250 },      \
-    { "SR6",     151250 },      \
-    { "SR7",     159250 },      \
-    { "SR8",     167250 },      \
-                                \
-    { "SR11",    231250 },      \
-    { "SR12",    239250 },      \
-    { "SR13",    247250 },      \
-    { "SR14",    255250 },      \
-    { "SR15",    263250 },      \
-    { "SR16",    271250 },      \
-    { "SR17",    279250 },      \
-    { "SR18",    287250 },      \
-    { "SR19",    295250 }
-
-#define FREQ_UHF        \
-    { "21",  471250 },  \
-    { "22",  479250 },  \
-    { "23",  487250 },  \
-    { "24",  495250 },  \
-    { "25",  503250 },  \
-    { "26",  511250 },  \
-    { "27",  519250 },  \
-    { "28",  527250 },  \
-    { "29",  535250 },  \
-    { "30",  543250 },  \
-    { "31",  551250 },  \
-    { "32",  559250 },  \
-    { "33",  567250 },  \
-    { "34",  575250 },  \
-    { "35",  583250 },  \
-    { "36",  591250 },  \
-    { "37",  599250 },  \
-    { "38",  607250 },  \
-    { "39",  615250 },  \
-    { "40",  623250 },  \
-    { "41",  631250 },  \
-    { "42",  639250 },  \
-    { "43",  647250 },  \
-    { "44",  655250 },  \
-    { "45",  663250 },  \
-    { "46",  671250 },  \
-    { "47",  679250 },  \
-    { "48",  687250 },  \
-    { "49",  695250 },  \
-    { "50",  703250 },  \
-    { "51",  711250 },  \
-    { "52",  719250 },  \
-    { "53",  727250 },  \
-    { "54",  735250 },  \
-    { "55",  743250 },  \
-    { "56",  751250 },  \
-    { "57",  759250 },  \
-    { "58",  767250 },  \
-    { "59",  775250 },  \
-    { "60",  783250 },  \
-    { "61",  791250 },  \
-    { "62",  799250 },  \
-    { "63",  807250 },  \
-    { "64",  815250 },  \
-    { "65",  823250 },  \
-    { "66",  831250 },  \
-    { "67",  839250 },  \
-    { "68",  847250 },  \
-    { "69",  855250 }
-
-static const struct CHANLIST europe_west[] = {
-    FREQ_CCIR_I_III,
-    FREQ_CCIR_SL_SH,
-    FREQ_CCIR_H,
-    FREQ_UHF
-};
-
-static const struct CHANLIST europe_east[] = {
-    FREQ_OIRT_I_III,
-    FREQ_OIRT_SL_SH,
-    FREQ_CCIR_I_III,
-    FREQ_CCIR_SL_SH,
-    FREQ_CCIR_H,
-    FREQ_UHF
-};
-
-static const struct CHANLIST pal_italy[] = {
-    { "A",       53750 },
-    { "B",       62250 },
-    { "C",       82250 },
-    { "D",      175250 },
-    { "E",      183750 },
-    { "F",      192250 },
-    { "G",      201250 },
-    { "H",      210250 },
-    { "H1",     217250 },
-    { "H2",     224250 },
-    FREQ_UHF
-};
-
-static const struct CHANLIST pal_ireland[] = {
-    { "A0",     45750 },
-    { "A1",     48000 },
-    { "A2",     53750 },
-    { "A3",     56000 },
-    { "A4",     61750 },
-    { "A5",     64000 },
-    { "A6",    175250 },
-    { "A7",    176000 },
-    { "A8",    183250 },
-    { "A9",    184000 },
-    { "A10",   191250 },
-    { "A11",   192000 },
-    { "A12",   199250 },
-    { "A13",   200000 },
-    { "A14",   207250 },
-    { "A15",   208000 },
-    { "A16",   215250 },
-    { "A17",   216000 },
-    { "A18",   224000 },
-    { "A19",   232000 },
-    { "A20",   248000 },
-    { "A21",   256000 },
-    { "A22",   264000 },
-    { "A23",   272000 },
-    { "A24",   280000 },
-    { "A25",   288000 },
-    { "A26",   296000 },
-    { "A27",   304000 },
-    { "A28",   312000 },
-    { "A29",   320000 },
-    { "A30",   344000 },
-    { "A31",   352000 },
-    { "A32",   408000 },
-    { "A33",   416000 },
-    { "A34",   448000 },
-    { "A35",   480000 },
-    { "A36",   520000 },
-    FREQ_UHF,
-};
-
-static const struct CHANLIST secam_france[] = {
-    { "K01",    47750 },
-    { "K02",    55750 },
-    { "K03",    60500 },
-    { "K04",    63750 },
-    { "K05",   176000 },
-    { "K06",   184000 },
-    { "K07",   192000 },
-    { "K08",   200000 },
-    { "K09",   208000 },
-    { "K10",   216000 },
-    { "KB",    116750 },
-    { "KC",    128750 },
-    { "KD",    140750 },
-    { "KE",    159750 },
-    { "KF",    164750 },
-    { "KG",    176750 },
-    { "KH",    188750 },
-    { "KI",    200750 },
-    { "KJ",    212750 },
-    { "KK",    224750 },
-    { "KL",    236750 },
-    { "KM",    248750 },
-    { "KN",    260750 },
-    { "KO",    272750 },
-    { "KP",    284750 },
-    { "KQ",    296750 },
-    { "H01",   303250 },
-    { "H02",   311250 },
-    { "H03",   319250 },
-    { "H04",   327250 },
-    { "H05",   335250 },
-    { "H06",   343250 },
-    { "H07",   351250 },
-    { "H08",   359250 },
-    { "H09",   367250 },
-    { "H10",   375250 },
-    { "H11",   383250 },
-    { "H12",   391250 },
-    { "H13",   399250 },
-    { "H14",   407250 },
-    { "H15",   415250 },
-    { "H16",   423250 },
-    { "H17",   431250 },
-    { "H18",   439250 },
-    { "H19",   447250 },
-    FREQ_UHF,
-};
-
-/* --------------------------------------------------------------------- */
-
-static const struct CHANLIST pal_newzealand[] = {
-    { "1",        45250 },
-    { "2",        55250 },
-    { "3",        62250 },
-    { "4",       175250 },
-    { "5",       182250 },
-    { "6",       189250 },
-    { "7",       196250 },
-    { "8",       203250 },
-    { "9",       210250 },
-    { "10",      217250 },
-    { "11",      224250 },
-    FREQ_UHF,
-};
-
-/* --------------------------------------------------------------------- */
-
-/* China broadcast */
-static const struct CHANLIST pal_bcast_cn[] = {
-    { "1",      49750 },
-    { "2",      57750 },
-    { "3",      65750 },
-    { "4",      77250 },
-    { "5",      85250 },
-    { "6",      112250 },
-    { "7",      120250 },
-    { "8",      128250 },
-    { "9",      136250 },
-    { "10",     144250 },
-    { "11",     152250 },
-    { "12",     160250 },
-    { "13",     168250 },
-    { "14",     176250 },
-    { "15",     184250 },
-    { "16",     192250 },
-    { "17",     200250 },
-    { "18",     208250 },
-    { "19",     216250 },
-    { "20",     224250 },
-    { "21",     232250 },
-    { "22",     240250 },
-    { "23",     248250 },
-    { "24",     256250 },
-    { "25",     264250 },
-    { "26",     272250 },
-    { "27",     280250 },
-    { "28",     288250 },
-    { "29",     296250 },
-    { "30",     304250 },
-    { "31",     312250 },
-    { "32",     320250 },
-    { "33",     328250 },
-    { "34",     336250 },
-    { "35",     344250 },
-    { "36",     352250 },
-    { "37",     360250 },
-    { "38",     368250 },
-    { "39",     376250 },
-    { "40",     384250 },
-    { "41",     392250 },
-    { "42",     400250 },
-    { "43",     408250 },
-    { "44",     416250 },
-    { "45",     424250 },
-    { "46",     432250 },
-    { "47",     440250 },
-    { "48",     448250 },
-    { "49",     456250 },
-    { "50",     463250 },
-    { "51",     471250 },
-    { "52",     479250 },
-    { "53",     487250 },
-    { "54",     495250 },
-    { "55",     503250 },
-    { "56",     511250 },
-    { "57",     519250 },
-    { "58",     527250 },
-    { "59",     535250 },
-    { "60",     543250 },
-    { "61",     551250 },
-    { "62",     559250 },
-    { "63",     607250 },
-    { "64",     615250 },
-    { "65",     623250 },
-    { "66",     631250 },
-    { "67",     639250 },
-    { "68",     647250 },
-    { "69",     655250 },
-    { "70",     663250 },
-    { "71",     671250 },
-    { "72",     679250 },
-    { "73",     687250 },
-    { "74",     695250 },
-    { "75",     703250 },
-    { "76",     711250 },
-    { "77",     719250 },
-    { "78",     727250 },
-    { "79",     735250 },
-    { "80",     743250 },
-    { "81",     751250 },
-    { "82",     759250 },
-    { "83",     767250 },
-    { "84",     775250 },
-    { "85",     783250 },
-    { "86",     791250 },
-    { "87",     799250 },
-    { "88",     807250 },
-    { "89",     815250 },
-    { "90",     823250 },
-    { "91",     831250 },
-    { "92",     839250 },
-    { "93",     847250 },
-    { "94",     855250 },
-};
-
-/* --------------------------------------------------------------------- */
-/* South Africa Broadcast */
-
-static const struct CHANLIST pal_bcast_za[] ={
-    { "1", 175250 },
-    { "2", 183250 },
-    { "3", 191250 },
-    { "4", 199250 },
-    { "5", 207250 },
-    { "6", 215250 },
-    { "7", 223250 },
-    { "8", 231250 },
-    FREQ_UHF
-};
-
-/* --------------------------------------------------------------------- */
-
-static const struct CHANLIST argentina[] = {
-    { "001",   56250 },
-    { "002",   62250 },
-    { "003",   68250 },
-    { "004",   78250 },
-    { "005",   84250 },
-    { "006",  176250 },
-    { "007",  182250 },
-    { "008",  188250 },
-    { "009",  194250 },
-    { "010",  200250 },
-    { "011",  206250 },
-    { "012",  212250 },
-    { "013",  122250 },
-    { "014",  128250 },
-    { "015",  134250 },
-    { "016",  140250 },
-    { "017",  146250 },
-    { "018",  152250 },
-    { "019",  158250 },
-    { "020",  164250 },
-    { "021",  170250 },
-    { "022",  218250 },
-    { "023",  224250 },
-    { "024",  230250 },
-    { "025",  236250 },
-    { "026",  242250 },
-    { "027",  248250 },
-    { "028",  254250 },
-    { "029",  260250 },
-    { "030",  266250 },
-    { "031",  272250 },
-    { "032",  278250 },
-    { "033",  284250 },
-    { "034",  290250 },
-    { "035",  296250 },
-    { "036",  302250 },
-    { "037",  308250 },
-    { "038",  314250 },
-    { "039",  320250 },
-    { "040",  326250 },
-    { "041",  332250 },
-    { "042",  338250 },
-    { "043",  344250 },
-    { "044",  350250 },
-    { "045",  356250 },
-    { "046",  362250 },
-    { "047",  368250 },
-    { "048",  374250 },
-    { "049",  380250 },
-    { "050",  386250 },
-    { "051",  392250 },
-    { "052",  398250 },
-    { "053",  404250 },
-    { "054",  410250 },
-    { "055",  416250 },
-    { "056",  422250 },
-    { "057",  428250 },
-    { "058",  434250 },
-    { "059",  440250 },
-    { "060",  446250 },
-    { "061",  452250 },
-    { "062",  458250 },
-    { "063",  464250 },
-    { "064",  470250 },
-    { "065",  476250 },
-    { "066",  482250 },
-    { "067",  488250 },
-    { "068",  494250 },
-    { "069",  500250 },
-    { "070",  506250 },
-    { "071",  512250 },
-    { "072",  518250 },
-    { "073",  524250 },
-    { "074",  530250 },
-    { "075",  536250 },
-    { "076",  542250 },
-    { "077",  548250 },
-    { "078",  554250 },
-    { "079",  560250 },
-    { "080",  566250 },
-    { "081",  572250 },
-    { "082",  578250 },
-    { "083",  584250 },
-    { "084",  590250 },
-    { "085",  596250 },
-    { "086",  602250 },
-    { "087",  608250 },
-    { "088",  614250 },
-    { "089",  620250 },
-    { "090",  626250 },
-    { "091",  632250 },
-    { "092",  638250 },
-    { "093",  644250 },
-};
-
-/* --------------------------------------------------------------------- */
-
-static const struct CHANLIST russia[] = {
-    {"1",     49750 },
-    {"2",     59250 },
-    {"3",     77250 },
-    {"4",     85250 },
-    {"5",     93250 },
-    {"SK1",   111250 },
-    {"SK2",   119250 },
-    {"SK3",   127250 },
-    {"SK4",   135250 },
-    {"SK5",   143250 },
-    {"SK6",   151250 },
-    {"SK7",   159250 },
-    {"SK8",   167250 },
-    {"6",     175250 },
-    {"7",     183250 },
-    {"8",     191250 },
-    {"9",     199250 },
-    {"10",    207250 },
-    {"11",    215250 },
-    {"12",    223250 },
-    {"SK11",  231250 },
-    {"SK12",  239250 },
-    {"SK13",  247250 },
-    {"SK14",  255250 },
-    {"SK15",  263250 },
-    {"SK16",  271250 },
-    {"SK17",  279250 },
-    {"SK18",  287250 },
-    {"S19",   295250 },
-    {"S20",   303250 },
-    {"S21",   311250 },
-    {"S22",   319250 },
-    {"S23",   327250 },
-    {"S24",   335250 },
-    {"S25",   343250 },
-    {"S26",   351250 },
-    {"S27",   359250 },
-    {"S28",   367250 },
-    {"S29",   375250 },
-    {"S30",   383250 },
-    {"S31",   391250 },
-    {"S32",   399250 },
-    {"S33",   407250 },
-    {"S34",   415250 },
-    {"S35",   423250 },
-    {"S36",   431250 },
-    {"S37",   439250 },
-    {"S38",   447250 },
-    {"S39",   455250 },
-    {"S40",   463250 },
-    {"21",    471250 },
-    {"22",    479250 },
-    {"23",    487250 },
-    {"24",    495250 },
-    {"25",    503250 },
-    {"26",    511250 },
-    {"27",    519250 },
-    {"28",    527250 },
-    {"29",    535250 },
-    {"30",    543250 },
-    {"31",    551250 },
-    {"32",    559250 },
-    {"33",    567250 },
-    {"34",    575250 },
-    {"35",    583250 },
-    {"36",    591250 },
-    {"37",    599250 },
-    {"38",    607250 },
-    {"39",    615250 },
-    {"40",    623250 },
-    {"41",    631250 },
-    {"42",    639250 },
-    {"43",    647250 },
-    {"44",    655250 },
-    {"45",    663250 },
-    {"46",    671250 },
-    {"47",    679250 },
-    {"48",    687250 },
-    {"49",    695250 },
-    {"50",    703250 },
-    {"51",    711250 },
-    {"52",    719250 },
-    {"53",    727250 },
-    {"54",    735250 },
-    {"55",    743250 },
-    {"56",    751250 },
-    {"57",    759250 },
-    {"58",    767250 },
-    {"59",    775250 },
-    {"60",    783250 },
-    {"61",    791250 },
-    {"62",    799250 },
-    {"63",    807250 },
-    {"64",    815250 },
-    {"65",    523250 },
-    {"66",    831250 },
-    {"67",    839250 },
-    {"68",    847250 },
-    {"69",    855250 },
-};
-/* --------------------------------------------------------------------- */
-
-const struct CHANLISTS chanlists[] = {
-    { "us-bcast",         ntsc_bcast,        CHAN_COUNT(ntsc_bcast)        },
-    { "us-cable",         ntsc_cable,        CHAN_COUNT(ntsc_cable)        },
-    { "us-cable-hrc",     ntsc_hrc,          CHAN_COUNT(ntsc_hrc)          },
-    { "japan-bcast",      ntsc_bcast_jp,     CHAN_COUNT(ntsc_bcast_jp)     },
-    { "japan-cable",      ntsc_cable_jp,     CHAN_COUNT(ntsc_cable_jp)     },
-    { "europe-west",      europe_west,       CHAN_COUNT(europe_west)       },
-    { "europe-east",      europe_east,       CHAN_COUNT(europe_east)       },
-    { "italy",            pal_italy,         CHAN_COUNT(pal_italy)         },
-    { "newzealand",       pal_newzealand,    CHAN_COUNT(pal_newzealand)    },
-    { "australia",        pal_australia,     CHAN_COUNT(pal_australia)     },
-    { "ireland",          pal_ireland,       CHAN_COUNT(pal_ireland)       },
-    { "france",           secam_france,      CHAN_COUNT(secam_france)      },
-    { "china-bcast",      pal_bcast_cn,      CHAN_COUNT(pal_bcast_cn)      },
-    { "southafrica",      pal_bcast_za,      CHAN_COUNT(pal_bcast_za)      },
-    { "argentina",        argentina,         CHAN_COUNT(argentina)         },
-    { "russia",           russia,            CHAN_COUNT(russia)            },
-    { NULL, NULL, 0 } /* EOF */
-};
-
-const int                chancount = CHAN_COUNT(europe_west);
diff -ruN mpv-0.29.1/stream/frequencies.h mpv-master/stream/frequencies.h
--- mpv-0.29.1/stream/frequencies.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/frequencies.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,133 +0,0 @@
-/*
- * Worldwide channel/frequency list
- *
- * Nathan Laredo (laredo@broked.net)
- *
- * Frequencies are given in kHz
- *
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef MPLAYER_FREQUENCIES_H
-#define MPLAYER_FREQUENCIES_H
-
-#define NTSC_AUDIO_CARRIER      4500
-#define PAL_AUDIO_CARRIER_I     6000
-#define PAL_AUDIO_CARRIER_BGHN  5500
-#define PAL_AUDIO_CARRIER_MN    4500
-#define PAL_AUDIO_CARRIER_D     6500
-#define SEACAM_AUDIO_DKK1L      6500
-#define SEACAM_AUDIO_BG         5500
-/* NICAM 728 32-kHz, 14-bit digital stereo audio is transmitted in 1ms frames
-   containing 8 bits frame sync, 5 bits control, 11 bits additional data, and
-   704 bits audio data.  The bit rate is reduced by transmitting only 10 bits
-   plus parity of each 14 bit sample, the largest sample in a frame determines
-   which 10 bits are transmitted.  The parity bits for audio samples also
-   specify the scaling factor used for that channel during that frame.  The
-   companeded audio data is interleaved to reduce the influence of dropouts
-   and the whole frame except for sync bits is scrambled for spectrum shaping.
-   Data is modulated using QPSK, at below following subcarrier freqs */
-#define NICAM728_PAL_BGH        5850
-#define NICAM728_PAL_I          6552
-
-/* COMPREHENSIVE LIST OF FORMAT BY COUNTRY
-   (M) NTSC used in:
-        Antigua, Aruba, Bahamas, Barbados, Belize, Bermuda, Bolivia, Burma,
-        Canada, Chile, Colombia, Costa Rica, Cuba, Curacao, Dominican Republic,
-        Ecuador, El Salvador, Guam Guatemala, Honduras, Jamaica, Japan,
-        South Korea, Mexico, Montserrat, Myanmar, Nicaragua, Panama, Peru,
-        Philippines, Puerto Rico, St Christopher and Nevis, Samoa, Suriname,
-        Taiwan, Trinidad/Tobago, United States, Venezuela, Virgin Islands
-   (B) PAL used in:
-        Albania, Algeria, Australia, Austria, Bahrain, Bangladesh, Belgium,
-        Bosnia-Herzegovinia, Brunei Darussalam, Cambodia, Cameroon, Croatia,
-        Cyprus, Denmark, Egypt, Ethiopia, Equatorial Guinea, Finland, Germany,
-        Ghana, Gibraltar, Greenland, Iceland, India, Indonesia, Israel, Italy,
-        Jordan, Kenya, Kuwait, Liberia, Libya, Luxembourg, Malaysa, Maldives,
-        Malta, Nepal, Netherlands, New Zeland, Nigeria, Norway, Oman, Pakistan,
-        Papua New Guinea, Portugal, Qatar, Sao Tome and Principe, Saudi Arabia,
-        Seychelles, Sierra Leone, Singapore, Slovenia, Somali, Spain,
-        Sri Lanka, Sudan, Swaziland, Sweden, Switzeland, Syria, Thailand,
-        Tunisia, Turkey, Uganda, United Arab Emirates, Yemen
-   (N) PAL used in: (Combination N = 4.5MHz audio carrier, 3.58MHz burst)
-        Argentina (Combination N), Paraguay, Uruguay
-   (M) PAL (525/60, 3.57MHz burst) used in:
-        Brazil
-   (G) PAL used in:
-        Albania, Algeria, Austria, Bahrain, Bosnia/Herzegovinia, Cambodia,
-        Cameroon, Croatia, Cyprus, Denmark, Egypt, Ethiopia, Equatorial Guinea,
-        Finland, Germany, Gibraltar, Greenland, Iceland, Israel, Italy, Jordan,
-        Kenya, Kuwait, Liberia, Libya, Luxembourg, Malaysia, Monaco,
-        Mozambique, Netherlands, New Zealand, Norway, Oman, Pakistan,
-        Papa New Guinea, Portugal, Qatar, Romania, Sierra Leone, Singapore,
-        Slovenia, Somalia, Spain, Sri Lanka, Sudan, Swaziland, Sweeden,
-        Switzerland, Syria, Thailand, Tunisia, Turkey, United Arab Emirates,
-        Yemen, Zambia, Zimbabwe
-   (D) PAL used in:
-        China, North Korea, Romania, Czech Republic
-   (H) PAL used in:
-        Belgium
-   (I) PAL used in:
-        Angola, Botswana, Gambia, Guinea-Bissau, Hong Kong, Ireland, Lesotho,
-        Malawi, Nambia, Nigeria, South Africa, Tanzania, United Kingdom,
-        Zanzibar
-   (B) SECAM used in:
-        Djibouti, Greece, Iran, Iraq, Lebanon, Mali, Mauritania, Mauritus,
-        Morocco
-   (D) SECAM used in:
-        Afghanistan, Armenia, Azerbaijan, Belarus, Bulgaria,
-        Estonia, Georgia, Hungary, Zazakhstan, Lithuania, Mongolia, Moldova,
-        Russia, Slovak Republic, Ukraine, Vietnam
-   (G) SECAM used in:
-        Greecem Iran, Iraq, Mali, Mauritus, Morocco, Saudi Arabia
-   (K) SECAM used in:
-        Armenia, Azerbaijan, Bulgaria, Estonia, Georgia,
-        Hungary, Kazakhstan, Lithuania, Madagascar, Moldova, Poland, Russia,
-        Slovak Republic, Ukraine, Vietnam
-   (K1) SECAM used in:
-        Benin, Burkina Faso, Burundi, Chad, Cape Verde, Central African
-        Republic, Comoros, Congo, Gabon, Madagascar, Niger, Rwanda, Senegal,
-        Togo, Zaire
-   (L) SECAM used in:
-        France
-*/
-
-/* --------------------------------------------------------------------- */
-
-struct CHANLIST {
-    char  name[8];
-    int   freq;
-};
-
-struct CHANLISTS {
-    const char             *name;
-    const struct CHANLIST  *list;
-    int                    count;
-};
-
-#define CHAN_COUNT(x) (sizeof(x)/sizeof(struct CHANLIST))
-
-/* --------------------------------------------------------------------- */
-
-extern const struct CHANLISTS   chanlists[];
-extern const int                chancount;
-
-#include "config.h"
-#if !HAVE_GPL
-#error GPL only
-#endif
-
-#endif /* MPLAYER_FREQUENCIES_H */
diff -ruN mpv-0.29.1/stream/rar.c mpv-master/stream/rar.c
--- mpv-0.29.1/stream/rar.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/rar.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,451 +0,0 @@
-/*****************************************************************************
- * rar.c: uncompressed RAR parser
- *****************************************************************************
- * Copyright (C) 2008-2010 Laurent Aimar
- * $Id: f368245f4260f913f5c211e09b7dd511a96525e6 $
- *
- * Author: Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2.1 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-/*****************************************************************************
- * Preamble
- *****************************************************************************/
-
-#include <assert.h>
-#include <limits.h>
-#include <stdio.h>
-
-#include <libavutil/intreadwrite.h>
-
-#include "mpv_talloc.h"
-#include "common/common.h"
-#include "stream.h"
-#include "rar.h"
-
-static const uint8_t rar_marker[] = {
-    0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x00
-};
-static const int rar_marker_size = sizeof(rar_marker);
-
-void RarFileDelete(rar_file_t *file)
-{
-    for (int i = 0; i < file->chunk_count; i++) {
-        free(file->chunk[i]->mrl);
-        free(file->chunk[i]);
-    }
-    talloc_free(file->chunk);
-    free(file->name);
-    free_stream(file->s);
-    free(file);
-}
-
-typedef struct {
-    uint16_t crc;
-    uint8_t  type;
-    uint16_t flags;
-    uint16_t size;
-    uint32_t add_size;
-} rar_block_t;
-
-enum {
-    RAR_BLOCK_MARKER = 0x72,
-    RAR_BLOCK_ARCHIVE = 0x73,
-    RAR_BLOCK_FILE = 0x74,
-    RAR_BLOCK_SUBBLOCK = 0x7a,
-    RAR_BLOCK_END = 0x7b,
-};
-enum {
-    RAR_BLOCK_END_HAS_NEXT = 0x0001,
-};
-enum {
-    RAR_BLOCK_FILE_HAS_PREVIOUS = 0x0001,
-    RAR_BLOCK_FILE_HAS_NEXT     = 0x0002,
-    RAR_BLOCK_FILE_HAS_HIGH     = 0x0100,
-};
-
-static int PeekBlock(struct stream *s, rar_block_t *hdr)
-{
-    bstr data = stream_peek(s, 11);
-    const uint8_t *peek = (uint8_t *)data.start;
-    int peek_size = data.len;
-
-    if (peek_size < 7)
-        return -1;
-
-    hdr->crc   = AV_RL16(&peek[0]);
-    hdr->type  = peek[2];
-    hdr->flags = AV_RL16(&peek[3]);
-    hdr->size  = AV_RL16(&peek[5]);
-    hdr->add_size = 0;
-    if ((hdr->flags & 0x8000) ||
-        hdr->type == RAR_BLOCK_FILE ||
-        hdr->type == RAR_BLOCK_SUBBLOCK) {
-        if (peek_size < 11)
-            return -1;
-        hdr->add_size = AV_RL32(&peek[7]);
-    }
-
-    if (hdr->size < 7)
-        return -1;
-    return 0;
-}
-static int SkipBlock(struct stream *s, const rar_block_t *hdr)
-{
-    uint64_t size = (uint64_t)hdr->size + hdr->add_size;
-
-    while (size > 0) {
-        int skip = MPMIN(size, INT_MAX);
-        if (!stream_skip(s, skip))
-            return -1;
-
-        size -= skip;
-    }
-    return 0;
-}
-
-static int IgnoreBlock(struct stream *s, int block)
-{
-    /* */
-    rar_block_t bk;
-    if (PeekBlock(s, &bk) || bk.type != block)
-        return -1;
-    return SkipBlock(s, &bk);
-}
-
-static int SkipEnd(struct stream *s, const rar_block_t *hdr)
-{
-    if (!(hdr->flags & RAR_BLOCK_END_HAS_NEXT))
-        return -1;
-
-    if (SkipBlock(s, hdr))
-        return -1;
-
-    /* Now, we need to look for a marker block,
-     * It seems that there is garbage at EOF */
-    for (;;) {
-        bstr peek = stream_peek(s, rar_marker_size);
-
-        if (peek.len < rar_marker_size)
-            return -1;
-
-        if (!memcmp(peek.start, rar_marker, rar_marker_size))
-            break;
-
-        if (!stream_skip(s, 1))
-            return -1;
-    }
-
-    /* Skip marker and archive blocks */
-    if (IgnoreBlock(s, RAR_BLOCK_MARKER))
-        return -1;
-    if (IgnoreBlock(s, RAR_BLOCK_ARCHIVE))
-        return -1;
-
-    return 0;
-}
-
-static int SkipFile(struct stream *s, int *count, rar_file_t ***file,
-                    const rar_block_t *hdr, const char *volume_mrl)
-{
-    int min_size = 7+21;
-    if (hdr->flags & RAR_BLOCK_FILE_HAS_HIGH)
-        min_size += 8;
-    if (hdr->size < (unsigned)min_size)
-        return -1;
-
-    bstr data = stream_peek(s, min_size);
-    if (data.len < min_size)
-        return -1;
-    const uint8_t *peek = (uint8_t *)data.start;
-
-    /* */
-    uint32_t file_size_low = AV_RL32(&peek[7+4]);
-    uint8_t  method = peek[7+18];
-    uint16_t name_size = AV_RL16(&peek[7+19]);
-    uint32_t file_size_high = 0;
-    if (hdr->flags & RAR_BLOCK_FILE_HAS_HIGH)
-        file_size_high = AV_RL32(&peek[7+29]);
-    const uint64_t file_size = ((uint64_t)file_size_high << 32) | file_size_low;
-
-    char *name = calloc(1, name_size + 1);
-    if (!name)
-        return -1;
-
-    const int name_offset = (hdr->flags & RAR_BLOCK_FILE_HAS_HIGH) ? (7+33) : (7+25);
-    if (name_offset + name_size <= hdr->size) {
-        const int max_size = name_offset + name_size;
-        bstr namedata = stream_peek(s, max_size);
-        if (namedata.len < max_size) {
-            free(name);
-            return -1;
-        }
-        memcpy(name, &namedata.start[name_offset], name_size);
-    }
-
-    rar_file_t *current = NULL;
-    if (method != 0x30) {
-        MP_WARN(s, "Ignoring compressed file %s (method=0x%2.2x)\n", name, method);
-        goto exit;
-    }
-
-    /* */
-    if( *count > 0 )
-        current = (*file)[*count - 1];
-
-    if (current &&
-        (current->is_complete ||
-          strcmp(current->name, name) ||
-          (hdr->flags & RAR_BLOCK_FILE_HAS_PREVIOUS) == 0))
-        current = NULL;
-
-    if (!current) {
-        if (hdr->flags & RAR_BLOCK_FILE_HAS_PREVIOUS)
-            goto exit;
-        current = calloc(1, sizeof(*current));
-        if (!current)
-            goto exit;
-        MP_TARRAY_APPEND(NULL, *file, *count, current);
-
-        current->name = name;
-        current->size = file_size;
-        current->is_complete = false;
-        current->real_size = 0;
-        current->chunk_count = 0;
-        current->chunk = NULL;
-
-        name = NULL;
-    }
-
-    /* Append chunks */
-    rar_file_chunk_t *chunk = malloc(sizeof(*chunk));
-    if (chunk) {
-        chunk->mrl = strdup(volume_mrl);
-        chunk->offset = stream_tell(s) + hdr->size;
-        chunk->size = hdr->add_size;
-        chunk->cummulated_size = 0;
-        if (current->chunk_count > 0) {
-            rar_file_chunk_t *previous = current->chunk[current->chunk_count-1];
-
-            chunk->cummulated_size += previous->cummulated_size +
-                                      previous->size;
-        }
-
-        MP_TARRAY_APPEND(NULL, current->chunk, current->chunk_count, chunk);
-
-        current->real_size += hdr->add_size;
-    }
-    if ((hdr->flags & RAR_BLOCK_FILE_HAS_NEXT) == 0)
-        current->is_complete = true;
-
-exit:
-    /* */
-    free(name);
-
-    /* We stop on the first non empty file if we cannot seek */
-    if (current) {
-        if (!s->seekable && current->size > 0)
-            return -1;
-    }
-
-    if (SkipBlock(s, hdr))
-        return -1;
-    return 0;
-}
-
-int RarProbe(struct stream *s)
-{
-    bstr peek = stream_peek(s, rar_marker_size);
-    if (peek.len < rar_marker_size)
-        return -1;
-    if (memcmp(peek.start, rar_marker, rar_marker_size))
-        return -1;
-    return 0;
-}
-
-typedef struct {
-    const char *match;
-    const char *format;
-    int start;
-    int stop;
-} rar_pattern_t;
-
-static const rar_pattern_t *FindVolumePattern(const char *location)
-{
-    static const rar_pattern_t patterns[] = {
-        { ".part1.rar",   "%s.part%.1d.rar", 2,   9 },
-        { ".part01.rar",  "%s.part%.2d.rar", 2,  99, },
-        { ".part001.rar", "%s.part%.3d.rar", 2, 999 },
-        { ".rar",         "%s.%c%.2d",       0, 999 },
-        { NULL, NULL, 0, 0 },
-    };
-
-    const size_t location_size = strlen(location);
-    for (int i = 0; patterns[i].match != NULL; i++) {
-        const size_t match_size = strlen(patterns[i].match);
-
-        if (location_size < match_size)
-            continue;
-        if (!strcmp(&location[location_size - match_size], patterns[i].match))
-            return &patterns[i];
-    }
-    return NULL;
-}
-
-int RarParse(struct stream *s, int *count, rar_file_t ***file)
-{
-    *count = 0;
-    *file = NULL;
-
-    const rar_pattern_t *pattern = FindVolumePattern(s->url);
-    int volume_offset = 0;
-
-    char *volume_mrl;
-    if (asprintf(&volume_mrl, "%s", s->url) < 0)
-        return -1;
-
-    struct stream *vol = s;
-    for (;;) {
-        /* Skip marker & archive */
-        if (IgnoreBlock(vol, RAR_BLOCK_MARKER) ||
-            IgnoreBlock(vol, RAR_BLOCK_ARCHIVE)) {
-            if (vol != s)
-                free_stream(vol);
-            free(volume_mrl);
-            return -1;
-        }
-
-        /* */
-        int has_next = -1;
-        for (;;) {
-            rar_block_t bk;
-            int ret;
-
-            if (PeekBlock(vol, &bk))
-                break;
-
-            switch(bk.type) {
-            case RAR_BLOCK_END:
-                ret = SkipEnd(vol, &bk);
-                has_next = ret && (bk.flags & RAR_BLOCK_END_HAS_NEXT);
-                break;
-            case RAR_BLOCK_FILE:
-                ret = SkipFile(vol, count, file, &bk, volume_mrl);
-                break;
-            default:
-                ret = SkipBlock(vol, &bk);
-                break;
-            }
-            if (ret)
-                break;
-        }
-        if (has_next < 0 && *count > 0 && !(*file)[*count -1]->is_complete)
-            has_next = 1;
-        if (vol != s)
-            free_stream(vol);
-
-        if (!has_next || !pattern)
-            goto done;
-
-        /* Open next volume */
-        const int volume_index = pattern->start + volume_offset++;
-        if (volume_index > pattern->stop)
-            goto done;
-
-        char *volume_base;
-        if (asprintf(&volume_base, "%.*s",
-                     (int)(strlen(s->url) - strlen(pattern->match)), s->url) < 0) {
-            goto done;
-        }
-
-        free(volume_mrl);
-        if (pattern->start) {
-            if (asprintf(&volume_mrl, pattern->format, volume_base, volume_index) < 0)
-                volume_mrl = NULL;
-        } else {
-            if (asprintf(&volume_mrl, pattern->format, volume_base,
-                         'r' + volume_index / 100, volume_index % 100) < 0)
-                volume_mrl = NULL;
-        }
-        free(volume_base);
-
-        if (!volume_mrl)
-            goto done;
-
-        vol = stream_create(volume_mrl, STREAM_READ, s->cancel, s->global);
-
-        if (!vol)
-            goto done;
-    }
-
-done:
-    free(volume_mrl);
-    if (*count == 0) {
-        talloc_free(*file);
-        return -1;
-    }
-    return 0;
-}
-
-int  RarSeek(rar_file_t *file, uint64_t position)
-{
-    if (position > file->real_size)
-        position = file->real_size;
-
-    /* Search the chunk */
-    const rar_file_chunk_t *old_chunk = file->current_chunk;
-    for (int i = 0; i < file->chunk_count; i++) {
-        file->current_chunk = file->chunk[i];
-        if (position < file->current_chunk->cummulated_size + file->current_chunk->size)
-            break;
-    }
-    file->i_pos = position;
-
-    const uint64_t offset = file->current_chunk->offset +
-                            (position - file->current_chunk->cummulated_size);
-
-    if (strcmp(old_chunk->mrl, file->current_chunk->mrl)) {
-        if (file->s)
-            free_stream(file->s);
-        file->s = stream_create(file->current_chunk->mrl, STREAM_READ,
-                                file->cancel, file->global);
-    }
-    return file->s ? stream_seek(file->s, offset) : 0;
-}
-
-ssize_t RarRead(rar_file_t *file, void *data, size_t size)
-{
-    size_t total = 0;
-    while (total < size) {
-        const uint64_t chunk_end = file->current_chunk->cummulated_size + file->current_chunk->size;
-        int max = MPMIN(MPMIN((int64_t)(size - total), (int64_t)(chunk_end - file->i_pos)), INT_MAX);
-        if (max <= 0)
-            break;
-
-        int r = stream_read(file->s, data, max);
-        if (r <= 0)
-            break;
-
-        total += r;
-        data = (char *)data + r;
-        file->i_pos += r;
-        if (file->i_pos >= chunk_end &&
-            RarSeek(file, file->i_pos))
-            break;
-    }
-    return total;
-
-}
diff -ruN mpv-0.29.1/stream/rar.h mpv-master/stream/rar.h
--- mpv-0.29.1/stream/rar.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/rar.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,61 +0,0 @@
-/*****************************************************************************
- * rar.h: uncompressed RAR parser
- *****************************************************************************
- * Copyright (C) 2008-2010 Laurent Aimar
- * $Id: 4dea45925c2d8f319d692475bc0307fdd9f6cfe7 $
- *
- * Author: Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2.1 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-#ifndef MP_RAR_H
-#define MP_RAR_H
-
-#include <inttypes.h>
-#include <sys/types.h>
-
-typedef struct {
-    char     *mrl;
-    uint64_t offset;
-    uint64_t size;
-    uint64_t cummulated_size;
-} rar_file_chunk_t;
-
-typedef struct {
-    char     *name;
-    uint64_t size;
-    bool     is_complete;
-
-    int              chunk_count;
-    rar_file_chunk_t **chunk;
-    uint64_t         real_size;  /* Gathered size */
-
-    // When actually reading the data
-    struct mpv_global *global;
-    struct mp_cancel *cancel;
-    uint64_t i_pos;
-    stream_t *s;
-    rar_file_chunk_t *current_chunk;
-} rar_file_t;
-
-int  RarProbe(struct stream *);
-void RarFileDelete(rar_file_t *);
-int  RarParse(struct stream *, int *, rar_file_t ***);
-
-int  RarSeek(rar_file_t *file, uint64_t position);
-ssize_t RarRead(rar_file_t *file, void *data, size_t size);
-
-#endif
diff -ruN mpv-0.29.1/stream/stream.c mpv-master/stream/stream.c
--- mpv-0.29.1/stream/stream.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream.c	2019-09-19 04:02:03.000000000 +0700
@@ -17,16 +17,12 @@
 
 #include <stdio.h>
 #include <stdlib.h>
-#include <sys/types.h>
-#include <unistd.h>
 #include <limits.h>
-#include <errno.h>
 
 #include <strings.h>
 #include <assert.h>
 
 #include <libavutil/common.h>
-#include "osdep/atomic.h"
 #include "osdep/io.h"
 
 #include "mpv_talloc.h"
@@ -36,6 +32,7 @@
 #include "common/common.h"
 #include "common/global.h"
 #include "misc/bstr.h"
+#include "misc/thread_tools.h"
 #include "common/msg.h"
 #include "options/options.h"
 #include "options/path.h"
@@ -45,18 +42,10 @@
 #include "options/m_option.h"
 #include "options/m_config.h"
 
-#ifdef __MINGW32__
-#include <windows.h>
-#else
-#include <poll.h>
-#endif
-
-// Includes additional padding in case sizes get rounded up by sector size.
-#define TOTAL_BUFFER_SIZE (STREAM_MAX_BUFFER_SIZE + STREAM_MAX_SECTOR_SIZE)
+#define TOTAL_BUFFER_SIZE STREAM_MAX_BUFFER_SIZE
 
 extern const stream_info_t stream_info_cdda;
 extern const stream_info_t stream_info_dvb;
-extern const stream_info_t stream_info_tv;
 extern const stream_info_t stream_info_smb;
 extern const stream_info_t stream_info_null;
 extern const stream_info_t stream_info_memory;
@@ -65,14 +54,11 @@
 extern const stream_info_t stream_info_ffmpeg_unsafe;
 extern const stream_info_t stream_info_avdevice;
 extern const stream_info_t stream_info_file;
-extern const stream_info_t stream_info_ifo;
 extern const stream_info_t stream_info_ifo_dvdnav;
-extern const stream_info_t stream_info_dvd;
 extern const stream_info_t stream_info_dvdnav;
 extern const stream_info_t stream_info_bdmv_dir;
 extern const stream_info_t stream_info_bluray;
 extern const stream_info_t stream_info_bdnav;
-extern const stream_info_t stream_info_rar;
 extern const stream_info_t stream_info_edl;
 extern const stream_info_t stream_info_libarchive;
 extern const stream_info_t stream_info_cb;
@@ -87,16 +73,9 @@
 #if HAVE_DVBIN
     &stream_info_dvb,
 #endif
-#if HAVE_TV
-    &stream_info_tv,
-#endif
 #if HAVE_LIBSMBCLIENT
     &stream_info_smb,
 #endif
-#if HAVE_DVDREAD || HAVE_DVDNAV
-    &stream_info_ifo,
-    &stream_info_dvd,
-#endif
 #if HAVE_DVDNAV
     &stream_info_ifo_dvdnav,
     &stream_info_dvdnav,
@@ -109,12 +88,10 @@
 #if HAVE_LIBARCHIVE
     &stream_info_libarchive,
 #endif
-
     &stream_info_memory,
     &stream_info_null,
     &stream_info_mf,
     &stream_info_edl,
-    &stream_info_rar,
     &stream_info_file,
     &stream_info_cb,
     NULL
@@ -238,7 +215,6 @@
     s->global = global;
     s->url = talloc_strdup(s, url);
     s->path = talloc_strdup(s, path);
-    s->allow_caching = true;
     s->is_network = sinfo->is_network;
     s->mode = flags & (STREAM_READ | STREAM_WRITE);
 
@@ -263,10 +239,7 @@
     }
 
     if (!s->read_chunk)
-        s->read_chunk = 4 * (s->sector_size ? s->sector_size : STREAM_BUFFER_SIZE);
-
-    if (!s->fill_buffer)
-        s->allow_caching = false;
+        s->read_chunk = 4 * STREAM_BUFFER_SIZE;
 
     assert(s->seekable == !!s->seek);
 
@@ -355,6 +328,7 @@
     // When reading succeeded we are obviously not at eof.
     s->eof = 0;
     s->pos += res;
+    s->total_unbuffered_read_bytes += res;
     return res;
 }
 
@@ -362,8 +336,6 @@
 {
     len = MPMIN(len, s->read_chunk);
     len = MPMAX(len, STREAM_BUFFER_SIZE);
-    if (s->sector_size)
-        len = s->sector_size;
     len = stream_read_unbuffered(s, s->buffer, len);
     s->buf_pos = 0;
     s->buf_len = len;
@@ -383,9 +355,9 @@
     assert(buf_size >= 0);
     if (s->buf_pos == s->buf_len && buf_size > 0) {
         s->buf_pos = s->buf_len = 0;
-        // Do a direct read, but only if there's no sector alignment requirement
+        // Do a direct read
         // Also, small reads will be more efficient with buffering & copying
-        if (!s->sector_size && buf_size >= STREAM_BUFFER_SIZE)
+        if (buf_size >= STREAM_BUFFER_SIZE)
             return stream_read_unbuffered(s, buf, buf_size);
         if (!stream_fill_buffer(s))
             return 0;
@@ -430,9 +402,8 @@
         // Fill rest of the buffer.
         while (buf_valid < len) {
             int chunk = MPMAX(len - buf_valid, STREAM_BUFFER_SIZE);
-            if (s->sector_size)
-                chunk = s->sector_size;
-            assert(buf_valid + chunk <= TOTAL_BUFFER_SIZE);
+            if (buf_valid + chunk > TOTAL_BUFFER_SIZE)
+                chunk = TOTAL_BUFFER_SIZE - buf_valid;
             int read = stream_read_unbuffered(s, &s->buffer[buf_valid], chunk);
             if (read == 0)
                 break; // EOF
@@ -449,15 +420,18 @@
 
 int stream_write_buffer(stream_t *s, unsigned char *buf, int len)
 {
-    int rd;
     if (!s->write_buffer)
         return -1;
-    rd = s->write_buffer(s, buf, len);
-    if (rd < 0)
-        return -1;
-    s->pos += rd;
-    assert(rd == len && "stream_write_buffer(): unexpected short write");
-    return rd;
+    int orig_len = len;
+    while (len) {
+        int w = s->write_buffer(s, buf, len);
+        if (w <= 0)
+            return -1;
+        s->pos += w;
+        buf += w;
+        len -= w;
+    }
+    return orig_len;
 }
 
 // Drop len bytes form input, possibly reading more until all is skipped. If
@@ -502,7 +476,8 @@
             return false;
         }
         if (s->seek(s, newpos) <= 0) {
-            MP_ERR(s, "Seek failed\n");
+            int level = mp_cancel_test(s->cancel) ? MSGL_V : MSGL_ERR;
+            MP_MSG(s, level, "Seek failed\n");
             return false;
         }
         stream_drop_buffers(s);
@@ -517,13 +492,14 @@
 
     s->eof = 0; // eof should be set only on read; seeking always clears it
 
-    if (pos == stream_tell(s))
-        return true;
-
     if (pos < 0) {
         MP_ERR(s, "Invalid seek to negative position %lld!\n", (long long)pos);
         pos = 0;
     }
+
+    if (pos == stream_tell(s))
+        return true;
+
     if (pos < s->pos) {
         int64_t x = pos - (s->pos - (int)s->buf_len);
         if (x >= 0) {
@@ -537,8 +513,6 @@
         return s->seekable && s->seek(s, pos);
 
     int64_t newpos = pos;
-    if (s->sector_size)
-        newpos = (pos / s->sector_size) * s->sector_size;
 
     MP_TRACE(s, "Seek from %" PRId64 " to %" PRId64
              " (with offset %d)\n", s->pos, pos, (int)(pos - newpos));
@@ -590,7 +564,6 @@
 
     if (s->close)
         s->close(s);
-    free_stream(s->underlying);
     talloc_free(s);
 }
 
@@ -606,98 +579,6 @@
     return s;
 }
 
-static stream_t *open_cache(stream_t *orig, const char *name)
-{
-    stream_t *cache = new_stream();
-    cache->underlying = orig;
-    cache->caching = true;
-    cache->seekable = true;
-    cache->mode = STREAM_READ;
-    cache->read_chunk = 4 * STREAM_BUFFER_SIZE;
-
-    cache->url = talloc_strdup(cache, orig->url);
-    cache->mime_type = talloc_strdup(cache, orig->mime_type);
-    cache->demuxer = talloc_strdup(cache, orig->demuxer);
-    cache->lavf_type = talloc_strdup(cache, orig->lavf_type);
-    cache->streaming = orig->streaming,
-    cache->is_network = orig->is_network;
-    cache->is_local_file = orig->is_local_file;
-    cache->is_directory = orig->is_directory;
-    cache->cancel = orig->cancel;
-    cache->global = orig->global;
-
-    cache->log = mp_log_new(cache, cache->global->log, name);
-
-    return cache;
-}
-
-static struct mp_cache_opts check_cache_opts(stream_t *stream,
-                                             struct mp_cache_opts *opts)
-{
-    struct mp_cache_opts use_opts = *opts;
-    if (use_opts.size == -1)
-        use_opts.size = stream->streaming ? use_opts.def_size : 0;
-    if (use_opts.size == -2)
-        use_opts.size = use_opts.def_size;
-
-    if (stream->mode != STREAM_READ || !stream->allow_caching || use_opts.size < 1)
-        use_opts.size = 0;
-    return use_opts;
-}
-
-bool stream_wants_cache(stream_t *stream, struct mp_cache_opts *opts)
-{
-    struct mp_cache_opts use_opts = check_cache_opts(stream, opts);
-    return use_opts.size > 0;
-}
-
-// return 1 on success, 0 if the cache is disabled/not needed, and -1 on error
-// or if the cache is disabled
-static int stream_enable_cache(stream_t **stream, struct mp_cache_opts *opts)
-{
-    stream_t *orig = *stream;
-    struct mp_cache_opts use_opts = check_cache_opts(*stream, opts);
-
-    if (use_opts.size < 1)
-        return 0;
-
-    stream_t *fcache = open_cache(orig, "file-cache");
-    if (stream_file_cache_init(fcache, orig, &use_opts) <= 0) {
-        fcache->underlying = NULL; // don't free original stream
-        free_stream(fcache);
-        fcache = orig;
-    }
-
-    stream_t *cache = open_cache(fcache, "cache");
-
-    int res = stream_cache_init(cache, fcache, &use_opts);
-    if (res <= 0) {
-        cache->underlying = NULL; // don't free original stream
-        free_stream(cache);
-        if (fcache != orig) {
-            fcache->underlying = NULL;
-            free_stream(fcache);
-        }
-    } else {
-        *stream = cache;
-    }
-    return res;
-}
-
-// Do some crazy stuff to call stream_enable_cache() with the global options.
-int stream_enable_cache_defaults(stream_t **stream)
-{
-    struct mpv_global *global = (*stream)->global;
-    if (!global)
-        return 0;
-    void *tmp = talloc_new(NULL);
-    struct mp_cache_opts *opts =
-        mp_get_config_group(tmp, global, &stream_cache_conf);
-    int r = stream_enable_cache(stream, opts);
-    talloc_free(tmp);
-    return r;
-}
-
 static uint16_t stream_read_word_endian(stream_t *s, bool big_endian)
 {
     unsigned int y = stream_read_char(s);
@@ -842,131 +723,6 @@
     return res;
 }
 
-#ifndef __MINGW32__
-struct mp_cancel {
-    atomic_bool triggered;
-    int wakeup_pipe[2];
-};
-
-static void cancel_destroy(void *p)
-{
-    struct mp_cancel *c = p;
-    if (c->wakeup_pipe[0] >= 0) {
-        close(c->wakeup_pipe[0]);
-        close(c->wakeup_pipe[1]);
-    }
-}
-
-struct mp_cancel *mp_cancel_new(void *talloc_ctx)
-{
-    struct mp_cancel *c = talloc_ptrtype(talloc_ctx, c);
-    talloc_set_destructor(c, cancel_destroy);
-    *c = (struct mp_cancel){.triggered = ATOMIC_VAR_INIT(false)};
-    mp_make_wakeup_pipe(c->wakeup_pipe);
-    return c;
-}
-
-// Request abort.
-void mp_cancel_trigger(struct mp_cancel *c)
-{
-    atomic_store(&c->triggered, true);
-    (void)write(c->wakeup_pipe[1], &(char){0}, 1);
-}
-
-// Restore original state. (Allows reusing a mp_cancel.)
-void mp_cancel_reset(struct mp_cancel *c)
-{
-    atomic_store(&c->triggered, false);
-    // Flush it fully.
-    while (1) {
-        int r = read(c->wakeup_pipe[0], &(char[256]){0}, 256);
-        if (r < 0 && errno == EINTR)
-            continue;
-        if (r <= 0)
-            break;
-    }
-}
-
-// Return whether the caller should abort.
-// For convenience, c==NULL is allowed.
-bool mp_cancel_test(struct mp_cancel *c)
-{
-    return c ? atomic_load_explicit(&c->triggered, memory_order_relaxed) : false;
-}
-
-// Wait until the even is signaled. If the timeout (in seconds) expires, return
-// false. timeout==0 polls, timeout<0 waits forever.
-bool mp_cancel_wait(struct mp_cancel *c, double timeout)
-{
-    struct pollfd fd = { .fd = c->wakeup_pipe[0], .events = POLLIN };
-    poll(&fd, 1, timeout * 1000);
-    return fd.revents & POLLIN;
-}
-
-// The FD becomes readable if mp_cancel_test() would return true.
-// Don't actually read from it, just use it for poll().
-int mp_cancel_get_fd(struct mp_cancel *c)
-{
-    return c->wakeup_pipe[0];
-}
-
-#else
-
-struct mp_cancel {
-    atomic_bool triggered;
-    HANDLE event;
-};
-
-static void cancel_destroy(void *p)
-{
-    struct mp_cancel *c = p;
-    CloseHandle(c->event);
-}
-
-struct mp_cancel *mp_cancel_new(void *talloc_ctx)
-{
-    struct mp_cancel *c = talloc_ptrtype(talloc_ctx, c);
-    talloc_set_destructor(c, cancel_destroy);
-    *c = (struct mp_cancel){.triggered = ATOMIC_VAR_INIT(false)};
-    c->event = CreateEventW(NULL, TRUE, FALSE, NULL);
-    return c;
-}
-
-void mp_cancel_trigger(struct mp_cancel *c)
-{
-    atomic_store(&c->triggered, true);
-    SetEvent(c->event);
-}
-
-void mp_cancel_reset(struct mp_cancel *c)
-{
-    atomic_store(&c->triggered, false);
-    ResetEvent(c->event);
-}
-
-bool mp_cancel_test(struct mp_cancel *c)
-{
-    return c ? atomic_load_explicit(&c->triggered, memory_order_relaxed) : false;
-}
-
-bool mp_cancel_wait(struct mp_cancel *c, double timeout)
-{
-    return WaitForSingleObject(c->event, timeout < 0 ? INFINITE : timeout * 1000)
-            == WAIT_OBJECT_0;
-}
-
-void *mp_cancel_get_event(struct mp_cancel *c)
-{
-    return c->event;
-}
-
-int mp_cancel_get_fd(struct mp_cancel *c)
-{
-    return -1;
-}
-
-#endif
-
 char **stream_get_proto_list(void)
 {
     char **list = NULL;
diff -ruN mpv-0.29.1/stream/stream.h mpv-master/stream/stream.h
--- mpv-0.29.1/stream/stream.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream.h	2019-09-19 04:02:03.000000000 +0700
@@ -29,7 +29,6 @@
 #include "misc/bstr.h"
 
 #define STREAM_BUFFER_SIZE 2048
-#define STREAM_MAX_SECTOR_SIZE (8 * 1024)
 
 // Max buffer for initial probe.
 #define STREAM_MAX_BUFFER_SIZE (2 * 1024 * 1024)
@@ -52,15 +51,10 @@
 enum stream_ctrl {
     STREAM_CTRL_GET_SIZE = 1,
 
-    // Cache
-    STREAM_CTRL_GET_CACHE_INFO,
-    STREAM_CTRL_SET_CACHE_SIZE,
-    STREAM_CTRL_SET_READAHEAD,
-
     // stream_memory.c
     STREAM_CTRL_SET_CONTENTS,
 
-    // stream_rar.c
+    // stream_libarchive.c
     STREAM_CTRL_GET_BASE_FILENAME,
 
     // Certain network protocols
@@ -68,67 +62,11 @@
     STREAM_CTRL_HAS_AVSEEK,
     STREAM_CTRL_GET_METADATA,
 
-    // TV
-    STREAM_CTRL_TV_SET_SCAN,
-    STREAM_CTRL_SET_TV_FREQ,
-    STREAM_CTRL_GET_TV_FREQ,
-    STREAM_CTRL_SET_TV_COLORS,
-    STREAM_CTRL_GET_TV_COLORS,
-    STREAM_CTRL_TV_SET_NORM,
-    STREAM_CTRL_TV_STEP_NORM,
-    STREAM_CTRL_TV_SET_CHAN,
-    STREAM_CTRL_TV_GET_CHAN,
-    STREAM_CTRL_TV_STEP_CHAN,
-    STREAM_CTRL_TV_LAST_CHAN,
-    STREAM_CTRL_DVB_SET_CHANNEL,
-    STREAM_CTRL_DVB_SET_CHANNEL_NAME,
-    STREAM_CTRL_DVB_GET_CHANNEL_NAME,
-    STREAM_CTRL_DVB_STEP_CHANNEL,
-
-    // Optical discs
-    STREAM_CTRL_GET_TIME_LENGTH,
-    STREAM_CTRL_GET_DVD_INFO,
-    STREAM_CTRL_GET_DISC_NAME,
-    STREAM_CTRL_GET_NUM_CHAPTERS,
-    STREAM_CTRL_GET_CURRENT_TIME,
-    STREAM_CTRL_GET_CHAPTER_TIME,
-    STREAM_CTRL_SEEK_TO_TIME,
-    STREAM_CTRL_GET_ASPECT_RATIO,
-    STREAM_CTRL_GET_NUM_ANGLES,
-    STREAM_CTRL_GET_ANGLE,
-    STREAM_CTRL_SET_ANGLE,
-    STREAM_CTRL_GET_NUM_TITLES,
-    STREAM_CTRL_GET_TITLE_LENGTH,       // double* (in: title number, out: len)
-    STREAM_CTRL_GET_LANG,
-    STREAM_CTRL_GET_CURRENT_TITLE,
-    STREAM_CTRL_SET_CURRENT_TITLE,
-};
-
-// for STREAM_CTRL_GET_CACHE_INFO
-struct stream_cache_info {
-    int64_t size;
-    int64_t fill;
-    bool idle;
-    int64_t speed;
-};
-
-struct stream_lang_req {
-    int type;     // STREAM_AUDIO, STREAM_SUB
-    int id;
-    char name[50];
+    // Garbage compatibility for obnoxious users
+    STREAM_CTRL_OPTICAL_CRAP_HACK1,
+    STREAM_CTRL_OPTICAL_CRAP_HACK2,
 };
 
-struct stream_dvd_info_req {
-    unsigned int palette[16];
-    int num_subs;
-};
-
-// for STREAM_CTRL_SET_TV_COLORS
-#define TV_COLOR_BRIGHTNESS     1
-#define TV_COLOR_HUE            2
-#define TV_COLOR_SATURATION     3
-#define TV_COLOR_CONTRAST       4
-
 // for STREAM_CTRL_AVSEEK
 struct stream_avseek {
     int stream_index;
@@ -157,13 +95,10 @@
     // Seek
     int (*seek)(struct stream *s, int64_t pos);
     // Control
-    // Will be later used to let streams like dvd and cdda report
-    // their structure (ie tracks, chapters, etc)
     int (*control)(struct stream *s, int cmd, void *arg);
     // Close
     void (*close)(struct stream *s);
 
-    int sector_size; // sector size (seek will be aligned on this size if non 0)
     int read_chunk; // maximum amount of data to read at once to limit latency
     unsigned int buf_pos, buf_len;
     int64_t pos;
@@ -179,8 +114,6 @@
     bool seekable : 1; // presence of general byte seeking support
     bool fast_skip : 1; // consider stream fast enough to fw-seek by skipping
     bool is_network : 1; // original stream_info_t.is_network flag
-    bool allow_caching : 1; // stream cache makes sense
-    bool caching : 1; // is a cache, or accesses a cache
     bool is_local_file : 1; // from the filesystem
     bool is_directory : 1; // directory on the filesystem
     bool access_references : 1; // open other streams
@@ -189,7 +122,9 @@
 
     struct mp_cancel *cancel;   // cancellation notification
 
-    struct stream *underlying;  // e.g. cache wrapper
+    // Read statistic for fill_buffer calls. All bytes read by fill_buffer() are
+    // added to this. The user can reset this as needed.
+    uint64_t total_unbuffered_read_bytes;
 
     // Includes additional padding in case sizes get rounded up by sector size.
     unsigned char buffer[];
@@ -197,16 +132,6 @@
 
 int stream_fill_buffer(stream_t *s);
 
-struct mp_cache_opts;
-bool stream_wants_cache(stream_t *stream, struct mp_cache_opts *opts);
-int stream_enable_cache_defaults(stream_t **stream);
-
-// Internal
-int stream_cache_init(stream_t *cache, stream_t *stream,
-                      struct mp_cache_opts *opts);
-int stream_file_cache_init(stream_t *cache, stream_t *stream,
-                           struct mp_cache_opts *opts);
-
 int stream_write_buffer(stream_t *s, unsigned char *buf, int len);
 
 inline static int stream_read_char(stream_t *s)
@@ -254,14 +179,6 @@
 void mp_url_unescape_inplace(char *buf);
 char *mp_url_escape(void *talloc_ctx, const char *s, const char *ok);
 
-struct mp_cancel *mp_cancel_new(void *talloc_ctx);
-void mp_cancel_trigger(struct mp_cancel *c);
-bool mp_cancel_test(struct mp_cancel *c);
-bool mp_cancel_wait(struct mp_cancel *c, double timeout);
-void mp_cancel_reset(struct mp_cancel *c);
-void *mp_cancel_get_event(struct mp_cancel *c); // win32 HANDLE
-int mp_cancel_get_fd(struct mp_cancel *c);
-
 // stream_file.c
 char *mp_file_url_to_filename(void *talloc_ctx, bstr url);
 char *mp_file_get_path(void *talloc_ctx, bstr url);
diff -ruN mpv-0.29.1/stream/stream_avdevice.c mpv-master/stream/stream_avdevice.c
--- mpv-0.29.1/stream/stream_avdevice.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_avdevice.c	2019-09-19 04:02:03.000000000 +0700
@@ -22,7 +22,6 @@
 static int open_f(stream_t *stream)
 {
     stream->demuxer = "lavf";
-    stream->allow_caching = false;
 
     return STREAM_OK;
 }
diff -ruN mpv-0.29.1/stream/stream_bluray.c mpv-master/stream/stream_bluray.c
--- mpv-0.29.1/stream/stream_bluray.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_bluray.c	2019-09-19 04:02:03.000000000 +0700
@@ -175,119 +175,19 @@
     struct bluray_priv_s *b = s->priv;
 
     switch (cmd) {
-    case STREAM_CTRL_GET_NUM_CHAPTERS: {
-        const BLURAY_TITLE_INFO *ti = b->title_info;
-        if (!ti)
-            return STREAM_UNSUPPORTED;
-        *((unsigned int *) arg) = ti->chapter_count;
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_GET_CHAPTER_TIME: {
-        const BLURAY_TITLE_INFO *ti = b->title_info;
-        if (!ti)
-            return STREAM_UNSUPPORTED;
-        int chapter = *(double *)arg;
-        double time = MP_NOPTS_VALUE;
-        if (chapter >= 0 || chapter < ti->chapter_count)
-            time = BD_TIME_TO_MP(ti->chapters[chapter].start);
-        if (time == MP_NOPTS_VALUE)
-            return STREAM_ERROR;
-        *(double *)arg = time;
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_SET_CURRENT_TITLE: {
-        const uint32_t title = *((unsigned int*)arg);
-        if (title >= b->num_titles || !play_title(b, title))
-            return STREAM_UNSUPPORTED;
-        b->current_title = title;
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_GET_CURRENT_TITLE: {
-        *((unsigned int *) arg) = b->current_title;
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_GET_NUM_TITLES: {
-        *((unsigned int *)arg) = b->num_titles;
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_GET_TIME_LENGTH: {
+    case STREAM_CTRL_OPTICAL_CRAP_HACK1: {
         const BLURAY_TITLE_INFO *ti = b->title_info;
         if (!ti)
             return STREAM_UNSUPPORTED;
         *((double *) arg) = BD_TIME_TO_MP(ti->duration);
         return STREAM_OK;
     }
-    case STREAM_CTRL_GET_CURRENT_TIME: {
-        *((double *) arg) = BD_TIME_TO_MP(bd_tell_time(b->bd));
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_SEEK_TO_TIME: {
+    case STREAM_CTRL_OPTICAL_CRAP_HACK2: {
         double pts = *((double *) arg);
         bd_seek_time(b->bd, BD_TIME_FROM_MP(pts));
         stream_drop_buffers(s);
-        // API makes it hard to determine seeking success
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_GET_NUM_ANGLES: {
-        const BLURAY_TITLE_INFO *ti = b->title_info;
-        if (!ti)
-            return STREAM_UNSUPPORTED;
-        *((int *) arg) = ti->angle_count;
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_GET_ANGLE: {
-        *((int *) arg) = b->current_angle;
         return STREAM_OK;
     }
-    case STREAM_CTRL_SET_ANGLE: {
-        const BLURAY_TITLE_INFO *ti = b->title_info;
-        if (!ti)
-            return STREAM_UNSUPPORTED;
-        int angle = *((int *) arg);
-        if (angle < 0 || angle > ti->angle_count)
-            return STREAM_UNSUPPORTED;
-        b->current_angle = angle;
-        bd_seamless_angle_change(b->bd, angle);
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_GET_LANG: {
-        const BLURAY_TITLE_INFO *ti = b->title_info;
-        if (ti && ti->clip_count) {
-            struct stream_lang_req *req = arg;
-            BLURAY_STREAM_INFO *si = NULL;
-            int count = 0;
-            switch (req->type) {
-            case STREAM_AUDIO:
-                count = ti->clips[0].audio_stream_count;
-                si = ti->clips[0].audio_streams;
-                break;
-            case STREAM_SUB:
-                count = ti->clips[0].pg_stream_count;
-                si = ti->clips[0].pg_streams;
-                break;
-            }
-            for (int n = 0; n < count; n++) {
-                BLURAY_STREAM_INFO *i = &si[n];
-                if (i->pid == req->id) {
-                    snprintf(req->name, sizeof(req->name), "%.4s", i->lang);
-                    return STREAM_OK;
-                }
-            }
-        }
-        return STREAM_ERROR;
-    }
-    case STREAM_CTRL_GET_DISC_NAME: {
-        const struct meta_dl *meta = bd_get_meta(b->bd);
-        if (!meta || !meta->di_name || !meta->di_name[0])
-            break;
-        *(char**)arg = talloc_strdup(NULL, meta->di_name);
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_GET_SIZE:
-        *(int64_t *)arg = bd_get_title_size(b->bd);
-        return STREAM_OK;
-    default:
-        break;
     }
 
     return STREAM_UNSUPPORTED;
@@ -454,9 +354,7 @@
     s->fill_buffer = bluray_stream_fill_buffer;
     s->close       = bluray_stream_close;
     s->control     = bluray_stream_control;
-    s->sector_size = BLURAY_SECTOR_SIZE;
     s->priv        = b;
-    s->demuxer     = "+disc";
 
     MP_VERBOSE(s, "Blu-ray successfully opened.\n");
 
diff -ruN mpv-0.29.1/stream/stream_cdda.c mpv-master/stream/stream_cdda.c
--- mpv-0.29.1/stream/stream_cdda.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_cdda.c	2019-09-19 04:02:03.000000000 +0700
@@ -226,42 +226,10 @@
     cdda_close(p->cd);
 }
 
-static int get_track_by_sector(cdda_priv *p, unsigned int sector)
-{
-    int i;
-    for (i = p->cd->tracks; i >= 0; --i)
-        if (p->cd->disc_toc[i].dwStartSector <= sector)
-            break;
-    return i;
-}
-
 static int control(stream_t *stream, int cmd, void *arg)
 {
     cdda_priv *p = stream->priv;
     switch (cmd) {
-    case STREAM_CTRL_GET_NUM_CHAPTERS:
-    {
-        int start_track = get_track_by_sector(p, p->start_sector);
-        int end_track = get_track_by_sector(p, p->end_sector);
-        if (start_track == -1 || end_track == -1)
-            return STREAM_ERROR;
-        *(unsigned int *)arg = end_track + 1 - start_track;
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_GET_CHAPTER_TIME:
-    {
-        int track = *(double *)arg;
-        int start_track = get_track_by_sector(p, p->start_sector);
-        int end_track = get_track_by_sector(p, p->end_sector);
-        track += start_track;
-        if (track > end_track)
-            return STREAM_ERROR;
-        int64_t sector = p->cd->disc_toc[track].dwStartSector;
-        int64_t pos = sector * CDIO_CD_FRAMESIZE_RAW;
-        // Assume standard audio CD: 44.1khz, 2 channels, s16 samples
-        *(double *)arg = pos / (44100.0 * 2 * 2);
-        return STREAM_OK;
-    }
     case STREAM_CTRL_GET_SIZE:
         *(int64_t *)arg =
             (p->end_sector + 1 - p->start_sector) * CDIO_CD_FRAMESIZE_RAW;
@@ -378,7 +346,6 @@
     priv->sector = priv->start_sector;
 
     st->priv = priv;
-    st->sector_size = CDIO_CD_FRAMESIZE_RAW;
 
     st->fill_buffer = fill_buffer;
     st->seek = seek;
diff -ruN mpv-0.29.1/stream/stream_dvb.c mpv-master/stream/stream_dvb.c
--- mpv-0.29.1/stream/stream_dvb.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_dvb.c	2019-09-19 04:02:03.000000000 +0700
@@ -73,7 +73,7 @@
 const struct m_sub_options stream_dvb_conf = {
     .opts = (const m_option_t[]) {
         OPT_STRING("prog", cfg_prog, 0),
-        OPT_INTRANGE("card", cfg_devno, 0, 1, 4),
+        OPT_INTRANGE("card", cfg_devno, 0, 0, MAX_ADAPTERS-1),
         OPT_INTRANGE("timeout", cfg_timeout, 0, 1, 30),
         OPT_STRING("file", cfg_file, M_OPT_FILE),
         OPT_FLAG("full-transponder", cfg_full_transponder, 0),
@@ -356,9 +356,14 @@
             mod[0] = '\0';
             // It's a VDR-style config line.
             parse_vdr_par_string(vdr_par_str, ptr);
-            // Units in VDR-style config files are divided by 1000.
-            ptr->freq *=  1000UL;
-            ptr->srate *=  1000UL;
+            // Frequency in VDR-style config files is in MHz for DVB-S,
+            // and may be in MHz, kHz or Hz for DVB-C and DVB-T.
+            // General rule to get useful units is to multiply by 1000 until value is larger than 1000000.
+            while (ptr->freq < 1000000UL) {
+                ptr->freq *= 1000UL;
+            }
+            // Symbol rate in VDR-style config files is divided by 1000.
+            ptr->srate *= 1000UL;
             switch (delsys) {
             case SYS_DVBT:
             case SYS_DVBT2:
@@ -742,7 +747,7 @@
             tries --;
             pfds[0].fd = fd;
             pfds[0].events = POLLIN | POLLPRI;
-            if (poll(pfds, 1, 500) <= 0) {
+            if (poll(pfds, 1, 2000) <= 0) {
                 MP_ERR(stream, "dvb_streaming_read, failed with "
                         "errno %d when reading %d bytes\n", errno, size - pos);
                 errno = 0;
@@ -896,6 +901,7 @@
     dvb_channels_list_t *list = NULL;
 
 
+#if 0
     switch (cmd) {
     case STREAM_CTRL_DVB_SET_CHANNEL: {
         unsigned int *iarg = arg;
@@ -921,13 +927,14 @@
         return STREAM_ERROR;
     }
     }
-
+#endif
 
     if (state->cur_adapter >= state->adapters_count)
         return STREAM_ERROR;
     list = state->adapters[state->cur_adapter].list;
 
     switch (cmd) {
+#if 0
     case STREAM_CTRL_GET_TV_FREQ:
         (*(unsigned int*)arg) = list->channels[list->current].freq;
         return STREAM_ERROR;
@@ -961,6 +968,7 @@
         *(char **)arg = talloc_strdup(NULL, progname);
         return STREAM_OK;
     }
+#endif
     case STREAM_CTRL_GET_METADATA: {
         struct mp_tags *metadata = talloc_zero(NULL, struct mp_tags);
         char *progname = list->channels[list->current].name;
@@ -1117,7 +1125,6 @@
     stream->close = dvbin_close;
     stream->control = dvbin_stream_control;
     stream->streaming = true;
-    stream->allow_caching = true;
     stream->demuxer = "lavf";
     stream->lavf_type = "mpegts";
 
@@ -1157,7 +1164,7 @@
     if (devno.len) {
         bstr r;
         priv->cfg_devno = bstrtoll(devno, &r, 0);
-        if (r.len || priv->cfg_devno < 0 || priv->cfg_devno > MAX_ADAPTERS) {
+        if (r.len || priv->cfg_devno < 0 || priv->cfg_devno >= MAX_ADAPTERS) {
             MP_ERR(stream, "invalid devno: '%.*s'\n", BSTR_P(devno));
             return NULL;
         }
diff -ruN mpv-0.29.1/stream/stream_dvd.c mpv-master/stream/stream_dvd.c
--- mpv-0.29.1/stream/stream_dvd.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_dvd.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,993 +0,0 @@
-/*
- * Original author: Benjamin Zores
- *
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <string.h>
-#include <strings.h>
-#include <libgen.h>
-#include <errno.h>
-#include <stdint.h>
-
-#include <dvdread/dvd_reader.h>
-#include <dvdread/ifo_types.h>
-#include <dvdread/ifo_read.h>
-#include <dvdread/nav_read.h>
-
-#include "osdep/io.h"
-
-#include "config.h"
-#include "mpv_talloc.h"
-#include "common/common.h"
-#include "common/msg.h"
-
-#define FIRST_AC3_AID 128
-#define FIRST_DTS_AID 136
-#define FIRST_MPG_AID 0
-#define FIRST_PCM_AID 160
-
-#include "stream.h"
-#include "options/m_config.h"
-#include "options/options.h"
-#include "options/path.h"
-
-#include "stream_dvd_common.h"
-
-#define LIBDVDREAD_VERSION(maj,min,micro)       ((maj)*10000 + (min)*100 + (micro))
-/*
- * Try to autodetect the libdvd-0.9.0 library
- * (0.9.0 removed the <dvdread/dvd_udf.h> header, and moved the two defines
- * DVD_VIDEO_LB_LEN and MAX_UDF_FILE_NAME_LEN from it to
- * <dvdread/dvd_reader.h>)
- */
-#ifndef DVDREAD_VERSION
-#if defined(DVD_VIDEO_LB_LEN) && defined(MAX_UDF_FILE_NAME_LEN)
-#define DVDREAD_VERSION LIBDVDREAD_VERSION(0,9,0)
-#else
-#define DVDREAD_VERSION LIBDVDREAD_VERSION(0,8,0)
-#endif
-#endif
-
-typedef struct {
-    int id; // 0 - 31 mpeg; 128 - 159 ac3; 160 - 191 pcm
-    int language;
-    int type;
-    int channels;
-} stream_language_t;
-
-typedef struct {
-  dvd_reader_t *dvd;
-  dvd_file_t *title;
-  ifo_handle_t *vmg_file;
-  tt_srpt_t *tt_srpt;
-  ifo_handle_t *vts_file;
-  vts_ptt_srpt_t *vts_ptt_srpt;
-  pgc_t *cur_pgc;
-//
-  int cur_title;
-  int cur_cell;
-  int last_cell;
-  int cur_pack;
-  int cell_last_pack;
-  int cur_pgc_idx;
-// Navi:
-  int packs_left;
-  dsi_t dsi_pack;
-  int angle_seek;
-  unsigned int *cell_times_table;
-// audio datas
-  int nr_of_channels;
-  stream_language_t audio_streams[32];
-// subtitles
-  int nr_of_subtitles;
-  stream_language_t subtitles[32];
-
-  int dvd_angle;
-  char *dvd_device_current;
-  int dvd_speed;
-  int dvd_title;
-
-  int cfg_title;
-  char *cfg_device;
-} dvd_priv_t;
-
-static int dvd_lang_from_aid(stream_t *stream, int id) {
-  dvd_priv_t *d;
-  int i;
-  if (!stream) return 0;
-  d = stream->priv;
-  if (!d) return 0;
-  for(i=0;i<d->nr_of_channels;i++) {
-    if(d->audio_streams[i].id==id)
-      return d->audio_streams[i].language;
-  }
-  return 0;
-}
-
-static int dvd_number_of_subs(stream_t *stream) {
-  int i;
-  int maxid = -1;
-  dvd_priv_t *d;
-  if (!stream) return -1;
-  d = stream->priv;
-  if (!d) return -1;
-  for (i = 0; i < d->nr_of_subtitles; i++)
-    if (d->subtitles[i].id > maxid) maxid = d->subtitles[i].id;
-  return maxid + 1;
-}
-
-static int dvd_lang_from_sid(stream_t *stream, int id) {
-  int i;
-  dvd_priv_t *d;
-  if (!stream) return 0;
-  d = stream->priv;
-  if (!d) return 0;
-  for (i = 0; i < d->nr_of_subtitles; i++)
-    if (d->subtitles[i].id == id && d->subtitles[i].language) return d->subtitles[i].language;
-  return 0;
-}
-
-static int dvd_next_cell(stream_t *stream, dvd_priv_t *d) {
-  int next_cell=d->cur_cell;
-
-  MP_DBG(stream, "dvd_next_cell: next1=0x%X  \n",next_cell);
-  if( d->cur_pgc->cell_playback[ next_cell ].block_type == BLOCK_TYPE_ANGLE_BLOCK ) {
-    while(next_cell<d->last_cell) {
-      if( d->cur_pgc->cell_playback[next_cell].block_mode == BLOCK_MODE_LAST_CELL )
-        break;
-      ++next_cell;
-    }
-  }
-  MP_DBG(stream, "dvd_next_cell: next2=0x%X  \n",next_cell);
-
-  ++next_cell;
-  if(next_cell>=d->last_cell)
-    return -1; // EOF
-  if(d->cur_pgc->cell_playback[next_cell].block_type == BLOCK_TYPE_ANGLE_BLOCK ) {
-    next_cell+=d->dvd_angle-1;
-    if(next_cell>=d->last_cell)
-      return -1; // EOF
-  }
-  MP_DBG(stream, "dvd_next_cell: next3=0x%X  \n",next_cell);
-  return next_cell;
-}
-
-static int dvd_read_sector(stream_t *stream, dvd_priv_t *d, unsigned char *data)
-{
-  int len;
-
-  if(d->packs_left==0) {
-    /**
-     * If we're not at the end of this cell, we can determine the next
-     * VOBU to display using the VOBU_SRI information section of the
-     * DSI.  Using this value correctly follows the current angle,
-     * avoiding the doubled scenes in The Matrix, and makes our life
-     * really happy.
-     *
-     * Otherwise, we set our next address past the end of this cell to
-     * force the code above to go to the next cell in the program.
-     */
-    if(d->dsi_pack.vobu_sri.next_vobu != SRI_END_OF_CELL) {
-       d->cur_pack= d->dsi_pack.dsi_gi.nv_pck_lbn + ( d->dsi_pack.vobu_sri.next_vobu & 0x7fffffff );
-       MP_DBG(stream, "Navi  new pos=0x%X  \n",d->cur_pack);
-    } else {
-      // end of cell! find next cell!
-      MP_VERBOSE(stream, "--- END OF CELL !!! ---\n");
-      d->cur_pack=d->cell_last_pack+1;
-    }
-  }
-
-read_next:
-  if(d->cur_pack>d->cell_last_pack) {
-    // end of cell!
-    int next=dvd_next_cell(stream, d);
-    if(next>=0) {
-      d->cur_cell=next;
-      // if( d->cur_pgc->cell_playback[d->cur_cell].block_type
-      // == BLOCK_TYPE_ANGLE_BLOCK ) d->cur_cell+=dvd_angle-1;
-      d->cur_pack = d->cur_pgc->cell_playback[ d->cur_cell ].first_sector;
-      d->cell_last_pack=d->cur_pgc->cell_playback[ d->cur_cell ].last_sector;
-      MP_VERBOSE(stream, "DVD next cell: %d  pack: 0x%X-0x%X  \n",d->cur_cell,d->cur_pack,d->cell_last_pack);
-    } else
-        return -1; // EOF
-  }
-
-  len = DVDReadBlocks(d->title, d->cur_pack, 1, data);
-  // only == 0 should indicate an error, but some dvdread version are buggy when used with dvdcss
-  if(len <= 0) return -1; //error
-
-  if(data[38]==0 && data[39]==0 && data[40]==1 && data[41]==0xBF &&
-    data[1024]==0 && data[1025]==0 && data[1026]==1 && data[1027]==0xBF) {
-       // found a Navi packet!!!
-#if DVDREAD_VERSION >= LIBDVDREAD_VERSION(0,9,0)
-    navRead_DSI(&d->dsi_pack, &(data[ DSI_START_BYTE ]));
-#else
-    navRead_DSI(&d->dsi_pack, &(data[ DSI_START_BYTE ]), sizeof(dsi_t));
-#endif
-    if(d->cur_pack != d->dsi_pack.dsi_gi.nv_pck_lbn ) {
-      MP_VERBOSE(stream, "Invalid NAVI packet! lba=0x%X  navi=0x%X  \n",
-        d->cur_pack,d->dsi_pack.dsi_gi.nv_pck_lbn);
-    } else {
-      // process!
-      d->packs_left = d->dsi_pack.dsi_gi.vobu_ea;
-      MP_DBG(stream, "Found NAVI packet! lba=0x%X  len=%d  \n",d->cur_pack,d->packs_left);
-      //navPrint_DSI(&d->dsi_pack);
-      MP_TRACE(stream, "\r### CELL %d: Navi: %d/%d  IFO: %d/%d   \n",d->cur_cell,
-        d->dsi_pack.dsi_gi.vobu_c_idn,d->dsi_pack.dsi_gi.vobu_vob_idn,
-        d->cur_pgc->cell_position[d->cur_cell].cell_nr,
-        d->cur_pgc->cell_position[d->cur_cell].vob_id_nr);
-
-      if(d->angle_seek) {
-        int i,skip=0;
-        for(i=0;i<9;i++)        // check if all values zero:
-          if((skip=d->dsi_pack.sml_agli.data[i].address)!=0) break;
-        if(skip && skip!=0x7fffffff) {
-          // sml_agli table has valid data (at least one non-zero):
-         d->cur_pack=d->dsi_pack.dsi_gi.nv_pck_lbn+
-         d->dsi_pack.sml_agli.data[d->dvd_angle-1].address;
-         d->angle_seek=0;
-         d->cur_pack--;
-         MP_VERBOSE(stream, "Angle-seek synced using sml_agli map!  new_lba=0x%X  \n",d->cur_pack);
-        } else {
-          // check if we're in the right cell, jump otherwise:
-          if( (d->dsi_pack.dsi_gi.vobu_c_idn==d->cur_pgc->cell_position[d->cur_cell].cell_nr) &&
-            (d->dsi_pack.dsi_gi.vobu_vob_idn==d->cur_pgc->cell_position[d->cur_cell].vob_id_nr) ){
-            d->angle_seek=0;
-            MP_VERBOSE(stream, "Angle-seek synced by cell/vob IDN search!  \n");
-          } else {
-            // wrong angle, skip this vobu:
-            d->cur_pack=d->dsi_pack.dsi_gi.nv_pck_lbn+
-            d->dsi_pack.dsi_gi.vobu_ea;
-            d->angle_seek=2; // DEBUG
-          }
-        }
-      }
-    }
-    ++d->cur_pack;
-    goto read_next;
-  }
-
-  ++d->cur_pack;
-  if(d->packs_left>=0) --d->packs_left;
-
-  if(d->angle_seek) {
-    if(d->angle_seek==2) MP_VERBOSE(stream, "!!! warning! reading packet while angle_seek !!!\n");
-    goto read_next; // searching for Navi packet
-  }
-
-  return d->cur_pack-1;
-}
-
-static int fill_buffer(stream_t *s, char *buf, int len)
-{
-  int64_t pos;
-  if (len < 2048)
-    return -1;
-  pos = dvd_read_sector(s, s->priv, buf);
-  if (pos < 0)
-    return -1;
-  return 2048; // full sector
-}
-
-static void stream_dvd_close(stream_t *s) {
-  dvd_priv_t *d = s->priv;
-  ifoClose(d->vts_file);
-  ifoClose(d->vmg_file);
-  DVDCloseFile(d->title);
-  DVDClose(d->dvd);
-  if (d->dvd_speed)
-    dvd_set_speed(s,d->dvd_device_current, -1); /* -1 => restore default */
-}
-
-static int mp_get_titleset_length(ifo_handle_t *vts_file, tt_srpt_t *tt_srpt, int title_no)
-{
-    int vts_ttn;  ///< title number within video title set
-    int pgc_no;   ///< program chain number
-    int msec;     ///< time length in milliseconds
-
-    msec=0;
-    if(!vts_file || !tt_srpt)
-        return 0;
-
-    if(vts_file->vtsi_mat && vts_file->vts_pgcit)
-    {
-            vts_ttn = tt_srpt->title[title_no].vts_ttn - 1;
-            pgc_no = vts_file->vts_ptt_srpt->title[vts_ttn].ptt[0].pgcn - 1;
-            msec = mp_dvdtimetomsec(&vts_file->vts_pgcit->pgci_srp[pgc_no].pgc->playback_time);
-    }
-    return msec;
-}
-
-
-static int get_num_chapter(ifo_handle_t *vts_file, tt_srpt_t *tt_srpt, int title_no)
-{
-    if(!vts_file || !tt_srpt)
-       return 0;
-
-    if(title_no < 0 || title_no >= tt_srpt->nr_of_srpts)
-       return 0;
-
-    // map global title to vts title
-    title_no = tt_srpt->title[title_no].vts_ttn - 1;
-
-    if(title_no < 0 || title_no >= vts_file->vts_ptt_srpt->nr_of_srpts)
-       return 0;
-
-    return vts_file->vts_ptt_srpt->title[title_no].nr_of_ptts;
-}
-
-// p: in=chapter number, out=PTS
-static int get_chapter_time(ifo_handle_t *vts_file, tt_srpt_t *tt_srpt, int title_no, double *p)
-{
-    unsigned int i, cell, last_cell;
-    unsigned int t=0;
-    ptt_info_t *ptt;
-    pgc_t *pgc;
-
-    title_no = tt_srpt->title[title_no].vts_ttn - 1;
-    if(vts_file->vts_ptt_srpt->title[title_no].nr_of_ptts < 2)
-       return 0;
-    ptt = vts_file->vts_ptt_srpt->title[title_no].ptt;
-
-    int cur = 0;
-    for(i=0; i<vts_file->vts_ptt_srpt->title[title_no].nr_of_ptts; i++)
-    {
-        pgc = vts_file->vts_pgcit->pgci_srp[ptt[i].pgcn-1].pgc;
-        cell = pgc->program_map[ptt[i].pgn-1]; //here the cell is 1-based
-        if(ptt[i].pgn<pgc->nr_of_programs)
-            last_cell = pgc->program_map[ptt[i].pgn];
-        else
-            last_cell = 0;
-        while (cell < last_cell) {
-            if(!(pgc->cell_playback[cell-1].block_type == BLOCK_TYPE_ANGLE_BLOCK &&
-                 pgc->cell_playback[cell-1].block_mode != BLOCK_MODE_FIRST_CELL)
-            ) {
-                if (cur == *p) {
-                    *p = t / 1000.0;
-                    return 1;
-                }
-                t += mp_dvdtimetomsec(&pgc->cell_playback[cell-1].playback_time);
-                cur++;
-            }
-            cell++;
-        }
-    }
-    return 0;
-}
-
-static void list_chapters(stream_t *stream, ifo_handle_t *vts_file, tt_srpt_t *tt_srpt, int title_no)
-{
-    MP_INFO(stream, "CHAPTERS: ");
-    for (int n = 0; ; n++) {
-        double p = n;
-        int r;
-        r = get_chapter_time(vts_file, tt_srpt, title_no, &p);
-        if (!r)
-            break;
-        int t = p * 1000;
-        MP_INFO(stream, "%02d:%02d:%02d.%03d,", t/3600000, (t/60000)%60, (t/1000)%60, t%1000);
-    }
-    MP_INFO(stream, "\n");
-}
-
-static double dvd_get_current_time(stream_t *stream, int cell)
-{
-    int i, tm;
-    dvd_priv_t *d = stream->priv;
-
-    tm=0;
-    if(cell < 0) cell=d->cur_cell;
-    for(i=0; i<cell; i++) {
-        if(d->cur_pgc->cell_playback[i].block_type == BLOCK_TYPE_ANGLE_BLOCK &&
-           d->cur_pgc->cell_playback[i].block_mode != BLOCK_MODE_FIRST_CELL
-        )
-          continue;
-        tm += d->cell_times_table[i];
-    }
-    tm += mp_dvdtimetomsec(&d->dsi_pack.dsi_gi.c_eltm);
-
-    return (double)tm/1000.0;
-}
-
-static void dvd_seek(stream_t *stream, dvd_priv_t *d, int pos)
-{
-  d->packs_left=-1;
-  d->cur_pack=pos;
-
-  // check if we stay in current cell (speedup things, and avoid angle skip)
-  if(d->cur_pack>d->cell_last_pack ||
-     d->cur_pack<d->cur_pgc->cell_playback[ d->cur_cell ].first_sector) {
-
-    // ok, cell change, find the right cell!
-    cell_playback_t *cell;
-    for(d->cur_cell=0; d->cur_cell < d->cur_pgc->nr_of_cells; d->cur_cell++) {
-      cell = &(d->cur_pgc->cell_playback[d->cur_cell]);
-      if(cell->block_type == BLOCK_TYPE_ANGLE_BLOCK && cell->block_mode != BLOCK_MODE_FIRST_CELL)
-        continue;
-      d->cell_last_pack=cell->last_sector;
-      if(d->cur_pack<cell->first_sector) {
-        d->cur_pack=cell->first_sector;
-        break;
-      }
-      if(d->cur_pack<=d->cell_last_pack) break; // ok, we find it! :)
-    }
-  }
-
-  MP_VERBOSE(stream, "DVD Seek! lba=0x%X  cell=%d  packs: 0x%X-0x%X  \n",
-    d->cur_pack,d->cur_cell,d->cur_pgc->cell_playback[ d->cur_cell ].first_sector,d->cell_last_pack);
-
-  // if we're in interleaved multi-angle cell, find the right angle chain!
-  // (read Navi block, and use the seamless angle jump table)
-  d->angle_seek=1;
-}
-
-static int do_seek(stream_t *s, int64_t newpos) {
-  stream_drop_buffers(s);
-  dvd_seek(s, s->priv,newpos/2048);
-  return 1;
-}
-
-static int dvd_seek_to_time(stream_t *stream, ifo_handle_t *vts_file, double sec)
-{
-    unsigned int i, j, k, timeunit, ac_time, tmap_sector=0, cell_sector=0, vobu_sector=0;
-    int t=0;
-    double tm, duration;
-    int64_t pos = -1;
-    dvd_priv_t *d = stream->priv;
-    vts_tmapt_t *vts_tmapt = vts_file->vts_tmapt;
-
-    if(!vts_file->vts_tmapt || sec < 0)
-        return 0;
-
-    duration = (double) mp_get_titleset_length(d->vts_file, d->tt_srpt, d->cur_title) / 1000.0f;
-    if(sec > duration)
-      return 0;
-
-    i=d->cur_pgc_idx;
-    timeunit = vts_tmapt->tmap[i].tmu;
-    for(j = 0; j < vts_tmapt->tmap[i].nr_of_entries; j++) {
-      ac_time = timeunit * (j + 1);
-      if(ac_time >= sec)
-        break;
-      tmap_sector = vts_tmapt->tmap[i].map_ent[j] & 0x7fffffff;
-    }
-    //search enclosing cell
-    for(i=0; i<d->cur_pgc->nr_of_cells; i++) {
-      if(tmap_sector >= d->cur_pgc->cell_playback[i].first_sector && tmap_sector <= d->cur_pgc->cell_playback[i].last_sector) {
-        cell_sector = d->cur_pgc->cell_playback[i].first_sector;
-        break;
-      }
-    }
-
-    pos = ((int64_t)cell_sector)<<11;
-    do_seek(stream, pos);
-    do {
-      char buf[2048];
-      if (dvd_read_sector(stream, stream->priv, buf) < 0) // skip
-          break;
-      t = mp_dvdtimetomsec(&d->dsi_pack.dsi_gi.c_eltm);
-    } while(!t);
-    tm = dvd_get_current_time(stream, -1);
-
-    pos = ((int64_t)tmap_sector)<<11;
-    do_seek(stream, pos);
-    //now get current time in terms of the cell+cell time offset
-    memset(&d->dsi_pack.dsi_gi.c_eltm, 0, sizeof(dvd_time_t));
-    while(tm <= sec) {
-        char buf[2048];
-        if (dvd_read_sector(stream, stream->priv, buf) < 0) // skip
-            break;
-        pos += 2048;
-        tm = dvd_get_current_time(stream, -1);
-    };
-    tmap_sector = pos >> 11;
-
-    //search closest VOBU sector
-    k=(vts_file->vts_vobu_admap->last_byte + 1 - VOBU_ADMAP_SIZE)/4; //entries in the vobu admap
-    for(i=1; i<k; i++) {
-      if(vts_file->vts_vobu_admap->vobu_start_sectors[i] > tmap_sector)
-        break;
-    }
-    vobu_sector = vts_file->vts_vobu_admap->vobu_start_sectors[i-1];
-    pos = ((int64_t)vobu_sector) << 11;
-    do_seek(stream, pos);
-
-    return 1;
-}
-
-static int control(stream_t *stream,int cmd,void* arg)
-{
-    dvd_priv_t *d = stream->priv;
-    switch(cmd)
-    {
-        case STREAM_CTRL_GET_TIME_LENGTH:
-        {
-            *((double *)arg) = (double) mp_get_titleset_length(d->vts_file, d->tt_srpt, d->cur_title)/1000.0;
-            return 1;
-        }
-        case STREAM_CTRL_GET_NUM_TITLES:
-        {
-            *((unsigned int *)arg) = d->vmg_file->tt_srpt->nr_of_srpts;
-            return 1;
-        }
-        case STREAM_CTRL_GET_TITLE_LENGTH:
-        {
-            int t = *(double *)arg;
-            if (t < 0 || t >= d->vmg_file->tt_srpt->nr_of_srpts)
-                break;
-            if (d->tt_srpt->title[t].title_set_nr !=
-                d->tt_srpt->title[d->dvd_title].title_set_nr)
-                break;
-            *(double *)arg =
-                mp_get_titleset_length(d->vts_file, d->tt_srpt, t) / 1000.0;
-            return 1;
-        }
-        case STREAM_CTRL_GET_NUM_CHAPTERS:
-        {
-            int r;
-            r = get_num_chapter(d->vts_file, d->tt_srpt, d->cur_title);
-            if(! r) return STREAM_UNSUPPORTED;
-            *((unsigned int *)arg) = r;
-            return 1;
-        }
-        case STREAM_CTRL_GET_CHAPTER_TIME:
-        {
-            int r;
-            r = get_chapter_time(d->vts_file, d->tt_srpt, d->cur_title, (double *)arg);
-            if(! r) return STREAM_UNSUPPORTED;
-            return 1;
-        }
-        case STREAM_CTRL_GET_CURRENT_TITLE:
-        {
-            *((unsigned int *)arg) = d->cur_title;
-            return 1;
-        }
-        case STREAM_CTRL_GET_CURRENT_TIME:
-        {
-            double tm;
-            tm = dvd_get_current_time(stream, -1);
-            if(tm != -1) {
-              *((double *)arg) = tm;
-              return 1;
-            }
-            break;
-        }
-        case STREAM_CTRL_SEEK_TO_TIME:
-        {
-            if(dvd_seek_to_time(stream, d->vts_file, *((double*)arg)))
-              return 1;
-            break;
-        }
-        case STREAM_CTRL_GET_ASPECT_RATIO:
-        {
-            *((double *)arg) = !d->vts_file->vtsi_mat->vts_video_attr.display_aspect_ratio ? 4.0/3.0 : 16.0/9.0;
-            return 1;
-        }
-        case STREAM_CTRL_GET_NUM_ANGLES:
-        {
-            *((int *)arg) = d->vmg_file->tt_srpt->title[d->dvd_title].nr_of_angles;
-            return 1;
-        }
-        case STREAM_CTRL_GET_ANGLE:
-        {
-            *((int *)arg) = d->dvd_angle;
-            return 1;
-        }
-        case STREAM_CTRL_SET_ANGLE:
-        {
-            int ang = *((int *)arg);
-            if(ang>d->vmg_file->tt_srpt->title[d->dvd_title].nr_of_angles || ang<=0)
-                break;
-            d->dvd_angle = ang;
-            d->angle_seek = 1;
-            return 1;
-        }
-        case STREAM_CTRL_GET_LANG:
-        {
-            struct stream_lang_req *req = arg;
-            int lang = 0;
-            switch(req->type) {
-            case STREAM_AUDIO:
-                lang = dvd_lang_from_aid(stream, req->id);
-                break;
-            case STREAM_SUB:
-                lang = dvd_lang_from_sid(stream, req->id);
-                break;
-            }
-            if (!lang)
-                break;
-            snprintf(req->name, sizeof(req->name), "%c%c", lang >> 8, lang);
-            return STREAM_OK;
-        }
-        case STREAM_CTRL_GET_DVD_INFO:
-        {
-            struct stream_dvd_info_req *req = arg;
-            memset(req, 0, sizeof(*req));
-            req->num_subs = dvd_number_of_subs(stream);
-            memcpy(req->palette, d->cur_pgc->palette, sizeof(req->palette));
-            return STREAM_OK;
-        }
-        case STREAM_CTRL_GET_DISC_NAME:
-        {
-            char buffer[128];
-            if (DVDUDFVolumeInfo(d->dvd, buffer, sizeof(buffer), NULL, 0) < 0 &&
-                DVDISOVolumeInfo(d->dvd, buffer, sizeof(buffer), NULL, 0) < 0)
-                break;
-            if (!buffer[0])
-                break;
-            *(char**)arg = talloc_strdup(NULL, buffer);
-            return STREAM_OK;
-        }
-        case STREAM_CTRL_GET_SIZE:
-            *(int64_t *)arg =
-                (d->cur_pgc->cell_playback[d->last_cell-1].last_sector)*2048LL;
-            return STREAM_OK;
-    }
-    return STREAM_UNSUPPORTED;
-}
-
-
-static int open_s_internal(stream_t *stream)
-{
-  int k;
-  dvd_priv_t *d = stream->priv;
-
-  struct dvd_opts *opts =
-    mp_get_config_group(stream, stream->global, &dvd_conf);
-
-  d->dvd_angle = opts->angle;
-
-  MP_VERBOSE(stream, "URL: %s\n", stream->url);
-  d->dvd_title = d->cfg_title + 1;
-  if(1){
-    //int ret,ret2;
-    int ttn,pgc_id,pgn;
-    dvd_reader_t *dvd;
-    dvd_file_t *title;
-    ifo_handle_t *vmg_file;
-    tt_srpt_t *tt_srpt;
-    ifo_handle_t *vts_file;
-    pgc_t *pgc;
-    /**
-     * Open the disc.
-     */
-    if(d->cfg_device && d->cfg_device[0])
-      d->dvd_device_current = d->cfg_device;
-    else if(opts->device && opts->device[0])
-      d->dvd_device_current = talloc_strdup(stream, opts->device);
-    else
-      d->dvd_device_current = DEFAULT_DVD_DEVICE;
-    d->dvd_speed = opts->speed;
-    dvd_set_speed(stream,d->dvd_device_current, d->dvd_speed);
-#if defined(__APPLE__) || defined(__DARWIN__)
-    /* Dynamic DVD drive selection on Darwin */
-    if(!strcmp(d->dvd_device_current, "/dev/rdiskN")) {
-      int i;
-      size_t len = strlen(d->dvd_device_current)+1;
-      char *temp_device = malloc(len);
-
-      for (i = 1; i < 10; i++) {
-        snprintf(temp_device, len, "/dev/rdisk%d", i);
-        dvd = DVDOpen(temp_device);
-        if(!dvd) {
-          MP_ERR(stream, "Couldn't open DVD device: %s (%s)\n",temp_device,
-                 mp_strerror(errno));
-        } else {
-#if DVDREAD_VERSION <= LIBDVDREAD_VERSION(0,9,4)
-          dvd_file_t *dvdfile = DVDOpenFile(dvd,d->dvd_title,DVD_READ_INFO_FILE);
-          if(!dvdfile) {
-            MP_ERR(stream, "Couldn't open DVD device: %s (%s)\n",temp_device,
-                   mp_strerror(errno));
-            DVDClose(dvd);
-            continue;
-          }
-          DVDCloseFile(dvdfile);
-#endif
-          break;
-        }
-      }
-      free(temp_device);
-
-      if(!dvd) {
-        return STREAM_UNSUPPORTED;
-      }
-    } else
-#endif /* defined(__APPLE__) || defined(__DARWIN__) */
-    {
-        dvd = DVDOpen(d->dvd_device_current);
-        if(!dvd) {
-          MP_ERR(stream, "Couldn't open DVD device: %s (%s)\n",
-                 d->dvd_device_current, mp_strerror(errno));
-          return STREAM_UNSUPPORTED;
-        }
-    }
-
-    MP_VERBOSE(stream, "Reading disc structure, please wait...\n");
-
-    /**
-     * Load the video manager to find out the information about the titles on
-     * this disc.
-     */
-    vmg_file = ifoOpen(dvd, 0);
-    if(!vmg_file) {
-      MP_ERR(stream, "Can't open VMG info!\n");
-      DVDClose( dvd );
-      return STREAM_UNSUPPORTED;
-    }
-    tt_srpt = vmg_file->tt_srpt;
-    /**
-     * Make sure our title number is valid.
-     */
-    MP_INFO(stream, "There are %d titles on this DVD.\n", tt_srpt->nr_of_srpts );
-    if(d->dvd_title < 1 || d->dvd_title > tt_srpt->nr_of_srpts) {
-      MP_ERR(stream, "Invalid DVD title number: %d\n", d->dvd_title);
-      ifoClose( vmg_file );
-      DVDClose( dvd );
-      return STREAM_UNSUPPORTED;
-    }
-    --(d->dvd_title); // remap 1.. -> 0..
-    /**
-     * Make sure the angle number is valid for this title.
-     */
-    MP_INFO(stream, "There are %d angles in this DVD title.\n", tt_srpt->title[d->dvd_title].nr_of_angles);
-    if(d->dvd_angle<1 || d->dvd_angle>tt_srpt->title[d->dvd_title].nr_of_angles) {
-      MP_ERR(stream, "Invalid DVD angle number: %d\n", d->dvd_angle);
-      goto fail;
-    }
-
-    ttn = tt_srpt->title[d->dvd_title].vts_ttn - 1;
-    /**
-     * Load the VTS information for the title set our title is in.
-     */
-    vts_file = ifoOpen( dvd, tt_srpt->title[d->dvd_title].title_set_nr );
-    if(!vts_file) {
-      MP_ERR(stream, "Cannot open the IFO file for DVD title %d.\n", tt_srpt->title[d->dvd_title].title_set_nr );
-      goto fail;
-    }
-    /**
-     * We've got enough info, time to open the title set data.
-     */
-    title = DVDOpenFile(dvd, tt_srpt->title[d->dvd_title].title_set_nr, DVD_READ_TITLE_VOBS);
-    if(!title) {
-      MP_ERR(stream, "Cannot open title VOBS (VTS_%02d_1.VOB).\n", tt_srpt->title[d->dvd_title].title_set_nr);
-      ifoClose( vts_file );
-      goto fail;
-    }
-
-    MP_VERBOSE(stream, "DVD successfully opened.\n");
-    // store data
-    d->dvd=dvd;
-    d->title=title;
-    d->vmg_file=vmg_file;
-    d->tt_srpt=tt_srpt;
-    d->vts_file=vts_file;
-    d->cur_title = d->dvd_title;
-
-    pgc_id = vts_file->vts_ptt_srpt->title[ttn].ptt[0].pgcn; // local
-    pgn  = vts_file->vts_ptt_srpt->title[ttn].ptt[0].pgn;  // local
-    pgc = vts_file->vts_pgcit ? vts_file->vts_pgcit->pgci_srp[pgc_id-1].pgc : NULL;
-    /**
-     * Check number of audio channels and types
-     */
-    {
-      d->nr_of_channels=0;
-      if(vts_file->vts_pgcit) {
-        int i;
-        for(i=0;i<8;i++)
-          if(pgc->audio_control[i] & 0x8000) {
-            audio_attr_t * audio = &vts_file->vtsi_mat->vts_audio_attr[i];
-            int language = 0;
-            char tmp[] = "unknown";
-            stream_language_t *audio_stream = &d->audio_streams[d->nr_of_channels];
-
-            if(audio->lang_type == 1) {
-              language=audio->lang_code;
-              tmp[0]=language>>8;
-              tmp[1]=language&0xff;
-              tmp[2]=0;
-            }
-
-            audio_stream->language=language;
-            audio_stream->id=pgc->audio_control[i] >> 8 & 7;
-            switch(audio->audio_format) {
-              case 0: // ac3
-                audio_stream->id+=FIRST_AC3_AID;
-                break;
-              case 6: // dts
-                audio_stream->id+=FIRST_DTS_AID;
-                break;
-              case 2: // mpeg layer 1/2/3
-              case 3: // mpeg2 ext
-                audio_stream->id+=FIRST_MPG_AID;
-                break;
-              case 4: // lpcm
-                audio_stream->id+=FIRST_PCM_AID;
-                break;
-           }
-
-           audio_stream->type=audio->audio_format;
-           // Pontscho: to my mind, tha channels:
-           //  1 - stereo
-           //  5 - 5.1
-           audio_stream->channels=audio->channels;
-           MP_INFO(stream, "audio stream: %d format: %s (%s) language: %s aid: %d.\n",
-             d->nr_of_channels,
-             dvd_audio_stream_types[ audio->audio_format ],
-             dvd_audio_stream_channels[ audio->channels ],
-             tmp,
-             audio_stream->id
-           );
-
-           d->nr_of_channels++;
-         }
-      }
-      MP_INFO(stream, "number of audio channels on disk: %d.\n",d->nr_of_channels );
-    }
-
-    /**
-     * Check number of subtitles and language
-     */
-    {
-      int i;
-
-      d->nr_of_subtitles=0;
-      for(i=0;i<32;i++)
-      if(pgc->subp_control[i] & 0x80000000) {
-        subp_attr_t * subtitle = &vts_file->vtsi_mat->vts_subp_attr[i];
-        video_attr_t *video = &vts_file->vtsi_mat->vts_video_attr;
-        int language = 0;
-        char tmp[] = "unknown";
-        stream_language_t *sub_stream = &d->subtitles[d->nr_of_subtitles];
-
-        if(subtitle->type == 1) {
-          language=subtitle->lang_code;
-          tmp[0]=language>>8;
-          tmp[1]=language&0xff;
-          tmp[2]=0;
-        }
-
-        sub_stream->language=language;
-        sub_stream->id=d->nr_of_subtitles;
-        if(video->display_aspect_ratio == 0) /* 4:3 */
-          sub_stream->id = pgc->subp_control[i] >> 24 & 31;
-        else if(video->display_aspect_ratio == 3) /* 16:9 */
-          sub_stream->id = pgc->subp_control[i] >> 8 & 31;
-
-        MP_INFO(stream, "subtitle ( sid ): %d language: %s\n", sub_stream->id, tmp);
-        d->nr_of_subtitles++;
-      }
-      MP_INFO(stream, "number of subtitles on disk: %d\n",d->nr_of_subtitles);
-    }
-
-    /**
-     * Determine which program chain we want to watch.  This is based on the
-     * chapter number.
-     */
-    d->cur_pgc_idx = pgc_id-1;
-    d->cur_pgc = vts_file->vts_pgcit->pgci_srp[pgc_id-1].pgc;
-    d->cur_cell = d->cur_pgc->program_map[pgn-1] - 1; // start playback here
-    d->packs_left=-1;      // for Navi stuff
-    d->angle_seek=0;
-      d->last_cell=d->cur_pgc->nr_of_cells;
-
-    if(d->cur_pgc->cell_playback[d->cur_cell].block_type == BLOCK_TYPE_ANGLE_BLOCK )
-      d->cur_cell+=d->dvd_angle-1;
-    d->cur_pack = d->cur_pgc->cell_playback[ d->cur_cell ].first_sector;
-    d->cell_last_pack=d->cur_pgc->cell_playback[ d->cur_cell ].last_sector;
-    MP_VERBOSE(stream, "DVD start cell: %d  pack: 0x%X-0x%X  \n",d->cur_cell,d->cur_pack,d->cell_last_pack);
-
-    //assign cell_times_table
-    d->cell_times_table = malloc(sizeof(unsigned int) * d->cur_pgc->nr_of_cells);
-    if(d->cell_times_table == NULL)
-      return STREAM_UNSUPPORTED;
-    for(k=0; k<d->cur_pgc->nr_of_cells; k++)
-      d->cell_times_table[k] = mp_dvdtimetomsec(&d->cur_pgc->cell_playback[k].playback_time);
-    list_chapters(stream, vts_file,tt_srpt,d->dvd_title);
-
-    // ... (unimplemented)
-    //    return NULL;
-    stream->demuxer = "+disc";
-    stream->lavf_type = "mpeg";
-    stream->sector_size = 2048;
-    stream->fill_buffer = fill_buffer;
-    stream->control = control;
-    stream->close = stream_dvd_close;
-    MP_VERBOSE(stream, "DVD start=%d end=%d  \n",d->cur_pack,d->cur_pgc->cell_playback[d->last_cell-1].last_sector);
-    stream->priv = (void*)d;
-    return STREAM_OK;
-
-fail:
-      ifoClose(vmg_file);
-      DVDClose(dvd);
-      return STREAM_UNSUPPORTED;
-  }
-  MP_ERR(stream, "mpv was compiled without DVD support, exiting.\n");
-  return STREAM_UNSUPPORTED;
-}
-
-static int open_s(stream_t *stream)
-{
-    dvd_priv_t *d = talloc_zero(stream, dvd_priv_t);
-    stream->priv = d;
-
-    bstr title, bdevice;
-    bstr_split_tok(bstr0(stream->path), "/", &title, &bdevice);
-
-    if (title.len) {
-        bstr rest;
-        d->cfg_title = bstrtoll(title, &rest, 10);
-        if (rest.len) {
-            MP_ERR(stream, "number expected: '%.*s'\n", BSTR_P(rest));
-            return STREAM_ERROR;
-        }
-    }
-
-    d->cfg_device = bstrto0(d, bdevice);
-
-    return open_s_internal(stream);
-}
-
-static int ifo_stream_open(stream_t *stream)
-{
-    dvd_priv_t *priv = talloc_zero(stream, dvd_priv_t);
-    stream->priv = priv;
-
-    if (!stream->access_references)
-        goto unsupported;
-
-    char *path = mp_file_get_path(priv, bstr0(stream->url));
-    if (!path)
-        goto unsupported;
-
-    if (!dvd_probe(path, ".ifo", "DVDVIDEO-VTS"))
-        goto unsupported;
-
-    char *base = mp_basename(path);
-
-    // Only accept individual titles - use dvdnav for video_ts.ifo
-    if (strncasecmp(base, "vts_", 4))
-        goto unsupported;
-
-    if (sscanf(base + 3, "_%02d_", &priv->cfg_title) != 1)
-        goto unsupported;
-
-    priv->cfg_device = bstrto0(priv, mp_dirname(path));
-
-    MP_INFO(stream, ".IFO detected. Redirecting to dvdread://\n");
-    return open_s_internal(stream);
-
-unsupported:
-    talloc_free(priv);
-    stream->priv = NULL;
-    return STREAM_UNSUPPORTED;
-}
-
-const stream_info_t stream_info_dvd = {
-  .name = "dvd",
-  .open = open_s,
-  .protocols = (const char*const[]){ "dvdread", NULL },
-};
-
-const stream_info_t stream_info_ifo = {
-    .name = "ifo",
-    .open = ifo_stream_open,
-    .protocols = (const char*const[]){ "file", "", NULL },
-};
diff -ruN mpv-0.29.1/stream/stream_dvd_common.c mpv-master/stream/stream_dvd_common.c
--- mpv-0.29.1/stream/stream_dvd_common.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_dvd_common.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,164 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <fcntl.h>
-#include <inttypes.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <string.h>
-#include <strings.h>
-#include <assert.h>
-
-#include <libavutil/intreadwrite.h>
-
-#include "config.h"
-
-#include <dvdread/ifo_types.h>
-
-#ifdef __FreeBSD__
-#include <sys/cdrio.h>
-#endif
-
-#ifdef __linux__
-#include <linux/cdrom.h>
-#include <scsi/sg.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#endif
-
-#include "osdep/io.h"
-
-#include "common/msg.h"
-#include "misc/bstr.h"
-#include "stream_dvd_common.h"
-
-const char * const dvd_audio_stream_types[8] = { "ac3","unknown","mpeg1","mpeg2ext","lpcm","unknown","dts" };
-const char * const dvd_audio_stream_channels[6] = { "mono", "stereo", "unknown", "unknown", "5.1/6.1", "5.1" };
-
-void dvd_set_speed(stream_t *stream, char *device, unsigned speed)
-{
-#if defined(__linux__) && defined(SG_IO) && defined(GPCMD_SET_STREAMING)
-  int fd;
-  unsigned char buffer[28];
-  unsigned char cmd[12];
-  struct sg_io_hdr sghdr;
-  struct stat st;
-
-  memset(&st, 0, sizeof(st));
-
-  if (stat(device, &st) == -1) return;
-
-  if (!S_ISBLK(st.st_mode)) return; /* not a block device */
-
-  switch (speed) {
-  case 0: /* don't touch speed setting */
-    return;
-  case -1: /* restore default value */
-    MP_INFO(stream, "Restoring DVD speed... ");
-    break;
-  default: /* limit to <speed> KB/s */
-    // speed < 100 is multiple of DVD single speed (1350KB/s)
-    if (speed < 100)
-      speed *= 1350;
-    MP_INFO(stream, "Limiting DVD speed to %dKB/s... ", speed);
-    break;
-  }
-
-  memset(&sghdr, 0, sizeof(sghdr));
-  sghdr.interface_id = 'S';
-  sghdr.timeout = 5000;
-  sghdr.dxfer_direction = SG_DXFER_TO_DEV;
-  sghdr.dxfer_len = sizeof(buffer);
-  sghdr.dxferp = buffer;
-  sghdr.cmd_len = sizeof(cmd);
-  sghdr.cmdp = cmd;
-
-  memset(cmd, 0, sizeof(cmd));
-  cmd[0] = GPCMD_SET_STREAMING;
-  cmd[10] = sizeof(buffer);
-
-  memset(buffer, 0, sizeof(buffer));
-  /* first sector 0, last sector 0xffffffff */
-  AV_WB32(buffer + 8, 0xffffffff);
-  if (speed == -1)
-    buffer[0] = 4; /* restore default */
-  else {
-    /* <speed> kilobyte */
-    AV_WB32(buffer + 12, speed);
-    AV_WB32(buffer + 20, speed);
-  }
-  /* 1 second */
-  AV_WB16(buffer + 18, 1000);
-  AV_WB16(buffer + 26, 1000);
-
-  fd = open(device, O_RDWR | O_NONBLOCK | O_CLOEXEC);
-  if (fd == -1) {
-    MP_INFO(stream, "Couldn't open DVD device for writing, changing DVD speed needs write access.\n");
-    return;
-  }
-
-  if (ioctl(fd, SG_IO, &sghdr) < 0)
-    MP_INFO(stream, "failed\n");
-  else
-    MP_INFO(stream, "successful\n");
-
-  close(fd);
-#endif
-}
-
-/**
-\brief Converts DVD time structure to milliseconds.
-\param *dev the DVD time structure to convert
-\return returns the time in milliseconds
-*/
-int mp_dvdtimetomsec(dvd_time_t *dt)
-{
-  int framerates[4] = {0, 2500, 0, 2997};
-  int framerate = framerates[(dt->frame_u & 0xc0) >> 6];
-  int msec = (((dt->hour & 0xf0) >> 3) * 5 + (dt->hour & 0x0f)) * 3600000;
-  msec += (((dt->minute & 0xf0) >> 3) * 5 + (dt->minute & 0x0f)) * 60000;
-  msec += (((dt->second & 0xf0) >> 3) * 5 + (dt->second & 0x0f)) * 1000;
-  if(framerate > 0)
-    msec += (((dt->frame_u & 0x30) >> 3) * 5 + (dt->frame_u & 0x0f)) * 100000 / framerate;
-  return msec;
-}
-
-// Check if this is likely to be an .ifo or similar file.
-int dvd_probe(const char *path, const char *ext, const char *sig)
-{
-    if (!bstr_case_endswith(bstr0(path), bstr0(ext)))
-        return false;
-
-    FILE *temp = fopen(path, "rb");
-    if (!temp)
-        return false;
-
-    bool r = false;
-
-    char data[50];
-
-    assert(strlen(sig) <= sizeof(data));
-
-    if (fread(data, 50, 1, temp) == 1) {
-        if (memcmp(data, sig, strlen(sig)) == 0)
-            r = true;
-    }
-
-    fclose(temp);
-    return r;
-}
diff -ruN mpv-0.29.1/stream/stream_dvd_common.h mpv-master/stream/stream_dvd_common.h
--- mpv-0.29.1/stream/stream_dvd_common.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_dvd_common.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,38 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef MPLAYER_STREAM_DVD_COMMON_H
-#define MPLAYER_STREAM_DVD_COMMON_H
-
-#include <inttypes.h>
-#include <stdbool.h>
-#include "stream.h"
-
-#include "config.h"
-#if !HAVE_GPL
-#error GPL only
-#endif
-
-extern const char * const dvd_audio_stream_channels[6];
-extern const char * const dvd_audio_stream_types[8];
-
-void dvd_set_speed(stream_t *stream, char *device, unsigned speed);
-int mp_dvdtimetomsec(dvd_time_t *dt);
-
-int dvd_probe(const char *path, const char *ext, const char *sig);
-
-#endif /* MPLAYER_STREAM_DVD_COMMON_H */
diff -ruN mpv-0.29.1/stream/stream_dvdnav.c mpv-master/stream/stream_dvdnav.c
--- mpv-0.29.1/stream/stream_dvdnav.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_dvdnav.c	2019-09-19 04:02:03.000000000 +0700
@@ -15,8 +15,6 @@
  * with mpv.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <libavutil/common.h>
-
 #include "config.h"
 
 #if !HAVE_GPL
@@ -31,7 +29,17 @@
 #include <errno.h>
 #include <assert.h>
 
+#ifdef __linux__
+#include <linux/cdrom.h>
+#include <scsi/sg.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#endif
+
 #include <dvdnav/dvdnav.h>
+#include <libavutil/common.h>
+#include <libavutil/intreadwrite.h>
 
 #include "osdep/io.h"
 
@@ -44,7 +52,6 @@
 #include "stream.h"
 #include "demux/demux.h"
 #include "video/out/vo.h"
-#include "stream_dvd_common.h"
 
 #define TITLE_MENU -1
 #define TITLE_LONGEST -2
@@ -87,71 +94,100 @@
 #define LOOKUP_NAME(array, i) \
     (((i) >= 0 && (i) < MP_ARRAY_SIZE(array)) ? array[(i)] : "?")
 
-/**
- * \brief mp_dvdnav_lang_from_aid() returns the language corresponding to audio id 'aid'
- * \param stream: - stream pointer
- * \param sid: physical subtitle id
- * \return 0 on error, otherwise language id
- */
-static int mp_dvdnav_lang_from_aid(stream_t *stream, int aid)
+static void dvd_set_speed(stream_t *stream, char *device, unsigned speed)
 {
-    uint8_t lg;
-    uint16_t lang;
-    struct priv *priv = stream->priv;
+#if defined(__linux__) && defined(SG_IO) && defined(GPCMD_SET_STREAMING)
+  int fd;
+  unsigned char buffer[28];
+  unsigned char cmd[12];
+  struct sg_io_hdr sghdr;
+  struct stat st;
+
+  memset(&st, 0, sizeof(st));
+
+  if (stat(device, &st) == -1) return;
+
+  if (!S_ISBLK(st.st_mode)) return; /* not a block device */
+
+  switch (speed) {
+  case 0: /* don't touch speed setting */
+    return;
+  case -1: /* restore default value */
+    MP_INFO(stream, "Restoring DVD speed... ");
+    break;
+  default: /* limit to <speed> KB/s */
+    // speed < 100 is multiple of DVD single speed (1350KB/s)
+    if (speed < 100)
+      speed *= 1350;
+    MP_INFO(stream, "Limiting DVD speed to %dKB/s... ", speed);
+    break;
+  }
+
+  memset(&sghdr, 0, sizeof(sghdr));
+  sghdr.interface_id = 'S';
+  sghdr.timeout = 5000;
+  sghdr.dxfer_direction = SG_DXFER_TO_DEV;
+  sghdr.dxfer_len = sizeof(buffer);
+  sghdr.dxferp = buffer;
+  sghdr.cmd_len = sizeof(cmd);
+  sghdr.cmdp = cmd;
+
+  memset(cmd, 0, sizeof(cmd));
+  cmd[0] = GPCMD_SET_STREAMING;
+  cmd[10] = sizeof(buffer);
+
+  memset(buffer, 0, sizeof(buffer));
+  /* first sector 0, last sector 0xffffffff */
+  AV_WB32(buffer + 8, 0xffffffff);
+  if (speed == -1)
+    buffer[0] = 4; /* restore default */
+  else {
+    /* <speed> kilobyte */
+    AV_WB32(buffer + 12, speed);
+    AV_WB32(buffer + 20, speed);
+  }
+  /* 1 second */
+  AV_WB16(buffer + 18, 1000);
+  AV_WB16(buffer + 26, 1000);
+
+  fd = open(device, O_RDWR | O_NONBLOCK | O_CLOEXEC);
+  if (fd == -1) {
+    MP_INFO(stream, "Couldn't open DVD device for writing, changing DVD speed needs write access.\n");
+    return;
+  }
+
+  if (ioctl(fd, SG_IO, &sghdr) < 0)
+    MP_INFO(stream, "failed\n");
+  else
+    MP_INFO(stream, "successful\n");
 
-    if (aid < 0)
-        return 0;
-    lg = dvdnav_get_audio_logical_stream(priv->dvdnav, aid & 0x7);
-    if (lg == 0xff)
-        return 0;
-    lang = dvdnav_audio_stream_to_lang(priv->dvdnav, lg);
-    if (lang == 0xffff)
-        return 0;
-    return lang;
+  close(fd);
+#endif
 }
 
-/**
- * \brief mp_dvdnav_lang_from_sid() returns the language corresponding to subtitle id 'sid'
- * \param stream: - stream pointer
- * \param sid: physical subtitle id
- * \return 0 on error, otherwise language id
- */
-static int mp_dvdnav_lang_from_sid(stream_t *stream, int sid)
+// Check if this is likely to be an .ifo or similar file.
+static int dvd_probe(const char *path, const char *ext, const char *sig)
 {
-    uint8_t k;
-    uint16_t lang;
-    struct priv *priv = stream->priv;
-    if (sid < 0)
-        return 0;
-    for (k = 0; k < 32; k++)
-        if (dvdnav_get_spu_logical_stream(priv->dvdnav, k) == sid)
-            break;
-    if (k == 32)
-        return 0;
-    lang = dvdnav_spu_stream_to_lang(priv->dvdnav, k);
-    if (lang == 0xffff)
-        return 0;
-    return lang;
-}
+    if (!bstr_case_endswith(bstr0(path), bstr0(ext)))
+        return false;
 
-/**
- * \brief mp_dvdnav_number_of_subs() returns the count of available subtitles
- * \param stream: - stream pointer
- * \return 0 on error, something meaningful otherwise
- */
-static int mp_dvdnav_number_of_subs(stream_t *stream)
-{
-    struct priv *priv = stream->priv;
-    uint8_t lg, k, n = 0;
+    FILE *temp = fopen(path, "rb");
+    if (!temp)
+        return false;
 
-    for (k = 0; k < 32; k++) {
-        lg = dvdnav_get_spu_logical_stream(priv->dvdnav, k);
-        if (lg == 0xff)
-            continue;
-        if (lg >= n)
-            n = lg + 1;
+    bool r = false;
+
+    char data[50];
+
+    assert(strlen(sig) <= sizeof(data));
+
+    if (fread(data, 50, 1, temp) == 1) {
+        if (memcmp(data, sig, strlen(sig)) == 0)
+            r = true;
     }
-    return n;
+
+    fclose(temp);
+    return r;
 }
 
 static int fill_buffer(stream_t *s, char *buf, int max_len)
@@ -237,92 +273,16 @@
 {
     struct priv *priv = stream->priv;
     dvdnav_t *dvdnav = priv->dvdnav;
-    int tit, part;
 
     switch (cmd) {
-    case STREAM_CTRL_GET_NUM_CHAPTERS: {
-        if (dvdnav_current_title_info(dvdnav, &tit, &part) != DVDNAV_STATUS_OK)
-            break;
-        if (dvdnav_get_number_of_parts(dvdnav, tit, &part) != DVDNAV_STATUS_OK)
-            break;
-        if (!part)
-            break;
-        *(unsigned int *)arg = part;
-        return 1;
-    }
-    case STREAM_CTRL_GET_CHAPTER_TIME: {
-        double *ch = arg;
-        int chapter = *ch;
-        if (dvdnav_current_title_info(dvdnav, &tit, &part) != DVDNAV_STATUS_OK)
-            break;
-        uint64_t *parts = NULL, duration = 0;
-        int n = dvdnav_describe_title_chapters(dvdnav, tit, &parts, &duration);
-        if (!parts)
-            break;
-        if (chapter < 0 || chapter + 1 > n)
-            break;
-        *ch = chapter > 0 ? parts[chapter - 1] / 90000.0 : 0;
-        free(parts);
-        return 1;
-    }
-    case STREAM_CTRL_GET_TIME_LENGTH: {
+    case STREAM_CTRL_OPTICAL_CRAP_HACK1: {
         if (priv->duration) {
             *(double *)arg = (double)priv->duration / 1000.0;
             return 1;
         }
         break;
     }
-    case STREAM_CTRL_GET_ASPECT_RATIO: {
-        uint8_t ar = dvdnav_get_video_aspect(dvdnav);
-        *(double *)arg = !ar ? 4.0 / 3.0 : 16.0 / 9.0;
-        return 1;
-    }
-    case STREAM_CTRL_GET_CURRENT_TIME: {
-        double tm;
-        tm = dvdnav_get_current_time(dvdnav) / 90000.0f;
-        if (tm != -1) {
-            *(double *)arg = tm;
-            return 1;
-        }
-        break;
-    }
-    case STREAM_CTRL_GET_NUM_TITLES: {
-        int32_t num_titles = 0;
-        if (dvdnav_get_number_of_titles(dvdnav, &num_titles) != DVDNAV_STATUS_OK)
-            break;
-        *((unsigned int*)arg)= num_titles;
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_GET_TITLE_LENGTH: {
-        int t = *(double *)arg;
-        int32_t num_titles = 0;
-        if (dvdnav_get_number_of_titles(dvdnav, &num_titles) != DVDNAV_STATUS_OK)
-            break;
-        if (t < 0 || t >= num_titles)
-            break;
-        uint64_t duration = 0;
-        uint64_t *parts = NULL;
-        dvdnav_describe_title_chapters(dvdnav, t + 1, &parts, &duration);
-        if (!parts)
-            break;
-        free(parts);
-        *(double *)arg = duration / 90000.0;
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_GET_CURRENT_TITLE: {
-        if (dvdnav_current_title_info(dvdnav, &tit, &part) != DVDNAV_STATUS_OK)
-            break;
-        *((unsigned int *) arg) = tit - 1;
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_SET_CURRENT_TITLE: {
-        int title = *((unsigned int *) arg);
-        if (dvdnav_title_play(priv->dvdnav, title + 1) != DVDNAV_STATUS_OK)
-            break;
-        stream_drop_buffers(stream);
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_SEEK_TO_TIME: {
+    case STREAM_CTRL_OPTICAL_CRAP_HACK2: {
         double *args = arg;
         double d = args[0]; // absolute target timestamp
         int flags = args[1]; // from SEEK_* flags (demux.h)
@@ -346,63 +306,6 @@
             MP_VERBOSE(stream, "block: %lu\n", (unsigned long)pos);
         return STREAM_OK;
     }
-    case STREAM_CTRL_GET_NUM_ANGLES: {
-        uint32_t curr, angles;
-        if (dvdnav_get_angle_info(dvdnav, &curr, &angles) != DVDNAV_STATUS_OK)
-            break;
-        *(int *)arg = angles;
-        return 1;
-    }
-    case STREAM_CTRL_GET_ANGLE: {
-        uint32_t curr, angles;
-        if (dvdnav_get_angle_info(dvdnav, &curr, &angles) != DVDNAV_STATUS_OK)
-            break;
-        *(int *)arg = curr;
-        return 1;
-    }
-    case STREAM_CTRL_SET_ANGLE: {
-        uint32_t curr, angles;
-        int new_angle = *(int *)arg;
-        if (dvdnav_get_angle_info(dvdnav, &curr, &angles) != DVDNAV_STATUS_OK)
-            break;
-        if (new_angle > angles || new_angle < 1)
-            break;
-        if (dvdnav_angle_change(dvdnav, new_angle) != DVDNAV_STATUS_OK)
-            return 1;
-    }
-    case STREAM_CTRL_GET_LANG: {
-        struct stream_lang_req *req = arg;
-        int lang = 0;
-        switch (req->type) {
-        case STREAM_AUDIO:
-            lang = mp_dvdnav_lang_from_aid(stream, req->id);
-            break;
-        case STREAM_SUB:
-            lang = mp_dvdnav_lang_from_sid(stream, req->id);
-            break;
-        }
-        if (!lang)
-            break;
-        snprintf(req->name, sizeof(req->name), "%c%c", lang >> 8, lang);
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_GET_DVD_INFO: {
-        struct stream_dvd_info_req *req = arg;
-        memset(req, 0, sizeof(*req));
-        req->num_subs = mp_dvdnav_number_of_subs(stream);
-        assert(sizeof(uint32_t) == sizeof(unsigned int));
-        memcpy(req->palette, priv->spu_clut, sizeof(req->palette));
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_GET_DISC_NAME: {
-        const char *volume = NULL;
-        if (dvdnav_get_title_string(dvdnav, &volume) != DVDNAV_STATUS_OK)
-            break;
-        if (!volume || !volume[0])
-            break;
-        *(char**)arg = talloc_strdup(NULL, volume);
-        return STREAM_OK;
-    }
     }
 
     return STREAM_UNSUPPORTED;
@@ -514,13 +417,10 @@
     if (p->opts->angle > 1)
         dvdnav_angle_change(priv->dvdnav, p->opts->angle);
 
-    stream->sector_size = 2048;
     stream->fill_buffer = fill_buffer;
     stream->control = control;
     stream->close = stream_dvdnav_close;
-    stream->demuxer = "+disc";
     stream->lavf_type = "mpeg";
-    stream->allow_caching = false;
 
     return STREAM_OK;
 }
diff -ruN mpv-0.29.1/stream/stream_edl.c mpv-master/stream/stream_edl.c
--- mpv-0.29.1/stream/stream_edl.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_edl.c	2019-09-19 04:02:03.000000000 +0700
@@ -6,7 +6,6 @@
 static int s_open (struct stream *stream)
 {
     stream->demuxer = "edl";
-    stream->allow_caching = false;
 
     return STREAM_OK;
 }
diff -ruN mpv-0.29.1/stream/stream_file.c mpv-master/stream/stream_file.c
--- mpv-0.29.1/stream/stream_file.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_file.c	2019-09-19 04:02:03.000000000 +0700
@@ -34,6 +34,7 @@
 
 #include "common/common.h"
 #include "common/msg.h"
+#include "misc/thread_tools.h"
 #include "stream.h"
 #include "options/m_option.h"
 #include "options/path.h"
@@ -64,6 +65,7 @@
     bool regular_file;
     bool appending;
     int64_t orig_size;
+    struct mp_cancel *cancel;
 };
 
 // Total timeout = RETRY_TIMEOUT * MAX_RETRIES
@@ -84,7 +86,7 @@
 
 #ifndef __MINGW32__
     if (p->use_poll) {
-        int c = s->cancel ? mp_cancel_get_fd(s->cancel) : -1;
+        int c = mp_cancel_get_fd(p->cancel);
         struct pollfd fds[2] = {
             {.fd = p->fd, .events = POLLIN},
             {.fd = c, .events = POLLIN},
@@ -111,7 +113,7 @@
         if (!p->appending || p->use_poll)
             break;
 
-        if (mp_cancel_wait(s->cancel, RETRY_TIMEOUT))
+        if (mp_cancel_wait(p->cancel, RETRY_TIMEOUT))
             break;
     }
 
@@ -121,16 +123,7 @@
 static int write_buffer(stream_t *s, char *buffer, int len)
 {
     struct priv *p = s->priv;
-    int r = len;
-    int wr;
-    while (r > 0) {
-        wr = write(p->fd, buffer, r);
-        if (wr <= 0)
-            return -1;
-        r -= wr;
-        buffer += wr;
-    }
-    return len - r;
+    return write(p->fd, buffer, len);
 }
 
 static int seek(stream_t *s, int64_t newpos)
@@ -323,7 +316,6 @@
     if (fstat(p->fd, &st) == 0) {
         if (S_ISDIR(st.st_mode)) {
             stream->is_directory = true;
-            stream->allow_caching = false;
             MP_INFO(stream, "This is a directory - adding to playlist.\n");
         } else if (S_ISREG(st.st_mode)) {
             p->regular_file = true;
@@ -360,6 +352,10 @@
 
     p->orig_size = get_size(stream);
 
+    p->cancel = mp_cancel_new(p);
+    if (stream->cancel)
+        mp_cancel_set_parent(p->cancel, stream->cancel);
+
     return STREAM_OK;
 }
 
diff -ruN mpv-0.29.1/stream/stream_lavf.c mpv-master/stream/stream_lavf.c
--- mpv-0.29.1/stream/stream_lavf.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_lavf.c	2019-09-19 04:02:03.000000000 +0700
@@ -24,6 +24,7 @@
 #include "common/msg.h"
 #include "common/tags.h"
 #include "common/av_common.h"
+#include "misc/thread_tools.h"
 #include "stream.h"
 #include "options/m_config.h"
 #include "options/m_option.h"
diff -ruN mpv-0.29.1/stream/stream_libarchive.c mpv-master/stream/stream_libarchive.c
--- mpv-0.29.1/stream/stream_libarchive.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_libarchive.c	2019-09-19 04:02:03.000000000 +0700
@@ -20,6 +20,7 @@
 
 #include "misc/bstr.h"
 #include "common/common.h"
+#include "misc/thread_tools.h"
 #include "stream.h"
 
 #include "stream_libarchive.h"
@@ -243,8 +244,11 @@
     struct mp_archive *mpa = talloc_zero(NULL, struct mp_archive);
     mpa->log = log;
     mpa->locale = newlocale(LC_ALL_MASK, "C.UTF-8", (locale_t)0);
-    if (!mpa->locale)
-        goto err;
+    if (!mpa->locale) {
+        mpa->locale = newlocale(LC_CTYPE_MASK, "", (locale_t)0);
+        if (!mpa->locale)
+            goto err;
+    }
     mpa->arch = archive_read_new();
     mpa->primary_src = src;
     if (!mpa->arch)
diff -ruN mpv-0.29.1/stream/stream_memory.c mpv-master/stream/stream_memory.c
--- mpv-0.29.1/stream/stream_memory.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_memory.c	2019-09-19 04:02:03.000000000 +0700
@@ -62,7 +62,6 @@
     stream->seekable = true;
     stream->control = control;
     stream->read_chunk = 1024 * 1024;
-    stream->allow_caching = false;
 
     struct priv *p = talloc_zero(stream, struct priv);
     stream->priv = p;
diff -ruN mpv-0.29.1/stream/stream_mf.c mpv-master/stream/stream_mf.c
--- mpv-0.29.1/stream/stream_mf.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_mf.c	2019-09-19 04:02:03.000000000 +0700
@@ -31,7 +31,6 @@
 mf_stream_open (stream_t *stream)
 {
   stream->demuxer = "mf";
-  stream->allow_caching = false;
 
   return STREAM_OK;
 }
diff -ruN mpv-0.29.1/stream/stream_rar.c mpv-master/stream/stream_rar.c
--- mpv-0.29.1/stream/stream_rar.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_rar.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,147 +0,0 @@
-// Major parts based on:
-/*****************************************************************************
- * access.c: uncompressed RAR access
- *****************************************************************************
- * Copyright (C) 2008-2010 Laurent Aimar
- * $Id: dcd973529e0029abe326d31f8d58cd13bbcc276c $
- *
- * Author: Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2.1 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-#include "config.h"
-
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <errno.h>
-
-#include "osdep/io.h"
-
-#include "common/msg.h"
-#include "stream.h"
-#include "options/m_option.h"
-#include "rar.h"
-
-/*
-This works as follows:
-
-- stream_open() with file01.rar
-    - is opened as normal file (stream_file.c or others) first
-    - demux_rar.c detects it
-    - if multi-part, opens file02.rar, file03.rar, etc. as actual streams
-    - it returns a playlist with entries like this to the player:
-        rar://bla01.rar|subfile.mkv
-      (one such entry for each file contained in the rar)
-- stream_open() with the playlist entry, e.g. rar://bla01.rar|subfile.mkv
-    - leads to rar_entry_open()
-    - opens bla01.rar etc. again as actual streams
-    - read accesses go into subfile.mkv contained in the rar file(s)
-*/
-
-static int rar_entry_fill_buffer(stream_t *s, char *buffer, int max_len)
-{
-    rar_file_t *rar_file = s->priv;
-    return RarRead(rar_file, buffer, max_len);
-}
-
-static int rar_entry_seek(stream_t *s, int64_t newpos)
-{
-    rar_file_t *rar_file = s->priv;
-    return RarSeek(rar_file, newpos);
-}
-
-static void rar_entry_close(stream_t *s)
-{
-    rar_file_t *rar_file = s->priv;
-    RarFileDelete(rar_file);
-}
-
-static int rar_entry_control(stream_t *s, int cmd, void *arg)
-{
-    rar_file_t *rar_file = s->priv;
-    switch (cmd) {
-    case STREAM_CTRL_GET_BASE_FILENAME:
-        *(char **)arg = talloc_strdup(NULL, rar_file->s->url);
-        return STREAM_OK;
-    case STREAM_CTRL_GET_SIZE:
-        *(int64_t *)arg = rar_file->size;
-        return STREAM_OK;
-    }
-    return STREAM_UNSUPPORTED;
-}
-
-static int rar_entry_open(stream_t *stream)
-{
-    if (!strchr(stream->path, '|'))
-        return STREAM_ERROR;
-
-    char *base = talloc_strdup(stream, stream->path);
-    char *name = strchr(base, '|');
-    *name++ = '\0';
-    mp_url_unescape_inplace(base);
-
-    struct stream *rar = stream_create(base, STREAM_READ | STREAM_SAFE_ONLY,
-                                       stream->cancel, stream->global);
-    if (!rar)
-        return STREAM_ERROR;
-
-    int count;
-    rar_file_t **files;
-    if (RarProbe(rar) || RarParse(rar, &count, &files)) {
-        free_stream(rar);
-        return STREAM_ERROR;
-    }
-
-    rar_file_t *file = NULL;
-    for (int i = 0; i < count; i++) {
-        if (!file && strcmp(files[i]->name, name) == 0)
-            file = files[i];
-        else
-            RarFileDelete(files[i]);
-    }
-    talloc_free(files);
-    if (!file) {
-        free_stream(rar);
-        return STREAM_ERROR;
-    }
-
-    rar_file_chunk_t dummy = {
-        .mrl = base,
-    };
-    file->current_chunk = &dummy;
-    file->s = rar; // transfer ownership
-    file->cancel = stream->cancel;
-    file->global = stream->global;
-    RarSeek(file, 0);
-
-    stream->priv = file;
-    stream->fill_buffer = rar_entry_fill_buffer;
-    stream->seek = rar_entry_seek;
-    stream->seekable = true;
-    stream->close = rar_entry_close;
-    stream->control = rar_entry_control;
-
-    return STREAM_OK;
-}
-
-const stream_info_t stream_info_rar = {
-    .name = "rar",
-    .open = rar_entry_open,
-    .protocols = (const char*const[]){ "rar", NULL },
-};
diff -ruN mpv-0.29.1/stream/stream_smb.c mpv-master/stream/stream_smb.c
--- mpv-0.29.1/stream/stream_smb.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_smb.c	2019-09-19 04:02:03.000000000 +0700
@@ -43,6 +43,7 @@
              char *password, int pwmaxlen)
 {
   strncpy(workgroup, "LAN", wgmaxlen - 1);
+  workgroup[wgmaxlen - 1] = '\0';
 }
 
 static int control(stream_t *s, int cmd, void *arg) {
@@ -84,18 +85,11 @@
 
 static int write_buffer(stream_t *s, char* buffer, int len) {
   struct priv *p = s->priv;
-  int r = len;
   int wr;
-  while (r > 0) {
-    pthread_mutex_lock(&smb_lock);
-    wr = smbc_write(p->fd,buffer,r);
-    pthread_mutex_unlock(&smb_lock);
-    if (wr <= 0)
-      return -1;
-    r -= wr;
-    buffer += wr;
-  }
-  return len - r;
+  pthread_mutex_lock(&smb_lock);
+  wr = smbc_write(p->fd,buffer,len);
+  pthread_mutex_unlock(&smb_lock);
+  return wr;
 }
 
 static void close_f(stream_t *s){
diff -ruN mpv-0.29.1/stream/stream_tv.c mpv-master/stream/stream_tv.c
--- mpv-0.29.1/stream/stream_tv.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/stream_tv.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,53 +0,0 @@
-/*
- * stream layer for TV Input, based on previous work from Albeu
- *
- * Copyright (C) 2006 Benjamin Zores
- * Original author: Albeu
- *
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "config.h"
-
-#include <stdlib.h>
-#include <string.h>
-
-#include "stream.h"
-#include "options/m_option.h"
-#include "tv.h"
-
-#include <stdio.h>
-
-static void
-tv_stream_close (stream_t *stream)
-{
-}
-static int
-tv_stream_open (stream_t *stream)
-{
-
-  stream->close=tv_stream_close;
-  stream->demuxer = "tv";
-  stream->allow_caching = false;
-
-  return STREAM_OK;
-}
-
-const stream_info_t stream_info_tv = {
-  .name = "tv",
-  .open = tv_stream_open,
-  .protocols = (const char*const[]){ "tv", NULL },
-};
diff -ruN mpv-0.29.1/stream/tv.c mpv-master/stream/tv.c
--- mpv-0.29.1/stream/tv.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/tv.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,986 +0,0 @@
-/*
- * TV Interface for MPlayer
- *
- * API idea based on libvo2
- *
- * Copyright (C) 2001 Alex Beregszaszi
- *
- * Feb 19, 2002: Significant rewrites by Charles R. Henrich (henrich@msu.edu)
- *               to add support for audio, and bktr *BSD support.
- *
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <strings.h>
-#include <sys/time.h>
-#include <assert.h>
-#include <libavutil/avstring.h>
-
-#include "config.h"
-
-
-#include "common/msg.h"
-#include "misc/ctype.h"
-
-#include "options/m_option.h"
-#include "options/m_config.h"
-#include "options/options.h"
-
-#include "stream.h"
-
-#include "audio/format.h"
-#include "osdep/timer.h"
-
-#include "tv.h"
-
-#include "frequencies.h"
-
-/* enumerating drivers (like in stream.c) */
-extern const tvi_info_t tvi_info_dummy;
-extern const tvi_info_t tvi_info_v4l2;
-
-/** List of drivers in autodetection order */
-static const tvi_info_t *const tvi_driver_list[]={
-#if HAVE_TV_V4L2
-    &tvi_info_v4l2,
-#endif
-    &tvi_info_dummy,
-    NULL
-};
-
-#define OPT_BASE_STRUCT tv_param_t
-const struct m_sub_options tv_params_conf = {
-    .opts = (const m_option_t[]) {
-        OPT_FLAG("immediatemode", immediate, 0),
-        OPT_FLAG("audio", audio, 0),
-        OPT_INT("audiorate", audiorate, 0),
-        OPT_STRING("driver", driver, 0),
-        OPT_STRING("device", device, 0),
-        OPT_FLOAT("freq", freq, 0),
-        OPT_STRING("channel", channel, 0),
-        OPT_STRING("chanlist", chanlist, 0),
-        OPT_STRING("norm", norm, 0),
-        OPT_INTRANGE("automute", automute, 0, 0, 255),
-#if HAVE_TV_V4L2
-        OPT_INT("normid", normid, 0),
-#endif
-        OPT_INTRANGE("width", width, 0, 0, 4096),
-        OPT_INTRANGE("height", height, 0, 0, 4096),
-        OPT_INT("input", input, 0),
-        OPT_GENERAL(int, "outfmt", outfmt, 0, .type = &m_option_type_fourcc),
-        OPT_FLOAT("fps", fps, 0),
-        OPT_STRINGLIST("channels", channels, 0),
-        OPT_INTRANGE("brightness", brightness, 0, -100, 100),
-        OPT_INTRANGE("contrast", contrast, 0, -100, 100),
-        OPT_INTRANGE("hue", hue, 0, -100, 100),
-        OPT_INTRANGE("saturation", saturation, 0, -100, 100),
-        OPT_INTRANGE("gain", gain, 0, -1, 100),
-#if HAVE_TV_V4L2
-        OPT_INTRANGE("amode", amode, 0, 0, 3),
-        OPT_INTRANGE("volume", volume, 0, 0, 65535),
-        OPT_INTRANGE("bass", bass, 0, 0, 65535),
-        OPT_INTRANGE("treble", treble, 0, 0, 65535),
-        OPT_INTRANGE("balance", balance, 0, 0, 65535),
-        OPT_INTRANGE("forcechan", forcechan, 0, 1, 2),
-        OPT_FLAG("forceaudio", force_audio, 0),
-        OPT_INTRANGE("buffersize", buffer_size, 0, 16, 1024),
-        OPT_FLAG("mjpeg", mjpeg, 0),
-        OPT_INTRANGE("decimation", decimation, 0, 1, 4),
-        OPT_INTRANGE("quality", quality, 0, 0, 100),
-#if HAVE_ALSA
-        OPT_FLAG("alsa", alsa, 0),
-#endif /* HAVE_ALSA */
-#endif /* HAVE_TV_V4L2 */
-        OPT_STRING("adevice", adevice, 0),
-        OPT_INTRANGE("audioid", audio_id, 0, 0, 9),
-        OPT_FLAG("scan-autostart", scan, 0),
-        OPT_INTRANGE("scan-threshold", scan_threshold, 0, 1, 100),
-        OPT_FLOATRANGE("scan-period", scan_period, 0, 0.1, 2.0),
-        {0}
-    },
-    .size = sizeof(tv_param_t),
-    .defaults = &(const tv_param_t){
-        .chanlist = "europe-east",
-        .norm = "pal",
-        .normid = -1,
-        .width = -1,
-        .height = -1,
-        .outfmt = -1,
-        .fps = -1.0,
-        .audio = 1,
-        .immediate = 1,
-        .audiorate = 44100,
-        .amode = -1,
-        .volume = -1,
-        .bass = -1,
-        .treble = -1,
-        .balance = -1,
-        .forcechan = -1,
-        .buffer_size = -1,
-        .decimation = 2,
-        .quality = 90,
-        .gain =  -1,
-        .scan_threshold = 50,
-        .scan_period = 0.5,
-    },
-};
-
-tvi_handle_t *tv_new_handle(int size, struct mp_log *log, const tvi_functions_t *functions)
-{
-    tvi_handle_t *h = calloc(1, sizeof(*h));
-
-    if (!h)
-        return NULL;
-
-    h->priv = calloc(1, size);
-
-    if (!h->priv) {
-        free(h);
-        return NULL;
-    }
-
-    h->log        = log;
-    h->functions  = functions;
-    h->chanlist   = -1;
-    h->norm       = -1;
-    h->channel    = -1;
-
-    return h;
-}
-
-void tv_free_handle(tvi_handle_t *h)
-{
-    if (!h)
-        return;
-    free(h->priv);
-    free(h->scan);
-    free(h);
-}
-
-void tv_start_scan(tvi_handle_t *tvh, int start)
-{
-    MP_INFO(tvh, "start scan\n");
-    tvh->tv_param->scan=start?1:0;
-}
-
-static int tv_set_freq_float(tvi_handle_t *tvh, float freq)
-{
-    return tv_set_freq(tvh, freq/1000.0*16);
-}
-
-void tv_scan(tvi_handle_t *tvh)
-{
-    unsigned int now;
-    struct CHANLIST cl;
-    tv_channels_t *tv_channel_tmp=NULL;
-    tv_channels_t *tv_channel_add=NULL;
-    tv_scan_t* scan;
-    int found=0, index=1;
-
-    //Channel scanner without tuner is useless and causes crash due to uninitialized chanlist_s
-    if (tvh->functions->control(tvh->priv, TVI_CONTROL_IS_TUNER, 0) != TVI_CONTROL_TRUE)
-    {
-        MP_WARN(tvh, "Channel scanner is not available without tuner\n");
-        tvh->tv_param->scan=0;
-        return;
-    }
-
-    scan = tvh->scan;
-    now=(unsigned int)mp_time_us();
-    if (!scan) {
-        scan=calloc(1,sizeof(tv_scan_t));
-        tvh->scan=scan;
-        cl = tvh->chanlist_s[scan->channel_num];
-        tv_set_freq_float(tvh, cl.freq);
-        scan->scan_timer=now+1e6*tvh->tv_param->scan_period;
-    }
-    if(scan->scan_timer>now)
-        return;
-
-    if (tv_get_signal(tvh)>tvh->tv_param->scan_threshold) {
-        cl = tvh->chanlist_s[scan->channel_num];
-        tv_channel_tmp=tvh->tv_channel_list;
-        while (tv_channel_tmp) {
-            index++;
-            if (cl.freq==tv_channel_tmp->freq){
-                found=1;
-                break;
-            }
-            tv_channel_add=tv_channel_tmp;
-            tv_channel_tmp=tv_channel_tmp->next;
-        }
-        if (!found) {
-            MP_INFO(tvh, "Found new channel: %s (#%d). \n",cl.name,index);
-            scan->new_channels++;
-            tv_channel_tmp = malloc(sizeof(tv_channels_t));
-            tv_channel_tmp->index=index;
-            tv_channel_tmp->next=NULL;
-            tv_channel_tmp->prev=tv_channel_add;
-            tv_channel_tmp->freq=cl.freq;
-            snprintf(tv_channel_tmp->name,sizeof(tv_channel_tmp->name),"ch%d",index);
-            strncpy(tv_channel_tmp->number, cl.name, 5);
-            tv_channel_tmp->number[4]='\0';
-            if (!tvh->tv_channel_list)
-                tvh->tv_channel_list=tv_channel_tmp;
-            else {
-                tv_channel_add->next=tv_channel_tmp;
-                tvh->tv_channel_list->prev=tv_channel_tmp;
-            }
-        }else
-            MP_INFO(tvh, "Found existing channel: %s-%s.\n",
-                tv_channel_tmp->number,tv_channel_tmp->name);
-    }
-    scan->channel_num++;
-    scan->scan_timer=now+1e6*tvh->tv_param->scan_period;
-    if (scan->channel_num>=chanlists[tvh->chanlist].count) {
-        tvh->tv_param->scan=0;
-        MP_INFO(tvh, "TV scan end. Found %d new channels.\n", scan->new_channels);
-        tv_channel_tmp=tvh->tv_channel_list;
-        if(tv_channel_tmp){
-            MP_INFO(tvh, "channels=");
-            while(tv_channel_tmp){
-                MP_INFO(tvh, "%s-%s",tv_channel_tmp->number,tv_channel_tmp->name);
-                if(tv_channel_tmp->next)
-                    MP_INFO(tvh, ",");
-                tv_channel_tmp=tv_channel_tmp->next;
-            }
-            MP_INFO(tvh, "\n");
-        }
-        if (!tvh->tv_channel_current) tvh->tv_channel_current=tvh->tv_channel_list;
-        if (tvh->tv_channel_current)
-            tv_set_freq_float(tvh, tvh->tv_channel_current->freq);
-        free(tvh->scan);
-        tvh->scan=NULL;
-    }else{
-        cl = tvh->chanlist_s[scan->channel_num];
-        tv_set_freq_float(tvh, cl.freq);
-        MP_INFO(tvh, "Trying: %s (%.2f). \n",cl.name,1e-3*cl.freq);
-    }
-}
-
-static int norm_from_string(tvi_handle_t *tvh, char* norm)
-{
-    const tvi_functions_t *funcs = tvh->functions;
-    char str[20];
-    int ret;
-
-    strncpy(str, norm, sizeof(str)-1);
-    str[sizeof(str)-1] = '\0';
-    ret=funcs->control(tvh->priv, TVI_CONTROL_SPC_GET_NORMID, str);
-
-    if (ret == TVI_CONTROL_TRUE) {
-        int *v = (int *)str;
-        return *v;
-    }
-
-    if(ret!=TVI_CONTROL_UNKNOWN)
-    {
-        MP_WARN(tvh, "tv.c: norm_from_string(%s): Bogus norm parameter, setting %s.\n", norm,"default");
-        return 0;
-    }
-
-    if (!strcasecmp(norm, "pal"))
-        return TV_NORM_PAL;
-    else if (!strcasecmp(norm, "ntsc"))
-        return TV_NORM_NTSC;
-    else if (!strcasecmp(norm, "secam"))
-        return TV_NORM_SECAM;
-    else if (!strcasecmp(norm, "palnc"))
-        return TV_NORM_PALNC;
-    else if (!strcasecmp(norm, "palm"))
-        return TV_NORM_PALM;
-    else if (!strcasecmp(norm, "paln"))
-        return TV_NORM_PALN;
-    else if (!strcasecmp(norm, "ntscjp"))
-        return TV_NORM_NTSCJP;
-    else {
-        MP_WARN(tvh, "tv.c: norm_from_string(%s): Bogus norm parameter, setting %s.\n", norm, "PAL");
-        return TV_NORM_PAL;
-    }
-}
-
-static void parse_channels(tvi_handle_t *tvh)
-{
-    char** channels = tvh->tv_param->channels;
-
-    MP_INFO(tvh, "TV channel names detected.\n");
-    tvh->tv_channel_list = malloc(sizeof(tv_channels_t));
-    tvh->tv_channel_list->index=1;
-    tvh->tv_channel_list->next=NULL;
-    tvh->tv_channel_list->prev=NULL;
-    tvh->tv_channel_current = tvh->tv_channel_list;
-    tvh->tv_channel_current->norm = tvh->norm;
-
-    while (*channels) {
-        char* tmp = *(channels++);
-        char* sep = strchr(tmp,'-');
-        int i;
-        struct CHANLIST cl;
-
-        if (!sep) continue; // Wrong syntax, but mplayer should not crash
-
-        av_strlcpy(tvh->tv_channel_current->name, sep + 1,
-                        sizeof(tvh->tv_channel_current->name));
-        sep[0] = '\0';
-        strncpy(tvh->tv_channel_current->number, tmp, 5);
-        tvh->tv_channel_current->number[4]='\0';
-
-        while ((sep=strchr(tvh->tv_channel_current->name, '_')))
-            sep[0] = ' ';
-
-        // if channel number is a number and larger than 1000 threat it as frequency
-        // tmp still contain pointer to null-terminated string with channel number here
-        if (atoi(tmp)>1000){
-            tvh->tv_channel_current->freq=atoi(tmp);
-        }else{
-            tvh->tv_channel_current->freq = 0;
-            for (i = 0; i < chanlists[tvh->chanlist].count; i++) {
-                cl = tvh->chanlist_s[i];
-                if (!strcasecmp(cl.name, tvh->tv_channel_current->number)) {
-                    tvh->tv_channel_current->freq=cl.freq;
-                    break;
-                }
-            }
-        }
-        if (tvh->tv_channel_current->freq == 0)
-            MP_ERR(tvh, "Couldn't find frequency for channel %s (%s)\n",
-                            tvh->tv_channel_current->number, tvh->tv_channel_current->name);
-        else {
-          sep = strchr(tvh->tv_channel_current->name, '-');
-          if ( !sep ) sep = strchr(tvh->tv_channel_current->name, '+');
-
-          if ( sep ) {
-            i = atoi (sep+1);
-            if ( sep[0] == '+' ) tvh->tv_channel_current->freq += i * 100;
-            if ( sep[0] == '-' ) tvh->tv_channel_current->freq -= i * 100;
-            sep[0] = '\0';
-          }
-
-          sep = strchr(tvh->tv_channel_current->name, '=');
-          if ( sep ) {
-            tvh->tv_channel_current->norm = norm_from_string(tvh, sep+1);
-            sep[0] = '\0';
-          }
-        }
-
-        /*MP_INFO(tvh, "-- Detected channel %s - %s (%5.3f)\n",
-                        tvh->tv_channel_current->number, tvh->tv_channel_current->name,
-                        (float)tvh->tv_channel_current->freq/1000);*/
-
-        tvh->tv_channel_current->next = malloc(sizeof(tv_channels_t));
-        tvh->tv_channel_current->next->index = tvh->tv_channel_current->index + 1;
-        tvh->tv_channel_current->next->prev = tvh->tv_channel_current;
-        tvh->tv_channel_current->next->next = NULL;
-        tvh->tv_channel_current = tvh->tv_channel_current->next;
-        tvh->tv_channel_current->norm = tvh->norm;
-    }
-    if (tvh->tv_channel_current->prev)
-        tvh->tv_channel_current->prev->next = NULL;
-    free(tvh->tv_channel_current);
-}
-
-int tv_set_norm(tvi_handle_t *tvh, char* norm)
-{
-    tvh->norm = norm_from_string(tvh, norm);
-
-    MP_VERBOSE(tvh, "Selected norm : %s\n", norm);
-    if (tvh->functions->control(tvh->priv, TVI_CONTROL_TUN_SET_NORM, &tvh->norm) != TVI_CONTROL_TRUE) {
-        MP_ERR(tvh, "Error: Cannot set norm!\n");
-        return 0;
-    }
-    return 1;
-}
-
-static int tv_set_norm_i(tvi_handle_t *tvh, int norm)
-{
-   tvh->norm = norm;
-
-   MP_VERBOSE(tvh, "Selected norm id: %d\n", norm);
-   if (tvh->functions->control(tvh->priv, TVI_CONTROL_TUN_SET_NORM, &tvh->norm) != TVI_CONTROL_TRUE) {
-      MP_ERR(tvh, "Error: Cannot set norm!\n");
-      return 0;
-   }
-
-   return 1;
-}
-
-static void set_norm_and_freq(tvi_handle_t *tvh, tv_channels_t *chan)
-{
-    MP_INFO(tvh, "Selected channel: %s - %s (freq: %.3f)\n",
-           chan->number, chan->name, chan->freq/1000.0);
-    tv_set_norm_i(tvh, chan->norm);
-    tv_set_freq_float(tvh, chan->freq);
-}
-
-int open_tv(tvi_handle_t *tvh)
-{
-    int i;
-    const tvi_functions_t *funcs = tvh->functions;
-    static const int tv_fmt_list[] = {
-      MP_FOURCC_YV12,
-      MP_FOURCC_I420,
-      MP_FOURCC_UYVY,
-      MP_FOURCC_YUY2,
-      MP_FOURCC_RGB32,
-      MP_FOURCC_RGB24,
-      MP_FOURCC_RGB16,
-      MP_FOURCC_RGB15
-    };
-
-    if (funcs->control(tvh->priv, TVI_CONTROL_IS_VIDEO, 0) != TVI_CONTROL_TRUE)
-    {
-        MP_ERR(tvh, "Error: No video input present!\n");
-        return 0;
-    }
-
-    if (tvh->tv_param->outfmt == -1)
-      for (i = 0; i < sizeof (tv_fmt_list) / sizeof (*tv_fmt_list); i++)
-        {
-          tvh->tv_param->outfmt = tv_fmt_list[i];
-          if (funcs->control (tvh->priv, TVI_CONTROL_VID_SET_FORMAT,
-                              &tvh->tv_param->outfmt) == TVI_CONTROL_TRUE)
-            break;
-        }
-    else
-    {
-    switch(tvh->tv_param->outfmt)
-    {
-        case MP_FOURCC_YV12:
-        case MP_FOURCC_I420:
-        case MP_FOURCC_UYVY:
-        case MP_FOURCC_YUY2:
-        case MP_FOURCC_RGB32:
-        case MP_FOURCC_RGB24:
-        case MP_FOURCC_BGR32:
-        case MP_FOURCC_BGR24:
-        case MP_FOURCC_BGR16:
-        case MP_FOURCC_BGR15:
-            break;
-        default:
-            MP_ERR(tvh, "==================================================================\n"\
-                        " WARNING: UNTESTED OR UNKNOWN OUTPUT IMAGE FORMAT REQUESTED (0x%x)\n"\
-                        " This may cause buggy playback or program crash! Bug reports will\n"\
-                        " be ignored! You should try again with YV12 (which is the default\n"\
-                        " colorspace) and read the documentation!\n"\
-                        "==================================================================\n"
-                ,tvh->tv_param->outfmt);
-    }
-    funcs->control(tvh->priv, TVI_CONTROL_VID_SET_FORMAT, &tvh->tv_param->outfmt);
-    }
-
-    /* set some params got from cmdline */
-    funcs->control(tvh->priv, TVI_CONTROL_SPC_SET_INPUT, &tvh->tv_param->input);
-
-    if ((!strcmp(tvh->tv_param->driver, "v4l2") && tvh->tv_param->normid >= 0))
-        tv_set_norm_i(tvh, tvh->tv_param->normid);
-    else
-        tv_set_norm(tvh,tvh->tv_param->norm);
-
-    /* limits on w&h are norm-dependent -- JM */
-    if (tvh->tv_param->width != -1 && tvh->tv_param->height != -1) {
-        // first tell the driver both width and height, some drivers do not support setting them independently.
-        int dim[2];
-        dim[0] = tvh->tv_param->width; dim[1] = tvh->tv_param->height;
-        funcs->control(tvh->priv, TVI_CONTROL_VID_SET_WIDTH_HEIGHT, dim);
-    }
-    /* set width */
-    if (tvh->tv_param->width != -1)
-    {
-        if (funcs->control(tvh->priv, TVI_CONTROL_VID_CHK_WIDTH, &tvh->tv_param->width) == TVI_CONTROL_TRUE)
-            funcs->control(tvh->priv, TVI_CONTROL_VID_SET_WIDTH, &tvh->tv_param->width);
-        else
-        {
-            MP_ERR(tvh, "Unable to set requested width: %d\n", tvh->tv_param->width);
-            funcs->control(tvh->priv, TVI_CONTROL_VID_GET_WIDTH, &tvh->tv_param->width);
-        }
-    }
-
-    /* set height */
-    if (tvh->tv_param->height != -1)
-    {
-        if (funcs->control(tvh->priv, TVI_CONTROL_VID_CHK_HEIGHT, &tvh->tv_param->height) == TVI_CONTROL_TRUE)
-            funcs->control(tvh->priv, TVI_CONTROL_VID_SET_HEIGHT, &tvh->tv_param->height);
-        else
-        {
-            MP_ERR(tvh, "Unable to set requested height: %d\n", tvh->tv_param->height);
-            funcs->control(tvh->priv, TVI_CONTROL_VID_GET_HEIGHT, &tvh->tv_param->height);
-        }
-    }
-
-    if (funcs->control(tvh->priv, TVI_CONTROL_IS_TUNER, 0) != TVI_CONTROL_TRUE)
-    {
-        MP_WARN(tvh, "Selected input hasn't got a tuner!\n");
-        goto done;
-    }
-
-    /* select channel list */
-    for (i = 0; chanlists[i].name != NULL; i++)
-    {
-        if (!strcasecmp(chanlists[i].name, tvh->tv_param->chanlist))
-        {
-            tvh->chanlist = i;
-            tvh->chanlist_s = chanlists[i].list;
-            break;
-        }
-    }
-
-    if (tvh->chanlist == -1) {
-        MP_WARN(tvh, "Unable to find selected channel list! (%s)\n",
-            tvh->tv_param->chanlist);
-        return 0;
-    } else
-        MP_VERBOSE(tvh, "Selected channel list: %s (including %d channels)\n",
-            chanlists[tvh->chanlist].name, chanlists[tvh->chanlist].count);
-
-    if (tvh->tv_param->freq && tvh->tv_param->channel)
-    {
-        MP_WARN(tvh, "You can't set frequency and channel simultaneously!\n");
-        goto done;
-    }
-
-    /* Handle channel names */
-    if (tvh->tv_param->channels) {
-        parse_channels(tvh);
-    } else
-            tvh->tv_channel_last_real = malloc(5);
-
-    if (tvh->tv_channel_list) {
-        int channel = 0;
-        if (tvh->tv_param->channel)
-         {
-           if (mp_isdigit(*tvh->tv_param->channel))
-                /* if tvh->tv_param->channel begins with a digit interpret it as a number */
-                channel = atoi(tvh->tv_param->channel);
-           else
-              {
-                /* if tvh->tv_param->channel does not begin with a digit
-                   set the first channel that contains tvh->tv_param->channel in its name */
-
-                tvh->tv_channel_current = tvh->tv_channel_list;
-                while ( tvh->tv_channel_current ) {
-                        if ( strstr(tvh->tv_channel_current->name, tvh->tv_param->channel) )
-                          break;
-                        tvh->tv_channel_current = tvh->tv_channel_current->next;
-                        }
-                if ( !tvh->tv_channel_current ) tvh->tv_channel_current = tvh->tv_channel_list;
-              }
-         }
-        else
-                channel = 1;
-
-        if ( channel ) {
-        tvh->tv_channel_current = tvh->tv_channel_list;
-        for (int n = 1; n < channel; n++)
-                if (tvh->tv_channel_current->next)
-                        tvh->tv_channel_current = tvh->tv_channel_current->next;
-        }
-
-        set_norm_and_freq(tvh, tvh->tv_channel_current);
-        tvh->tv_channel_last = tvh->tv_channel_current;
-    } else {
-    /* we need to set frequency */
-    if (tvh->tv_param->freq)
-    {
-        unsigned long freq = tvh->tv_param->freq * 16;
-
-        /* set freq in MHz */
-        funcs->control(tvh->priv, TVI_CONTROL_TUN_SET_FREQ, &freq);
-
-        funcs->control(tvh->priv, TVI_CONTROL_TUN_GET_FREQ, &freq);
-        MP_VERBOSE(tvh, "Selected frequency: %lu (%.3f)\n",
-            freq, freq/16.0);
-    }
-
-            if (tvh->tv_param->channel) {
-        struct CHANLIST cl;
-
-        MP_VERBOSE(tvh, "Requested channel: %s\n", tvh->tv_param->channel);
-        for (i = 0; i < chanlists[tvh->chanlist].count; i++)
-        {
-            cl = tvh->chanlist_s[i];
-                    //  printf("count%d: name: %s, freq: %d\n",
-                    //  i, cl.name, cl.freq);
-            if (!strcasecmp(cl.name, tvh->tv_param->channel))
-            {
-                        strcpy(tvh->tv_channel_last_real, cl.name);
-                tvh->channel = i;
-                MP_INFO(tvh, "Selected channel: %s (freq: %.3f)\n",
-                    cl.name, cl.freq/1000.0);
-                tv_set_freq_float(tvh, cl.freq);
-                break;
-            }
-        }
-    }
-    }
-
-    /* grep frequency in chanlist */
-    {
-        unsigned long i2 = 0;
-        int freq;
-
-        tv_get_freq(tvh, &i2);
-
-        freq = (int) (((float)(i2/16))*1000)+250;
-
-        for (i = 0; i < chanlists[tvh->chanlist].count; i++)
-        {
-            if (tvh->chanlist_s[i].freq == freq)
-            {
-                tvh->channel = i+1;
-                break;
-            }
-        }
-    }
-
-done:
-    /* also start device! */
-        return 1;
-}
-
-tvi_handle_t *tv_begin(tv_param_t* tv_param, struct mp_log *log)
-{
-    int i;
-    tvi_handle_t* h;
-    if(tv_param->driver && !strcmp(tv_param->driver,"help")){
-        mp_info(log, "Available drivers:\n");
-        for(i=0;tvi_driver_list[i];i++){
-            mp_info(log, " %s\t%s\n",tvi_driver_list[i]->short_name,tvi_driver_list[i]->name);
-        }
-        return NULL;
-    }
-
-    for(i=0;tvi_driver_list[i];i++){
-        if (!tv_param->driver || !strcmp(tvi_driver_list[i]->short_name, tv_param->driver)){
-            h=tvi_driver_list[i]->tvi_init(log, tv_param);
-            //Requested driver initialization failed
-            if (!h && tv_param->driver)
-                return NULL;
-            //Driver initialization failed during autodetection process.
-            if (!h)
-                continue;
-
-            h->tv_param=tv_param;
-            MP_INFO(h, "Selected driver: %s\n name: %s\n", tvi_driver_list[i]->short_name,
-            tvi_driver_list[i]->name);
-            talloc_free(tv_param->driver);
-            tv_param->driver=talloc_strdup(NULL, tvi_driver_list[i]->short_name);
-            return h;
-        }
-    }
-
-    if(tv_param->driver)
-        mp_err(log, "No such driver: %s\n", tv_param->driver);
-    else
-        mp_err(log, "TV driver autodetection failed.\n");
-    return NULL;
-}
-
-int tv_uninit(tvi_handle_t *tvh)
-{
-    int res;
-    if(!tvh) return 1;
-    if (!tvh->priv) return 1;
-    res=tvh->functions->uninit(tvh->priv);
-    if(res) {
-        free(tvh->priv);
-        tvh->priv=NULL;
-    }
-    return res;
-}
-
-int tv_set_color_options(tvi_handle_t *tvh, int opt, int value)
-{
-    const tvi_functions_t *funcs = tvh->functions;
-
-    switch(opt)
-    {
-        case TV_COLOR_BRIGHTNESS:
-            return funcs->control(tvh->priv, TVI_CONTROL_VID_SET_BRIGHTNESS, &value);
-        case TV_COLOR_HUE:
-            return funcs->control(tvh->priv, TVI_CONTROL_VID_SET_HUE, &value);
-        case TV_COLOR_SATURATION:
-            return funcs->control(tvh->priv, TVI_CONTROL_VID_SET_SATURATION, &value);
-        case TV_COLOR_CONTRAST:
-            return funcs->control(tvh->priv, TVI_CONTROL_VID_SET_CONTRAST, &value);
-        default:
-            MP_WARN(tvh, "Unknown color option (%d) specified!\n", opt);
-    }
-
-    return TVI_CONTROL_UNKNOWN;
-}
-
-int tv_get_color_options(tvi_handle_t *tvh, int opt, int* value)
-{
-    const tvi_functions_t *funcs = tvh->functions;
-
-    switch(opt)
-    {
-        case TV_COLOR_BRIGHTNESS:
-            return funcs->control(tvh->priv, TVI_CONTROL_VID_GET_BRIGHTNESS, value);
-        case TV_COLOR_HUE:
-            return funcs->control(tvh->priv, TVI_CONTROL_VID_GET_HUE, value);
-        case TV_COLOR_SATURATION:
-            return funcs->control(tvh->priv, TVI_CONTROL_VID_GET_SATURATION, value);
-        case TV_COLOR_CONTRAST:
-            return funcs->control(tvh->priv, TVI_CONTROL_VID_GET_CONTRAST, value);
-        default:
-            MP_WARN(tvh, "Unknown color option (%d) specified!\n", opt);
-    }
-
-    return TVI_CONTROL_UNKNOWN;
-}
-
-int tv_get_freq(tvi_handle_t *tvh, unsigned long *freq)
-{
-    if (tvh->functions->control(tvh->priv, TVI_CONTROL_IS_TUNER, 0) == TVI_CONTROL_TRUE)
-    {
-        tvh->functions->control(tvh->priv, TVI_CONTROL_TUN_GET_FREQ, freq);
-        MP_VERBOSE(tvh, "Current frequency: %lu (%.3f)\n",
-            *freq, *freq/16.0);
-    }
-    return 1;
-}
-
-int tv_set_freq(tvi_handle_t *tvh, unsigned long freq)
-{
-    if (tvh->functions->control(tvh->priv, TVI_CONTROL_IS_TUNER, 0) == TVI_CONTROL_TRUE)
-    {
-//      unsigned long freq = atof(tvh->tv_param->freq)*16;
-
-        /* set freq in MHz */
-        tvh->functions->control(tvh->priv, TVI_CONTROL_TUN_SET_FREQ, &freq);
-
-        tvh->functions->control(tvh->priv, TVI_CONTROL_TUN_GET_FREQ, &freq);
-        MP_VERBOSE(tvh, "Current frequency: %lu (%.3f)\n",
-            freq, freq/16.0);
-    }
-    return 1;
-}
-
-int tv_get_signal(tvi_handle_t *tvh)
-{
-    int signal=0;
-    if (tvh->functions->control(tvh->priv, TVI_CONTROL_IS_TUNER, 0) != TVI_CONTROL_TRUE ||
-        tvh->functions->control(tvh->priv, TVI_CONTROL_TUN_GET_SIGNAL, &signal)!=TVI_CONTROL_TRUE)
-        return 0;
-
-    return signal;
-}
-
-/*****************************************************************
- * \brief tune current frequency by step_interval value
- * \parameter step_interval increment value in 1/16 MHz
- * \note frequency is rounded to 1/16 MHz value
- * \return 1
- *
- */
-int tv_step_freq(tvi_handle_t* tvh, float step_interval){
-    unsigned long frequency = 0;
-
-    tvh->tv_param->scan=0;
-    tv_get_freq(tvh,&frequency);
-    frequency+=step_interval;
-    return tv_set_freq(tvh,frequency);
-}
-
-int tv_step_channel_real(tvi_handle_t *tvh, int direction)
-{
-    struct CHANLIST cl;
-
-    tvh->tv_param->scan=0;
-    if (direction == TV_CHANNEL_LOWER)
-    {
-        if (tvh->channel-1 >= 0)
-        {
-            strcpy(tvh->tv_channel_last_real, tvh->chanlist_s[tvh->channel].name);
-            cl = tvh->chanlist_s[--tvh->channel];
-            MP_INFO(tvh, "Selected channel: %s (freq: %.3f)\n",
-                cl.name, cl.freq/1000.0);
-            tv_set_freq_float(tvh, cl.freq);
-        }
-    }
-
-    if (direction == TV_CHANNEL_HIGHER)
-    {
-        if (tvh->channel+1 < chanlists[tvh->chanlist].count)
-        {
-            strcpy(tvh->tv_channel_last_real, tvh->chanlist_s[tvh->channel].name);
-            cl = tvh->chanlist_s[++tvh->channel];
-            MP_INFO(tvh, "Selected channel: %s (freq: %.3f)\n",
-                cl.name, cl.freq/1000.0);
-            tv_set_freq_float(tvh, cl.freq);
-        }
-    }
-    return 1;
-}
-
-int tv_step_channel(tvi_handle_t *tvh, int direction) {
-        tvh->tv_param->scan=0;
-        if (tvh->tv_channel_list) {
-                if (direction == TV_CHANNEL_HIGHER) {
-                        tvh->tv_channel_last = tvh->tv_channel_current;
-                        if (tvh->tv_channel_current->next)
-                                tvh->tv_channel_current = tvh->tv_channel_current->next;
-                        else
-                                tvh->tv_channel_current = tvh->tv_channel_list;
-                        set_norm_and_freq(tvh, tvh->tv_channel_current);
-                }
-                if (direction == TV_CHANNEL_LOWER) {
-                        tvh->tv_channel_last = tvh->tv_channel_current;
-                        if (tvh->tv_channel_current->prev)
-                                tvh->tv_channel_current = tvh->tv_channel_current->prev;
-                        else
-                                while (tvh->tv_channel_current->next)
-                                        tvh->tv_channel_current = tvh->tv_channel_current->next;
-                        set_norm_and_freq(tvh, tvh->tv_channel_current);
-                }
-        } else tv_step_channel_real(tvh, direction);
-        return 1;
-}
-
-int tv_set_channel_real(tvi_handle_t *tvh, char *channel) {
-        int i;
-        struct CHANLIST cl;
-
-        tvh->tv_param->scan=0;
-        strcpy(tvh->tv_channel_last_real, tvh->chanlist_s[tvh->channel].name);
-        for (i = 0; i < chanlists[tvh->chanlist].count; i++)
-        {
-            cl = tvh->chanlist_s[i];
-//          printf("count%d: name: %s, freq: %d\n",
-//              i, cl.name, cl.freq);
-            if (!strcasecmp(cl.name, channel))
-            {
-                tvh->channel = i;
-                MP_INFO(tvh, "Selected channel: %s (freq: %.3f)\n",
-                    cl.name, cl.freq/1000.0);
-                tv_set_freq_float(tvh, cl.freq);
-                break;
-            }
-        }
-        return 1;
-}
-
-int tv_set_channel(tvi_handle_t *tvh, char *channel) {
-        int i, channel_int;
-
-        tvh->tv_param->scan=0;
-        if (tvh->tv_channel_list) {
-                tvh->tv_channel_last = tvh->tv_channel_current;
-                channel_int = atoi(channel);
-                tvh->tv_channel_current = tvh->tv_channel_list;
-                for (i = 1; i < channel_int; i++)
-                        if (tvh->tv_channel_current->next)
-                                tvh->tv_channel_current = tvh->tv_channel_current->next;
-                set_norm_and_freq(tvh, tvh->tv_channel_current);
-        } else tv_set_channel_real(tvh, channel);
-        return 1;
-}
-
-int tv_last_channel(tvi_handle_t *tvh) {
-
-        tvh->tv_param->scan=0;
-        if (tvh->tv_channel_list) {
-                tv_channels_t *tmp;
-
-                tmp = tvh->tv_channel_last;
-                tvh->tv_channel_last = tvh->tv_channel_current;
-                tvh->tv_channel_current = tmp;
-
-                set_norm_and_freq(tvh, tvh->tv_channel_current);
-        } else {
-                int i;
-                struct CHANLIST cl;
-
-                for (i = 0; i < chanlists[tvh->chanlist].count; i++)
-                {
-                    cl = tvh->chanlist_s[i];
-                    if (!strcasecmp(cl.name, tvh->tv_channel_last_real))
-                    {
-                        strcpy(tvh->tv_channel_last_real, tvh->chanlist_s[tvh->channel].name);
-                        tvh->channel = i;
-                        MP_INFO(tvh, "Selected channel: %s (freq: %.3f)\n",
-                            cl.name, cl.freq/1000.0);
-                        tv_set_freq_float(tvh, cl.freq);
-                        break;
-                    }
-                }
-        }
-        return 1;
-}
-
-int tv_step_norm(tvi_handle_t *tvh)
-{
-  tvh->norm++;
-  if (tvh->functions->control(tvh->priv, TVI_CONTROL_TUN_SET_NORM,
-                              &tvh->norm) != TVI_CONTROL_TRUE) {
-    tvh->norm = 0;
-    if (tvh->functions->control(tvh->priv, TVI_CONTROL_TUN_SET_NORM,
-                                &tvh->norm) != TVI_CONTROL_TRUE) {
-      MP_ERR(tvh, "Error: Cannot set norm!\n");
-      return 0;
-    }
-  }
-    return 1;
-}
-
-int tv_stream_control(tvi_handle_t *tvh, int cmd, void *arg)
-{
-    switch (cmd) {
-    case STREAM_CTRL_TV_SET_SCAN:
-        tv_start_scan(tvh, *(int *)arg);
-        return STREAM_OK;
-    case STREAM_CTRL_SET_TV_FREQ:
-        tv_set_freq(tvh, *(float *)arg * 16.0f);
-        return STREAM_OK;
-    case STREAM_CTRL_GET_TV_FREQ: {
-        unsigned long tmp = 0;
-        tv_get_freq(tvh, &tmp);
-        *(float *)arg = tmp / 16.0f;
-        return STREAM_OK;
-    }
-    case STREAM_CTRL_SET_TV_COLORS:
-        tv_set_color_options(tvh, ((int *)arg)[0], ((int *)arg)[1]);
-        return STREAM_OK;
-    case STREAM_CTRL_GET_TV_COLORS:
-        tv_get_color_options(tvh, ((int *)arg)[0], &((int *)arg)[1]);
-        return STREAM_OK;
-    case STREAM_CTRL_TV_SET_NORM:
-        tv_set_norm(tvh, (char *)arg);
-        return STREAM_OK;
-    case STREAM_CTRL_TV_STEP_NORM:
-        tv_step_norm(tvh);
-        return STREAM_OK;
-    case STREAM_CTRL_TV_SET_CHAN:
-        tv_set_channel(tvh, (char *)arg);
-        return STREAM_OK;
-    case STREAM_CTRL_TV_STEP_CHAN:
-        if (*(int *)arg >= 0) {
-            tv_step_channel(tvh, TV_CHANNEL_HIGHER);
-        } else {
-            tv_step_channel(tvh, TV_CHANNEL_LOWER);
-        }
-        return STREAM_OK;
-    case STREAM_CTRL_TV_LAST_CHAN:
-        tv_last_channel(tvh);
-        return STREAM_OK;
-    }
-    return STREAM_UNSUPPORTED;
-}
diff -ruN mpv-0.29.1/stream/tv.h mpv-master/stream/tv.h
--- mpv-0.29.1/stream/tv.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/tv.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,285 +0,0 @@
-/*
- * TV interface
- *
- * Copyright (C) 2001 Alex Beregszászi
- * Copyright (C) 2007 Attila Ötvös
- * Copyright (C) 2007 Vladimir Voroshilov <voroshil@gmail.com>
- *
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef MPLAYER_TV_H
-#define MPLAYER_TV_H
-
-#include "osdep/endian.h"
-
-#include "config.h"
-#if !HAVE_GPL
-#error GPL only
-#endif
-
-struct mp_log;
-
-typedef struct tv_params {
-    float freq;
-    char *channel;
-    char *chanlist;
-    char *norm;
-    int automute;
-    int normid;
-    char *device;
-    char *driver;
-    int width;
-    int height;
-    int input;
-    int outfmt;
-    float fps;
-    char **channels;
-    int audio;
-    int immediate;
-    int audiorate;
-    int audio_id;
-    int amode;
-    int volume;
-    int bass;
-    int treble;
-    int balance;
-    int forcechan;
-    int force_audio;
-    int buffer_size;
-    int mjpeg;
-    int decimation;
-    int quality;
-    int alsa;
-    char* adevice;
-    int brightness;
-    int contrast;
-    int hue;
-    int saturation;
-    int gain;
-
-    int scan;
-    int scan_threshold;
-    float scan_period;
-} tv_param_t;
-
-struct tv_stream_params {
-    char *channel;
-    int input;
-};
-
-typedef struct tvi_info_s
-{
-    struct tvi_handle_s * (*tvi_init)(struct mp_log *log, tv_param_t* tv_param);
-    const char *name;
-    const char *short_name;
-} tvi_info_t;
-
-
-struct priv;
-
-typedef struct tvi_functions_s
-{
-    int (*init)(struct priv *priv);
-    int (*uninit)(struct priv *priv);
-    int (*control)(struct priv *priv, int cmd, void *arg);
-    int (*start)(struct priv *priv);
-    double (*grab_video_frame)(struct priv *priv, char *buffer, int len);
-    int (*get_video_framesize)(struct priv *priv);
-    double (*grab_audio_frame)(struct priv *priv, char *buffer, int len);
-    int (*get_audio_framesize)(struct priv *priv);
-} tvi_functions_t;
-
-typedef struct tvi_handle_s {
-    struct mp_log       *log;
-    const tvi_functions_t       *functions;
-    void                *priv;
-    int                 seq;
-    struct demuxer      *demuxer;
-
-    /* specific */
-    int                 norm;
-    int                 chanlist;
-    const struct CHANLIST *chanlist_s;
-    int                 channel;
-    tv_param_t          * tv_param;
-    void                * scan;
-
-    struct tv_channels_s *tv_channel_list;
-    struct tv_channels_s *tv_channel_current, *tv_channel_last;
-    char *tv_channel_last_real;
-} tvi_handle_t;
-
-typedef struct tv_channels_s {
-    int index;
-    char number[5];
-    char name[20];
-    int norm;
-    int   freq;
-    struct tv_channels_s *next;
-    struct tv_channels_s *prev;
-} tv_channels_t;
-
-typedef struct {
-    unsigned int     scan_timer;
-    int     channel_num;
-    int     new_channels;
-} tv_scan_t;
-
-#define TVI_CONTROL_FALSE               0
-#define TVI_CONTROL_TRUE                1
-#define TVI_CONTROL_NA                  -1
-#define TVI_CONTROL_UNKNOWN             -2
-
-/* ======================== CONTROLS =========================== */
-
-/* GENERIC controls */
-#define TVI_CONTROL_IS_AUDIO            0x1
-#define TVI_CONTROL_IS_VIDEO            0x2
-#define TVI_CONTROL_IS_TUNER            0x3
-#define TVI_CONTROL_IMMEDIATE           0x4
-
-/* VIDEO controls */
-#define TVI_CONTROL_VID_GET_FPS         0x101
-#define TVI_CONTROL_VID_GET_PLANES      0x102
-#define TVI_CONTROL_VID_GET_BITS        0x103
-#define TVI_CONTROL_VID_CHK_BITS        0x104
-#define TVI_CONTROL_VID_SET_BITS        0x105
-#define TVI_CONTROL_VID_GET_FORMAT      0x106
-#define TVI_CONTROL_VID_CHK_FORMAT      0x107
-#define TVI_CONTROL_VID_SET_FORMAT      0x108
-#define TVI_CONTROL_VID_GET_WIDTH       0x109
-#define TVI_CONTROL_VID_CHK_WIDTH       0x110
-#define TVI_CONTROL_VID_SET_WIDTH       0x111
-#define TVI_CONTROL_VID_GET_HEIGHT      0x112
-#define TVI_CONTROL_VID_CHK_HEIGHT      0x113
-#define TVI_CONTROL_VID_SET_HEIGHT      0x114
-#define TVI_CONTROL_VID_GET_BRIGHTNESS  0x115
-#define TVI_CONTROL_VID_SET_BRIGHTNESS  0x116
-#define TVI_CONTROL_VID_GET_HUE         0x117
-#define TVI_CONTROL_VID_SET_HUE         0x118
-#define TVI_CONTROL_VID_GET_SATURATION  0x119
-#define TVI_CONTROL_VID_SET_SATURATION  0x11a
-#define TVI_CONTROL_VID_GET_CONTRAST    0x11b
-#define TVI_CONTROL_VID_SET_CONTRAST    0x11c
-#define TVI_CONTROL_VID_GET_PICTURE     0x11d
-#define TVI_CONTROL_VID_SET_PICTURE     0x11e
-#define TVI_CONTROL_VID_SET_GAIN        0x11f
-#define TVI_CONTROL_VID_GET_GAIN        0x120
-#define TVI_CONTROL_VID_SET_WIDTH_HEIGHT        0x121
-
-/* TUNER controls */
-#define TVI_CONTROL_TUN_GET_FREQ        0x201
-#define TVI_CONTROL_TUN_SET_FREQ        0x202
-#define TVI_CONTROL_TUN_GET_TUNER       0x203   /* update priv->tuner struct for used input */
-#define TVI_CONTROL_TUN_SET_TUNER       0x204   /* update priv->tuner struct for used input */
-#define TVI_CONTROL_TUN_GET_NORM        0x205
-#define TVI_CONTROL_TUN_SET_NORM        0x206
-#define TVI_CONTROL_TUN_GET_SIGNAL      0x207
-
-/* AUDIO controls */
-#define TVI_CONTROL_AUD_GET_FORMAT      0x301
-#define TVI_CONTROL_AUD_GET_SAMPLERATE  0x302
-#define TVI_CONTROL_AUD_GET_CHANNELS    0x304
-#define TVI_CONTROL_AUD_SET_SAMPLERATE  0x305
-
-/* SPECIFIC controls */
-#define TVI_CONTROL_SPC_GET_INPUT       0x401   /* set input channel (tv,s-video,composite..) */
-#define TVI_CONTROL_SPC_SET_INPUT       0x402   /* set input channel (tv,s-video,composite..) */
-#define TVI_CONTROL_SPC_GET_NORMID      0x403   /* get normid from norm name */
-
-int tv_set_color_options(tvi_handle_t *tvh, int opt, int val);
-int tv_get_color_options(tvi_handle_t *tvh, int opt, int* val);
-
-int tv_step_channel_real(tvi_handle_t *tvh, int direction);
-int tv_step_channel(tvi_handle_t *tvh, int direction);
-#define TV_CHANNEL_LOWER        1
-#define TV_CHANNEL_HIGHER       2
-
-int tv_last_channel(tvi_handle_t *tvh);
-
-int tv_set_channel_real(tvi_handle_t *tvh, char *channel);
-int tv_set_channel(tvi_handle_t *tvh, char *channel);
-
-int tv_step_norm(tvi_handle_t *tvh);
-int tv_step_chanlist(tvi_handle_t *tvh);
-
-int tv_set_freq(tvi_handle_t *tvh, unsigned long freq);
-int tv_get_freq(tvi_handle_t *tvh, unsigned long *freq);
-int tv_get_signal(tvi_handle_t *tvh);
-int tv_step_freq(tvi_handle_t *tvh, float step_interval);
-
-int tv_set_norm(tvi_handle_t *tvh, char* norm);
-
-void tv_start_scan(tvi_handle_t *tvh, int start);
-
-tvi_handle_t *tv_new_handle(int size, struct mp_log *log, const tvi_functions_t *functions);
-void tv_free_handle(tvi_handle_t *h);
-
-#define TV_NORM_PAL             1
-#define TV_NORM_NTSC            2
-#define TV_NORM_SECAM           3
-#define TV_NORM_PALNC           4
-#define TV_NORM_PALM            5
-#define TV_NORM_PALN            6
-#define TV_NORM_NTSCJP          7
-
-int tv_uninit(tvi_handle_t *tvh);
-void tv_scan(tvi_handle_t *tvh);
-int open_tv(tvi_handle_t *tvh);
-tvi_handle_t *tv_begin(tv_param_t* tv_param, struct mp_log *log);
-int tv_stream_control(tvi_handle_t *tvh, int cmd, void *arg);
-
-extern const struct m_sub_options tv_params_conf;
-
-#define MP_FOURCC(a,b,c,d) ((a) | ((b)<<8) | ((c)<<16) | ((unsigned)(d)<<24))
-
-#if BYTE_ORDER == BIG_ENDIAN
-#define MP_FOURCC_E(a,b,c,d) MP_FOURCC(a,b,c,d)
-#else
-#define MP_FOURCC_E(a,b,c,d) MP_FOURCC(d,c,b,a)
-#endif
-
-#define MP_FOURCC_RGB8  MP_FOURCC_E(8,   'B', 'G', 'R')
-#define MP_FOURCC_RGB12 MP_FOURCC_E(12,  'B', 'G', 'R')
-#define MP_FOURCC_RGB15 MP_FOURCC_E(15,  'B', 'G', 'R')
-#define MP_FOURCC_RGB16 MP_FOURCC_E(16,  'B', 'G', 'R')
-#define MP_FOURCC_RGB24 MP_FOURCC_E(24,  'B', 'G', 'R')
-#define MP_FOURCC_RGB32 MP_FOURCC_E('A', 'B', 'G', 'R')
-
-#define MP_FOURCC_BGR8  MP_FOURCC_E(8,   'R', 'G', 'B')
-#define MP_FOURCC_BGR12 MP_FOURCC_E(12,  'R', 'G', 'B')
-#define MP_FOURCC_BGR15 MP_FOURCC_E(15,  'R', 'G', 'B')
-#define MP_FOURCC_BGR16 MP_FOURCC_E(16,  'R', 'G', 'B')
-#define MP_FOURCC_BGR24 MP_FOURCC_E(24,  'R', 'G', 'B')
-#define MP_FOURCC_BGR32 MP_FOURCC_E('A', 'R', 'G', 'B')
-
-#define MP_FOURCC_YVU9  MP_FOURCC('Y', 'U', 'V', '9')
-#define MP_FOURCC_YUV9  MP_FOURCC('Y', 'V', 'U', '9')
-#define MP_FOURCC_YV12  MP_FOURCC('Y', 'V', '1', '2')
-#define MP_FOURCC_I420  MP_FOURCC('I', '4', '2', '0')
-#define MP_FOURCC_IYUV  MP_FOURCC('I', 'Y', 'U', 'V')
-#define MP_FOURCC_Y800  MP_FOURCC('Y', '8', '0', '0')
-#define MP_FOURCC_NV12  MP_FOURCC('N', 'V', '1', '2')
-#define MP_FOURCC_NV21  MP_FOURCC('N', 'V', '2', '1')
-
-#define MP_FOURCC_UYVY  MP_FOURCC('U', 'Y', 'V', 'Y')
-#define MP_FOURCC_YUY2  MP_FOURCC('Y', 'U', 'Y', '2')
-
-#define MP_FOURCC_MJPEG MP_FOURCC('M', 'J', 'P', 'G')
-#define MP_FOURCC_JPEG  MP_FOURCC('J', 'P', 'E', 'G')
-
-#endif /* MPLAYER_TV_H */
diff -ruN mpv-0.29.1/stream/tvi_def.h mpv-master/stream/tvi_def.h
--- mpv-0.29.1/stream/tvi_def.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/tvi_def.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,93 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef MPLAYER_TVI_DEF_H
-#define MPLAYER_TVI_DEF_H
-
-#include <stdlib.h> /* malloc */
-#include <string.h> /* memset */
-#include "tv.h"
-
-static int init(priv_t *priv);
-static int uninit(priv_t *priv);
-static int do_control(priv_t *priv, int cmd, void *arg);
-static int start(priv_t *priv);
-static double grab_video_frame(priv_t *priv, char *buffer, int len);
-static int get_video_framesize(priv_t *priv);
-static double grab_audio_frame(priv_t *priv, char *buffer, int len);
-static int get_audio_framesize(priv_t *priv);
-
-static const tvi_functions_t functions =
-{
-    init,
-    uninit,
-    do_control,
-    start,
-    grab_video_frame,
-    get_video_framesize,
-    grab_audio_frame,
-    get_audio_framesize
-};
-
-/**
- Fills video frame in given buffer with blue color for yv12,i420,uyvy,yuy2.
- Other formats will be filled with 0xC0
-*/
-static inline void fill_blank_frame(char* buffer,int len,int fmt){
-    int i;
-    // RGB(0,0,255) <-> YVU(41,110,240)
-
-    switch(fmt){
-    case MP_FOURCC_YV12:
-        memset(buffer, 41,4*len/6);       //Y
-        memset(buffer+4*len/6, 110,len/6);//V
-        memset(buffer+5*len/6, 240,len/6);//U
-        break;
-    case MP_FOURCC_I420:
-        memset(buffer, 41,4*len/6);       //Y
-        memset(buffer+4*len/6, 240,len/6);//U
-        memset(buffer+5*len/6, 110,len/6);//V
-        break;
-    case MP_FOURCC_UYVY:
-        for(i=0;i<len;i+=4){
-            buffer[i]=0xFF;
-            buffer[i+1]=0;
-            buffer[i+2]=0;
-            buffer[i+3]=0;
-        }
-        break;
-    case MP_FOURCC_YUY2:
-        for(i=0;i<len;i+=4){
-            buffer[i]=0;
-            buffer[i+1]=0xFF;
-            buffer[i+2]=0;
-            buffer[i+3]=0;
-        }
-        break;
-    case MP_FOURCC_MJPEG:
-    case MP_FOURCC_JPEG:
-        /*
-        This is compressed format. I don't know yet how to fill such frame with blue color.
-        Keeping frame unchanged.
-        */
-        break;
-    default:
-        memset(buffer,0xC0,len);
-    }
-}
-
-#endif /* MPLAYER_TVI_DEF_H */
diff -ruN mpv-0.29.1/stream/tvi_dummy.c mpv-master/stream/tvi_dummy.c
--- mpv-0.29.1/stream/tvi_dummy.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/tvi_dummy.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,126 +0,0 @@
-/*
- * Only a sample!
- *
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "config.h"
-
-#include <stdio.h>
-#include "common/common.h"
-#include "tv.h"
-
-static tvi_handle_t *tvi_init_dummy(struct mp_log *log, tv_param_t* tv_param);
-/* information about this file */
-const tvi_info_t tvi_info_dummy = {
-        tvi_init_dummy,
-        "NULL-TV",
-        "dummy",
-};
-
-/* private data's */
-typedef struct priv {
-    int width;
-    int height;
-} priv_t;
-
-#include "tvi_def.h"
-
-/* handler creator - entry point ! */
-static tvi_handle_t *tvi_init_dummy(struct mp_log *log, tv_param_t* tv_param)
-{
-    return tv_new_handle(sizeof(priv_t), log, &functions);
-}
-
-/* initialisation */
-static int init(priv_t *priv)
-{
-    priv->width = 320;
-    priv->height = 200;
-    return 1;
-}
-
-/* that's the real start, we'got the format parameters (checked with control) */
-static int start(priv_t *priv)
-{
-    return 1;
-}
-
-static int uninit(priv_t *priv)
-{
-    return 1;
-}
-
-static int do_control(priv_t *priv, int cmd, void *arg)
-{
-    switch(cmd)
-    {
-        case TVI_CONTROL_IS_VIDEO:
-            return TVI_CONTROL_TRUE;
-        case TVI_CONTROL_VID_GET_FORMAT:
-            *(int *)arg = MP_FOURCC_YV12;
-            return TVI_CONTROL_TRUE;
-        case TVI_CONTROL_VID_SET_FORMAT:
-        {
-//          int req_fmt = *(int *)arg;
-            int req_fmt = *(int *)arg;
-            if (req_fmt != MP_FOURCC_YV12)
-                return TVI_CONTROL_FALSE;
-            return TVI_CONTROL_TRUE;
-        }
-        case TVI_CONTROL_VID_SET_WIDTH:
-            priv->width = *(int *)arg;
-            return TVI_CONTROL_TRUE;
-        case TVI_CONTROL_VID_GET_WIDTH:
-            *(int *)arg = priv->width;
-            return TVI_CONTROL_TRUE;
-        case TVI_CONTROL_VID_SET_HEIGHT:
-            priv->height = *(int *)arg;
-            return TVI_CONTROL_TRUE;
-        case TVI_CONTROL_VID_GET_HEIGHT:
-            *(int *)arg = priv->height;
-            return TVI_CONTROL_TRUE;
-        case TVI_CONTROL_VID_CHK_WIDTH:
-        case TVI_CONTROL_VID_CHK_HEIGHT:
-            return TVI_CONTROL_TRUE;
-        case TVI_CONTROL_TUN_SET_NORM:
-            return TVI_CONTROL_TRUE;
-    }
-    return TVI_CONTROL_UNKNOWN;
-}
-
-static double grab_video_frame(priv_t *priv, char *buffer, int len)
-{
-    memset(buffer, 0x42, len);
-    return MP_NOPTS_VALUE;
-}
-
-static int get_video_framesize(priv_t *priv)
-{
-    /* YV12 */
-    return priv->width * priv->height * 12 / 8;
-}
-
-static double grab_audio_frame(priv_t *priv, char *buffer, int len)
-{
-    memset(buffer, 0x42, len);
-    return MP_NOPTS_VALUE;
-}
-
-static int get_audio_framesize(priv_t *priv)
-{
-    return 1;
-}
diff -ruN mpv-0.29.1/stream/tvi_v4l2.c mpv-master/stream/tvi_v4l2.c
--- mpv-0.29.1/stream/tvi_v4l2.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/stream/tvi_v4l2.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,1786 +0,0 @@
-/*
- * Video 4 Linux 2 input
- *
- * copyright (c) 2003 Martin Olschewski <olschewski@zpr.uni-koeln.de>
- * copyright (c) 2003 Jindrich Makovicka <makovick@gmail.com>
- *
- * Some ideas are based on works from
- *   Alex Beregszaszi <alex@fsn.hu>
- *   Gerd Knorr <kraxel@bytesex.org>
- *
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/*
-known issues:
-- norm setting isn't consistent with tvi_v4l
-- the same for volume/bass/treble/balance
-*/
-
-#include "config.h"
-
-#include <errno.h>
-#include <fcntl.h>
-#include <pthread.h>
-#include <stdio.h>
-#include <string.h>
-#include <strings.h>
-#include <time.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <unistd.h>
-#include <math.h>
-#if HAVE_SYS_VIDEOIO_H
-#include <sys/videoio.h>
-#else
-#include <linux/videodev2.h>
-#endif
-#if HAVE_LIBV4L2
-#include <libv4l2.h>
-#endif
-#include "common/msg.h"
-#include "common/common.h"
-#include "audio/format.h"
-#include "tv.h"
-#include "audio_in.h"
-
-#if !HAVE_LIBV4L2
-#define v4l2_open   open
-#define v4l2_close  close
-#define v4l2_ioctl  ioctl
-#define v4l2_mmap   mmap
-#define v4l2_munmap munmap
-#endif
-
-// flag introduced in kernel 3.10
-#ifndef V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC
-#define V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC 0x2000
-#endif
-
-#if defined(_POSIX_TIMERS) && _POSIX_TIMERS > 0
-#define HAVE_CLOCK_GETTIME 1
-#else
-#define HAVE_CLOCK_GETTIME 0
-#endif
-
-#define info tvi_info_v4l2
-static tvi_handle_t *tvi_init_v4l2(struct mp_log *log, tv_param_t* tv_param);
-/* information about this file */
-const tvi_info_t tvi_info_v4l2 = {
-    tvi_init_v4l2,
-    "Video 4 Linux 2 input",
-    "v4l2",
-};
-
-struct map {
-    struct v4l2_buffer buf;
-    void   *addr;
-    size_t len;
-};
-
-#define BUFFER_COUNT 6
-
-/** video ringbuffer entry */
-typedef struct {
-    unsigned char               *data;     ///< frame contents
-    long long                   timestamp; ///< frame timestamp
-    int                         framesize; ///< actual frame size
-} video_buffer_entry;
-
-/* private data */
-typedef struct priv {
-    /* video */
-    struct mp_log               *log;
-    char                        *video_dev;
-    int                         video_fd;
-    int                         mp_format;
-    struct v4l2_capability      capability;
-    struct v4l2_input           input;
-    struct v4l2_format          format;
-    struct v4l2_standard        standard;
-    struct v4l2_tuner           tuner;
-    struct map                  *map;
-    int                         mapcount;
-    int                         frames;
-    volatile long long          first_frame; ///< number of useconds
-    long long                   curr_frame;  ///< usec, using kernel timestamps
-    int                         clk_id;      /**< clk_id from clock_gettime
-                                                  used in frame timestamps */
-    /* audio video interleaving ;-) */
-    volatile int                streamon;
-    pthread_t                   audio_grabber_thread;
-    pthread_mutex_t             skew_mutex;
-
-    /* 2nd level video buffers */
-    int                         first;
-    int                         immediate_mode;
-
-    int                         video_buffer_size_max;
-    volatile int                video_buffer_size_current;
-    video_buffer_entry          *video_ringbuffer;
-    volatile int                video_head;
-    volatile int                video_tail;
-    volatile int                video_cnt;
-    pthread_t                   video_grabber_thread;
-    pthread_mutex_t             video_buffer_mutex;
-
-    /* audio */
-    char                        *audio_dev;
-    audio_in_t                  audio_in;
-
-    long long                   audio_start_time;
-    int                         audio_buffer_size;
-    int                         aud_skew_cnt;
-    unsigned char               *audio_ringbuffer;
-    long long                   *audio_skew_buffer;
-    long long                   *audio_skew_delta_buffer;
-    volatile int                audio_head;
-    volatile int                audio_tail;
-    volatile int                audio_cnt;
-    volatile long long          audio_skew;
-    volatile double             audio_skew_factor;
-    volatile long long          audio_skew_measure_time;
-    volatile int                audio_drop;
-    volatile int                shutdown;
-
-    int                         audio_initialized;
-    double                      audio_secs_per_block;
-    long long                   audio_usecs_per_block;
-    long long                   audio_skew_total;
-    long long                   audio_skew_delta_total;
-    long                        audio_recv_blocks_total;
-    long                        audio_sent_blocks_total;
-    pthread_mutex_t             audio_mutex;
-    int                         audio_insert_null_samples;
-    volatile long               audio_null_blocks_inserted;
-    volatile long long          dropped_frames_timeshift;
-    long long                   dropped_frames_compensated;
-
-    tv_param_t                  *tv_param;
-} priv_t;
-
-typedef struct tt_stream_props_s{
-    int sampling_rate;
-    int samples_per_line;
-    int offset;
-    int count[2];     ///< number of lines in first and second fields
-    int interlaced;   ///< vbi data are interlaced
-    int bufsize;      ///< required buffer size
-} tt_stream_props;
-
-#include "tvi_def.h"
-
-static void *audio_grabber(void *data);
-static void *video_grabber(void *data);
-
-/**********************************************************************\
-
-    Only few of the fourccs are the same in v4l2 and mplayer:
-
-    MP_FOURCC_YVU9 == V4L2_PIX_FMT_YVU410
-    MP_FOURCC_YV12 == V4L2_PIX_FMT_YVU420
-    MP_FOURCC_NV12 == V4L2_PIX_FMT_NV12
-    MP_FOURCC_422P == V4L2_PIX_FMT_YUV422P
-    MP_FOURCC_411P == V4L2_PIX_FMT_YUV411P
-    MP_FOURCC_UYVY == V4L2_PIX_FMT_UYVY
-    MP_FOURCC_Y41P == V4L2_PIX_FMT_Y41P
-
-    This may be an useful translation table for some others:
-
-    MP_FOURCC_RGB8  == V4L2_PIX_FMT_RGB332
-    MP_FOURCC_BGR15 == V4L2_PIX_FMT_RGB555
-    MP_FOURCC_BGR16 == V4L2_PIX_FMT_RGB565
-    MP_FOURCC_RGB24 == V4L2_PIX_FMT_RGB24
-    MP_FOURCC_RGB32 == V4L2_PIX_FMT_RGB32
-    MP_FOURCC_BGR24 == V4L2_PIX_FMT_BGR24
-    MP_FOURCC_BGR32 == V4L2_PIX_FMT_BGR32
-    MP_FOURCC_Y800  == V4L2_PIX_FMT_GREY
-    MP_FOURCC_YUV9  == V4L2_PIX_FMT_YUV410
-    MP_FOURCC_I420  == V4L2_PIX_FMT_YUV420
-    MP_FOURCC_YUY2  == V4L2_PIX_FMT_YUYV
-
-\**********************************************************************/
-
-/*
-** Translate a mplayer fourcc to a video4linux2 pixel format.
-*/
-static int fcc_mp2vl(int fcc)
-{
-    switch (fcc) {
-    case MP_FOURCC_RGB8:   return V4L2_PIX_FMT_RGB332;
-    case MP_FOURCC_BGR15:  return V4L2_PIX_FMT_RGB555;
-    case MP_FOURCC_BGR16:  return V4L2_PIX_FMT_RGB565;
-    case MP_FOURCC_RGB24:  return V4L2_PIX_FMT_RGB24;
-    case MP_FOURCC_RGB32:  return V4L2_PIX_FMT_RGB32;
-    case MP_FOURCC_BGR24:  return V4L2_PIX_FMT_BGR24;
-    case MP_FOURCC_BGR32:  return V4L2_PIX_FMT_BGR32;
-    case MP_FOURCC_Y800:   return V4L2_PIX_FMT_GREY;
-    case MP_FOURCC_YUV9:   return V4L2_PIX_FMT_YUV410;
-    case MP_FOURCC_I420:   return V4L2_PIX_FMT_YUV420;
-    case MP_FOURCC_YUY2:   return V4L2_PIX_FMT_YUYV;
-    case MP_FOURCC_YV12:   return V4L2_PIX_FMT_YVU420;
-    case MP_FOURCC_UYVY:   return V4L2_PIX_FMT_UYVY;
-    case MP_FOURCC_MJPEG:  return V4L2_PIX_FMT_MJPEG;
-    case MP_FOURCC_JPEG:   return V4L2_PIX_FMT_JPEG;
-    }
-    return fcc;
-}
-
-/*
-** Translate a video4linux2 fourcc aka pixel format to mplayer.
-*/
-static int fcc_vl2mp(int fcc)
-{
-    switch (fcc) {
-    case V4L2_PIX_FMT_RGB332:   return MP_FOURCC_RGB8;
-    case V4L2_PIX_FMT_RGB555:   return MP_FOURCC_BGR15;
-    case V4L2_PIX_FMT_RGB565:   return MP_FOURCC_BGR16;
-    case V4L2_PIX_FMT_RGB24:    return MP_FOURCC_RGB24;
-    case V4L2_PIX_FMT_RGB32:    return MP_FOURCC_RGB32;
-    case V4L2_PIX_FMT_BGR24:    return MP_FOURCC_BGR24;
-    case V4L2_PIX_FMT_BGR32:    return MP_FOURCC_BGR32;
-    case V4L2_PIX_FMT_GREY:     return MP_FOURCC_Y800;
-    case V4L2_PIX_FMT_YUV410:   return MP_FOURCC_YUV9;
-    case V4L2_PIX_FMT_YUV420:   return MP_FOURCC_I420;
-    case V4L2_PIX_FMT_YVU420:   return MP_FOURCC_YV12;
-    case V4L2_PIX_FMT_YUYV:     return MP_FOURCC_YUY2;
-    case V4L2_PIX_FMT_UYVY:     return MP_FOURCC_UYVY;
-    case V4L2_PIX_FMT_MJPEG:    return MP_FOURCC_MJPEG;
-    case V4L2_PIX_FMT_JPEG:     return MP_FOURCC_JPEG;
-    }
-    return fcc;
-}
-
-/*
-** Translate a video4linux2 fourcc aka pixel format
-** to a human readable string.
-*/
-static const char *pixfmt2name(char *buf, int pixfmt)
-{
-    switch (pixfmt) {
-    case V4L2_PIX_FMT_RGB332:       return "RGB332";
-    case V4L2_PIX_FMT_RGB555:       return "RGB555";
-    case V4L2_PIX_FMT_RGB565:       return "RGB565";
-    case V4L2_PIX_FMT_RGB555X:      return "RGB555X";
-    case V4L2_PIX_FMT_RGB565X:      return "RGB565X";
-    case V4L2_PIX_FMT_BGR24:        return "BGR24";
-    case V4L2_PIX_FMT_RGB24:        return "RGB24";
-    case V4L2_PIX_FMT_BGR32:        return "BGR32";
-    case V4L2_PIX_FMT_RGB32:        return "RGB32";
-    case V4L2_PIX_FMT_GREY:         return "GREY";
-    case V4L2_PIX_FMT_YVU410:       return "YVU410";
-    case V4L2_PIX_FMT_YVU420:       return "YVU420";
-    case V4L2_PIX_FMT_YUYV:         return "YUYV";
-    case V4L2_PIX_FMT_UYVY:         return "UYVY";
-/*    case V4L2_PIX_FMT_YVU422P:      return "YVU422P"; */
-/*    case V4L2_PIX_FMT_YVU411P:      return "YVU411P"; */
-    case V4L2_PIX_FMT_YUV422P:      return "YUV422P";
-    case V4L2_PIX_FMT_YUV411P:      return "YUV411P";
-    case V4L2_PIX_FMT_Y41P:         return "Y41P";
-    case V4L2_PIX_FMT_NV12:         return "NV12";
-    case V4L2_PIX_FMT_NV21:         return "NV21";
-    case V4L2_PIX_FMT_YUV410:       return "YUV410";
-    case V4L2_PIX_FMT_YUV420:       return "YUV420";
-    case V4L2_PIX_FMT_YYUV:         return "YYUV";
-    case V4L2_PIX_FMT_HI240:        return "HI240";
-    case V4L2_PIX_FMT_WNVA:         return "WNVA";
-    case V4L2_PIX_FMT_MJPEG:        return "MJPEG";
-    case V4L2_PIX_FMT_JPEG:         return "JPEG";
-    }
-    sprintf(buf, "unknown (0x%x)", pixfmt);
-    return buf;
-}
-
-
-/*
-** Gives the depth of a video4linux2 fourcc aka pixel format in bits.
-*/
-static int pixfmt2depth(int pixfmt)
-{
-    switch (pixfmt) {
-    case V4L2_PIX_FMT_RGB332:
-        return 8;
-    case V4L2_PIX_FMT_RGB555:
-    case V4L2_PIX_FMT_RGB565:
-    case V4L2_PIX_FMT_RGB555X:
-    case V4L2_PIX_FMT_RGB565X:
-        return 16;
-    case V4L2_PIX_FMT_BGR24:
-    case V4L2_PIX_FMT_RGB24:
-        return 24;
-    case V4L2_PIX_FMT_BGR32:
-    case V4L2_PIX_FMT_RGB32:
-        return 32;
-    case V4L2_PIX_FMT_GREY:
-        return 8;
-    case V4L2_PIX_FMT_YVU410:
-        return 9;
-    case V4L2_PIX_FMT_YVU420:
-        return 12;
-    case V4L2_PIX_FMT_YUYV:
-    case V4L2_PIX_FMT_UYVY:
-    case V4L2_PIX_FMT_YUV422P:
-    case V4L2_PIX_FMT_YUV411P:
-        return 16;
-    case V4L2_PIX_FMT_Y41P:
-    case V4L2_PIX_FMT_NV12:
-    case V4L2_PIX_FMT_NV21:
-        return 12;
-    case V4L2_PIX_FMT_YUV410:
-        return 9;
-    case V4L2_PIX_FMT_YUV420:
-        return 12;
-    case V4L2_PIX_FMT_YYUV:
-        return 16;
-    case V4L2_PIX_FMT_HI240:
-        return 8;
-
-    }
-    return 0;
-}
-
-static int amode2v4l(int amode)
-{
-    switch (amode) {
-    case 0:
-        return V4L2_TUNER_MODE_MONO;
-    case 1:
-        return V4L2_TUNER_MODE_STEREO;
-    case 2:
-        return V4L2_TUNER_MODE_LANG1;
-    case 3:
-        return V4L2_TUNER_MODE_LANG2;
-    default:
-        return -1;
-    }
-}
-
-
-/*
-** Get current FPS.
-*/
-static double getfps(priv_t *priv)
-{
-    if (priv->tv_param->fps > 0)
-        return priv->tv_param->fps;
-    if (priv->standard.frameperiod.denominator && priv->standard.frameperiod.numerator)
-        return (double)priv->standard.frameperiod.denominator / priv->standard.frameperiod.numerator;
-    return 25.0;
-}
-
-// sets and sanitizes audio buffer/block sizes
-static void setup_audio_buffer_sizes(priv_t *priv)
-{
-    int bytes_per_sample = priv->audio_in.bytes_per_sample;
-    int seconds = priv->video_buffer_size_max/getfps(priv);
-
-    if (seconds < 5) seconds = 5;
-    if (seconds > 500) seconds = 500;
-
-    // make the audio buffer at least as the video buffer capacity (or 5 seconds) long
-    priv->audio_buffer_size = 1 + seconds*priv->audio_in.samplerate
-        *priv->audio_in.channels
-        *bytes_per_sample/priv->audio_in.blocksize;
-    if (priv->audio_buffer_size < 256) priv->audio_buffer_size = 256;
-
-    // make the skew buffer at least 1 second long
-    priv->aud_skew_cnt = 1 + 1*priv->audio_in.samplerate
-        *priv->audio_in.channels
-        *bytes_per_sample/priv->audio_in.blocksize;
-    if (priv->aud_skew_cnt < 16) priv->aud_skew_cnt = 16;
-
-    MP_VERBOSE(priv, "Audio capture - buffer %d blocks of %d bytes, skew average from %d meas.\n",
-           priv->audio_buffer_size, priv->audio_in.blocksize, priv->aud_skew_cnt);
-}
-
-static void init_audio(priv_t *priv)
-{
-    if (priv->audio_initialized) return;
-
-    if (priv->tv_param->audio) {
-#if HAVE_ALSA
-        if (priv->tv_param->alsa)
-            audio_in_init(&priv->audio_in, priv->log, AUDIO_IN_ALSA);
-        else
-            audio_in_init(&priv->audio_in, priv->log, AUDIO_IN_OSS);
-#else
-        audio_in_init(&priv->audio_in, priv->log, AUDIO_IN_OSS);
-#endif
-
-        if (priv->audio_dev) {
-            audio_in_set_device(&priv->audio_in, priv->audio_dev);
-        }
-
-        audio_in_set_samplerate(&priv->audio_in, 44100);
-        if (priv->capability.capabilities & V4L2_CAP_TUNER) {
-            if (priv->tuner.audmode == V4L2_TUNER_MODE_STEREO) {
-                audio_in_set_channels(&priv->audio_in, 2);
-            } else {
-                audio_in_set_channels(&priv->audio_in, 1);
-            }
-        } else {
-            if (priv->tv_param->forcechan >= 0) {
-                audio_in_set_channels(&priv->audio_in, priv->tv_param->forcechan);
-            } else {
-                audio_in_set_channels(&priv->audio_in, 2);
-            }
-        }
-
-        if (audio_in_setup(&priv->audio_in) < 0) return;
-
-        priv->audio_initialized = 1;
-    }
-}
-
-#if 0
-/*
-** the number of milliseconds elapsed between time0 and time1
-*/
-static size_t difftv(struct timeval time1, struct timeval time0)
-{
-    return        (time1.tv_sec  - time0.tv_sec)  * 1000 +
-        (time1.tv_usec - time0.tv_usec) / 1000;
-}
-#endif
-
-/*
-** Get current video capture format.
-*/
-static int getfmt(priv_t *priv)
-{
-    int i;
-
-    priv->format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    if ((i = v4l2_ioctl(priv->video_fd, VIDIOC_G_FMT, &priv->format)) < 0) {
-        MP_ERR(priv, "ioctl get format failed: %s\n",
-               mp_strerror(errno));
-    }
-    return i;
-}
-
-
-/*
-** Get current video capture standard.
-*/
-static int getstd(priv_t *priv)
-{
-    v4l2_std_id id;
-    int i=0;
-
-    if (v4l2_ioctl(priv->video_fd, VIDIOC_G_STD, &id) < 0) {
-        struct v4l2_streamparm      parm;
-
-        parm.type=V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if(v4l2_ioctl(priv->video_fd, VIDIOC_G_PARM, &parm) >= 0) {
-            MP_WARN(priv, "your device driver does not support VIDIOC_G_STD ioctl,"
-                   " VIDIOC_G_PARM was used instead.\n");
-            priv->standard.index=0;
-            priv->standard.id=0;
-            priv->standard.frameperiod=parm.parm.capture.timeperframe;
-            return 0;
-        }
-
-        MP_ERR(priv, "ioctl get standard failed: %s\n", mp_strerror(errno));
-        return -1;
-    }
-    do {
-        priv->standard.index = i++;
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_ENUMSTD, &priv->standard) < 0) {
-            return -1;
-        }
-    } while (priv->standard.id != id);
-    return 0;
-}
-
-#if HAVE_CLOCK_GETTIME
-/*
-** Gets current timestamp, using specified clock id.
-** @return number of microseconds.
-*/
-static long long get_curr_timestamp(int clk_id)
-{
-    struct timespec ts;
-    clock_gettime(clk_id, &ts);
-    return (long long)ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
-}
-#else
-/*
-** Gets current timestamp, using system time.
-** @return number of microseconds.
-*/
-static long long get_curr_timestamp(int clk_id)
-{
-    struct timeval tv;
-    gettimeofday(&tv, NULL);
-    return (long long)tv.tv_sec * 1000000 + tv.tv_usec;
-}
-#endif
-
-/***********************************************************************\
- *                                                                     *
- *                                                                     *
- *        Interface to mplayer                                         *
- *                                                                     *
- *                                                                     *
-\***********************************************************************/
-
-static int set_mute(priv_t *priv, int value)
-{
-    struct v4l2_control control;
-    control.id = V4L2_CID_AUDIO_MUTE;
-    control.value = value;
-    if (v4l2_ioctl(priv->video_fd, VIDIOC_S_CTRL, &control) < 0) {
-        MP_ERR(priv, "ioctl set mute failed: %s\n", mp_strerror(errno));
-        return 0;
-    }
-    return 1;
-}
-
-/*
-** MPlayer uses values from -100 up to 100 for controls.
-** Here they are scaled to what the tv card needs and applied.
-*/
-static int set_control(priv_t *priv, struct v4l2_control *control, int val_signed) {
-    struct v4l2_queryctrl        qctrl;
-    qctrl.id = control->id;
-    if (v4l2_ioctl(priv->video_fd, VIDIOC_QUERYCTRL, &qctrl) < 0) {
-        MP_ERR(priv, "ioctl query control failed: %s\n", mp_strerror(errno));
-        return TVI_CONTROL_FALSE;
-    }
-
-    if (val_signed) {
-        if (control->value < 0) {
-            control->value = qctrl.default_value + control->value *
-                (qctrl.default_value - qctrl.minimum) / 100;
-        } else {
-            control->value = qctrl.default_value + control->value *
-                (qctrl.maximum - qctrl.default_value) / 100;
-        }
-    } else {
-        if (control->value < 50) {
-            control->value = qctrl.default_value + (control->value-50) *
-                (qctrl.default_value - qctrl.minimum) / 50;
-        } else {
-            control->value = qctrl.default_value + (control->value-50) *
-                (qctrl.maximum - qctrl.default_value) / 50;
-        }
-    }
-
-
-    if (v4l2_ioctl(priv->video_fd, VIDIOC_S_CTRL, control) < 0) {
-        MP_ERR(priv, "ioctl set %s %d failed: %s\n",
-               qctrl.name, control->value, mp_strerror(errno));
-        return TVI_CONTROL_FALSE;
-    }
-    MP_VERBOSE(priv, "set %s: %d [%d, %d]\n",
-     qctrl.name, control->value, qctrl.minimum, qctrl.maximum);
-
-    return TVI_CONTROL_TRUE;
-}
-
-
-/*
-** Scale the control values back to what mplayer needs.
-*/
-static int get_control(priv_t *priv, struct v4l2_control *control, int val_signed) {
-    struct v4l2_queryctrl        qctrl;
-
-    qctrl.id = control->id;
-    if (v4l2_ioctl(priv->video_fd, VIDIOC_QUERYCTRL, &qctrl) < 0) {
-        MP_ERR(priv, "ioctl query control failed: %s\n", mp_strerror(errno));
-        return TVI_CONTROL_FALSE;
-    }
-
-    if (v4l2_ioctl(priv->video_fd, VIDIOC_G_CTRL, control) < 0) {
-        MP_ERR(priv, "ioctl get %s failed: %s\n", qctrl.name, mp_strerror(errno));
-        return TVI_CONTROL_FALSE;
-    }
-    MP_VERBOSE(priv, "get %s: %d [%d, %d]\n",
-     qctrl.name, control->value, qctrl.minimum, qctrl.maximum);
-
-    if (val_signed) {
-        if (control->value < qctrl.default_value) {
-            control->value = (control->value - qctrl.default_value) * 100 /
-                (qctrl.default_value - qctrl.minimum);
-        } else {
-            control->value = (control->value - qctrl.default_value) * 100 /
-                (qctrl.maximum - qctrl.default_value);
-        }
-    } else {
-        if (control->value < qctrl.default_value) {
-            control->value = (control->value - qctrl.default_value) * 50 /
-                (qctrl.default_value - qctrl.minimum) + 50;
-        } else {
-            control->value = (control->value - qctrl.default_value) * 50 /
-                (qctrl.maximum - qctrl.default_value) + 50;
-        }
-    }
-
-    return TVI_CONTROL_TRUE;
-}
-
-static int do_control(priv_t *priv, int cmd, void *arg)
-{
-    struct v4l2_control control;
-    struct v4l2_frequency frequency;
-    char buf[80];
-
-    switch(cmd) {
-    case TVI_CONTROL_IS_VIDEO:
-        return priv->capability.capabilities & V4L2_CAP_VIDEO_CAPTURE?
-            TVI_CONTROL_TRUE: TVI_CONTROL_FALSE;
-    case TVI_CONTROL_IS_AUDIO:
-        if (priv->tv_param->force_audio) return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_IS_TUNER:
-        return priv->capability.capabilities & V4L2_CAP_TUNER?
-            TVI_CONTROL_TRUE: TVI_CONTROL_FALSE;
-    case TVI_CONTROL_IMMEDIATE:
-        priv->immediate_mode = 1;
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_VID_GET_FPS:
-        *(float *)arg = getfps(priv);
-        MP_VERBOSE(priv, "get fps: %f\n", *(float *)arg);
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_VID_GET_BITS:
-        if (getfmt(priv) < 0) return TVI_CONTROL_FALSE;
-        *(int *)arg = pixfmt2depth(priv->format.fmt.pix.pixelformat);
-        MP_VERBOSE(priv, "get depth: %d\n", *(int *)arg);
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_VID_GET_FORMAT:
-        if (getfmt(priv) < 0) return TVI_CONTROL_FALSE;
-        *(int *)arg = fcc_vl2mp(priv->format.fmt.pix.pixelformat);
-        MP_VERBOSE(priv, "get format: %s\n",
-                   pixfmt2name(buf, priv->format.fmt.pix.pixelformat));
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_VID_SET_FORMAT:
-        if (getfmt(priv) < 0) return TVI_CONTROL_FALSE;
-        priv->format.fmt.pix.pixelformat = fcc_mp2vl(*(int *)arg);
-        priv->format.fmt.pix.field = V4L2_FIELD_ANY;
-
-        priv->mp_format = *(int *)arg;
-        MP_VERBOSE(priv, "set format: %s\n",
-               pixfmt2name(buf, priv->format.fmt.pix.pixelformat));
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_S_FMT, &priv->format) < 0) {
-            MP_ERR(priv, "ioctl set format failed: %s\n", mp_strerror(errno));
-            return TVI_CONTROL_FALSE;
-        }
-        /* according to the v4l2 specs VIDIOC_S_FMT should not fail, inflexible drivers
-          might even always return the default parameters -> update the format here*/
-        priv->mp_format = fcc_vl2mp(priv->format.fmt.pix.pixelformat);
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_VID_GET_WIDTH:
-        if (getfmt(priv) < 0) return TVI_CONTROL_FALSE;
-        *(int *)arg = priv->format.fmt.pix.width;
-        MP_VERBOSE(priv, "get width: %d\n", *(int *)arg);
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_VID_CHK_WIDTH:
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_VID_SET_WIDTH_HEIGHT:
-        if (getfmt(priv) < 0) return TVI_CONTROL_FALSE;
-        priv->format.fmt.pix.width = ((int *)arg)[0];
-        priv->format.fmt.pix.height = ((int *)arg)[1];
-        priv->format.fmt.pix.field = V4L2_FIELD_ANY;
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_S_FMT, &priv->format) < 0)
-            return TVI_CONTROL_FALSE;
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_VID_SET_WIDTH:
-        if (getfmt(priv) < 0) return TVI_CONTROL_FALSE;
-        priv->format.fmt.pix.width = *(int *)arg;
-        MP_VERBOSE(priv, "set width: %d\n", *(int *)arg);
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_S_FMT, &priv->format) < 0) {
-            MP_ERR(priv, "ioctl set width failed: %s\n", mp_strerror(errno));
-            return TVI_CONTROL_FALSE;
-        }
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_VID_GET_HEIGHT:
-        if (getfmt(priv) < 0) return TVI_CONTROL_FALSE;
-        *(int *)arg = priv->format.fmt.pix.height;
-        MP_VERBOSE(priv, "get height: %d\n", *(int *)arg);
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_VID_CHK_HEIGHT:
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_VID_SET_HEIGHT:
-        if (getfmt(priv) < 0) return TVI_CONTROL_FALSE;
-        priv->format.fmt.pix.height = *(int *)arg;
-        priv->format.fmt.pix.field = V4L2_FIELD_ANY;
-        MP_VERBOSE(priv, "set height: %d\n", *(int *)arg);
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_S_FMT, &priv->format) < 0) {
-            MP_ERR(priv, "ioctl set height failed: %s\n", mp_strerror(errno));
-            return TVI_CONTROL_FALSE;
-        }
-        return TVI_CONTROL_TRUE;
-        case TVI_CONTROL_VID_GET_BRIGHTNESS:
-            control.id = V4L2_CID_BRIGHTNESS;
-            if (get_control(priv, &control, 1) == TVI_CONTROL_TRUE) {
-                *(int *)arg = control.value;
-                return TVI_CONTROL_TRUE;
-            }
-            return TVI_CONTROL_FALSE;
-        case TVI_CONTROL_VID_SET_BRIGHTNESS:
-            control.id = V4L2_CID_BRIGHTNESS;
-            control.value = *(int *)arg;
-            return set_control(priv, &control, 1);
-        case TVI_CONTROL_VID_GET_HUE:
-            control.id = V4L2_CID_HUE;
-            if (get_control(priv, &control, 1) == TVI_CONTROL_TRUE) {
-                *(int *)arg = control.value;
-                return TVI_CONTROL_TRUE;
-            }
-            return TVI_CONTROL_FALSE;
-        case TVI_CONTROL_VID_SET_HUE:
-            control.id = V4L2_CID_HUE;
-            control.value = *(int *)arg;
-            return set_control(priv, &control, 1);
-        case TVI_CONTROL_VID_GET_SATURATION:
-            control.id = V4L2_CID_SATURATION;
-            if (get_control(priv, &control, 1) == TVI_CONTROL_TRUE) {
-                *(int *)arg = control.value;
-                return TVI_CONTROL_TRUE;
-            }
-            return TVI_CONTROL_FALSE;
-        case TVI_CONTROL_VID_SET_SATURATION:
-            control.id = V4L2_CID_SATURATION;
-            control.value = *(int *)arg;
-            return set_control(priv, &control, 1);
-        case TVI_CONTROL_VID_GET_GAIN:
-        {
-
-            control.id = V4L2_CID_AUTOGAIN;
-            if(get_control(priv,&control,0)!=TVI_CONTROL_TRUE)
-                return TVI_CONTROL_FALSE;
-
-            if(control.value){ //Auto Gain control is enabled
-                *(int*)arg=0;
-                return TVI_CONTROL_TRUE;
-            }
-
-            //Manual Gain control
-            control.id = V4L2_CID_GAIN;
-            if(get_control(priv,&control,0)!=TVI_CONTROL_TRUE)
-                return TVI_CONTROL_FALSE;
-
-            *(int*)arg=control.value?control.value:1;
-
-            return TVI_CONTROL_TRUE;
-        }
-        case TVI_CONTROL_VID_SET_GAIN:
-        {
-            //value==0 means automatic gain control
-            int value=*(int*)arg;
-
-            if (value < 0 || value>100)
-                return TVI_CONTROL_FALSE;
-
-            control.id=value?V4L2_CID_GAIN:V4L2_CID_AUTOGAIN;
-            control.value=value?value:1;
-
-            return set_control(priv,&control,0);
-        }
-        case TVI_CONTROL_VID_GET_CONTRAST:
-            control.id = V4L2_CID_CONTRAST;
-            if (get_control(priv, &control, 1) == TVI_CONTROL_TRUE) {
-                *(int *)arg = control.value;
-                return TVI_CONTROL_TRUE;
-            }
-            return TVI_CONTROL_FALSE;
-        case TVI_CONTROL_VID_SET_CONTRAST:
-            control.id = V4L2_CID_CONTRAST;
-            control.value = *(int *)arg;
-            return set_control(priv, &control, 1);
-    case TVI_CONTROL_TUN_GET_FREQ:
-        frequency.tuner = 0;
-        frequency.type  = V4L2_TUNER_ANALOG_TV;
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_G_FREQUENCY, &frequency) < 0) {
-            MP_ERR(priv, "ioctl get frequency failed: %s\n", mp_strerror(errno));
-            return TVI_CONTROL_FALSE;
-        }
-        *(int *)arg = frequency.frequency;
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_TUN_SET_FREQ:
-#if 0
-        set_mute(priv, 1);
-        usleep(100000); // wait to suppress noise during switching
-#endif
-        frequency.tuner = 0;
-        frequency.type  = V4L2_TUNER_ANALOG_TV;
-        frequency.frequency = *(int *)arg;
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_S_FREQUENCY, &frequency) < 0) {
-            MP_ERR(priv, "ioctl set frequency failed: %s\n", mp_strerror(errno));
-            return TVI_CONTROL_FALSE;
-        }
-#if 0
-        usleep(100000); // wait to suppress noise during switching
-        set_mute(priv, 0);
-#endif
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_TUN_GET_TUNER:
-        MP_VERBOSE(priv, "get tuner\n");
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_G_TUNER, &priv->tuner) < 0) {
-            MP_ERR(priv, "ioctl get tuner failed: %s\n", mp_strerror(errno));
-            return TVI_CONTROL_FALSE;
-        }
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_TUN_SET_TUNER:
-        MP_VERBOSE(priv, "set tuner\n");
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_S_TUNER, &priv->tuner) < 0) {
-            MP_ERR(priv, "ioctl set tuner failed: %s\n", mp_strerror(errno));
-            return TVI_CONTROL_FALSE;
-        }
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_TUN_GET_NORM:
-        *(int *)arg = priv->standard.index;
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_TUN_GET_SIGNAL:
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_G_TUNER, &priv->tuner) < 0) {
-            MP_ERR(priv, "ioctl get tuner failed: %s\n", mp_strerror(errno));
-            return TVI_CONTROL_FALSE;
-        }
-        *(int*)arg=100*(priv->tuner.signal>>8)/255;
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_TUN_SET_NORM:
-        priv->standard.index = *(int *)arg;
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_ENUMSTD, &priv->standard) < 0) {
-            MP_ERR(priv, "ioctl enum norm failed: %s\n", mp_strerror(errno));
-            return TVI_CONTROL_FALSE;
-        }
-        MP_VERBOSE(priv, "set norm: %s\n", priv->standard.name);
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_S_STD, &priv->standard.id) < 0) {
-            MP_ERR(priv, "ioctl set norm failed: %s\n", mp_strerror(errno));
-            return TVI_CONTROL_FALSE;
-        }
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_SPC_GET_NORMID:
-        {
-            int i;
-            for (i = 0;; i++) {
-                struct v4l2_standard standard;
-                memset(&standard, 0, sizeof(standard));
-                standard.index = i;
-                if (-1 == v4l2_ioctl(priv->video_fd, VIDIOC_ENUMSTD, &standard))
-                    return TVI_CONTROL_FALSE;
-                if (!strcasecmp(standard.name, (char *)arg)) {
-                    *(int *)arg = i;
-                    return TVI_CONTROL_TRUE;
-                }
-            }
-            return TVI_CONTROL_FALSE;
-        }
-    case TVI_CONTROL_SPC_GET_INPUT:
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_G_INPUT, (int *)arg) < 0) {
-            MP_ERR(priv, "ioctl get input failed: %s\n", mp_strerror(errno));
-            return TVI_CONTROL_FALSE;
-        }
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_SPC_SET_INPUT:
-        MP_VERBOSE(priv, "set input: %d\n", *(int *)arg);
-        priv->input.index = *(int *)arg;
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_ENUMINPUT, &priv->input) < 0) {
-            MP_ERR(priv, "ioctl enum input failed: %s\n", mp_strerror(errno));
-            return TVI_CONTROL_FALSE;
-        }
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_S_INPUT, (int *)arg) < 0) {
-            MP_ERR(priv, "ioctl set input failed: %s\n", mp_strerror(errno));
-            return TVI_CONTROL_FALSE;
-        }
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_AUD_GET_FORMAT:
-        init_audio(priv);
-        if (!priv->audio_initialized) return TVI_CONTROL_FALSE;
-        *(int *)arg = AF_FORMAT_S16;
-        MP_VERBOSE(priv, "get audio format: %d\n", *(int *)arg);
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_AUD_GET_SAMPLERATE:
-        init_audio(priv);
-        if (!priv->audio_initialized) return TVI_CONTROL_FALSE;
-        *(int *)arg = priv->audio_in.samplerate;
-        MP_VERBOSE(priv, "get audio samplerate: %d\n", *(int *)arg);
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_AUD_GET_CHANNELS:
-        init_audio(priv);
-        if (!priv->audio_initialized) return TVI_CONTROL_FALSE;
-        *(int *)arg = priv->audio_in.channels;
-        MP_VERBOSE(priv, "get audio channels: %d\n", *(int *)arg);
-        return TVI_CONTROL_TRUE;
-    case TVI_CONTROL_AUD_SET_SAMPLERATE:
-        init_audio(priv);
-        MP_VERBOSE(priv, "set audio samplerate: %d\n", *(int *)arg);
-        if (audio_in_set_samplerate(&priv->audio_in, *(int*)arg) < 0) return TVI_CONTROL_FALSE;
-//        setup_audio_buffer_sizes(priv);
-        return TVI_CONTROL_TRUE;
-    }
-    MP_VERBOSE(priv, "unknown control: %d\n", cmd);
-    return TVI_CONTROL_UNKNOWN;
-}
-
-
-#define PRIV ((priv_t *) (tvi_handle->priv))
-
-/* handler creator - entry point ! */
-static tvi_handle_t *tvi_init_v4l2(struct mp_log *log, tv_param_t* tv_param)
-{
-    tvi_handle_t *tvi_handle;
-
-    tvi_handle = tv_new_handle(sizeof(priv_t), log, &functions);
-    if (!tvi_handle) {
-        return NULL;
-    }
-    PRIV->log = log;
-    PRIV->video_fd = -1;
-
-    PRIV->video_dev = strdup(tv_param->device? tv_param->device: "/dev/video0");
-    if (!PRIV->video_dev) {
-        tv_free_handle(tvi_handle);
-        return NULL;
-    }
-
-    if (tv_param->adevice) {
-        PRIV->audio_dev = strdup(tv_param->adevice);
-        if (!PRIV->audio_dev) {
-            free(PRIV->video_dev);
-            tv_free_handle(tvi_handle);
-            return NULL;
-        }
-    }
-
-    PRIV->tv_param=tv_param;
-    return tvi_handle;
-}
-
-#undef PRIV
-
-
-static int uninit(priv_t *priv)
-{
-    int i, frames, dropped = 0;
-
-    priv->shutdown = 1;
-    if(priv->video_grabber_thread)
-        pthread_join(priv->video_grabber_thread, NULL);
-    pthread_mutex_destroy(&priv->video_buffer_mutex);
-
-    if (priv->streamon) {
-        /* get performance */
-        frames = 1 + lrintf((double)(priv->curr_frame - priv->first_frame) / 1e6 * getfps(priv));
-        dropped = frames - priv->frames;
-
-        /* turn off streaming */
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_STREAMOFF, &(priv->map[0].buf.type)) < 0) {
-            MP_ERR(priv, "ioctl streamoff failed: %s\n", mp_strerror(errno));
-        }
-        priv->streamon = 0;
-
-        /* unqueue all remaining buffers (not sure if this code is correct) */
-        for (i = 0; i < priv->mapcount; i++) {
-            if (v4l2_ioctl(priv->video_fd, VIDIOC_DQBUF, &priv->map[i].buf) < 0) {
-                MP_ERR(priv, "VIDIOC_DQBUF failed: %s\n", mp_strerror(errno));
-            }
-        }
-    }
-
-    /* unmap all buffers */
-    for (i = 0; i < priv->mapcount; i++) {
-        if (v4l2_munmap(priv->map[i].addr, priv->map[i].len) < 0) {
-            MP_ERR(priv, "munmap capture buffer failed: %s\n", mp_strerror(errno));
-        }
-    }
-
-    /* stop audio thread */
-    if (priv->tv_param->audio && priv->audio_grabber_thread) {
-        pthread_join(priv->audio_grabber_thread, NULL);
-        pthread_mutex_destroy(&priv->skew_mutex);
-        pthread_mutex_destroy(&priv->audio_mutex);
-    }
-
-    set_mute(priv, 1);
-
-    /* free memory and close device */
-    free(priv->map);
-    priv->map = NULL;
-    priv->mapcount = 0;
-    if (priv->video_fd != -1) {
-        v4l2_close(priv->video_fd);
-        priv->video_fd = -1;
-    }
-    free(priv->video_dev);
-    priv->video_dev = NULL;
-
-    if (priv->video_ringbuffer) {
-        for (int n = 0; n < priv->video_buffer_size_current; n++) {
-            free(priv->video_ringbuffer[n].data);
-        }
-        free(priv->video_ringbuffer);
-    }
-    if (priv->tv_param->audio) {
-        free(priv->audio_ringbuffer);
-        free(priv->audio_skew_buffer);
-        free(priv->audio_skew_delta_buffer);
-
-        audio_in_uninit(&priv->audio_in);
-    }
-
-    /* show some nice statistics ;-) */
-    MP_INFO(priv, "%d frames successfully processed, %d frames dropped.\n",
-            priv->frames, dropped);
-    MP_VERBOSE(priv, "up to %u video frames buffered.\n",
-               priv->video_buffer_size_current);
-    return 1;
-}
-
-
-/* initialisation */
-static int init(priv_t *priv)
-{
-    int i;
-
-    priv->audio_ringbuffer = NULL;
-    priv->audio_skew_buffer = NULL;
-    priv->audio_skew_delta_buffer = NULL;
-
-    priv->audio_initialized = 0;
-
-    /* Open the video device. */
-    priv->video_fd = v4l2_open(priv->video_dev, O_RDWR);
-    if (priv->video_fd < 0) {
-        MP_ERR(priv, "unable to open '%s': %s\n", priv->video_dev, mp_strerror(errno));
-        uninit(priv);
-        return 0;
-    }
-    MP_DBG(priv, "video fd: %s: %d\n", priv->video_dev, priv->video_fd);
-
-    /*
-    ** Query the video capabilities and current settings
-    ** for further control calls.
-    */
-    if (v4l2_ioctl(priv->video_fd, VIDIOC_QUERYCAP, &priv->capability) < 0) {
-        MP_ERR(priv, "ioctl query capabilities failed: %s\n", mp_strerror(errno));
-        uninit(priv);
-        return 0;
-    }
-
-    if (!(priv->capability.capabilities & V4L2_CAP_VIDEO_CAPTURE))
-    {
-        MP_ERR(priv, "Device %s is not a video capture device.\n",
-               priv->video_dev);
-        return 0;
-    }
-
-    if (getfmt(priv) < 0) {
-        uninit(priv);
-        return 0;
-    }
-    getstd(priv);
-    /*
-    ** if this device has got a tuner query it's settings
-    ** otherwise set some nice defaults
-    */
-    if (priv->capability.capabilities & V4L2_CAP_TUNER) {
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_G_TUNER, &priv->tuner) < 0) {
-            MP_ERR(priv, "ioctl get tuner failed: %s\n", mp_strerror(errno));
-            uninit(priv);
-            return 0;
-        }
-    }
-    MP_INFO(priv, "Selected device: %s\n", priv->capability.card);
-    if (priv->capability.capabilities & V4L2_CAP_TUNER) {
-        MP_INFO(priv, " Tuner cap:%s%s%s\n",
-                (priv->tuner.capability & V4L2_TUNER_CAP_STEREO) ? " STEREO" : "",
-                (priv->tuner.capability & V4L2_TUNER_CAP_LANG1)  ? " LANG1"  : "",
-                (priv->tuner.capability & V4L2_TUNER_CAP_LANG2)  ? " LANG2"  : "");
-        MP_INFO(priv, " Tuner rxs:%s%s%s%s\n",
-                (priv->tuner.rxsubchans & V4L2_TUNER_SUB_MONO)   ? " MONO"   : "",
-                (priv->tuner.rxsubchans & V4L2_TUNER_SUB_STEREO) ? " STEREO" : "",
-                (priv->tuner.rxsubchans & V4L2_TUNER_SUB_LANG1)  ? " LANG1"  : "",
-                (priv->tuner.rxsubchans & V4L2_TUNER_SUB_LANG2)  ? " LANG2"  : "");
-    }
-    MP_INFO(priv, " Capabilities:%s%s%s%s%s%s%s%s%s%s%s\n",
-           priv->capability.capabilities & V4L2_CAP_VIDEO_CAPTURE?
-           "  video capture": "",
-           priv->capability.capabilities & V4L2_CAP_VIDEO_OUTPUT?
-           "  video output": "",
-           priv->capability.capabilities & V4L2_CAP_VIDEO_OVERLAY?
-           "  video overlay": "",
-           priv->capability.capabilities & V4L2_CAP_VBI_CAPTURE?
-           "  VBI capture device": "",
-           priv->capability.capabilities & V4L2_CAP_VBI_OUTPUT?
-           "  VBI output": "",
-           priv->capability.capabilities & V4L2_CAP_RDS_CAPTURE?
-           "  RDS data capture": "",
-           priv->capability.capabilities & V4L2_CAP_TUNER?
-           "  tuner": "",
-           priv->capability.capabilities & V4L2_CAP_AUDIO?
-           "  audio": "",
-           priv->capability.capabilities & V4L2_CAP_READWRITE?
-           "  read/write": "",
-           priv->capability.capabilities & V4L2_CAP_ASYNCIO?
-           "  async i/o": "",
-           priv->capability.capabilities & V4L2_CAP_STREAMING?
-           "  streaming": "");
-    MP_INFO(priv, " supported norms:");
-    for (i = 0;; i++) {
-        struct v4l2_standard standard;
-        memset(&standard, 0, sizeof(standard));
-        standard.index = i;
-        if (-1 == v4l2_ioctl(priv->video_fd, VIDIOC_ENUMSTD, &standard))
-            break;
-        MP_INFO(priv, " %d = %s;", i, standard.name);
-    }
-    MP_INFO(priv, "\n inputs:");
-    for (i = 0; 1; i++) {
-        struct v4l2_input input;
-
-        input.index = i;
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_ENUMINPUT, &input) < 0) {
-            break;
-        }
-        MP_INFO(priv, " %d = %s;", i, input.name);
-    }
-    i = -1;
-    if (v4l2_ioctl(priv->video_fd, VIDIOC_G_INPUT, &i) < 0) {
-        MP_ERR(priv, "ioctl get input failed: %s\n", mp_strerror(errno));
-    }
-    char buf[80];
-    MP_INFO(priv, "\n Current input: %d\n", i);
-    for (i = 0; ; i++) {
-        struct v4l2_fmtdesc fmtdesc;
-
-        fmtdesc.index = i;
-        fmtdesc.type  = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_ENUM_FMT, &fmtdesc) < 0) {
-            break;
-        }
-        MP_VERBOSE(priv, " Format %-6s (%2d bits, %s)\n",
-               pixfmt2name(buf, fmtdesc.pixelformat), pixfmt2depth(fmtdesc.pixelformat),
-               fmtdesc.description);
-    }
-    MP_INFO(priv, " Current format: %s\n",
-           pixfmt2name(buf, priv->format.fmt.pix.pixelformat));
-
-    /* set some nice defaults */
-    if (getfmt(priv) < 0) return 0;
-    priv->format.fmt.pix.width  = 640;
-    priv->format.fmt.pix.height = 480;
-    if (v4l2_ioctl(priv->video_fd, VIDIOC_S_FMT, &priv->format) < 0) {
-        MP_ERR(priv, "ioctl set format failed: %s\n", mp_strerror(errno));
-        uninit(priv);
-        return 0;
-    }
-
-//    if (!(priv->capability.capabilities & V4L2_CAP_AUDIO) && !priv->tv_param->force_audio) priv->tv_param->noaudio = 1;
-
-    if (priv->capability.capabilities & V4L2_CAP_TUNER) {
-        struct v4l2_control control;
-        if (priv->tv_param->amode >= 0) {
-            MP_VERBOSE(priv, "setting audio mode\n");
-            priv->tuner.audmode = amode2v4l(priv->tv_param->amode);
-            if (v4l2_ioctl(priv->video_fd, VIDIOC_S_TUNER, &priv->tuner) < 0) {
-                MP_ERR(priv, "ioctl set tuner failed: %s\n", mp_strerror(errno));
-                return TVI_CONTROL_FALSE;
-            }
-        }
-        MP_INFO(priv, "current audio mode is :%s%s%s%s\n",
-                (priv->tuner.audmode == V4L2_TUNER_MODE_MONO)   ? " MONO"   : "",
-                (priv->tuner.audmode == V4L2_TUNER_MODE_STEREO) ? " STEREO" : "",
-                (priv->tuner.audmode == V4L2_TUNER_MODE_LANG1)  ? " LANG1"  : "",
-                (priv->tuner.audmode == V4L2_TUNER_MODE_LANG2)  ? " LANG2"  : "");
-
-        if (priv->tv_param->volume >= 0) {
-            control.id = V4L2_CID_AUDIO_VOLUME;
-            control.value = priv->tv_param->volume;
-            set_control(priv, &control, 0);
-        }
-        if (priv->tv_param->bass >= 0) {
-            control.id = V4L2_CID_AUDIO_BASS;
-            control.value = priv->tv_param->bass;
-            set_control(priv, &control, 0);
-        }
-        if (priv->tv_param->treble >= 0) {
-            control.id = V4L2_CID_AUDIO_TREBLE;
-            control.value = priv->tv_param->treble;
-            set_control(priv, &control, 0);
-        }
-        if (priv->tv_param->balance >= 0) {
-            control.id = V4L2_CID_AUDIO_BALANCE;
-            control.value = priv->tv_param->balance;
-            set_control(priv, &control, 0);
-        }
-    }
-
-    return 1;
-}
-
-static int get_capture_buffer_size(priv_t *priv)
-{
-    uint64_t bufsize;
-    int cnt;
-
-    if (priv->tv_param->buffer_size >= 0) {
-        bufsize = priv->tv_param->buffer_size*1024*1024;
-    } else {
-        bufsize = 16*1024*1024;
-    }
-
-    cnt = bufsize/priv->format.fmt.pix.sizeimage;
-    if (cnt < 2) cnt = 2;
-
-    return cnt;
-}
-
-/* that's the real start, we'got the format parameters (checked with control) */
-static int start(priv_t *priv)
-{
-    struct v4l2_requestbuffers request;
-    unsigned int i;
-
-    /* setup audio parameters */
-
-    init_audio(priv);
-    if (priv->tv_param->audio && !priv->audio_initialized) return 0;
-
-    priv->video_buffer_size_max = get_capture_buffer_size(priv);
-
-    if (priv->tv_param->audio) {
-        setup_audio_buffer_sizes(priv);
-        priv->audio_skew_buffer = calloc(priv->aud_skew_cnt, sizeof(long long));
-        if (!priv->audio_skew_buffer) {
-            MP_ERR(priv, "cannot allocate skew buffer: %s\n", mp_strerror(errno));
-            return 0;
-        }
-        priv->audio_skew_delta_buffer = calloc(priv->aud_skew_cnt, sizeof(long long));
-        if (!priv->audio_skew_delta_buffer) {
-            MP_ERR(priv, "cannot allocate skew buffer: %s\n", mp_strerror(errno));
-            return 0;
-        }
-
-        priv->audio_ringbuffer = calloc(priv->audio_in.blocksize, priv->audio_buffer_size);
-        if (!priv->audio_ringbuffer) {
-            MP_ERR(priv, "cannot allocate audio buffer: %s\n", mp_strerror(errno));
-            return 0;
-        }
-
-        priv->audio_secs_per_block = (double)priv->audio_in.blocksize/(priv->audio_in.samplerate
-                                                                    *priv->audio_in.channels
-                                                                    *priv->audio_in.bytes_per_sample);
-        priv->audio_usecs_per_block = 1e6*priv->audio_secs_per_block;
-        priv->audio_head = 0;
-        priv->audio_tail = 0;
-        priv->audio_cnt = 0;
-        priv->audio_drop = 0;
-        priv->audio_skew = 0;
-        priv->audio_skew_total = 0;
-        priv->audio_skew_delta_total = 0;
-        priv->audio_recv_blocks_total = 0;
-        priv->audio_sent_blocks_total = 0;
-        priv->audio_null_blocks_inserted = 0;
-        priv->audio_insert_null_samples = 0;
-        priv->dropped_frames_timeshift = 0;
-        priv->dropped_frames_compensated = 0;
-
-        pthread_mutex_init(&priv->skew_mutex, NULL);
-        pthread_mutex_init(&priv->audio_mutex, NULL);
-    }
-
-    /* setup video parameters */
-    if (priv->tv_param->audio) {
-        if (priv->video_buffer_size_max < 3*getfps(priv)*priv->audio_secs_per_block) {
-            MP_ERR(priv, "Video buffer shorter than 3 times audio frame duration.\n"
-                   "You will probably experience heavy framedrops.\n");
-        }
-    }
-
-    {
-        int bytesperline = priv->format.fmt.pix.width*pixfmt2depth(priv->format.fmt.pix.pixelformat)/8;
-
-        MP_VERBOSE(priv, "Using a ring buffer for maximum %d frames, %d MB total size.\n",
-               priv->video_buffer_size_max,
-               priv->video_buffer_size_max*priv->format.fmt.pix.height*bytesperline/(1024*1024));
-    }
-
-    priv->video_ringbuffer = calloc(priv->video_buffer_size_max, sizeof(video_buffer_entry));
-    if (!priv->video_ringbuffer) {
-        MP_ERR(priv, "cannot allocate video buffer: %s\n", mp_strerror(errno));
-        return 0;
-    }
-    pthread_mutex_init(&priv->video_buffer_mutex, NULL);
-
-    priv->video_head = 0;
-    priv->video_tail = 0;
-    priv->video_cnt = 0;
-
-    /* request buffers */
-    request.count = BUFFER_COUNT;
-
-    request.type  = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    request.memory = V4L2_MEMORY_MMAP;
-    if (v4l2_ioctl(priv->video_fd, VIDIOC_REQBUFS, &request) < 0) {
-        MP_ERR(priv, "ioctl request buffers failed: %s\n", mp_strerror(errno));
-        return 0;
-    }
-
-    /* query buffers */
-    if (!(priv->map = calloc(request.count, sizeof(struct map)))) {
-        MP_ERR(priv, "malloc capture buffers failed: %s\n",  mp_strerror(errno));
-        return 0;
-    }
-
-    /* map and queue buffers */
-    for (i = 0; i < request.count; i++) {
-        priv->map[i].buf.index = i;
-        priv->map[i].buf.type  = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        priv->map[i].buf.memory  = V4L2_MEMORY_MMAP;
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_QUERYBUF, &(priv->map[i].buf)) < 0) {
-            MP_ERR(priv, "ioctl query buffer failed: %s\n", mp_strerror(errno));
-            free(priv->map);
-            priv->map = NULL;
-            return 0;
-        }
-        priv->map[i].addr = v4l2_mmap (0, priv->map[i].buf.length, PROT_READ |
-                                  PROT_WRITE, MAP_SHARED, priv->video_fd, priv->map[i].buf.m.offset);
-        if (priv->map[i].addr == MAP_FAILED) {
-            MP_ERR(priv, "mmap capture buffer failed: %s\n",  mp_strerror(errno));
-            priv->map[i].len = 0;
-            return 0;
-        }
-        priv->map[i].len = priv->map[i].buf.length;
-#ifdef HAVE_CLOCK_GETTIME
-        priv->clk_id = (priv->map[i].buf.flags & V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC)
-                           ? CLOCK_MONOTONIC : CLOCK_REALTIME;
-#else
-        if (priv->map[i].buf.flags & V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC)
-            MP_WARN(priv, "compiled without clock_gettime() that is needed to handle monotone video timestamps from the kernel. Expect desync.\n");
-#endif
-        /* count up to make sure this is correct every time */
-        priv->mapcount++;
-
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_QBUF, &(priv->map[i].buf)) < 0) {
-            MP_ERR(priv, "ioctl queue buffer failed: %s\n", mp_strerror(errno));
-            return 0;
-        }
-    }
-
-    /* start audio thread */
-    priv->shutdown = 0;
-    priv->audio_skew_measure_time = 0;
-    priv->first_frame = 0;
-    priv->audio_skew = 0;
-    priv->first = 1;
-
-    set_mute(priv, 0);
-
-    return 1;
-}
-
-// copies a video frame
-static inline void copy_frame(priv_t *priv, video_buffer_entry *dest, unsigned char *source,int len)
-{
-    dest->framesize=len;
-    if(priv->tv_param->automute>0){
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_G_TUNER, &priv->tuner) >= 0) {
-            if(priv->tv_param->automute<<8>priv->tuner.signal){
-                fill_blank_frame(dest->data,dest->framesize,fcc_vl2mp(priv->format.fmt.pix.pixelformat));
-                set_mute(priv,1);
-                return;
-            }
-        }
-        set_mute(priv,0);
-    }
-    memcpy(dest->data, source, len);
-}
-
-// maximum skew change, in frames
-#define MAX_SKEW_DELTA 0.6
-static void *video_grabber(void *data)
-{
-    priv_t *priv = (priv_t*)data;
-    long long skew, prev_skew, xskew, interval, prev_interval, delta;
-    int i;
-    int framesize = priv->format.fmt.pix.sizeimage;
-    fd_set rdset;
-    struct timeval timeout;
-    struct v4l2_buffer buf;
-
-    xskew = 0;
-    skew = 0;
-    interval = 0;
-    prev_interval = 0;
-    prev_skew = 0;
-
-    MP_VERBOSE(priv, "going to capture\n");
-    if (v4l2_ioctl(priv->video_fd, VIDIOC_STREAMON, &(priv->format.type)) < 0) {
-        MP_ERR(priv, "ioctl streamon failed: %s\n", mp_strerror(errno));
-        return 0;
-    }
-    priv->streamon = 1;
-
-    if (priv->tv_param->audio) {
-        pthread_create(&priv->audio_grabber_thread, NULL, audio_grabber, priv);
-    }
-
-    for (priv->frames = 0; !priv->shutdown;)
-    {
-        int ret;
-
-        while (priv->video_cnt == priv->video_buffer_size_max) {
-            usleep(10000);
-            if (priv->shutdown) {
-                return NULL;
-            }
-        }
-
-        FD_ZERO (&rdset);
-        FD_SET (priv->video_fd, &rdset);
-
-        timeout.tv_sec = 1;
-        timeout.tv_usec = 0;
-
-        i = select(priv->video_fd + 1, &rdset, NULL, NULL, &timeout);
-        if (i < 0) {
-            MP_ERR(priv, "select failed: %s\n", mp_strerror(errno));
-            continue;
-        }
-        else if (i == 0) {
-            MP_ERR(priv, "select timeout\n");
-            continue;
-        }
-        else if (!FD_ISSET(priv->video_fd, &rdset)) {
-            continue;
-        }
-
-        memset(&buf,0,sizeof(buf));
-        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        buf.memory = V4L2_MEMORY_MMAP;
-        ret = v4l2_ioctl(priv->video_fd, VIDIOC_DQBUF, &buf);
-
-        if (ret < 0) {
-            /*
-              if there's no signal, the buffer might me dequeued
-              so we query all the buffers to see which one we should
-              put back to queue
-
-              observed with saa7134 0.2.8
-              don't know if is it a bug or (mis)feature
-             */
-            MP_ERR(priv, "ioctl dequeue buffer failed: %s, idx = %d\n",
-                   mp_strerror(errno), buf.index);
-            for (i = 0; i < priv->mapcount; i++) {
-                memset(&buf,0,sizeof(buf));
-                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-                buf.memory = V4L2_MEMORY_MMAP;
-                buf.index = i;
-                ret = v4l2_ioctl(priv->video_fd, VIDIOC_QUERYBUF, &buf);
-                if (ret < 0) {
-                    MP_ERR(priv, "ioctl query buffer failed: %s, idx = %d\n",
-                           mp_strerror(errno), buf.index);
-                    return 0;
-                }
-                if ((buf.flags & (V4L2_BUF_FLAG_QUEUED | V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_DONE)) == V4L2_BUF_FLAG_MAPPED) {
-                    if (v4l2_ioctl(priv->video_fd, VIDIOC_QBUF, &(priv->map[i].buf)) < 0) {
-                        MP_ERR(priv, "ioctl queue buffer failed: %s\n",
-                               mp_strerror(errno));
-                        return 0;
-                    }
-                }
-            }
-            continue;
-        }
-
-        /* store the timestamp of the very first frame as reference */
-        if (!priv->frames++) {
-            if (priv->tv_param->audio) pthread_mutex_lock(&priv->skew_mutex);
-            priv->first_frame = buf.timestamp.tv_sec * 1000000LL + buf.timestamp.tv_usec;
-            if (priv->tv_param->audio) pthread_mutex_unlock(&priv->skew_mutex);
-        }
-        priv->curr_frame = buf.timestamp.tv_sec * 1000000LL + buf.timestamp.tv_usec;
-//        fprintf(stderr, "idx = %d, ts = %f\n", buf.index, (double)(priv->curr_frame) / 1e6);
-
-        interval = priv->curr_frame - priv->first_frame;
-        delta = interval - prev_interval;
-
-        // interpolate the skew in time
-        if (priv->tv_param->audio) pthread_mutex_lock(&priv->skew_mutex);
-        xskew = priv->audio_skew + (interval - priv->audio_skew_measure_time)*priv->audio_skew_factor;
-        if (priv->tv_param->audio) pthread_mutex_unlock(&priv->skew_mutex);
-            // correct extreme skew changes to avoid (especially) moving backwards in time
-        if (xskew - prev_skew > delta*MAX_SKEW_DELTA) {
-            skew = prev_skew + delta*MAX_SKEW_DELTA;
-        } else if (xskew - prev_skew < -delta*MAX_SKEW_DELTA) {
-            skew = prev_skew - delta*MAX_SKEW_DELTA;
-        } else {
-            skew = xskew;
-        }
-
-        MP_TRACE(priv, "\nfps = %f, interval = %f, a_skew = %f, corr_skew = %f\n",
-               delta ? (double)1e6/delta : -1,
-               (double)1e-6*interval, (double)1e-6*xskew, (double)1e-6*skew);
-        MP_TRACE(priv, "vcnt = %d, acnt = %d\n", priv->video_cnt, priv->audio_cnt);
-
-        prev_skew = skew;
-        prev_interval = interval;
-
-        /* allocate a new buffer, if needed */
-        pthread_mutex_lock(&priv->video_buffer_mutex);
-        if (priv->video_buffer_size_current < priv->video_buffer_size_max) {
-            if (priv->video_cnt == priv->video_buffer_size_current) {
-                unsigned char *newbuf = malloc(framesize);
-                if (newbuf) {
-                    memmove(priv->video_ringbuffer+priv->video_tail+1, priv->video_ringbuffer+priv->video_tail,
-                            (priv->video_buffer_size_current-priv->video_tail)*sizeof(video_buffer_entry));
-                    priv->video_ringbuffer[priv->video_tail].data = newbuf;
-                    if ((priv->video_head >= priv->video_tail) && (priv->video_cnt > 0)) priv->video_head++;
-                    priv->video_buffer_size_current++;
-                }
-            }
-        }
-        pthread_mutex_unlock(&priv->video_buffer_mutex);
-
-        if (priv->video_cnt == priv->video_buffer_size_current) {
-            MP_ERR(priv, "\nvideo buffer full - dropping frame\n");
-            if (!priv->immediate_mode || priv->audio_insert_null_samples) {
-                pthread_mutex_lock(&priv->audio_mutex);
-                priv->dropped_frames_timeshift += delta;
-                pthread_mutex_unlock(&priv->audio_mutex);
-            }
-        } else {
-            if (priv->immediate_mode) {
-                priv->video_ringbuffer[priv->video_tail].timestamp = interval - skew;
-            } else {
-                // compensate for audio skew
-                // negative skew => there are more audio samples, increase interval
-                // positive skew => less samples, shorten the interval
-                priv->video_ringbuffer[priv->video_tail].timestamp = interval - skew;
-                if (priv->audio_insert_null_samples && priv->video_ringbuffer[priv->video_tail].timestamp > 0) {
-                    pthread_mutex_lock(&priv->audio_mutex);
-                    priv->video_ringbuffer[priv->video_tail].timestamp +=
-                        (priv->audio_null_blocks_inserted
-                         - priv->dropped_frames_timeshift/priv->audio_usecs_per_block)
-                        *priv->audio_usecs_per_block;
-                    pthread_mutex_unlock(&priv->audio_mutex);
-                }
-            }
-            copy_frame(priv, priv->video_ringbuffer+priv->video_tail, priv->map[buf.index].addr,buf.bytesused);
-            priv->video_tail = (priv->video_tail+1)%priv->video_buffer_size_current;
-            priv->video_cnt++;
-        }
-        if (v4l2_ioctl(priv->video_fd, VIDIOC_QBUF, &buf) < 0) {
-            MP_ERR(priv, "ioctl queue buffer failed: %s\n", mp_strerror(errno));
-            return 0;
-        }
-    }
-    return NULL;
-}
-
-#define MAX_LOOP 500
-static double grab_video_frame(priv_t *priv, char *buffer, int len)
-{
-    int loop_cnt = 0;
-
-    if (priv->first) {
-        pthread_create(&priv->video_grabber_thread, NULL, video_grabber, priv);
-        priv->first = 0;
-    }
-
-    while (priv->video_cnt == 0) {
-        usleep(1000);
-        if (loop_cnt++ > MAX_LOOP) return 0;
-    }
-
-    pthread_mutex_lock(&priv->video_buffer_mutex);
-    long long interval = priv->video_ringbuffer[priv->video_head].timestamp;
-    memcpy(buffer, priv->video_ringbuffer[priv->video_head].data, len);
-    priv->video_cnt--;
-    priv->video_head = (priv->video_head+1)%priv->video_buffer_size_current;
-    pthread_mutex_unlock(&priv->video_buffer_mutex);
-
-    return interval == -1 ? MP_NOPTS_VALUE : interval*1e-6;
-}
-
-static int get_video_framesize(priv_t *priv)
-{
-    /*
-      this routine will be called before grab_video_frame
-      thus let's return topmost frame's size
-    */
-    if (priv->video_cnt)
-        return priv->video_ringbuffer[priv->video_head].framesize;
-    /*
-      no video frames yet available. i don't know what to do in this case,
-      thus let's return some fallback result (for compressed format this will be
-      maximum allowed frame size.
-    */
-    return priv->format.fmt.pix.sizeimage;
-}
-
-static void *audio_grabber(void *data)
-{
-    priv_t *priv = (priv_t*)data;
-    int i, audio_skew_ptr = 0;
-    long long current_time, prev_skew = 0, prev_skew_uncorr = 0;
-    long long start_time_avg, curr_timestamp;
-
-    start_time_avg = priv->audio_start_time = get_curr_timestamp(priv->clk_id);
-    audio_in_start_capture(&priv->audio_in);
-    for (i = 0; i < priv->aud_skew_cnt; i++)
-        priv->audio_skew_buffer[i] = 0;
-    for (i = 0; i < priv->aud_skew_cnt; i++)
-        priv->audio_skew_delta_buffer[i] = 0;
-
-    for (; !priv->shutdown;)
-    {
-        if (audio_in_read_chunk(&priv->audio_in, priv->audio_ringbuffer+priv->audio_tail*priv->audio_in.blocksize) < 0)
-            continue;
-        pthread_mutex_lock(&priv->skew_mutex);
-        if (priv->first_frame == 0) {
-            // there is no first frame yet (unlikely to happen)
-            start_time_avg = priv->audio_start_time = get_curr_timestamp(priv->clk_id);
-//            fprintf(stderr, "warning - first frame not yet available!\n");
-            pthread_mutex_unlock(&priv->skew_mutex);
-            continue;
-        }
-        pthread_mutex_unlock(&priv->skew_mutex);
-
-        priv->audio_recv_blocks_total++;
-        curr_timestamp = get_curr_timestamp(priv->clk_id);
-        current_time = curr_timestamp - priv->audio_start_time;
-
-        if (priv->audio_recv_blocks_total < priv->aud_skew_cnt*2) {
-            start_time_avg += curr_timestamp - priv->audio_usecs_per_block*priv->audio_recv_blocks_total;
-            priv->audio_start_time = start_time_avg/(priv->audio_recv_blocks_total+1);
-        }
-
-//        fprintf(stderr, "spb = %f, bs = %d, skew = %f\n", priv->audio_secs_per_block, priv->audio_in.blocksize,
-//                (double)(current_time - 1e6*priv->audio_secs_per_block*priv->audio_recv_blocks_total)/1e6);
-
-        // put the current skew into the ring buffer
-        priv->audio_skew_total -= priv->audio_skew_buffer[audio_skew_ptr];
-        priv->audio_skew_buffer[audio_skew_ptr] = current_time
-            - priv->audio_usecs_per_block*priv->audio_recv_blocks_total;
-        priv->audio_skew_total += priv->audio_skew_buffer[audio_skew_ptr];
-
-        pthread_mutex_lock(&priv->skew_mutex);
-
-        // skew calculation
-
-        // compute the sliding average of the skews
-        if (priv->audio_recv_blocks_total > priv->aud_skew_cnt) {
-            priv->audio_skew = priv->audio_skew_total/priv->aud_skew_cnt;
-        } else {
-            priv->audio_skew = priv->audio_skew_total/priv->audio_recv_blocks_total;
-        }
-
-        // put the current skew change (skew-prev_skew) into the ring buffer
-        priv->audio_skew_delta_total -= priv->audio_skew_delta_buffer[audio_skew_ptr];
-        priv->audio_skew_delta_buffer[audio_skew_ptr] = priv->audio_skew - prev_skew_uncorr;
-        priv->audio_skew_delta_total += priv->audio_skew_delta_buffer[audio_skew_ptr];
-        prev_skew_uncorr = priv->audio_skew; // remember the _uncorrected_ average value
-
-        audio_skew_ptr = (audio_skew_ptr+1) % priv->aud_skew_cnt; // rotate the buffer pointer
-
-        // sliding average approximates the value in the middle of the interval
-        // so interpolate the skew value further to the current time
-        priv->audio_skew += priv->audio_skew_delta_total/2;
-
-        // now finally, priv->audio_skew contains fairly good approximation
-        // of the current value
-
-        // current skew factor (assuming linearity)
-        // used for further interpolation in video_grabber
-        // probably overkill but seems to be necessary for
-        // stress testing by dropping half of the audio frames ;)
-        // especially when using ALSA with large block sizes
-        // where audio_skew remains a long while behind
-        if ((priv->audio_skew_measure_time != 0) && (current_time - priv->audio_skew_measure_time != 0)) {
-            priv->audio_skew_factor = (double)(priv->audio_skew-prev_skew)/(current_time - priv->audio_skew_measure_time);
-        } else {
-            priv->audio_skew_factor = 0.0;
-        }
-
-        priv->audio_skew_measure_time = current_time;
-        prev_skew = priv->audio_skew;
-        priv->audio_skew += priv->audio_start_time - priv->first_frame;
-        pthread_mutex_unlock(&priv->skew_mutex);
-
-//        fprintf(stderr, "audio_skew = %f, delta = %f\n", (double)priv->audio_skew/1e6, (double)priv->audio_skew_delta_total/1e6);
-
-        pthread_mutex_lock(&priv->audio_mutex);
-        if ((priv->audio_tail+1) % priv->audio_buffer_size == priv->audio_head) {
-            MP_ERR(priv, "\ntoo bad - dropping audio frame !\n");
-            priv->audio_drop++;
-        } else {
-            priv->audio_tail = (priv->audio_tail+1) % priv->audio_buffer_size;
-            priv->audio_cnt++;
-        }
-        pthread_mutex_unlock(&priv->audio_mutex);
-    }
-    return NULL;
-}
-
-static double grab_audio_frame(priv_t *priv, char *buffer, int len)
-{
-    MP_DBG(priv, "grab_audio_frame(priv=%p, buffer=%p, len=%d)\n",
-        priv, buffer, len);
-
-    // hack: if grab_audio_frame is called first, it means we are used by mplayer
-    // => switch to the mode which outputs audio immediately, even if
-    // it should be silence
-    if (priv->first) priv->audio_insert_null_samples = 1;
-
-    pthread_mutex_lock(&priv->audio_mutex);
-    while (priv->audio_insert_null_samples
-           && priv->dropped_frames_timeshift - priv->dropped_frames_compensated >= priv->audio_usecs_per_block) {
-        // some frames were dropped - drop the corresponding number of audio blocks
-        if (priv->audio_drop) {
-            priv->audio_drop--;
-        } else {
-            if (priv->audio_head == priv->audio_tail) break;
-            priv->audio_head = (priv->audio_head+1) % priv->audio_buffer_size;
-        }
-        priv->dropped_frames_compensated += priv->audio_usecs_per_block;
-    }
-
-    // compensate for dropped audio frames
-    if (priv->audio_drop && (priv->audio_head == priv->audio_tail)) {
-        priv->audio_drop--;
-        memset(buffer, 0, len);
-        goto out;
-    }
-
-    if (priv->audio_insert_null_samples && (priv->audio_head == priv->audio_tail)) {
-        // return silence to avoid desync and stuttering
-        memset(buffer, 0, len);
-        priv->audio_null_blocks_inserted++;
-        goto out;
-    }
-
-    pthread_mutex_unlock(&priv->audio_mutex);
-    while (priv->audio_head == priv->audio_tail) {
-        // this is mencoder => just wait until some audio is available
-        usleep(10000);
-    }
-    pthread_mutex_lock(&priv->audio_mutex);
-    memcpy(buffer, priv->audio_ringbuffer+priv->audio_head*priv->audio_in.blocksize, len);
-    priv->audio_head = (priv->audio_head+1) % priv->audio_buffer_size;
-    priv->audio_cnt--;
-out:
-    pthread_mutex_unlock(&priv->audio_mutex);
-    priv->audio_sent_blocks_total++;
-    return (double)priv->audio_sent_blocks_total*priv->audio_secs_per_block;
-}
-
-static int get_audio_framesize(priv_t *priv)
-{
-    return priv->audio_in.blocksize;
-}
diff -ruN mpv-0.29.1/sub/filter_sdh.c mpv-master/sub/filter_sdh.c
--- mpv-0.29.1/sub/filter_sdh.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/sub/filter_sdh.c	2019-09-19 04:02:03.000000000 +0700
@@ -406,8 +406,11 @@
                     line_with_text =  true;
                 }
             } else if (*rp && rp[0] != '\\') {
-                if (rp[0] > 32 && rp[0] < 127 && rp[0] != '-')
+                if ((rp[0] > 32 && rp[0] < 127 && rp[0] != '-') ||
+                    (unsigned char)rp[0] >= 0xC0)
+                {
                     line_with_text =  true;
+                }
                 append(sd, buf, rp[0]);
                 rp++;
             } else if (rp[0] == '\\' && rp[1] != 'N') {
diff -ruN mpv-0.29.1/sub/lavc_conv.c mpv-master/sub/lavc_conv.c
--- mpv-0.29.1/sub/lavc_conv.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/sub/lavc_conv.c	2019-09-19 04:02:03.000000000 +0700
@@ -85,6 +85,7 @@
         goto error;
     if (mp_lavc_set_extradata(avctx, extradata, extradata_len) < 0)
         goto error;
+    av_dict_set(&opts, "sub_text_format", "ass", 0);
     if (strcmp(codec_name, "eia_608") == 0)
         av_dict_set(&opts, "real_time", "1", 0);
     if (avcodec_open2(avctx, codec, &opts) < 0)
@@ -227,8 +228,11 @@
 
 #endif
 
-// Return a NULL-terminated list of ASS event lines.
-char **lavc_conv_decode(struct lavc_conv *priv, struct demux_packet *packet)
+// Return a NULL-terminated list of ASS event lines and have
+// the AVSubtitle display PTS and duration set to input
+// double variables.
+char **lavc_conv_decode(struct lavc_conv *priv, struct demux_packet *packet,
+                        double *sub_pts, double *sub_duration)
 {
     AVCodecContext *avctx = priv->avctx;
     AVPacket pkt;
@@ -254,6 +258,14 @@
     if (ret < 0) {
         MP_ERR(priv, "Error decoding subtitle\n");
     } else if (got_sub) {
+        *sub_pts = packet->pts + mp_pts_from_av(priv->cur.start_display_time,
+                                               &avctx->time_base);
+        *sub_duration = priv->cur.end_display_time == UINT32_MAX ?
+                        UINT32_MAX :
+                        mp_pts_from_av(priv->cur.end_display_time -
+                                       priv->cur.start_display_time,
+                                       &avctx->time_base);
+
         for (int i = 0; i < priv->cur.num_rects; i++) {
             if (priv->cur.rects[i]->w > 0 && priv->cur.rects[i]->h > 0)
                 MP_WARN(priv, "Ignoring bitmap subtitle.\n");
diff -ruN mpv-0.29.1/sub/osd.c mpv-master/sub/osd.c
--- mpv-0.29.1/sub/osd.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/sub/osd.c	2019-09-19 04:02:03.000000000 +0700
@@ -217,8 +217,10 @@
     osd_obj->progbar_state.value = s->value;
     osd_obj->progbar_state.num_stops = s->num_stops;
     MP_TARRAY_GROW(osd_obj, osd_obj->progbar_state.stops, s->num_stops);
-    memcpy(osd_obj->progbar_state.stops, s->stops,
-           sizeof(osd_obj->progbar_state.stops[0]) * s->num_stops);
+    if (s->num_stops) {
+        memcpy(osd_obj->progbar_state.stops, s->stops,
+               sizeof(osd_obj->progbar_state.stops[0]) * s->num_stops);
+    }
     osd_obj->osd_changed = true;
     osd->want_redraw_notification = true;
     pthread_mutex_unlock(&osd->lock);
diff -ruN mpv-0.29.1/sub/sd.h mpv-master/sub/sd.h
--- mpv-0.29.1/sub/sd.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/sub/sd.h	2019-09-19 04:02:03.000000000 +0700
@@ -46,7 +46,8 @@
 struct lavc_conv *lavc_conv_create(struct mp_log *log, const char *codec_name,
                                    char *extradata, int extradata_len);
 char *lavc_conv_get_extradata(struct lavc_conv *priv);
-char **lavc_conv_decode(struct lavc_conv *priv, struct demux_packet *packet);
+char **lavc_conv_decode(struct lavc_conv *priv, struct demux_packet *packet,
+                        double *sub_pts, double *sub_duration);
 void lavc_conv_reset(struct lavc_conv *priv);
 void lavc_conv_uninit(struct lavc_conv *priv);
 
diff -ruN mpv-0.29.1/sub/sd_ass.c mpv-master/sub/sd_ass.c
--- mpv-0.29.1/sub/sd_ass.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/sub/sd_ass.c	2019-09-19 04:02:03.000000000 +0700
@@ -177,8 +177,7 @@
         ass_set_style_overrides(ctx->ass_library, opts->ass_force_style_list);
 
     ctx->ass_track = ass_new_track(ctx->ass_library);
-    if (!ctx->is_converted)
-        ctx->ass_track->track_type = TRACK_TYPE_ASS;
+    ctx->ass_track->track_type = TRACK_TYPE_ASS;
 
     ctx->shadow_track = ass_new_track(ctx->ass_library);
     ctx->shadow_track->PlayResX = 384;
@@ -234,20 +233,27 @@
         if (!sd->opts->sub_clear_on_seek && packet->pos >= 0 &&
             check_packet_seen(sd, packet->pos))
             return;
-        if (packet->duration < 0) {
+
+        double sub_pts = 0;
+        double sub_duration = 0;
+        char **r = lavc_conv_decode(ctx->converter, packet, &sub_pts,
+                                    &sub_duration);
+        if (packet->duration < 0 || sub_duration == UINT32_MAX) {
             if (!ctx->duration_unknown) {
                 MP_WARN(sd, "Subtitle with unknown duration.\n");
                 ctx->duration_unknown = true;
             }
-            packet->duration = UNKNOWN_DURATION;
+            sub_duration = UNKNOWN_DURATION;
         }
-        char **r = lavc_conv_decode(ctx->converter, packet);
+
         for (int n = 0; r && r[n]; n++) {
             char *ass_line = r[n];
             if (sd->opts->sub_filter_SDH)
                 ass_line = filter_SDH(sd, track->event_format, 0, ass_line, 0);
             if (ass_line)
-                ass_process_data(track, ass_line, strlen(ass_line));
+                ass_process_chunk(track, ass_line, strlen(ass_line),
+                                  llrint(sub_pts * 1000),
+                                  llrint(sub_duration * 1000));
             if (sd->opts->sub_filter_SDH)
                 talloc_free(ass_line);
         }
diff -ruN mpv-0.29.1/test/json.c mpv-master/test/json.c
--- mpv-0.29.1/test/json.c	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/test/json.c	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,97 @@
+#include "test_helpers.h"
+
+#include "common/common.h"
+#include "misc/json.h"
+#include "misc/node.h"
+
+struct entry {
+    const char *src;
+    const char *out_txt;
+    struct mpv_node out_data;
+    bool expect_fail;
+};
+
+#define TEXT(...) #__VA_ARGS__
+
+#define VAL_LIST(...) (struct mpv_node[]){__VA_ARGS__}
+
+#define L(...) __VA_ARGS__
+
+#define NODE_INT64(v) {.format = MPV_FORMAT_INT64,  .u = { .int64 = (v) }}
+#define NODE_STR(v)   {.format = MPV_FORMAT_STRING, .u = { .string = (v) }}
+#define NODE_BOOL(v)  {.format = MPV_FORMAT_FLAG,   .u = { .flag = (bool)(v) }}
+#define NODE_FLOAT(v) {.format = MPV_FORMAT_DOUBLE, .u = { .double_ = (v) }}
+#define NODE_NONE()   {.format = MPV_FORMAT_NONE }
+#define NODE_ARRAY(...) {.format = MPV_FORMAT_NODE_ARRAY, .u = { .list =    \
+    &(struct mpv_node_list) {                                               \
+        .num = sizeof(VAL_LIST(__VA_ARGS__)) / sizeof(struct mpv_node),     \
+        .values = VAL_LIST(__VA_ARGS__)}}}
+#define NODE_MAP(k, v) {.format = MPV_FORMAT_NODE_MAP, .u = { .list =       \
+    &(struct mpv_node_list) {                                               \
+        .num = sizeof(VAL_LIST(v)) / sizeof(struct mpv_node),               \
+        .values = VAL_LIST(v),                                              \
+        .keys = (char**)(const char *[]){k}}}}
+
+static const struct entry entries[] = {
+    { "null", "null", NODE_NONE()},
+    { "true", "true", NODE_BOOL(true)},
+    { "false", "false", NODE_BOOL(false)},
+    { "", .expect_fail = true},
+    { "abc", .expect_fail = true},
+    { "  123  ", "123", NODE_INT64(123)},
+    { "123.25", "123.250000", NODE_FLOAT(123.25)},
+    { TEXT("a\n\\\/\\\""), TEXT("a\n\\/\\\""), NODE_STR("a\n\\/\\\"")},
+    { TEXT("a\u2c29"), TEXT("aⰩ"), NODE_STR("a\342\260\251")},
+    { "[1,2,3]", "[1,2,3]",
+        NODE_ARRAY(NODE_INT64(1), NODE_INT64(2), NODE_INT64(3))},
+    { "[ ]", "[]", NODE_ARRAY()},
+    { "[1,,2]", .expect_fail = true},
+    { "[,]", .expect_fail = true},
+    { TEXT({"a":1, "b":2}), TEXT({"a":1,"b":2}),
+        NODE_MAP(L("a", "b"), L(NODE_INT64(1), NODE_INT64(2)))},
+    { "{ }", "{}", NODE_MAP(L(), L())},
+    { TEXT({"a":b}), .expect_fail = true},
+    { TEXT({1a:"b"}), .expect_fail = true},
+
+    // non-standard extensions
+    { "[1,2,]", "[1,2]", NODE_ARRAY(NODE_INT64(1), NODE_INT64(2))},
+    { TEXT({a:"b"}), TEXT({"a":"b"}),
+        NODE_MAP(L("a"), L(NODE_STR("b")))},
+    { TEXT({a="b"}), TEXT({"a":"b"}),
+        NODE_MAP(L("a"), L(NODE_STR("b")))},
+    { TEXT({a ="b"}), TEXT({"a":"b"}),
+        NODE_MAP(L("a"), L(NODE_STR("b")))},
+    { TEXT({_a12="b"}), TEXT({"_a12":"b"}),
+        NODE_MAP(L("_a12"), L(NODE_STR("b")))},
+};
+
+#define MAX_DEPTH 10
+
+static void test_json(void **state)
+{
+    for (int n = 0; n < MP_ARRAY_SIZE(entries); n++) {
+        const struct entry *e = &entries[n];
+        print_message("%d: %s\n", n, e->src);
+        void *tmp = talloc_new(NULL);
+        char *s = talloc_strdup(tmp, e->src);
+        json_skip_whitespace(&s);
+        struct mpv_node res;
+        bool ok = json_parse(tmp, &res, &s, MAX_DEPTH) >= 0;
+        assert_true(ok != e->expect_fail);
+        if (!ok)
+            continue;
+        char *d = talloc_strdup(tmp, "");
+        assert_true(json_write(&d, &res) >= 0);
+        assert_string_equal(e->out_txt, d);
+        assert_true(equal_mpv_node(&e->out_data, &res));
+        talloc_free(tmp);
+    }
+}
+
+int main(void) {
+    const struct CMUnitTest tests[] = {
+        cmocka_unit_test(test_json),
+    };
+    return cmocka_run_group_tests(tests, NULL, NULL);
+}
+
diff -ruN mpv-0.29.1/test/linked_list.c mpv-master/test/linked_list.c
--- mpv-0.29.1/test/linked_list.c	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/test/linked_list.c	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,162 @@
+#include "test_helpers.h"
+
+#include "common/common.h"
+#include "misc/linked_list.h"
+
+struct list_item {
+    int v;
+    struct {
+        struct list_item *prev, *next;
+    } list_node;
+};
+
+struct the_list {
+    struct list_item *head, *tail;
+};
+
+static bool do_check_list(struct the_list *lst, int *c, int num_c)
+{
+    if (!lst->head)
+        assert_true(!lst->tail);
+    if (!lst->tail)
+        assert_true(!lst->head);
+
+    for (struct list_item *cur = lst->head; cur; cur = cur->list_node.next) {
+        if (cur->list_node.prev) {
+            assert_true(cur->list_node.prev->list_node.next == cur);
+            assert_true(lst->head != cur);
+        } else {
+            assert_true(lst->head == cur);
+        }
+        if (cur->list_node.next) {
+            assert_true(cur->list_node.next->list_node.prev == cur);
+            assert_true(lst->tail != cur);
+        } else {
+            assert_true(lst->tail == cur);
+        }
+
+        if (num_c < 1)
+            return false;
+        if (c[0] != cur->v)
+            return false;
+
+        num_c--;
+        c++;
+    }
+
+    if (num_c)
+        return false;
+
+    return true;
+}
+
+static void test_linked_list(void **state)
+{
+    struct the_list lst = {0};
+    struct list_item e1 = {1};
+    struct list_item e2 = {2};
+    struct list_item e3 = {3};
+    struct list_item e4 = {4};
+    struct list_item e5 = {5};
+    struct list_item e6 = {6};
+
+#define check_list(...) \
+        assert_true(do_check_list(&lst, (int[]){__VA_ARGS__}, \
+                        sizeof((int[]){__VA_ARGS__}) / sizeof(int)));
+#define check_list_empty() \
+        assert_true(do_check_list(&lst, NULL, 0));
+
+    check_list_empty();
+    LL_APPEND(list_node, &lst, &e1);
+
+    check_list(1);
+    LL_APPEND(list_node, &lst, &e2);
+
+    check_list(1, 2);
+    LL_APPEND(list_node, &lst, &e4);
+
+    check_list(1, 2, 4);
+    LL_CLEAR(list_node, &lst);
+
+    check_list_empty();
+    LL_PREPEND(list_node, &lst, &e4);
+
+    check_list(4);
+    LL_PREPEND(list_node, &lst, &e2);
+
+    check_list(2, 4);
+    LL_PREPEND(list_node, &lst, &e1);
+
+    check_list(1, 2, 4);
+    LL_CLEAR(list_node, &lst);
+
+    check_list_empty();
+    LL_INSERT_BEFORE(list_node, &lst, (struct list_item *)NULL, &e6);
+
+    check_list(6);
+    LL_INSERT_BEFORE(list_node, &lst, (struct list_item *)NULL, &e1);
+
+    check_list(6, 1);
+    LL_INSERT_BEFORE(list_node, &lst, (struct list_item *)NULL, &e2);
+
+    check_list(6, 1, 2);
+    LL_INSERT_BEFORE(list_node, &lst, &e6, &e3);
+
+    check_list(3, 6, 1, 2);
+    LL_INSERT_BEFORE(list_node, &lst, &e6, &e5);
+
+    check_list(3, 5, 6, 1, 2);
+    LL_INSERT_BEFORE(list_node, &lst, &e2, &e4);
+
+    check_list(3, 5, 6, 1, 4, 2);
+    LL_REMOVE(list_node, &lst, &e6);
+
+    check_list(3, 5, 1, 4, 2);
+    LL_REMOVE(list_node, &lst, &e3);
+
+    check_list(5, 1, 4, 2);
+    LL_REMOVE(list_node, &lst, &e2);
+
+    check_list(5, 1, 4);
+    LL_REMOVE(list_node, &lst, &e4);
+
+    check_list(5, 1);
+    LL_REMOVE(list_node, &lst, &e5);
+
+    check_list(1);
+    LL_REMOVE(list_node, &lst, &e1);
+
+    check_list_empty();
+    LL_APPEND(list_node, &lst, &e2);
+
+    check_list(2);
+    LL_REMOVE(list_node, &lst, &e2);
+
+    check_list_empty();
+    LL_INSERT_AFTER(list_node, &lst, (struct list_item *)NULL, &e1);
+
+    check_list(1);
+    LL_INSERT_AFTER(list_node, &lst, (struct list_item *)NULL, &e2);
+
+    check_list(2, 1);
+    LL_INSERT_AFTER(list_node, &lst, (struct list_item *)NULL, &e3);
+
+    check_list(3, 2, 1);
+    LL_INSERT_AFTER(list_node, &lst, &e3, &e4);
+
+    check_list(3, 4, 2, 1);
+    LL_INSERT_AFTER(list_node, &lst, &e4, &e5);
+
+    check_list(3, 4, 5, 2, 1);
+    LL_INSERT_AFTER(list_node, &lst, &e1, &e6);
+
+    check_list(3, 4, 5, 2, 1, 6);
+}
+
+int main(void) {
+    const struct CMUnitTest tests[] = {
+        cmocka_unit_test(test_linked_list),
+    };
+    return cmocka_run_group_tests(tests, NULL, NULL);
+}
+
diff -ruN mpv-0.29.1/version.sh mpv-master/version.sh
--- mpv-0.29.1/version.sh	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/version.sh	2019-09-19 04:02:03.000000000 +0700
@@ -54,7 +54,7 @@
 NEW_REVISION="#define VERSION \"${VERSION}\""
 OLD_REVISION=$(head -n 1 "$version_h" 2> /dev/null)
 BUILDDATE="#define BUILDDATE \"$(date)\""
-MPVCOPYRIGHT="#define MPVCOPYRIGHT \"Copyright © 2000-2018 mpv/MPlayer/mplayer2 projects\""
+MPVCOPYRIGHT="#define MPVCOPYRIGHT \"Copyright © 2000-2019 mpv/MPlayer/mplayer2 projects\""
 
 # Update version.h only on revision changes to avoid spurious rebuilds
 if test "$NEW_REVISION" != "$OLD_REVISION"; then
diff -ruN mpv-0.29.1/video/decode/vd_lavc.c mpv-master/video/decode/vd_lavc.c
--- mpv-0.29.1/video/decode/vd_lavc.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/decode/vd_lavc.c	2019-09-19 04:02:03.000000000 +0700
@@ -28,9 +28,12 @@
 #include <libavutil/intreadwrite.h>
 #include <libavutil/pixdesc.h>
 
+#include "config.h"
+
 #include "mpv_talloc.h"
 #include "common/global.h"
 #include "common/msg.h"
+#include "options/m_config.h"
 #include "options/options.h"
 #include "misc/bstr.h"
 #include "common/av_common.h"
@@ -59,6 +62,8 @@
 static int get_buffer2_direct(AVCodecContext *avctx, AVFrame *pic, int flags);
 static enum AVPixelFormat get_format_hwdec(struct AVCodecContext *avctx,
                                            const enum AVPixelFormat *pix_fmt);
+static int hwdec_validate_opt(struct mp_log *log, const m_option_t *opt,
+                              struct bstr name, struct bstr param);
 
 #define HWDEC_DELAY_QUEUE_COUNT 2
 
@@ -84,6 +89,9 @@
     int software_fallback;
     char **avopts;
     int dr;
+    char *hwdec_api;
+    char *hwdec_codecs;
+    int hwdec_image_format;
 };
 
 static const struct m_opt_choice_alternatives discard_names[] = {
@@ -101,20 +109,24 @@
 
 const struct m_sub_options vd_lavc_conf = {
     .opts = (const m_option_t[]){
-        OPT_FLAG("fast", fast, 0),
-        OPT_FLAG("show-all", show_all, 0),
-        OPT_DISCARD("skiploopfilter", skip_loop_filter, 0),
-        OPT_DISCARD("skipidct", skip_idct, 0),
-        OPT_DISCARD("skipframe", skip_frame, 0),
-        OPT_DISCARD("framedrop", framedrop, 0),
-        OPT_INT("threads", threads, M_OPT_MIN, .min = 0),
-        OPT_FLAG("bitexact", bitexact, 0),
-        OPT_FLAG("assume-old-x264", old_x264, 0),
-        OPT_FLAG("check-hw-profile", check_hw_profile, 0),
-        OPT_CHOICE_OR_INT("software-fallback", software_fallback, 0, 1, INT_MAX,
-                          ({"no", INT_MAX}, {"yes", 1})),
-        OPT_KEYVALUELIST("o", avopts, 0),
-        OPT_FLAG("dr", dr, 0),
+        OPT_FLAG("vd-lavc-fast", fast, 0),
+        OPT_FLAG("vd-lavc-show-all", show_all, 0),
+        OPT_DISCARD("vd-lavc-skiploopfilter", skip_loop_filter, 0),
+        OPT_DISCARD("vd-lavc-skipidct", skip_idct, 0),
+        OPT_DISCARD("vd-lavc-skipframe", skip_frame, 0),
+        OPT_DISCARD("vd-lavc-framedrop", framedrop, 0),
+        OPT_INT("vd-lavc-threads", threads, M_OPT_MIN, .min = 0),
+        OPT_FLAG("vd-lavc-bitexact", bitexact, 0),
+        OPT_FLAG("vd-lavc-assume-old-x264", old_x264, 0),
+        OPT_FLAG("vd-lavc-check-hw-profile", check_hw_profile, 0),
+        OPT_CHOICE_OR_INT("vd-lavc-software-fallback", software_fallback,
+                          0, 1, INT_MAX, ({"no", INT_MAX}, {"yes", 1})),
+        OPT_KEYVALUELIST("vd-lavc-o", avopts, 0),
+        OPT_FLAG("vd-lavc-dr", dr, 0),
+        OPT_STRING_VALIDATE("hwdec", hwdec_api, M_OPT_OPTIONAL_PARAM,
+                            hwdec_validate_opt),
+        OPT_STRING("hwdec-codecs", hwdec_codecs, 0),
+        OPT_IMAGEFORMAT("hwdec-image-format", hwdec_image_format, 0, .min = -1),
         {0}
     },
     .size = sizeof(struct vd_lavc_params),
@@ -127,12 +139,14 @@
         .skip_frame = AVDISCARD_DEFAULT,
         .framedrop = AVDISCARD_NONREF,
         .dr = 1,
+        .hwdec_api = HAVE_RPI ? "mmal" : "no",
+        .hwdec_codecs = "h264,vc1,hevc,vp9",
     },
 };
 
 struct hwdec_info {
     char name[64];
-    char method_name[16]; // non-unique name describing the hwdec method
+    char method_name[24]; // non-unique name describing the hwdec method
     const AVCodec *codec; // implemented by this codec
     enum AVHWDeviceType lavc_device; // if not NONE, get a hwdevice
     bool copying; // if true, outputs sw frames, or copy to sw ourselves
@@ -147,7 +161,8 @@
 
 typedef struct lavc_ctx {
     struct mp_log *log;
-    struct MPOpts *opts;
+    struct m_config_cache *opts_cache;
+    struct vd_lavc_params *opts;
     struct mp_codec_params *codec;
     AVCodecContext *avctx;
     AVFrame *pic;
@@ -409,6 +424,8 @@
     vd_ffmpeg_ctx *ctx = vd->priv;
     const char *codec = ctx->codec->codec;
 
+    m_config_cache_update(ctx->opts_cache);
+
     bstr opt = bstr0(ctx->opts->hwdec_api);
 
     bool hwdec_requested = !bstr_equals0(opt, "no");
@@ -493,8 +510,8 @@
     }
 }
 
-int hwdec_validate_opt(struct mp_log *log, const m_option_t *opt,
-                       struct bstr name, struct bstr param)
+static int hwdec_validate_opt(struct mp_log *log, const m_option_t *opt,
+                              struct bstr name, struct bstr param)
 {
     if (bstr_equals0(param, "help")) {
         struct hwdec_info *hwdecs = NULL;
@@ -543,9 +560,11 @@
 static void init_avctx(struct mp_filter *vd)
 {
     vd_ffmpeg_ctx *ctx = vd->priv;
-    struct vd_lavc_params *lavc_param = ctx->opts->vd_lavc_params;
+    struct vd_lavc_params *lavc_param = ctx->opts;
     struct mp_codec_params *c = ctx->codec;
 
+    m_config_cache_update(ctx->opts_cache);
+
     assert(!ctx->avctx);
 
     const AVCodec *lavc_codec = NULL;
@@ -911,7 +930,7 @@
 {
     vd_ffmpeg_ctx *ctx = vd->priv;
     AVCodecContext *avctx = ctx->avctx;
-    struct vd_lavc_params *opts = ctx->opts->vd_lavc_params;
+    struct vd_lavc_params *opts = ctx->opts;
 
     if (!avctx || ctx->hwdec_failed)
         return false;
@@ -937,7 +956,7 @@
 static void handle_err(struct mp_filter *vd)
 {
     vd_ffmpeg_ctx *ctx = vd->priv;
-    struct vd_lavc_params *opts = ctx->opts->vd_lavc_params;
+    struct vd_lavc_params *opts = ctx->opts;
 
     MP_WARN(vd, "Error while decoding frame!\n");
 
@@ -1194,7 +1213,8 @@
 
     vd_ffmpeg_ctx *ctx = vd->priv;
     ctx->log = vd->log;
-    ctx->opts = vd->global->opts;
+    ctx->opts_cache = m_config_cache_alloc(ctx, vd->global, &vd_lavc_conf);
+    ctx->opts = ctx->opts_cache->opts;
     ctx->codec = codec;
     ctx->decoder = talloc_strdup(ctx, decoder);
     ctx->hwdec_swpool = mp_image_pool_new(ctx);
diff -ruN mpv-0.29.1/video/filter/vf_vapoursynth.c mpv-master/video/filter/vf_vapoursynth.c
--- mpv-0.29.1/video/filter/vf_vapoursynth.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/filter/vf_vapoursynth.c	2019-09-19 04:02:03.000000000 +0700
@@ -272,14 +272,6 @@
 {
     struct priv *p = userData;
 
-    pthread_mutex_lock(&p->lock);
-
-    // If these assertions fail, n is an unrequested frame (or filtered twice).
-    assert(n >= p->out_frameno && n < p->out_frameno + p->max_requests);
-    int index = n - p->out_frameno;
-    MP_TRACE(p, "filtered frame %d (%d)\n", n, index);
-    assert(p->requested[index] == &dummy_img);
-
     struct mp_image *res = NULL;
     if (f) {
         struct mp_image img = map_vs_frame(p, f, false);
@@ -299,6 +291,15 @@
         res = mp_image_new_copy(&img);
         p->vsapi->freeFrame(f);
     }
+
+    pthread_mutex_lock(&p->lock);
+
+    // If these assertions fail, n is an unrequested frame (or filtered twice).
+    assert(n >= p->out_frameno && n < p->out_frameno + p->max_requests);
+    int index = n - p->out_frameno;
+    MP_TRACE(p, "filtered frame %d (%d)\n", n, index);
+    assert(p->requested[index] == &dummy_img);
+
     if (!res && !p->shutdown) {
         if (p->eof) {
             res = (struct mp_image *)&dummy_img_eof;
@@ -535,11 +536,14 @@
                 p->vsapi->setFilterError("Could not allocate VS frame", frameCtx);
                 break;
             }
+
+            pthread_mutex_unlock(&p->lock);
             struct mp_image vsframe = map_vs_frame(p, ret, true);
             mp_image_copy(&vsframe, img);
             int res = 1e6;
             int dur = img->pkt_duration * res + 0.5;
             set_vs_frame_props(p, ret, img, dur, res);
+            pthread_mutex_lock(&p->lock);
             break;
         }
         pthread_cond_wait(&p->wakeup, &p->lock);
diff -ruN mpv-0.29.1/video/filter/vf_vavpp.c mpv-master/video/filter/vf_vavpp.c
--- mpv-0.29.1/video/filter/vf_vavpp.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/filter/vf_vavpp.c	2019-09-19 04:02:03.000000000 +0700
@@ -54,6 +54,7 @@
     int deint_type;
     int interlaced_only;
     int reversal_bug;
+    int force;
 };
 
 struct priv {
@@ -448,6 +449,13 @@
 
     p->queue = mp_refqueue_alloc(f);
 
+    if (!p->opts->force) {
+        MP_ERR(f, "This filter is disabled because it is known to cause GPU "
+                  "lockups. This is a driver bug. You can override this by "
+                  "passing force=yes as filter argument.\n");
+        goto error;
+    }
+
     p->av_device_ref = mp_filter_load_hwdec_device(f, AV_HWDEVICE_TYPE_VAAPI);
     if (!p->av_device_ref)
         goto error;
@@ -482,6 +490,7 @@
                 {"motion-compensated", 5})),
     OPT_FLAG("interlaced-only", interlaced_only, 0),
     OPT_FLAG("reversal-bug", reversal_bug, 0),
+    OPT_FLAG("force", force, 0),
     {0}
 };
 
diff -ruN mpv-0.29.1/video/fmt-conversion.c mpv-master/video/fmt-conversion.c
--- mpv-0.29.1/video/fmt-conversion.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/fmt-conversion.c	2019-09-19 04:02:03.000000000 +0700
@@ -35,6 +35,7 @@
     {IMGFMT_RGB24, AV_PIX_FMT_RGB24},
     {IMGFMT_UYVY,  AV_PIX_FMT_UYVY422},
     {IMGFMT_NV12,  AV_PIX_FMT_NV12},
+    {IMGFMT_NV24,  AV_PIX_FMT_NV24},
     {IMGFMT_Y8,    AV_PIX_FMT_GRAY8},
     {IMGFMT_Y16, AV_PIX_FMT_GRAY16},
     {IMGFMT_420P,  AV_PIX_FMT_YUV420P},
diff -ruN mpv-0.29.1/video/image_loader.c mpv-master/video/image_loader.c
--- mpv-0.29.1/video/image_loader.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/image_loader.c	2019-09-19 04:02:03.000000000 +0700
@@ -2,7 +2,7 @@
 
 #include "common/common.h"
 #include "mp_image.h"
-#include "image_writer.h"
+#include "player/screenshot.h"
 
 #include "image_loader.h"
 
diff -ruN mpv-0.29.1/video/image_writer.c mpv-master/video/image_writer.c
--- mpv-0.29.1/video/image_writer.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/image_writer.c	2019-09-19 04:02:03.000000000 +0700
@@ -18,7 +18,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <setjmp.h>
 
 #include <libavcodec/avcodec.h>
 #include <libavutil/mem.h>
@@ -27,6 +26,7 @@
 #include "config.h"
 
 #if HAVE_JPEG
+#include <setjmp.h>
 #include <jpeglib.h>
 #endif
 
@@ -48,6 +48,9 @@
     .png_filter = 5,
     .jpeg_quality = 90,
     .jpeg_source_chroma = 1,
+    .webp_lossless = 0,
+    .webp_quality = 75,
+    .webp_compression = 4,
     .tag_csp = 0,
 };
 
@@ -55,6 +58,7 @@
     {"jpg",  AV_CODEC_ID_MJPEG},
     {"jpeg", AV_CODEC_ID_MJPEG},
     {"png",  AV_CODEC_ID_PNG},
+    {"webp", AV_CODEC_ID_WEBP},
     {0}
 };
 
@@ -66,6 +70,9 @@
     OPT_FLAG("jpeg-source-chroma", jpeg_source_chroma, 0),
     OPT_INTRANGE("png-compression", png_compression, 0, 0, 9),
     OPT_INTRANGE("png-filter", png_filter, 0, 0, 5),
+    OPT_FLAG("webp-lossless", webp_lossless, 0),
+    OPT_INTRANGE("webp-quality", webp_quality, 0, 0, 100),
+    OPT_INTRANGE("webp-compression", webp_compression, 0, 0, 6),
     OPT_FLAG("high-bit-depth", high_bit_depth, 0),
     OPT_FLAG("tag-colorspace", tag_csp, 0),
     {0},
@@ -96,7 +103,13 @@
 
     av_init_packet(&pkt);
 
-    struct AVCodec *codec = avcodec_find_encoder(ctx->opts->format);
+    struct AVCodec *codec;
+    if (ctx->opts->format == AV_CODEC_ID_WEBP) {
+        codec = avcodec_find_encoder_by_name("libwebp"); // non-animated encoder
+    } else {
+        codec = avcodec_find_encoder(ctx->opts->format);
+    }
+
     AVCodecContext *avctx = NULL;
     if (!codec)
         goto print_open_fail;
@@ -109,9 +122,11 @@
     avctx->height = image->h;
     avctx->color_range = mp_csp_levels_to_avcol_range(image->params.color.levels);
     avctx->pix_fmt = imgfmt2pixfmt(image->imgfmt);
-    // Annoying deprecated garbage for the jpg encoder.
-    if (image->params.color.levels == MP_CSP_LEVELS_PC)
-        avctx->pix_fmt = replace_j_format(avctx->pix_fmt);
+    if (codec->id == AV_CODEC_ID_MJPEG) {
+        // Annoying deprecated garbage for the jpg encoder.
+        if (image->params.color.levels == MP_CSP_LEVELS_PC)
+            avctx->pix_fmt = replace_j_format(avctx->pix_fmt);
+    }
     if (avctx->pix_fmt == AV_PIX_FMT_NONE) {
         MP_ERR(ctx, "Image format %s not supported by lavc.\n",
                mp_imgfmt_to_name(image->imgfmt));
@@ -121,6 +136,12 @@
         avctx->compression_level = ctx->opts->png_compression;
         av_opt_set_int(avctx, "pred", ctx->opts->png_filter,
                        AV_OPT_SEARCH_CHILDREN);
+    } else if (codec->id == AV_CODEC_ID_WEBP) {
+        avctx->compression_level = ctx->opts->webp_compression;
+        av_opt_set_int(avctx, "lossless", ctx->opts->webp_lossless,
+                       AV_OPT_SEARCH_CHILDREN);
+        av_opt_set_int(avctx, "quality", ctx->opts->webp_quality,
+                       AV_OPT_SEARCH_CHILDREN);
     }
 
     if (avcodec_open2(avctx, codec, NULL) < 0) {
@@ -291,8 +312,9 @@
     return 0;
 }
 
-struct mp_image *convert_image(struct mp_image *image, int destfmt,
-                               struct mp_log *log)
+static struct mp_image *convert_image(struct mp_image *image, int destfmt,
+                                      enum mp_csp_levels yuv_levels,
+                                      struct mp_log *log)
 {
     int d_w, d_h;
     mp_image_params_get_dsize(&image->params, &d_w, &d_h);
@@ -308,9 +330,9 @@
 
     // If RGB, just assume everything is correct.
     if (p.color.space != MP_CSP_RGB) {
-        // Currently, assume what FFmpeg's jpg encoder needs.
+        // Currently, assume what FFmpeg's jpg encoder or libwebp needs.
         // Of course this works only for non-HDR (no HDR support in libswscale).
-        p.color.levels = MP_CSP_LEVELS_PC;
+        p.color.levels = yuv_levels;
         p.color.space = MP_CSP_BT_601;
         p.chroma_location = MP_CHROMA_CENTER;
         mp_image_params_guess_csp(&p);
@@ -354,11 +376,24 @@
         destfmt = IMGFMT_RGB24;
     }
 #endif
+    if (opts->format == AV_CODEC_ID_WEBP && !opts->webp_lossless) {
+        // For lossy images, libwebp has its own RGB->YUV conversion.
+        // We don't want that, so force YUV/YUVA here.
+        int alpha = image->fmt.flags & MP_IMGFLAG_ALPHA;
+        destfmt = alpha ? pixfmt2imgfmt(AV_PIX_FMT_YUVA420P) : IMGFMT_420P;
+    }
 
     if (!destfmt)
         destfmt = get_target_format(&ctx);
 
-    struct mp_image *dst = convert_image(image, destfmt, log);
+    enum mp_csp_levels levels; // Ignored if destfmt is a RGB format
+    if (opts->format == AV_CODEC_ID_WEBP) {
+        levels = MP_CSP_LEVELS_TV;
+    } else {
+        levels = MP_CSP_LEVELS_PC;
+    }
+
+    struct mp_image *dst = convert_image(image, destfmt, levels, log);
     if (!dst)
         return false;
 
diff -ruN mpv-0.29.1/video/image_writer.h mpv-master/video/image_writer.h
--- mpv-0.29.1/video/image_writer.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/image_writer.h	2019-09-19 04:02:03.000000000 +0700
@@ -32,6 +32,9 @@
     int jpeg_progressive;
     int jpeg_baseline;
     int jpeg_source_chroma;
+    int webp_lossless;
+    int webp_quality;
+    int webp_compression;
     int tag_csp;
 };
 
@@ -61,11 +64,5 @@
 bool write_image(struct mp_image *image, const struct image_writer_opts *opts,
                  const char *filename, struct mp_log *log);
 
-/* Return the image converted to the given format. If the pixel aspect ratio is
- * not 1:1, the image is scaled as well. Returns NULL on failure.
- */
-struct mp_image *convert_image(struct mp_image *image, int destfmt,
-                               struct mp_log *log);
-
 // Debugging helper.
 void dump_png(struct mp_image *image, const char *filename, struct mp_log *log);
diff -ruN mpv-0.29.1/video/img_format.h mpv-master/video/img_format.h
--- mpv-0.29.1/video/img_format.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/img_format.h	2019-09-19 04:02:03.000000000 +0700
@@ -163,6 +163,9 @@
     // Like IMGFMT_NV12, but with 10 bits per component (and 6 bits of padding)
     IMGFMT_P010,
 
+    // Like IMGFMT_NV12, but for 4:4:4
+    IMGFMT_NV24,
+
     // RGB/BGR Formats
 
     // Byte accessed (low address to high address)
diff -ruN mpv-0.29.1/video/mp_image.c mpv-master/video/mp_image.c
--- mpv-0.29.1/video/mp_image.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/mp_image.c	2019-09-19 04:02:03.000000000 +0700
@@ -72,6 +72,9 @@
         int alloc_h = MP_ALIGN_UP(h, 32) >> desc.ys[n];
         int line_bytes = (alloc_w * desc.bpp[n] + 7) / 8;
         out_stride[n] = MP_ALIGN_UP(line_bytes, stride_align);
+        // also align to a multiple of desc.bytes[n]
+        while (desc.bytes[n] && out_stride[n] % desc.bytes[n])
+            out_stride[n] += stride_align;
         out_plane_size[n] = out_stride[n] * alloc_h;
     }
     if (desc.flags & MP_IMGFLAG_PAL)
diff -ruN mpv-0.29.1/video/out/cocoa/events_view.m mpv-master/video/out/cocoa/events_view.m
--- mpv-0.29.1/video/out/cocoa/events_view.m	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/cocoa/events_view.m	2019-09-19 04:02:03.000000000 +0700
@@ -46,6 +46,12 @@
     return self;
 }
 
+- (void)drawRect:(NSRect)rect
+{
+    [[NSColor blackColor] setFill];
+    NSRectFill(rect);
+}
+
 // mpv uses flipped coordinates, because X11 uses those. So let's just use them
 // as well without having to do any coordinate conversion of mouse positions.
 - (BOOL)isFlipped { return YES; }
diff -ruN mpv-0.29.1/video/out/cocoa-cb/events_view.swift mpv-master/video/out/cocoa-cb/events_view.swift
--- mpv-0.29.1/video/out/cocoa-cb/events_view.swift	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/cocoa-cb/events_view.swift	2019-09-19 04:02:03.000000000 +0700
@@ -20,9 +20,7 @@
 class EventsView: NSView {
 
     weak var cocoaCB: CocoaCB!
-    var mpv: MPVHelper! {
-        get { return cocoaCB == nil ? nil : cocoaCB.mpv }
-    }
+    var mpv: MPVHelper { get { return cocoaCB.mpv } }
 
     var tracker: NSTrackingArea?
     var hasMouseDown: Bool = false
@@ -34,9 +32,9 @@
     init(cocoaCB ccb: CocoaCB) {
         cocoaCB = ccb
         super.init(frame: NSMakeRect(0, 0, 960, 480))
-        autoresizingMask = [.viewWidthSizable, .viewHeightSizable]
+        autoresizingMask = [.width, .height]
         wantsBestResolutionOpenGLSurface = true
-        register(forDraggedTypes: [NSFilenamesPboardType, NSURLPboardType])
+        registerForDraggedTypes([ .fileURLCompat, .URLCompat, .string ])
     }
 
     required init?(coder: NSCoder) {
@@ -44,13 +42,14 @@
     }
 
     override func updateTrackingAreas() {
-        if tracker != nil {
-            removeTrackingArea(tracker!)
+        if let tracker = self.tracker {
+            removeTrackingArea(tracker)
         }
 
         tracker = NSTrackingArea(rect: bounds,
             options: [.activeAlways, .mouseEnteredAndExited, .mouseMoved, .enabledDuringMouseDrag],
             owner: self, userInfo: nil)
+        // here tracker is guaranteed to be none-nil
         addTrackingArea(tracker!)
 
         if containsMouseLocation() {
@@ -59,26 +58,48 @@
     }
 
     override func draggingEntered(_ sender: NSDraggingInfo) -> NSDragOperation {
-        guard let types = sender.draggingPasteboard().types else { return [] }
-        if types.contains(NSFilenamesPboardType) || types.contains(NSURLPboardType) {
+        guard let types = sender.draggingPasteboard.types else { return [] }
+        if types.contains(.fileURLCompat) || types.contains(.URLCompat) || types.contains(.string) {
             return .copy
         }
         return []
     }
 
+    func isURL(_ str: String) -> Bool {
+        // force unwrapping is fine here, regex is guarnteed to be valid
+        let regex = try! NSRegularExpression(pattern: "^(https?|ftp)://[^\\s/$.?#].[^\\s]*$",
+                                             options: .caseInsensitive)
+        let isURL = regex.numberOfMatches(in: str,
+                                     options: [],
+                                       range: NSRange(location: 0, length: str.count))
+        return isURL > 0
+    }
+
     override func performDragOperation(_ sender: NSDraggingInfo) -> Bool {
-        let pb = sender.draggingPasteboard()
-        guard let types = sender.draggingPasteboard().types else { return false }
-        if types.contains(NSFilenamesPboardType) {
-            if let files = pb.propertyList(forType: NSFilenamesPboardType) as? [Any] {
+        let pb = sender.draggingPasteboard
+        guard let types = pb.types else { return false }
+
+        if types.contains(.fileURLCompat) || types.contains(.URLCompat) {
+            if let urls = pb.readObjects(forClasses: [NSURL.self]) as? [URL] {
+                let files = urls.map { $0.absoluteString }
                 EventsResponder.sharedInstance().handleFilesArray(files)
                 return true
             }
-        } else if types.contains(NSURLPboardType) {
-            if let url = pb.propertyList(forType: NSURLPboardType) as? [Any] {
-                EventsResponder.sharedInstance().handleFilesArray(url)
-                return true
+        } else if types.contains(.string) {
+            guard let str = pb.string(forType: .string) else { return false }
+            var filesArray: [String] = []
+
+            for val in str.components(separatedBy: "\n") {
+                let url = val.trimmingCharacters(in: .whitespacesAndNewlines)
+                let path = (url as NSString).expandingTildeInPath
+                if isURL(url) {
+                    filesArray.append(url)
+                } else if path.starts(with: "/") {
+                    filesArray.append(path)
+                }
             }
+            EventsResponder.sharedInstance().handleFilesArray(filesArray)
+            return true
         }
         return false
     }
@@ -105,14 +126,14 @@
         if mpv.getBoolProperty("input-cursor") {
             cocoa_put_key_with_modifiers(SWIFT_KEY_MOUSE_LEAVE, 0)
         }
-        cocoaCB.window.hideTitleBar()
+        cocoaCB.titleBar?.hide()
     }
 
     override func mouseMoved(with event: NSEvent) {
-        if mpv != nil && mpv.getBoolProperty("input-cursor") {
+        if mpv.getBoolProperty("input-cursor") {
             signalMouseMovement(event)
         }
-        cocoaCB.window.showTitleBar()
+        cocoaCB.titleBar?.show()
     }
 
     override func mouseDragged(with event: NSEvent) {
@@ -131,7 +152,7 @@
         if mpv.getBoolProperty("input-cursor") {
             signalMouseUp(event)
         }
-        cocoaCB.window.isMoving = false
+        cocoaCB.window?.isMoving = false
     }
 
     override func rightMouseDown(with event: NSEvent) {
@@ -180,8 +201,8 @@
         point = convertToBacking(point)
         point.y = -point.y
 
-        cocoaCB.window.updateMovableBackground(point)
-        if !cocoaCB.window.isMoving {
+        cocoaCB.window?.updateMovableBackground(point)
+        if !(cocoaCB.window?.isMoving ?? false) {
             mpv.setMousePosition(point)
         }
     }
@@ -190,7 +211,7 @@
         var delta: Double
         var cmd: Int32
 
-        if fabs(event.deltaY) >= fabs(event.deltaX) {
+        if abs(event.deltaY) >= abs(event.deltaX) {
             delta = Double(event.deltaY) * 0.1;
             cmd = delta > 0 ? SWIFT_WHEEL_UP : SWIFT_WHEEL_DOWN;
         } else {
@@ -198,7 +219,7 @@
             cmd = delta > 0 ? SWIFT_WHEEL_RIGHT : SWIFT_WHEEL_LEFT;
         }
 
-        mpv.putAxis(cmd, delta: fabs(delta))
+        mpv.putAxis(cmd, delta: abs(delta))
     }
 
     override func scrollWheel(with event: NSEvent) {
@@ -214,7 +235,7 @@
             let deltaY = modifiers.contains(.shift) ? event.scrollingDeltaX : event.scrollingDeltaY
             var mpkey: Int32
 
-            if fabs(deltaY) >= fabs(deltaX) {
+            if abs(deltaY) >= abs(deltaX) {
                 mpkey = deltaY > 0 ? SWIFT_WHEEL_UP : SWIFT_WHEEL_DOWN;
             } else {
                 mpkey = deltaX > 0 ? SWIFT_WHEEL_RIGHT : SWIFT_WHEEL_LEFT;
@@ -227,30 +248,32 @@
     func containsMouseLocation() -> Bool {
         if cocoaCB == nil { return false }
         var topMargin: CGFloat = 0.0
-        let menuBarHeight = NSApp.mainMenu!.menuBarHeight
+        let menuBarHeight = NSApp.mainMenu?.menuBarHeight ?? 23.0
+
+        guard let window = cocoaCB.window else { return false }
+        guard var vF = window.screen?.frame else { return false }
 
-        if cocoaCB.window.isInFullscreen && (menuBarHeight > 0) {
-            topMargin = cocoaCB.window.titleBarHeight + 1 + menuBarHeight
+        if window.isInFullscreen && (menuBarHeight > 0) {
+            topMargin = TitleBar.height + 1 + menuBarHeight
         }
 
-        guard var vF = window?.screen?.frame else { return false }
         vF.size.height -= topMargin
 
-        let vFW = window!.convertFromScreen(vF)
+        let vFW = window.convertFromScreen(vF)
         let vFV = convert(vFW, from: nil)
-        let pt = convert(window!.mouseLocationOutsideOfEventStream, from: nil)
+        let pt = convert(window.mouseLocationOutsideOfEventStream, from: nil)
 
         var clippedBounds = bounds.intersection(vFV)
-        if !cocoaCB.window.isInFullscreen {
-            clippedBounds.origin.y += cocoaCB.window.titleBarHeight
-            clippedBounds.size.height -= cocoaCB.window.titleBarHeight
+        if !window.isInFullscreen {
+            clippedBounds.origin.y += TitleBar.height
+            clippedBounds.size.height -= TitleBar.height
         }
         return clippedBounds.contains(pt)
     }
 
     func canHideCursor() -> Bool {
-        if cocoaCB.window == nil { return false }
-        return !hasMouseDown && containsMouseLocation() && window!.isKeyWindow
+        guard let window = cocoaCB.window else { return false }
+        return !hasMouseDown && containsMouseLocation() && window.isKeyWindow
     }
 
     func getMpvButton(_ event: NSEvent) -> Int32 {
diff -ruN mpv-0.29.1/video/out/cocoa-cb/title_bar.swift mpv-master/video/out/cocoa-cb/title_bar.swift
--- mpv-0.29.1/video/out/cocoa-cb/title_bar.swift	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/cocoa-cb/title_bar.swift	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,248 @@
+/*
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+import Cocoa
+
+class TitleBar: NSVisualEffectView {
+
+    weak var cocoaCB: CocoaCB!
+    var mpv: MPVHelper { get { return cocoaCB.mpv } }
+
+    var systemBar: NSView? {
+        get { return cocoaCB.window?.standardWindowButton(.closeButton)?.superview }
+    }
+    static var height: CGFloat {
+        get { return NSWindow.frameRect(forContentRect: CGRect.zero, styleMask: .titled).size.height }
+    }
+    var buttons: [NSButton] {
+        get { return ([.closeButton, .miniaturizeButton, .zoomButton] as [NSWindow.ButtonType]).compactMap { cocoaCB.window?.standardWindowButton($0) } }
+    }
+
+    override var material: NSVisualEffectView.Material {
+        get { return super.material }
+        set {
+            super.material = newValue
+            // fix for broken deprecated materials
+            if material == .light || material == .dark {
+                state = .active
+            } else if #available(macOS 10.11, *),
+                      material == .mediumLight || material == .ultraDark
+            {
+                state = .active
+            } else {
+                state = .followsWindowActiveState
+            }
+
+        }
+    }
+
+    init(frame: NSRect, window: NSWindow, cocoaCB ccb: CocoaCB) {
+        let f = NSMakeRect(0, frame.size.height - TitleBar.height,
+                           frame.size.width, TitleBar.height)
+        cocoaCB = ccb
+        super.init(frame: f)
+        alphaValue = 0
+        blendingMode = .withinWindow
+        autoresizingMask = [.width, .minYMargin]
+        systemBar?.alphaValue = 0
+        state = .followsWindowActiveState
+        wantsLayer = true
+
+        window.contentView?.addSubview(self, positioned: .above, relativeTo: nil)
+        window.titlebarAppearsTransparent = true
+        window.styleMask.insert(.fullSizeContentView)
+        set(appearance: Int(mpv.macOpts?.macos_title_bar_appearance ?? 0))
+        set(material: Int(mpv.macOpts?.macos_title_bar_material ?? 0))
+        set(color: mpv.macOpts?.macos_title_bar_color ?? "#00000000")
+    }
+
+    required init?(coder: NSCoder) {
+        fatalError("init(coder:) has not been implemented")
+    }
+
+    // catch these events so they are not propagated to the underlying view
+    override func mouseDown(with event: NSEvent) { }
+
+    override func mouseUp(with event: NSEvent) {
+        if event.clickCount > 1 {
+            let def = UserDefaults.standard
+            var action = def.string(forKey: "AppleActionOnDoubleClick")
+
+            // macOS 10.10 and earlier
+            if action == nil {
+                action = def.bool(forKey: "AppleMiniaturizeOnDoubleClick") == true ?
+                    "Minimize" : "Maximize"
+            }
+
+            if action == "Minimize" {
+                window?.miniaturize(self)
+            } else if action == "Maximize" {
+                window?.zoom(self)
+            }
+        }
+    }
+
+    func set(appearance: Any) {
+        if appearance is Int {
+            window?.appearance = appearanceFrom(string: String(appearance as? Int ?? 0))
+        } else {
+            window?.appearance = appearanceFrom(string: appearance as? String ?? "auto")
+        }
+    }
+
+    func set(material: Any) {
+        if material is Int {
+            self.material = materialFrom(string: String(material as? Int ?? 0))
+        } else {
+            self.material = materialFrom(string: material as? String ?? "titlebar")
+        }
+    }
+
+    func set(color: Any) {
+        if color is String {
+            layer?.backgroundColor = NSColor(hex: color as? String ?? "#00000000").cgColor
+        } else {
+            let col = color as? m_color ?? m_color(r: 0, g: 0, b: 0, a: 0)
+            let red   = CGFloat(col.r)/255
+            let green = CGFloat(col.g)/255
+            let blue  = CGFloat(col.b)/255
+            let alpha = CGFloat(col.a)/255
+            layer?.backgroundColor = NSColor(calibratedRed: red, green: green,
+                                             blue: blue, alpha: alpha).cgColor
+        }
+    }
+
+    func show() {
+        guard let window = cocoaCB.window else { return }
+        if !window.border && !window.isInFullscreen { return }
+        let loc = cocoaCB.view?.convert(window.mouseLocationOutsideOfEventStream, from: nil)
+
+        buttons.forEach { $0.isHidden = false }
+        NSAnimationContext.runAnimationGroup({ (context) -> Void in
+            context.duration = 0.20
+            systemBar?.animator().alphaValue = 1
+            if !window.isInFullscreen && !window.isAnimating {
+                animator().alphaValue = 1
+                isHidden = false
+            }
+        }, completionHandler: nil )
+
+        if loc?.y ?? 0 > TitleBar.height {
+            hideDelayed()
+        } else {
+            NSObject.cancelPreviousPerformRequests(withTarget: self, selector: #selector(hide), object: nil)
+        }
+    }
+
+    @objc func hide() {
+        guard let window = cocoaCB.window else { return }
+        if window.isInFullscreen && !window.isAnimating {
+            alphaValue = 0
+            isHidden = true
+            return
+        }
+        NSAnimationContext.runAnimationGroup({ (context) -> Void in
+            context.duration = 0.20
+            systemBar?.animator().alphaValue = 0
+            animator().alphaValue = 0
+        }, completionHandler: {
+            self.buttons.forEach { $0.isHidden = true }
+            self.isHidden = true
+        })
+    }
+
+    func hideDelayed() {
+        NSObject.cancelPreviousPerformRequests(withTarget: self,
+                                                 selector: #selector(hide),
+                                                   object: nil)
+        perform(#selector(hide), with: nil, afterDelay: 0.5)
+    }
+
+    func appearanceFrom(string: String) -> NSAppearance? {
+        switch string {
+        case "1", "aqua":
+            return NSAppearance(named: .aqua)
+        case "3", "vibrantLight":
+            return NSAppearance(named: .vibrantLight)
+        case "4", "vibrantDark":
+            return NSAppearance(named: .vibrantDark)
+        default: break
+        }
+
+        if #available(macOS 10.14, *) {
+            switch string {
+            case "2", "darkAqua":
+                return NSAppearance(named: .darkAqua)
+            case "5", "aquaHighContrast":
+                return NSAppearance(named: .accessibilityHighContrastAqua)
+            case "6", "darkAquaHighContrast":
+                return NSAppearance(named: .accessibilityHighContrastDarkAqua)
+            case "7", "vibrantLightHighContrast":
+                return NSAppearance(named: .accessibilityHighContrastVibrantLight)
+            case "8", "vibrantDarkHighContrast":
+                return NSAppearance(named: .accessibilityHighContrastVibrantDark)
+            case "0", "auto": fallthrough
+            default:
+                return nil
+            }
+        }
+
+        let style = UserDefaults.standard.string(forKey: "AppleInterfaceStyle")
+        return appearanceFrom(string: style == nil ? "aqua" : "vibrantDark")
+    }
+
+    func materialFrom(string: String) -> NSVisualEffectView.Material {
+        switch string {
+        case "1",  "selection": return .selection
+        case "0",  "titlebar":  return .titlebar
+        case "14", "dark":      return .dark
+        case "15", "light":     return .light
+        default:                break
+        }
+
+#if HAVE_MACOS_10_11_FEATURES
+        if #available(macOS 10.11, *) {
+            switch string {
+            case "2,", "menu":          return .menu
+            case "3",  "popover":       return .popover
+            case "4",  "sidebar":       return .sidebar
+            case "16", "mediumLight":   return .mediumLight
+            case "17", "ultraDark":     return .ultraDark
+            default:                    break
+            }
+        }
+#endif
+#if HAVE_MACOS_10_14_FEATURES
+        if #available(macOS 10.14, *) {
+            switch string {
+            case "5,", "headerView":            return .headerView
+            case "6",  "sheet":                 return .sheet
+            case "7",  "windowBackground":      return .windowBackground
+            case "8",  "hudWindow":             return .hudWindow
+            case "9",  "fullScreen":            return .fullScreenUI
+            case "10", "toolTip":               return .toolTip
+            case "11", "contentBackground":     return .contentBackground
+            case "12", "underWindowBackground": return .underWindowBackground
+            case "13", "underPageBackground":   return .underPageBackground
+            default:                            break
+            }
+        }
+#endif
+
+        return .titlebar
+    }
+}
diff -ruN mpv-0.29.1/video/out/cocoa-cb/video_layer.swift mpv-master/video/out/cocoa-cb/video_layer.swift
--- mpv-0.29.1/video/out/cocoa-cb/video_layer.swift	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/cocoa-cb/video_layer.swift	2019-09-19 04:02:03.000000000 +0700
@@ -19,21 +19,54 @@
 import OpenGL.GL
 import OpenGL.GL3
 
+let glVersions: [CGLOpenGLProfile] = [
+    kCGLOGLPVersion_3_2_Core,
+    kCGLOGLPVersion_Legacy
+]
+
+let glFormatBase: [CGLPixelFormatAttribute] = [
+    kCGLPFAOpenGLProfile,
+    kCGLPFAAccelerated,
+    kCGLPFADoubleBuffer
+]
+
+let glFormatSoftwareBase: [CGLPixelFormatAttribute] = [
+    kCGLPFAOpenGLProfile,
+    kCGLPFARendererID,
+    CGLPixelFormatAttribute(UInt32(kCGLRendererGenericFloatID)),
+    kCGLPFADoubleBuffer
+]
+
+let glFormatOptional: [CGLPixelFormatAttribute] = [
+    kCGLPFABackingStore,
+    kCGLPFAAllowOfflineRenderers,
+    kCGLPFASupportsAutomaticGraphicsSwitching
+]
+
+let attributeLookUp: [UInt32:String] = [
+    kCGLOGLPVersion_3_2_Core.rawValue:     "kCGLOGLPVersion_3_2_Core",
+    kCGLOGLPVersion_Legacy.rawValue:       "kCGLOGLPVersion_Legacy",
+    kCGLPFAOpenGLProfile.rawValue:         "kCGLPFAOpenGLProfile",
+    UInt32(kCGLRendererGenericFloatID):    "kCGLRendererGenericFloatID",
+    kCGLPFARendererID.rawValue:            "kCGLPFARendererID",
+    kCGLPFAAccelerated.rawValue:           "kCGLPFAAccelerated",
+    kCGLPFADoubleBuffer.rawValue:          "kCGLPFADoubleBuffer",
+    kCGLPFABackingStore.rawValue:          "kCGLPFABackingStore",
+    kCGLPFAAllowOfflineRenderers.rawValue: "kCGLPFAAllowOfflineRenderers",
+    kCGLPFASupportsAutomaticGraphicsSwitching.rawValue: "kCGLPFASupportsAutomaticGraphicsSwitching",
+]
+
 class VideoLayer: CAOpenGLLayer {
 
     weak var cocoaCB: CocoaCB!
-    var mpv: MPVHelper! {
-        get { return cocoaCB == nil ? nil : cocoaCB.mpv }
-    }
+    var mpv: MPVHelper { get { return cocoaCB.mpv } }
 
-    let videoLock = NSLock()
     let displayLock = NSLock()
-    var hasVideo: Bool = false
+    let cglContext: CGLContextObj
+    let cglPixelFormat: CGLPixelFormatObj
     var needsFlip: Bool = false
-    var canDrawOffScreen: Bool = false
-    var cglContext: CGLContextObj? = nil
-    var cglPixelFormat: CGLPixelFormatObj? = nil
-    var surfaceSize: NSSize?
+    var forceDraw: Bool = false
+    var surfaceSize: NSSize = NSSize(width: 0, height: 0)
 
     enum Draw: Int { case normal = 1, atomic, atomicEnd }
     var draw: Draw = .normal
@@ -53,30 +86,36 @@
             if inLiveResize {
                 isAsynchronous = true
             }
-            update()
+            update(force: true)
         }
     }
 
     init(cocoaCB ccb: CocoaCB) {
         cocoaCB = ccb
+        cglPixelFormat = VideoLayer.createPixelFormat(ccb.mpv)
+        cglContext = VideoLayer.createContext(ccb.mpv, cglPixelFormat)
         super.init()
         autoresizingMask = [.layerWidthSizable, .layerHeightSizable]
         backgroundColor = NSColor.black.cgColor
 
-        cglPixelFormat = copyCGLPixelFormat(forDisplayMask: 0)
-        CGLCreateContext(cglPixelFormat!, nil, &cglContext)
         var i: GLint = 1
-        CGLSetParameter(cglContext!, kCGLCPSwapInterval, &i)
-        CGLSetCurrentContext(cglContext!)
+        CGLSetParameter(cglContext, kCGLCPSwapInterval, &i)
+        CGLSetCurrentContext(cglContext)
 
         mpv.initRender()
         mpv.setRenderUpdateCallback(updateCallback, context: self)
         mpv.setRenderControlCallback(cocoaCB.controlCallback, context: cocoaCB)
     }
 
+    //necessary for when the layer containing window changes the screen
     override init(layer: Any) {
-        let oldLayer = layer as! VideoLayer
+        guard let oldLayer = layer as? VideoLayer else {
+            fatalError("init(layer: Any) passed an invalid layer")
+        }
         cocoaCB = oldLayer.cocoaCB
+        surfaceSize = oldLayer.surfaceSize
+        cglPixelFormat = oldLayer.cglPixelFormat
+        cglContext = oldLayer.cglContext
         super.init()
     }
 
@@ -91,7 +130,8 @@
         if inLiveResize == false {
             isAsynchronous = false
         }
-        return mpv != nil && cocoaCB.backendState == .initialized
+        return cocoaCB.backendState == .initialized &&
+               (forceDraw || mpv.isRenderUpdateFrame())
     }
 
     override func draw(inCGLContext ctx: CGLContextObj,
@@ -99,11 +139,8 @@
                        forLayerTime t: CFTimeInterval,
                        displayTime ts: UnsafePointer<CVTimeStamp>?) {
         needsFlip = false
-        canDrawOffScreen = true
-        draw(ctx)
-    }
+        forceDraw = false
 
-    func draw(_ ctx: CGLContextObj) {
         if draw.rawValue >= Draw.atomic.rawValue {
              if draw == .atomic {
                 draw = .atomicEnd
@@ -113,8 +150,7 @@
         }
 
         updateSurfaceSize()
-        mpv.drawRender(surfaceSize!)
-        CGLFlushDrawable(ctx)
+        mpv.drawRender(surfaceSize, ctx)
 
         if needsICCUpdate {
             needsICCUpdate = false
@@ -125,17 +161,17 @@
     func updateSurfaceSize() {
         var dims: [GLint] = [0, 0, 0, 0]
         glGetIntegerv(GLenum(GL_VIEWPORT), &dims)
-        surfaceSize = NSMakeSize(CGFloat(dims[2]), CGFloat(dims[3]))
+        surfaceSize = NSSize(width: CGFloat(dims[2]), height: CGFloat(dims[3]))
 
-        if NSEqualSizes(surfaceSize!, NSZeroSize) {
+        if NSEqualSizes(surfaceSize, NSZeroSize) {
             surfaceSize = bounds.size
-            surfaceSize!.width *= contentsScale
-            surfaceSize!.height *= contentsScale
+            surfaceSize.width *= contentsScale
+            surfaceSize.height *= contentsScale
         }
     }
 
     func atomicDrawingStart() {
-        if draw == .normal && hasVideo {
+        if draw == .normal {
             NSDisableScreenUpdates()
             draw = .atomic
         }
@@ -149,74 +185,16 @@
     }
 
     override func copyCGLPixelFormat(forDisplayMask mask: UInt32) -> CGLPixelFormatObj {
-        if cglPixelFormat != nil { return cglPixelFormat! }
-
-        let glVersions: [CGLOpenGLProfile] = [
-            kCGLOGLPVersion_3_2_Core,
-            kCGLOGLPVersion_Legacy
-        ]
-
-        var pix: CGLPixelFormatObj?
-        var err: CGLError = CGLError(rawValue: 0)
-        var npix: GLint = 0
-
-        verLoop : for ver in glVersions {
-            if mpv.macOpts!.cocoa_cb_sw_renderer == 1 { break }
-
-            var glAttributes: [CGLPixelFormatAttribute] = [
-                kCGLPFAOpenGLProfile, CGLPixelFormatAttribute(ver.rawValue),
-                kCGLPFAAccelerated,
-                kCGLPFADoubleBuffer,
-                kCGLPFABackingStore,
-                kCGLPFAAllowOfflineRenderers,
-                kCGLPFASupportsAutomaticGraphicsSwitching,
-                _CGLPixelFormatAttribute(rawValue: 0)
-            ]
-
-            for index in stride(from: glAttributes.count-2, through: 4, by: -1) {
-                err = CGLChoosePixelFormat(glAttributes, &pix, &npix)
-                if err == kCGLBadAttribute || err == kCGLBadPixelFormat || pix == nil {
-                    glAttributes.remove(at: index)
-                } else {
-                    break verLoop
-                }
-            }
-        }
-
-        if (err != kCGLNoError || pix == nil) && mpv.macOpts!.cocoa_cb_sw_renderer != 0 {
-            if mpv.macOpts!.cocoa_cb_sw_renderer == -1 {
-                let errS = String(cString: CGLErrorString(err))
-                mpv.sendWarning("Couldn't create hardware accelerated CGL " +
-                                "pixel format, falling back to software " +
-                                "renderer: \(errS) (\(err.rawValue))")
-            }
-
-            let glAttributes: [CGLPixelFormatAttribute] = [
-                kCGLPFAOpenGLProfile, CGLPixelFormatAttribute(kCGLOGLPVersion_3_2_Core.rawValue),
-                kCGLPFARendererID, CGLPixelFormatAttribute(UInt32(kCGLRendererGenericFloatID)),
-                kCGLPFADoubleBuffer,
-                kCGLPFABackingStore,
-                _CGLPixelFormatAttribute(rawValue: 0)
-            ]
-
-            err = CGLChoosePixelFormat(glAttributes, &pix, &npix)
-        }
-
-        if err != kCGLNoError || pix == nil {
-            let errS = String(cString: CGLErrorString(err))
-            mpv.sendError("Couldn't create any CGL pixel format: \(errS) (\(err.rawValue))")
-            exit(1)
-        }
-        return pix!
+        return cglPixelFormat
     }
 
     override func copyCGLContext(forPixelFormat pf: CGLPixelFormatObj) -> CGLContextObj {
-        contentsScale = cocoaCB.window.backingScaleFactor
-        return cglContext!
+        contentsScale = cocoaCB.window?.backingScaleFactor ?? 1.0
+        return cglContext
     }
 
     let updateCallback: mpv_render_update_fn = { (ctx) in
-        let layer: VideoLayer = MPVHelper.bridge(ptr: ctx!)
+        let layer: VideoLayer = unsafeBitCast(ctx, to: VideoLayer.self)
         layer.update()
     }
 
@@ -225,34 +203,96 @@
         let isUpdate = needsFlip
         super.display()
         CATransaction.flush()
-        if isUpdate {
-            if !cocoaCB.window.occlusionState.contains(.visible) &&
-                needsFlip && canDrawOffScreen
-            {
-                CGLSetCurrentContext(cglContext!)
-                draw(cglContext!)
-            } else if needsFlip {
-                update()
+        if isUpdate && needsFlip {
+            CGLSetCurrentContext(cglContext)
+            if mpv.isRenderUpdateFrame() {
+                mpv.drawRender(NSZeroSize, cglContext, skip: true)
             }
         }
         displayLock.unlock()
     }
 
-    func setVideo(_ state: Bool) {
-        videoLock.lock()
-        hasVideo = state
-        videoLock.unlock()
-    }
-
-    func update() {
+    func update(force: Bool = false) {
+        if force { forceDraw = true }
         queue.async {
-            self.videoLock.lock()
-            if !self.inLiveResize && self.hasVideo {
+            if self.forceDraw || !self.inLiveResize {
                 self.needsFlip = true
                 self.display()
             }
-            self.videoLock.unlock()
         }
     }
 
+    class func createPixelFormat(_ mpv: MPVHelper) -> CGLPixelFormatObj {
+        var pix: CGLPixelFormatObj?
+        var err: CGLError = CGLError(rawValue: 0)
+        let swRender = mpv.macOpts?.cocoa_cb_sw_renderer ?? -1
+
+        if swRender != 1 {
+            (pix, err) = VideoLayer.findPixelFormat(mpv)
+        }
+
+        if (err != kCGLNoError || pix == nil) && swRender != 0 {
+            (pix, err) = VideoLayer.findPixelFormat(mpv, software: true)
+        }
+
+        guard let pixelFormat = pix, err == kCGLNoError else {
+            mpv.sendError("Couldn't create any CGL pixel format")
+            exit(1)
+        }
+
+        return pixelFormat
+    }
+
+    class func findPixelFormat(_ mpv: MPVHelper, software: Bool = false) -> (CGLPixelFormatObj?, CGLError) {
+        var pix: CGLPixelFormatObj?
+        var err: CGLError = CGLError(rawValue: 0)
+        var npix: GLint = 0
+
+        for ver in glVersions {
+            var glBase = software ? glFormatSoftwareBase : glFormatBase
+            glBase.insert(CGLPixelFormatAttribute(ver.rawValue), at: 1)
+            var glFormat = glBase + glFormatOptional
+
+            for index in stride(from: glFormat.count-1, through: glBase.count-1, by: -1) {
+                let format = glFormat + [_CGLPixelFormatAttribute(rawValue: 0)]
+                err = CGLChoosePixelFormat(format, &pix, &npix)
+
+                if err == kCGLBadAttribute || err == kCGLBadPixelFormat || pix == nil {
+                    glFormat.remove(at: index)
+                } else {
+                    let attArray = glFormat.map({ (value: _CGLPixelFormatAttribute) -> String in
+                        return attributeLookUp[value.rawValue] ?? "unknown attribute"
+                    })
+
+                    mpv.sendVerbose("Created CGL pixel format with attributes: " +
+                                    "\(attArray.joined(separator: ", "))")
+                    return (pix, err)
+                }
+            }
+        }
+
+        let errS = String(cString: CGLErrorString(err))
+        mpv.sendWarning("Couldn't create a " +
+                        "\(software ? "software" : "hardware accelerated") " +
+                        "CGL pixel format: \(errS) (\(err.rawValue))")
+
+        if software == false && (mpv.macOpts?.cocoa_cb_sw_renderer ?? -1) == -1 {
+            mpv.sendWarning("Falling back to software renderer")
+        }
+
+        return (pix, err)
+    }
+
+    class func createContext(_ mpv: MPVHelper, _ pixelFormat: CGLPixelFormatObj) -> CGLContextObj {
+        var context: CGLContextObj?
+        let error = CGLCreateContext(pixelFormat, nil, &context)
+
+        guard let cglContext = context, error == kCGLNoError else {
+            let errS = String(cString: CGLErrorString(error))
+            mpv.sendError("Couldn't create a CGLContext: " + errS)
+            exit(1)
+        }
+
+        return cglContext
+    }
 }
diff -ruN mpv-0.29.1/video/out/cocoa-cb/window.swift mpv-master/video/out/cocoa-cb/window.swift
--- mpv-0.29.1/video/out/cocoa-cb/window.swift	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/cocoa-cb/window.swift	2019-09-19 04:02:03.000000000 +0700
@@ -20,9 +20,7 @@
 class Window: NSWindow, NSWindowDelegate {
 
     weak var cocoaCB: CocoaCB! = nil
-    var mpv: MPVHelper! {
-        get { return cocoaCB == nil ? nil : cocoaCB.mpv }
-    }
+    var mpv: MPVHelper { get { return cocoaCB.mpv } }
 
     var targetScreen: NSScreen?
     var previousScreen: NSScreen?
@@ -37,12 +35,12 @@
 
     var keepAspect: Bool = true {
         didSet {
-            if !isInFullscreen {
-                unfsContentFrame = convertToScreen(contentView!.frame)
+            if let contentViewFrame = contentView?.frame, !isInFullscreen {
+                unfsContentFrame = convertToScreen(contentViewFrame)
             }
 
             if keepAspect {
-                contentAspectRatio = unfsContentFrame!.size
+                contentAspectRatio = unfsContentFrame?.size ?? contentAspectRatio
             } else {
                 resizeIncrements = NSSize(width: 1.0, height: 1.0)
             }
@@ -50,24 +48,13 @@
     }
 
     var border: Bool = true {
-        didSet { if !border { hideTitleBar() } }
-    }
-
-    var titleBarEffect: NSVisualEffectView?
-    var titleBar: NSView {
-        get { return (standardWindowButton(.closeButton)?.superview)! }
-    }
-    var titleBarHeight: CGFloat {
-        get { return NSWindow.frameRect(forContentRect: CGRect.zero, styleMask: .titled).size.height }
-    }
-    var titleButtons: [NSButton] {
-        get { return ([.closeButton, .miniaturizeButton, .zoomButton] as [NSWindowButton]).flatMap { standardWindowButton($0) } }
+        didSet { if !border { cocoaCB.titleBar?.hide() } }
     }
 
     override var canBecomeKey: Bool { return true }
     override var canBecomeMain: Bool { return true }
 
-    override var styleMask: NSWindowStyleMask {
+    override var styleMask: NSWindow.StyleMask {
         get { return super.styleMask }
         set {
             let responder = firstResponder
@@ -82,19 +69,34 @@
         self.init(contentRect: contentRect,
                   styleMask: [.titled, .closable, .miniaturizable, .resizable],
                   backing: .buffered, defer: false, screen: screen)
+
+        // workaround for an AppKit bug where the NSWindow can't be placed on a
+        // none Main screen NSScreen outside the Main screen's frame bounds
+        if let wantedScreen = screen, screen != NSScreen.main {
+            var absoluteWantedOrigin = contentRect.origin
+            absoluteWantedOrigin.x += wantedScreen.frame.origin.x
+            absoluteWantedOrigin.y += wantedScreen.frame.origin.y
+
+            if !NSEqualPoints(absoluteWantedOrigin, self.frame.origin) {
+                self.setFrameOrigin(absoluteWantedOrigin)
+            }
+        }
+
         cocoaCB = ccb
         title = cocoaCB.title
         minSize = NSMakeSize(160, 90)
         collectionBehavior = .fullScreenPrimary
         delegate = self
-        contentView!.addSubview(view)
-        view.frame = contentView!.frame
 
-        unfsContentFrame = convertToScreen(contentView!.frame)
-        targetScreen = screen!
-        currentScreen = screen!
-        unfScreen = screen!
-        initTitleBar()
+        if let cView = contentView {
+            cView.addSubview(view)
+            view.frame = cView.frame
+            unfsContentFrame = convertToScreen(cView.frame)
+        }
+
+        targetScreen = screen
+        currentScreen = screen
+        unfScreen = screen
 
         if let app = NSApp as? Application {
             app.menuBar.register(#selector(setHalfWindowSize), for: MPM_H_SIZE)
@@ -105,112 +107,6 @@
         }
     }
 
-    func initTitleBar() {
-        var f = contentView!.bounds
-        f.origin.y = f.size.height - titleBarHeight
-        f.size.height = titleBarHeight
-
-        styleMask.insert(.fullSizeContentView)
-        titleBar.alphaValue = 0
-        titlebarAppearsTransparent = true
-        titleBarEffect = NSVisualEffectView(frame: f)
-        titleBarEffect!.alphaValue = 0
-        titleBarEffect!.blendingMode = .withinWindow
-        titleBarEffect!.autoresizingMask = [.viewWidthSizable, .viewMinYMargin]
-
-        setTitleBarStyle(Int(mpv.macOpts!.macos_title_bar_style))
-        contentView!.addSubview(titleBarEffect!, positioned: .above, relativeTo: nil)
-    }
-
-    func setTitleBarStyle(_ style: Any) {
-        var effect: String
-
-        if style is Int {
-            switch style as! Int {
-            case 4:
-                effect = "auto"
-            case 3:
-                effect = "mediumlight"
-            case 2:
-                effect = "light"
-            case 1:
-                effect = "ultradark"
-            case 0: fallthrough
-            default:
-                effect = "dark"
-            }
-        } else {
-            effect = style as! String
-        }
-
-        if effect == "auto" {
-            let systemStyle = UserDefaults.standard.string(forKey: "AppleInterfaceStyle")
-            effect = systemStyle == nil ? "mediumlight" : "ultradark"
-        }
-
-        switch effect {
-        case "mediumlight":
-            appearance = NSAppearance(named: NSAppearanceNameVibrantLight)
-            titleBarEffect!.material = .titlebar
-            titleBarEffect!.state = .followsWindowActiveState
-        case "light":
-            appearance = NSAppearance(named: NSAppearanceNameVibrantLight)
-            titleBarEffect!.material = .light
-            titleBarEffect!.state = .active
-        case "ultradark":
-            appearance = NSAppearance(named: NSAppearanceNameVibrantDark)
-            titleBarEffect!.material = .titlebar
-            titleBarEffect!.state = .followsWindowActiveState
-        case "dark": fallthrough
-        default:
-            appearance = NSAppearance(named: NSAppearanceNameVibrantDark)
-            titleBarEffect!.material = .dark
-            titleBarEffect!.state = .active
-        }
-    }
-
-    func showTitleBar() {
-        if titleBarEffect == nil || (!border && !isInFullscreen) { return }
-        let loc = cocoaCB.view.convert(mouseLocationOutsideOfEventStream, from: nil)
-
-        titleButtons.forEach { $0.isHidden = false }
-        NSAnimationContext.runAnimationGroup({ (context) -> Void in
-            context.duration = 0.20
-            titleBar.animator().alphaValue = 1
-            if !isInFullscreen && !isAnimating {
-                titleBarEffect!.animator().alphaValue = 1
-            }
-        }, completionHandler: nil )
-
-        if loc.y > titleBarHeight {
-            hideTitleBarDelayed()
-        } else {
-            NSObject.cancelPreviousPerformRequests(withTarget: self, selector: #selector(hideTitleBar), object: nil)
-        }
-    }
-
-    func hideTitleBar() {
-        if titleBarEffect == nil { return }
-        if isInFullscreen && !isAnimating {
-            titleBarEffect!.alphaValue = 0
-            return
-        }
-        NSAnimationContext.runAnimationGroup({ (context) -> Void in
-            context.duration = 0.20
-            titleBar.animator().alphaValue = 0
-            titleBarEffect!.animator().alphaValue = 0
-        }, completionHandler: {
-            self.titleButtons.forEach { $0.isHidden = true }
-        })
-    }
-
-    func hideTitleBarDelayed() {
-        NSObject.cancelPreviousPerformRequests(withTarget: self,
-                                                 selector: #selector(hideTitleBar),
-                                                   object: nil)
-        perform(#selector(hideTitleBar), with: nil, afterDelay: 0.5)
-    }
-
     override func toggleFullScreen(_ sender: Any?) {
         if isAnimating {
             return
@@ -228,13 +124,13 @@
             previousScreen = screen
         }
 
-        if !isInFullscreen {
-            unfsContentFrame = convertToScreen(contentView!.frame)
+        if let contentViewFrame = contentView?.frame, !isInFullscreen {
+            unfsContentFrame = convertToScreen(contentViewFrame)
             unfScreen = screen
         }
         // move window to target screen when going to fullscreen
-        if !isInFullscreen && (targetScreen != screen) {
-            let frame = calculateWindowPosition(for: targetScreen!, withoutBounds: false)
+        if let tScreen = targetScreen, !isInFullscreen && (tScreen != screen) {
+            let frame = calculateWindowPosition(for: tScreen, withoutBounds: false)
             setFrame(frame, display: true)
         }
 
@@ -259,19 +155,22 @@
     }
 
     func window(_ window: NSWindow, startCustomAnimationToEnterFullScreenWithDuration duration: TimeInterval) {
-        cocoaCB.view.layerContentsPlacement = .scaleProportionallyToFit
-        hideTitleBar()
+        guard let tScreen = targetScreen else { return }
+        cocoaCB.view?.layerContentsPlacement = .scaleProportionallyToFit
+        cocoaCB.titleBar?.hide()
         NSAnimationContext.runAnimationGroup({ (context) -> Void in
             context.duration = getFsAnimationDuration(duration - 0.05)
-            window.animator().setFrame(targetScreen!.frame, display: true)
+            window.animator().setFrame(tScreen.frame, display: true)
         }, completionHandler: { })
     }
 
     func window(_ window: NSWindow, startCustomAnimationToExitFullScreenWithDuration duration: TimeInterval) {
-        let newFrame = calculateWindowPosition(for: targetScreen!, withoutBounds: targetScreen == screen)
-        let intermediateFrame = aspectFit(rect: newFrame, in: screen!.frame)
-        cocoaCB.view.layerContentsPlacement = .scaleProportionallyToFill
-        hideTitleBar()
+        guard let tScreen = targetScreen, let currentScreen = screen else { return }
+        let newFrame = calculateWindowPosition(for: tScreen, withoutBounds: tScreen == screen)
+        let intermediateFrame = aspectFit(rect: newFrame, in: currentScreen.frame)
+        cocoaCB.view?.layerContentsPlacement = .scaleProportionallyToFill
+        cocoaCB.titleBar?.hide()
+        styleMask.remove(.fullScreen)
         setFrame(intermediateFrame, display: true)
 
         NSAnimationContext.runAnimationGroup({ (context) -> Void in
@@ -285,27 +184,29 @@
         cocoaCB.flagEvents(VO_EVENT_FULLSCREEN_STATE)
         cocoaCB.updateCusorVisibility()
         endAnimation(frame)
-        showTitleBar()
+        cocoaCB.titleBar?.show()
     }
 
     func windowDidExitFullScreen(_ notification: Notification) {
+        guard let tScreen = targetScreen else { return }
         isInFullscreen = false
         cocoaCB.flagEvents(VO_EVENT_FULLSCREEN_STATE)
-        endAnimation(calculateWindowPosition(for: targetScreen!, withoutBounds: targetScreen == screen))
-        cocoaCB.view.layerContentsPlacement = .scaleProportionallyToFit
+        endAnimation(calculateWindowPosition(for: tScreen, withoutBounds: targetScreen == screen))
+        cocoaCB.view?.layerContentsPlacement = .scaleProportionallyToFit
     }
 
     func windowDidFailToEnterFullScreen(_ window: NSWindow) {
-        let newFrame = calculateWindowPosition(for: targetScreen!, withoutBounds: targetScreen == screen)
+        guard let tScreen = targetScreen else { return }
+        let newFrame = calculateWindowPosition(for: tScreen, withoutBounds: targetScreen == screen)
         setFrame(newFrame, display: true)
         endAnimation()
     }
 
     func windowDidFailToExitFullScreen(_ window: NSWindow) {
-        let newFrame = targetScreen!.frame
-        setFrame(newFrame, display: true)
+        guard let targetFrame = targetScreen?.frame else { return }
+        setFrame(targetFrame, display: true)
         endAnimation()
-        cocoaCB.view.layerContentsPlacement = .scaleProportionallyToFit
+        cocoaCB.view?.layerContentsPlacement = .scaleProportionallyToFit
     }
 
     func endAnimation(_ newFrame: NSRect = NSZeroRect) {
@@ -317,29 +218,31 @@
         }
 
         isAnimating = false
-        cocoaCB.layer.update()
+        cocoaCB.layer?.update()
         cocoaCB.checkShutdown()
     }
 
     func setToFullScreen() {
+        guard let targetFrame = targetScreen?.frame else { return }
         styleMask.insert(.fullScreen)
         NSApp.presentationOptions = [.autoHideMenuBar, .autoHideDock]
-        setFrame(targetScreen!.frame, display: true)
+        setFrame(targetFrame, display: true)
         endAnimation()
         isInFullscreen = true
         cocoaCB.flagEvents(VO_EVENT_FULLSCREEN_STATE)
-        cocoaCB.layer.update()
+        cocoaCB.layer?.update()
     }
 
     func setToWindow() {
-        let newFrame = calculateWindowPosition(for: targetScreen!, withoutBounds: targetScreen == screen)
+        guard let tScreen = targetScreen else { return }
+        let newFrame = calculateWindowPosition(for: tScreen, withoutBounds: targetScreen == screen)
         NSApp.presentationOptions = []
         setFrame(newFrame, display: true)
         styleMask.remove(.fullScreen)
         endAnimation()
         isInFullscreen = false
         cocoaCB.flagEvents(VO_EVENT_FULLSCREEN_STATE)
-        cocoaCB.layer.update()
+        cocoaCB.layer?.update()
     }
 
     func getFsAnimationDuration(_ def: Double) -> Double{
@@ -347,35 +250,37 @@
         if duration == "default" {
             return def
         } else {
-            return Double(duration)!/1000
+            return (Double(duration) ?? 0.2)/1000
         }
     }
 
     func setOnTop(_ state: Bool, _ ontopLevel: Any) {
+        let stdLevel: NSWindow.Level = .normal
+
         if state {
             if ontopLevel is Int {
-                switch ontopLevel as! Int {
-                case -1:
-                    level = Int(CGWindowLevelForKey(.floatingWindow))
-                case -2:
-                    level = Int(CGWindowLevelForKey(.statusWindow))+1
+                switch ontopLevel as? Int {
+                case .some(-1):
+                    level = .floating
+                case .some(-2):
+                    level = .statusBar + 1
                 default:
-                    level = ontopLevel as! Int
+                    level = NSWindow.Level(ontopLevel as? Int ?? stdLevel.rawValue)
                 }
             } else {
-                switch ontopLevel as! String {
-                case "window":
-                    level = Int(CGWindowLevelForKey(.floatingWindow))
-                case "system":
-                    level = Int(CGWindowLevelForKey(.statusWindow))+1
+                switch ontopLevel as? String {
+                case .some("window"):
+                    level = .floating
+                case .some("system"):
+                    level = .statusBar + 1
                 default:
-                    level = Int(ontopLevel as! String)!
+                    level = NSWindow.Level(Int(ontopLevel as? String ?? "") ?? stdLevel.rawValue)
                 }
             }
             collectionBehavior.remove(.transient)
             collectionBehavior.insert(.managed)
         } else {
-            level = Int(CGWindowLevelForKey(.normalWindow))
+            level = stdLevel
         }
     }
 
@@ -396,7 +301,7 @@
     }
 
     func updateSize(_ size: NSSize) {
-        if size != contentView!.frame.size {
+        if let currentSize = contentView?.frame.size, size != currentSize {
             let newContentFrame = centeredContentSize(for: frame, size: size)
             if !isInFullscreen {
                 updateFrame(newContentFrame)
@@ -407,12 +312,10 @@
     }
 
     override func setFrame(_ frameRect: NSRect, display flag: Bool) {
-        let newFrame = !isAnimating && isInFullscreen ? targetScreen!.frame :
-                                                        frameRect
-        super.setFrame(newFrame, display: flag)
+        super.setFrame(frameRect, display: flag)
 
-        if keepAspect {
-            contentAspectRatio = unfsContentFrame!.size
+        if let size = unfsContentFrame?.size, keepAspect {
+            contentAspectRatio = size
         }
     }
 
@@ -434,10 +337,13 @@
     }
 
     func calculateWindowPosition(for tScreen: NSScreen, withoutBounds: Bool) -> NSRect {
-        var newFrame = frameRect(forContentRect: unfsContentFrame!)
+        guard let contentFrame = unfsContentFrame, let screen = unfScreen else {
+            return frame
+        }
+        var newFrame = frameRect(forContentRect: contentFrame)
         let targetFrame = tScreen.frame
         let targetVisibleFrame = tScreen.visibleFrame
-        let unfsScreenFrame = unfScreen!.frame
+        let unfsScreenFrame = screen.frame
         let visibleWindow = NSIntersectionRect(unfsScreenFrame, newFrame)
 
         // calculate visible area of every side
@@ -504,10 +410,12 @@
             return frameRect
         }
 
+        guard let ts: NSScreen = tScreen ?? screen ?? NSScreen.main else {
+            return frameRect
+        }
         var nf: NSRect = frameRect
-        let ts: NSScreen = tScreen ?? screen ?? NSScreen.main()!
         let of: NSRect = frame
-        let vf: NSRect = (isAnimating ? targetScreen! : ts).visibleFrame
+        let vf: NSRect = (isAnimating ? (targetScreen ?? ts) : ts).visibleFrame
         let ncf: NSRect = contentRect(forFrameRect: nf)
 
         // screen bounds top and bottom
@@ -535,9 +443,9 @@
         return nf
     }
 
-    func setNormalWindowSize() { setWindowScale(1.0) }
-    func setHalfWindowSize()   { setWindowScale(0.5) }
-    func setDoubleWindowSize() { setWindowScale(2.0) }
+    @objc func setNormalWindowSize() { setWindowScale(1.0) }
+    @objc func setHalfWindowSize()   { setWindowScale(0.5) }
+    @objc func setDoubleWindowSize() { setWindowScale(2.0) }
 
     func setWindowScale(_ scale: Double) {
         mpv.commandAsync(["osd-auto", "set", "window-scale", "\(scale)"])
@@ -557,26 +465,34 @@
     }
 
     func windowDidChangeScreenProfile(_ notification: Notification) {
-        cocoaCB.layer.needsICCUpdate = true
+        cocoaCB.layer?.needsICCUpdate = true
     }
 
     func windowDidChangeBackingProperties(_ notification: Notification) {
-        cocoaCB.layer.contentsScale = backingScaleFactor
+        cocoaCB.layer?.contentsScale = backingScaleFactor
     }
 
     func windowWillStartLiveResize(_ notification: Notification) {
-        cocoaCB.layer.inLiveResize = true
+        cocoaCB.layer?.inLiveResize = true
     }
 
     func windowDidEndLiveResize(_ notification: Notification) {
-        cocoaCB.layer.inLiveResize = false
+        cocoaCB.layer?.inLiveResize = false
     }
 
-    func windowShouldClose(_ sender: Any) -> Bool {
+    func windowShouldClose(_ sender: NSWindow) -> Bool {
         cocoa_put_key(SWIFT_KEY_CLOSE_WIN)
         return false
     }
 
+    func windowDidMiniaturize(_ notification: Notification) {
+        cocoaCB.flagEvents(VO_EVENT_WIN_STATE)
+    }
+
+    func windowDidDeminiaturize(_ notification: Notification) {
+        cocoaCB.flagEvents(VO_EVENT_WIN_STATE)
+    }
+
     func windowDidResignKey(_ notification: Notification) {
         cocoaCB.setCursorVisiblility(true)
     }
@@ -585,6 +501,12 @@
         cocoaCB.updateCusorVisibility()
     }
 
+    func windowDidChangeOcclusionState(_ notification: Notification) {
+        if occlusionState.contains(.visible) {
+            cocoaCB.layer?.update(force: true)
+        }
+    }
+
     func windowWillMove(_ notification: Notification) {
         isMoving = true
     }
diff -ruN mpv-0.29.1/video/out/cocoa_cb_common.swift mpv-master/video/out/cocoa_cb_common.swift
--- mpv-0.29.1/video/out/cocoa_cb_common.swift	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/cocoa_cb_common.swift	2019-09-19 04:02:03.000000000 +0700
@@ -20,18 +20,19 @@
 
 class CocoaCB: NSObject {
 
-    var mpv: MPVHelper!
-    var window: Window!
-    var view: EventsView!
-    var layer: VideoLayer!
+    var mpv: MPVHelper
+    var window: Window?
+    var titleBar: TitleBar?
+    var view: EventsView?
+    var layer: VideoLayer?
     var link: CVDisplayLink?
 
     var cursorHidden: Bool = false
     var cursorVisibilityWanted: Bool = true
-    var isShuttingDown: Bool = false
+    @objc var isShuttingDown: Bool = false
 
     var title: String = "mpv" {
-        didSet { if window != nil { window.title = title } }
+        didSet { if let window = window { window.title = title } }
     }
 
     enum State {
@@ -51,9 +52,9 @@
 
     let queue: DispatchQueue = DispatchQueue(label: "io.mpv.queue")
 
-    convenience init(_ mpvHandle: OpaquePointer) {
-        self.init()
+    @objc init(_ mpvHandle: OpaquePointer) {
         mpv = MPVHelper(mpvHandle)
+        super.init()
         layer = VideoLayer(cocoaCB: self)
     }
 
@@ -62,9 +63,9 @@
             backendState = .needsInit
 
             view = EventsView(cocoaCB: self)
-            view.layer = layer
-            view.wantsLayer = true
-            view.layerContentsPlacement = .scaleProportionallyToFit
+            view?.layer = layer
+            view?.wantsLayer = true
+            view?.layerContentsPlacement = .scaleProportionallyToFit
             startDisplayLink(vo)
             initLightSensor()
             addDisplayReconfigureObserver()
@@ -72,18 +73,17 @@
     }
 
     func uninit() {
-        layer.setVideo(false)
-        window.orderOut(nil)
+        window?.orderOut(nil)
     }
 
     func reconfig(_ vo: UnsafeMutablePointer<vo>) {
+        mpv.vo = vo
         if backendState == .needsInit {
             DispatchQueue.main.sync { self.initBackend(vo) }
         } else {
             DispatchQueue.main.async {
-                self.layer.setVideo(true)
                 self.updateWindowSize(vo)
-                self.layer.update()
+                self.layer?.update()
             }
         }
     }
@@ -93,24 +93,38 @@
         NSApp.setActivationPolicy(.regular)
         setAppIcon()
 
-        let targetScreen = getScreenBy(id: Int(opts.screen_id)) ?? NSScreen.main()
-        let wr = getWindowGeometry(forScreen: targetScreen!, videoOut: vo)
+        guard let view = self.view else {
+            mpv.sendError("Something went wrong, no View was initialized")
+            exit(1)
+        }
+        guard let targetScreen = getScreenBy(id: Int(opts.screen_id)) ?? NSScreen.main else {
+            mpv.sendError("Something went wrong, no Screen was found")
+            exit(1)
+        }
+
+        let wr = getWindowGeometry(forScreen: targetScreen, videoOut: vo)
         window = Window(contentRect: wr, screen: targetScreen, view: view, cocoaCB: self)
+        guard let window = self.window else {
+            mpv.sendError("Something went wrong, no Window was initialized")
+            exit(1)
+        }
+
         updateICCProfile()
         window.setOnTop(Bool(opts.ontop), Int(opts.ontop_level))
         window.keepAspect = Bool(opts.keepaspect_window)
         window.title = title
         window.border = Bool(opts.border)
 
+        titleBar = TitleBar(frame: wr, window: window, cocoaCB: self)
+
         window.isRestorable = false
         window.makeMain()
         window.makeKeyAndOrderFront(nil)
         NSApp.activate(ignoringOtherApps: true)
-        layer.setVideo(true)
 
         if Bool(opts.fullscreen) {
             DispatchQueue.main.async {
-                self.window.toggleFullScreen(nil)
+                self.window?.toggleFullScreen(nil)
             }
         } else {
             window.isMovableByWindowBackground = true
@@ -121,13 +135,17 @@
 
     func updateWindowSize(_ vo: UnsafeMutablePointer<vo>) {
         let opts: mp_vo_opts = vo.pointee.opts.pointee
-        let targetScreen = getScreenBy(id: Int(opts.screen_id)) ?? NSScreen.main()
-        let wr = getWindowGeometry(forScreen: targetScreen!, videoOut: vo)
-        if !window.isVisible {
-            window.makeKeyAndOrderFront(nil)
+        guard let targetScreen = getScreenBy(id: Int(opts.screen_id)) ?? NSScreen.main else {
+            mpv.sendWarning("Couldn't update Window size, no Screen available")
+            return
         }
-        layer.atomicDrawingStart()
-        window.updateSize(wr.size)
+
+        let wr = getWindowGeometry(forScreen: targetScreen, videoOut: vo)
+        if !(window?.isVisible ?? false) {
+            window?.makeKeyAndOrderFront(nil)
+        }
+        layer?.atomicDrawingStart()
+        window?.updateSize(wr.size)
     }
 
     func setAppIcon() {
@@ -143,62 +161,75 @@
                          flagsIn: CVOptionFlags,
                         flagsOut: UnsafeMutablePointer<CVOptionFlags>,
               displayLinkContext: UnsafeMutableRawPointer?) -> CVReturn in
-        let ccb: CocoaCB = MPVHelper.bridge(ptr: displayLinkContext!)
+        let ccb = unsafeBitCast(displayLinkContext, to: CocoaCB.self)
         ccb.mpv.reportRenderFlip()
         return kCVReturnSuccess
     }
 
     func startDisplayLink(_ vo: UnsafeMutablePointer<vo>) {
         let opts: mp_vo_opts = vo.pointee.opts.pointee
-        let screen = getScreenBy(id: Int(opts.screen_id)) ?? NSScreen.main()
-        let displayId = screen!.deviceDescription["NSScreenNumber"] as! UInt32
-
         CVDisplayLinkCreateWithActiveCGDisplays(&link)
-        CVDisplayLinkSetCurrentCGDisplay(link!, displayId)
+
+        guard let screen = getScreenBy(id: Int(opts.screen_id)) ?? NSScreen.main,
+              let link = self.link else
+        {
+            mpv.sendWarning("Couldn't start DisplayLink, no Screen or DisplayLink available")
+            return
+        }
+
+        CVDisplayLinkSetCurrentCGDisplay(link, screen.displayID)
         if #available(macOS 10.12, *) {
-            CVDisplayLinkSetOutputHandler(link!) { link, now, out, inFlags, outFlags -> CVReturn in
+            CVDisplayLinkSetOutputHandler(link) { link, now, out, inFlags, outFlags -> CVReturn in
                 self.mpv.reportRenderFlip()
                 return kCVReturnSuccess
             }
         } else {
-            CVDisplayLinkSetOutputCallback(link!, linkCallback, MPVHelper.bridge(obj: self))
+            CVDisplayLinkSetOutputCallback(link, linkCallback, MPVHelper.bridge(obj: self))
         }
-        CVDisplayLinkStart(link!)
+        CVDisplayLinkStart(link)
     }
 
     func stopDisplaylink() {
-        if link != nil && CVDisplayLinkIsRunning(link!) {
-            CVDisplayLinkStop(link!)
+        if let link = self.link, CVDisplayLinkIsRunning(link) {
+            CVDisplayLinkStop(link)
         }
     }
 
     func updateDisplaylink() {
-        let displayId = UInt32(window.screen!.deviceDescription["NSScreenNumber"] as! Int)
-        CVDisplayLinkSetCurrentCGDisplay(link!, displayId)
+        guard let screen = window?.screen, let link = self.link else {
+            mpv.sendWarning("Couldn't update DisplayLink, no Screen or DisplayLink available")
+            return
+        }
 
+        CVDisplayLinkSetCurrentCGDisplay(link, screen.displayID)
         queue.asyncAfter(deadline: DispatchTime.now() + 0.1) {
             self.flagEvents(VO_EVENT_WIN_STATE)
         }
     }
 
     func currentFps() -> Double {
-        var actualFps = CVDisplayLinkGetActualOutputVideoRefreshPeriod(link!)
-        let nominalData = CVDisplayLinkGetNominalOutputVideoRefreshPeriod(link!)
+        if let link = self.link {
+            var actualFps = CVDisplayLinkGetActualOutputVideoRefreshPeriod(link)
+            let nominalData = CVDisplayLinkGetNominalOutputVideoRefreshPeriod(link)
 
-        if (nominalData.flags & Int32(CVTimeFlags.isIndefinite.rawValue)) < 1 {
-            let nominalFps = Double(nominalData.timeScale) / Double(nominalData.timeValue)
+            if (nominalData.flags & Int32(CVTimeFlags.isIndefinite.rawValue)) < 1 {
+                let nominalFps = Double(nominalData.timeScale) / Double(nominalData.timeValue)
 
-            if actualFps > 0 {
-                actualFps = 1/actualFps
-            }
+                if actualFps > 0 {
+                    actualFps = 1/actualFps
+                }
 
-            if fabs(actualFps - nominalFps) > 0.1 {
-                mpv.sendVerbose("Falling back to nominal display refresh rate: \(nominalFps)")
-                return nominalFps
-            } else {
-                return actualFps
+                if fabs(actualFps - nominalFps) > 0.1 {
+                    mpv.sendVerbose("Falling back to nominal display refresh rate: \(nominalFps)")
+                    return nominalFps
+                } else {
+                    return actualFps
+                }
             }
+        } else {
+            mpv.sendWarning("No DisplayLink available")
         }
+
         mpv.sendWarning("Falling back to standard display refresh rate: 60Hz")
         return 60.0
     }
@@ -222,8 +253,7 @@
     }
 
     func setCursorVisiblility(_ visible: Bool) {
-        let visibility = visible ? true : !view.canHideCursor()
-
+        let visibility = visible ? true : !(view?.canHideCursor() ?? false)
         if visibility && cursorHidden {
             NSCursor.unhide()
             cursorHidden = false;
@@ -234,9 +264,14 @@
     }
 
     func updateICCProfile() {
-        mpv.setRenderICCProfile(window.screen!.colorSpace!)
+        guard let colorSpace = window?.screen?.colorSpace else {
+            mpv.sendWarning("Couldn't update ICC Profile, no color space available")
+            return
+        }
+
+        mpv.setRenderICCProfile(colorSpace)
         if #available(macOS 10.11, *) {
-            layer.colorspace = window.screen!.colorSpace!.cgColorSpace!
+            layer?.colorspace = colorSpace.cgColorSpace
         }
     }
 
@@ -244,22 +279,23 @@
         // the polinomial approximation for apple lmu value -> lux was empirically
         // derived by firefox developers (Apple provides no documentation).
         // https://bugzilla.mozilla.org/show_bug.cgi?id=793728
-        let power_c4 = 1 / pow(10, 27)
-        let power_c3 = 1 / pow(10, 19)
-        let power_c2 = 1 / pow(10, 12)
-        let power_c1 = 1 / pow(10, 5)
-
-        let term4 = -3.0 * power_c4 * pow(Decimal(v), 4)
-        let term3 = 2.6 * power_c3 * pow(Decimal(v), 3)
-        let term2 = -3.4 * power_c2 * pow(Decimal(v), 2)
-        let term1 = 3.9 * power_c1 * Decimal(v)
+        let power_c4: Double = 1 / pow(10, 27)
+        let power_c3: Double = 1 / pow(10, 19)
+        let power_c2: Double = 1 / pow(10, 12)
+        let power_c1: Double = 1 / pow(10, 5)
+
+        let lum = Double(v)
+        let term4: Double = -3.0 * power_c4 * pow(lum, 4.0)
+        let term3: Double = 2.6 * power_c3 * pow(lum, 3.0)
+        let term2: Double = -3.4 * power_c2 * pow(lum, 2.0)
+        let term1: Double = 3.9 * power_c1 * lum
 
-        let lux = Int(ceil( Double((term4 + term3 + term2 + term1 - 0.19) as NSNumber)))
-        return Int(lux > 0 ? lux : 0)
+        let lux = Int(ceil(term4 + term3 + term2 + term1 - 0.19))
+        return lux > 0 ? lux : 0
     }
 
     var lightSensorCallback: IOServiceInterestCallback = { (ctx, service, messageType, messageArgument) -> Void in
-        let ccb: CocoaCB = MPVHelper.bridge(ptr: ctx!)
+        let ccb = unsafeBitCast(ctx, to: CocoaCB.self)
 
         var outputs: UInt32 = 2
         var values: [UInt64] = [0, 0]
@@ -304,10 +340,11 @@
 
     var reconfigureCallback: CGDisplayReconfigurationCallBack = { (display, flags, userInfo) in
         if flags.contains(.setModeFlag) {
-            let ccb: CocoaCB = MPVHelper.bridge(ptr: userInfo!)
-            let displayID = (ccb.window.screen!.deviceDescription["NSScreenNumber"] as! NSNumber).intValue
-            if UInt32(displayID) == display {
-                ccb.mpv.sendVerbose("Detected display mode change, updating screen refresh rate\n");
+            let ccb = unsafeBitCast(userInfo, to: CocoaCB.self)
+            let displayID = ccb.window?.screen?.displayID ?? display
+
+            if displayID == display {
+                ccb.mpv.sendVerbose("Detected display mode change, updating screen refresh rate");
                 ccb.flagEvents(VO_EVENT_WIN_STATE)
             }
         }
@@ -329,19 +366,18 @@
         case "current", "default", "all":
             return getScreenBy(id: -1)
         default:
-            return getScreenBy(id: Int(screenID)!)
+            return getScreenBy(id: Int(screenID) ?? 0)
         }
     }
 
     func getScreenBy(id screenID: Int) -> NSScreen? {
-        let screens = NSScreen.screens()
-        if screenID >= screens!.count {
+        if screenID >= NSScreen.screens.count {
             mpv.sendInfo("Screen ID \(screenID) does not exist, falling back to current device")
             return nil
         } else if screenID < 0 {
             return nil
         }
-        return screens![screenID]
+        return NSScreen.screens[screenID]
     }
 
     func getWindowGeometry(forScreen targetScreen: NSScreen,
@@ -369,6 +405,7 @@
         eventsLock.lock()
         events |= ev
         eventsLock.unlock()
+        vo_wakeup(mpv.vo)
     }
 
     func checkEvents() -> Int {
@@ -380,25 +417,32 @@
     }
 
     var controlCallback: mp_render_cb_control_fn = { ( vo, ctx, events, request, data ) -> Int32 in
-        let ccb: CocoaCB = MPVHelper.bridge(ptr: ctx!)
+        let ccb = unsafeBitCast(ctx, to: CocoaCB.self)
 
         switch mp_voctrl(request) {
         case VOCTRL_CHECK_EVENTS:
-            events!.pointee = Int32(ccb.checkEvents())
-            return VO_TRUE
+            if let ev = events {
+                ev.pointee = Int32(ccb.checkEvents())
+                return VO_TRUE
+            }
+            return VO_FALSE
         case VOCTRL_FULLSCREEN:
             DispatchQueue.main.async {
-                ccb.window.toggleFullScreen(nil)
+                ccb.window?.toggleFullScreen(nil)
             }
             return VO_TRUE
         case VOCTRL_GET_FULLSCREEN:
-            let fsData = data!.assumingMemoryBound(to: Int32.self)
-            fsData.pointee = ccb.window.isInFullscreen ? 1 : 0
-            return VO_TRUE
+            if let fsData = data?.assumingMemoryBound(to: Int32.self) {
+                fsData.pointee = (ccb.window?.isInFullscreen ?? false) ? 1 : 0
+                return VO_TRUE
+            }
+            return VO_FALSE
         case VOCTRL_GET_DISPLAY_FPS:
-            let fps = data!.assumingMemoryBound(to: CDouble.self)
-            fps.pointee = ccb.currentFps()
-            return VO_TRUE
+            if let fps = data?.assumingMemoryBound(to: CDouble.self) {
+                fps.pointee = ccb.currentFps()
+                return VO_TRUE
+            }
+            return VO_FALSE
         case VOCTRL_RESTORE_SCREENSAVER:
             ccb.enableDisplaySleep()
             return VO_TRUE
@@ -406,50 +450,88 @@
             ccb.disableDisplaySleep()
             return VO_TRUE
         case VOCTRL_SET_CURSOR_VISIBILITY:
-            ccb.cursorVisibilityWanted = data!.assumingMemoryBound(to: CBool.self).pointee
-            DispatchQueue.main.async {
-                ccb.setCursorVisiblility(ccb.cursorVisibilityWanted)
+            if let cursorVisibility = data?.assumingMemoryBound(to: CBool.self) {
+                ccb.cursorVisibilityWanted = cursorVisibility.pointee
+                DispatchQueue.main.async {
+                    ccb.setCursorVisiblility(ccb.cursorVisibilityWanted)
+                }
+                return VO_TRUE
             }
-            return VO_TRUE
+            return VO_FALSE
         case VOCTRL_SET_UNFS_WINDOW_SIZE:
-            let sizeData = data!.assumingMemoryBound(to: Int32.self)
-            let size = UnsafeBufferPointer(start: sizeData, count: 2)
-            var rect = NSMakeRect(0, 0, CGFloat(size[0]), CGFloat(size[1]))
-            DispatchQueue.main.async {
-                if !ccb.mpv.getBoolProperty("hidpi-window-scale") {
-                    rect = ccb.window.currentScreen!.convertRectFromBacking(rect)
+            if let sizeData = data?.assumingMemoryBound(to: Int32.self) {
+                let size = UnsafeBufferPointer(start: sizeData, count: 2)
+                var rect = NSMakeRect(0, 0, CGFloat(size[0]), CGFloat(size[1]))
+                DispatchQueue.main.async {
+                    if let screen = ccb.window?.currentScreen, !ccb.mpv.getBoolProperty("hidpi-window-scale") {
+                        rect = screen.convertRectFromBacking(rect)
+                    }
+                    ccb.window?.updateSize(rect.size)
                 }
-                ccb.window.updateSize(rect.size)
+                return VO_TRUE
             }
-            return VO_TRUE
+            return VO_FALSE
         case VOCTRL_GET_WIN_STATE:
-            let minimized = data!.assumingMemoryBound(to: Int32.self)
-            minimized.pointee = ccb.window.isMiniaturized ? VO_WIN_STATE_MINIMIZED : Int32(0)
-            return VO_TRUE
+            if let minimized = data?.assumingMemoryBound(to: Int32.self) {
+                minimized.pointee = ccb.window?.isMiniaturized ?? false ?
+                    VO_WIN_STATE_MINIMIZED : Int32(0)
+                return VO_TRUE
+            }
+            return VO_FALSE
+        case VOCTRL_GET_DISPLAY_NAMES:
+            if let opts: mp_vo_opts = vo?.pointee.opts?.pointee,
+               let dnames = data?.assumingMemoryBound(to: UnsafeMutablePointer<UnsafeMutablePointer<Int8>?>?.self)
+            {
+                var array: UnsafeMutablePointer<UnsafeMutablePointer<Int8>?>? = nil
+                var count: Int32 = 0
+                let screen = ccb.window != nil ? ccb.window?.screen :
+                                                 ccb.getScreenBy(id: Int(opts.screen_id)) ??
+                                                 NSScreen.main
+                let displayName = screen?.displayName ?? "Unknown"
+
+                SWIFT_TARRAY_STRING_APPEND(nil, &array, &count, ta_xstrdup(nil, displayName))
+                SWIFT_TARRAY_STRING_APPEND(nil, &array, &count, nil)
+                dnames.pointee = array
+                return VO_TRUE
+            }
+            return VO_FALSE
         case VOCTRL_UPDATE_WINDOW_TITLE:
-            let titleData = data!.assumingMemoryBound(to: Int8.self)
-            let title = String(cString: titleData)
-            DispatchQueue.main.async {
-                ccb.title = String(cString: titleData)
+            if let titleData = data?.assumingMemoryBound(to: Int8.self) {
+                DispatchQueue.main.async {
+                    ccb.title = String(cString: titleData)
+                }
+                return VO_TRUE
             }
-            return VO_TRUE
+            return VO_FALSE
         case VOCTRL_PREINIT:
-            DispatchQueue.main.sync { ccb.preinit(vo!) }
-            return VO_TRUE
+            if let vout = vo {
+                DispatchQueue.main.sync { ccb.preinit(vout) }
+                return VO_TRUE
+            }
+            return VO_FALSE
         case VOCTRL_UNINIT:
             DispatchQueue.main.async { ccb.uninit() }
             return VO_TRUE
         case VOCTRL_RECONFIG:
-            ccb.reconfig(vo!)
-            return VO_TRUE
+            if let vout = vo {
+                ccb.reconfig(vout)
+                return VO_TRUE
+            }
+            return VO_FALSE
         default:
             return VO_NOTIMPL
         }
     }
 
     func shutdown(_ destroy: Bool = false) {
+        isShuttingDown = window?.isAnimating ?? false ||
+                         window?.isInFullscreen ?? false && mpv.getBoolProperty("native-fs")
+        if window?.isInFullscreen ?? false && !(window?.isAnimating ?? false) {
+            window?.close()
+        }
+        if isShuttingDown { return }
+
         setCursorVisiblility(true)
-        layer.setVideo(false)
         stopDisplaylink()
         uninitLightSensor()
         removeDisplayReconfigureObserver()
@@ -463,13 +545,9 @@
         }
     }
 
-    func processEvent(_ event: UnsafePointer<mpv_event>) {
+    @objc func processEvent(_ event: UnsafePointer<mpv_event>) {
         switch event.pointee.event_id {
         case MPV_EVENT_SHUTDOWN:
-            if window != nil && window.isAnimating {
-                isShuttingDown = true
-                return
-            }
             shutdown()
         case MPV_EVENT_PROPERTY_CHANGE:
             if backendState == .initialized {
@@ -489,19 +567,27 @@
         switch String(cString: property.name) {
         case "border":
             if let data = MPVHelper.mpvFlagToBool(property.data) {
-                window.border = data
+                window?.border = data
             }
         case "ontop":
             if let data = MPVHelper.mpvFlagToBool(property.data) {
-                window.setOnTop(data, mpv.getStringProperty("ontop-level") ?? "window")
+                window?.setOnTop(data, mpv.getStringProperty("ontop-level") ?? "window")
             }
         case "keepaspect-window":
             if let data = MPVHelper.mpvFlagToBool(property.data) {
-                window.keepAspect = data
+                window?.keepAspect = data
+            }
+        case "macos-title-bar-appearance":
+            if let data = MPVHelper.mpvStringArrayToString(property.data) {
+                titleBar?.set(appearance: data)
+            }
+        case "macos-title-bar-material":
+            if let data = MPVHelper.mpvStringArrayToString(property.data) {
+                titleBar?.set(material: data)
             }
-        case "macos-title-bar-style":
+        case "macos-title-bar-color":
             if let data = MPVHelper.mpvStringArrayToString(property.data) {
-                window.setTitleBarStyle(data)
+                titleBar?.set(color: data)
             }
         default:
             break
diff -ruN mpv-0.29.1/video/out/d3d11/context.c mpv-master/video/out/d3d11/context.c
--- mpv-0.29.1/video/out/d3d11/context.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/d3d11/context.c	2019-09-19 04:02:03.000000000 +0700
@@ -161,14 +161,16 @@
 {
     struct priv *p = ctx->priv;
 
-    ra_tex_free(ctx->ra, &p->backbuffer);
+    if (ctx->ra)
+        ra_tex_free(ctx->ra, &p->backbuffer);
     SAFE_RELEASE(p->swapchain);
     vo_w32_uninit(ctx->vo);
     SAFE_RELEASE(p->device);
 
     // Destory the RA last to prevent objects we hold from showing up in D3D's
     // leak checker
-    ctx->ra->fns->destroy(ctx->ra);
+    if (ctx->ra)
+        ctx->ra->fns->destroy(ctx->ra);
 }
 
 static const struct ra_swapchain_fns d3d11_swapchain = {
diff -ruN mpv-0.29.1/video/out/d3d11/hwdec_dxva2dxgi.c mpv-master/video/out/d3d11/hwdec_dxva2dxgi.c
--- mpv-0.29.1/video/out/d3d11/hwdec_dxva2dxgi.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/d3d11/hwdec_dxva2dxgi.c	2019-09-19 04:02:03.000000000 +0700
@@ -148,7 +148,9 @@
     struct priv_owner *o = mapper->owner->priv;
     struct priv *p = mapper->priv;
 
+    ID3D11Device_AddRef(o->dev11);
     p->dev11 = o->dev11;
+    IDirect3DDevice9Ex_AddRef(o->dev9);
     p->dev9 = o->dev9;
     ID3D11Device_GetImmediateContext(o->dev11, &p->ctx11);
 
@@ -409,6 +411,10 @@
 
     for (int i = 0; i < p->queue_len; i++)
         surf_destroy(mapper, p->queue[i]);
+
+    SAFE_RELEASE(p->ctx11);
+    SAFE_RELEASE(p->dev9);
+    SAFE_RELEASE(p->dev11);
 }
 
 static int mapper_map(struct ra_hwdec_mapper *mapper)
diff -ruN mpv-0.29.1/video/out/d3d11/ra_d3d11.c mpv-master/video/out/d3d11/ra_d3d11.c
--- mpv-0.29.1/video/out/d3d11/ra_d3d11.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/d3d11/ra_d3d11.c	2019-09-19 04:02:03.000000000 +0700
@@ -4,7 +4,7 @@
 #include <d3d11sdklayers.h>
 #include <dxgi1_2.h>
 #include <d3dcompiler.h>
-#include <crossc.h>
+#include <spirv_cross_c.h>
 
 #include "common/msg.h"
 #include "osdep/io.h"
@@ -233,6 +233,9 @@
             .pixel_size     = d3dfmt->bytes,
             .linear_filter  = (support & sup_filter) == sup_filter,
             .renderable     = (support & sup_render) == sup_render,
+            // TODO: Check whether it's a storage format
+            // https://docs.microsoft.com/en-us/windows/desktop/direct3d12/typed-unordered-access-view-loads
+            .storable       = true,
         };
 
         if (support & D3D11_FORMAT_SUPPORT_TEXTURE1D)
@@ -383,14 +386,16 @@
     struct d3d_tex *tex_p = tex->priv = talloc_zero(tex, struct d3d_tex);
     DXGI_FORMAT fmt = fmt_to_dxgi(params->format);
 
+    D3D11_SUBRESOURCE_DATA data;
     D3D11_SUBRESOURCE_DATA *pdata = NULL;
     if (params->initial_data) {
-        pdata = &(D3D11_SUBRESOURCE_DATA) {
+        data = (D3D11_SUBRESOURCE_DATA) {
             .pSysMem = params->initial_data,
             .SysMemPitch = params->w * params->format->pixel_size,
         };
         if (params->dimensions >= 3)
-            pdata->SysMemSlicePitch = pdata->SysMemPitch * params->h;
+            data.SysMemSlicePitch = data.SysMemPitch * params->h;
+        pdata = &data;
     }
 
     D3D11_USAGE usage = D3D11_USAGE_DEFAULT;
@@ -642,7 +647,8 @@
     ptrdiff_t stride = tex->params.dimensions >= 2 ? tex->params.w : 0;
     ptrdiff_t pitch = tex->params.dimensions >= 3 ? stride * tex->params.h : 0;
     bool invalidate = true;
-    D3D11_BOX *rc = NULL;
+    D3D11_BOX rc;
+    D3D11_BOX *prc = NULL;
 
     if (tex->params.dimensions == 2) {
         stride = params->stride;
@@ -650,7 +656,7 @@
         if (params->rc && (params->rc->x0 != 0 || params->rc->y0 != 0 ||
             params->rc->x1 != tex->params.w || params->rc->y1 != tex->params.h))
         {
-            rc = &(D3D11_BOX) {
+            rc = (D3D11_BOX) {
                 .left = params->rc->x0,
                 .top = params->rc->y0,
                 .front = 0,
@@ -658,6 +664,7 @@
                 .bottom = params->rc->y1,
                 .back = 1,
             };
+            prc = &rc;
             invalidate = params->invalidate;
         }
     }
@@ -665,11 +672,11 @@
     int subresource = tex_p->array_slice >= 0 ? tex_p->array_slice : 0;
     if (p->ctx1) {
         ID3D11DeviceContext1_UpdateSubresource1(p->ctx1, tex_p->res,
-            subresource, rc, src, stride, pitch,
+            subresource, prc, src, stride, pitch,
             invalidate ? D3D11_COPY_DISCARD : 0);
     } else {
         ID3D11DeviceContext_UpdateSubresource(p->ctx, tex_p->res, subresource,
-            rc, src, stride, pitch);
+            prc, src, stride, pitch);
     }
 
     return true;
@@ -734,9 +741,12 @@
 
     struct d3d_buf *buf_p = buf->priv = talloc_zero(buf, struct d3d_buf);
 
+    D3D11_SUBRESOURCE_DATA data;
     D3D11_SUBRESOURCE_DATA *pdata = NULL;
-    if (params->initial_data)
-        pdata = &(D3D11_SUBRESOURCE_DATA) { .pSysMem = params->initial_data };
+    if (params->initial_data) {
+        data = (D3D11_SUBRESOURCE_DATA) { .pSysMem = params->initial_data };
+        pdata = &data;
+    }
 
     D3D11_BUFFER_DESC desc = { .ByteWidth = params->size };
     switch (params->type) {
@@ -1241,7 +1251,7 @@
     }
 }
 
-static int desc_namespace(enum ra_vartype type)
+static int desc_namespace(struct ra *ra, enum ra_vartype type)
 {
     // Images and SSBOs both use UAV bindings
     if (type == RA_VARTYPE_IMG_W)
@@ -1255,19 +1265,23 @@
     struct ra_d3d11 *p = ra->priv;
     struct spirv_compiler *spirv = p->spirv;
     void *ta_ctx = talloc_new(NULL);
-    crossc_compiler *cross = NULL;
+    spvc_result sc_res = SPVC_SUCCESS;
+    spvc_context sc_ctx = NULL;
+    spvc_parsed_ir sc_ir = NULL;
+    spvc_compiler sc_compiler = NULL;
+    spvc_compiler_options sc_opts = NULL;
     const char *hlsl = NULL;
     ID3DBlob *errors = NULL;
     bool success = false;
     HRESULT hr;
 
-    int cross_shader_model;
+    int sc_shader_model;
     if (p->fl >= D3D_FEATURE_LEVEL_11_0) {
-        cross_shader_model = 50;
+        sc_shader_model = 50;
     } else if (p->fl >= D3D_FEATURE_LEVEL_10_1) {
-        cross_shader_model = 41;
+        sc_shader_model = 41;
     } else {
-        cross_shader_model = 40;
+        sc_shader_model = 40;
     }
 
     int64_t start_us = mp_time_us();
@@ -1278,17 +1292,42 @@
 
     int64_t shaderc_us = mp_time_us();
 
-    cross = crossc_hlsl_create((uint32_t*)spv_module.start,
-                               spv_module.len / sizeof(uint32_t));
+    sc_res = spvc_context_create(&sc_ctx);
+    if (sc_res != SPVC_SUCCESS)
+        goto done;
 
-    crossc_hlsl_set_shader_model(cross, cross_shader_model);
-    crossc_set_flip_vert_y(cross, type == GLSL_SHADER_VERTEX);
+    sc_res = spvc_context_parse_spirv(sc_ctx, (SpvId *)spv_module.start,
+                                      spv_module.len / sizeof(SpvId), &sc_ir);
+    if (sc_res != SPVC_SUCCESS)
+        goto done;
 
-    hlsl = crossc_compile(cross);
-    if (!hlsl) {
-        MP_ERR(ra, "SPIRV-Cross failed: %s\n", crossc_strerror(cross));
+    sc_res = spvc_context_create_compiler(sc_ctx, SPVC_BACKEND_HLSL, sc_ir,
+                                          SPVC_CAPTURE_MODE_TAKE_OWNERSHIP,
+                                          &sc_compiler);
+    if (sc_res != SPVC_SUCCESS)
         goto done;
+
+    sc_res = spvc_compiler_create_compiler_options(sc_compiler, &sc_opts);
+    if (sc_res != SPVC_SUCCESS)
+        goto done;
+    sc_res = spvc_compiler_options_set_uint(sc_opts,
+        SPVC_COMPILER_OPTION_HLSL_SHADER_MODEL, sc_shader_model);
+    if (sc_res != SPVC_SUCCESS)
+        goto done;
+    if (type == GLSL_SHADER_VERTEX) {
+        // FLIP_VERTEX_Y is only valid for vertex shaders
+        sc_res = spvc_compiler_options_set_bool(sc_opts,
+            SPVC_COMPILER_OPTION_FLIP_VERTEX_Y, SPVC_TRUE);
+        if (sc_res != SPVC_SUCCESS)
+            goto done;
     }
+    sc_res = spvc_compiler_install_compiler_options(sc_compiler, sc_opts);
+    if (sc_res != SPVC_SUCCESS)
+        goto done;
+
+    sc_res = spvc_compiler_compile(sc_compiler, &hlsl);
+    if (sc_res != SPVC_SUCCESS)
+        goto done;
 
     int64_t cross_us = mp_time_us();
 
@@ -1312,7 +1351,11 @@
                d3dcompile_us - cross_us);
 
     success = true;
-done:;
+done:
+    if (sc_res != SPVC_SUCCESS) {
+        MP_MSG(ra, MSGL_ERR, "SPIRV-Cross failed: %s\n",
+               spvc_context_get_last_error_string(sc_ctx));
+    }
     int level = success ? MSGL_DEBUG : MSGL_ERR;
     MP_MSG(ra, level, "GLSL source:\n");
     mp_log_source(ra->log, level, glsl);
@@ -1321,7 +1364,8 @@
         mp_log_source(ra->log, level, hlsl);
     }
     SAFE_RELEASE(errors);
-    crossc_destroy(cross);
+    if (sc_ctx)
+        spvc_context_destroy(sc_ctx);
     talloc_free(ta_ctx);
     return success;
 }
@@ -1418,14 +1462,16 @@
 }
 
 static const char cache_magic[4] = "RD11";
-static const int cache_version = 2;
+static const int cache_version = 3;
 
 struct cache_header {
     char magic[sizeof(cache_magic)];
     int cache_version;
     char compiler[SPIRV_NAME_MAX_LEN];
     int spv_compiler_version;
-    uint32_t cross_version;
+    unsigned spvc_compiler_major;
+    unsigned spvc_compiler_minor;
+    unsigned spvc_compiler_patch;
     struct dll_version d3d_compiler_version;
     int feature_level;
     size_t vert_bytecode_len;
@@ -1449,6 +1495,9 @@
     struct cache_header *header = (struct cache_header *)cache.start;
     cache = bstr_cut(cache, sizeof(*header));
 
+    unsigned spvc_major, spvc_minor, spvc_patch;
+    spvc_get_version(&spvc_major, &spvc_minor, &spvc_patch);
+
     if (strncmp(header->magic, cache_magic, sizeof(cache_magic)) != 0)
         return;
     if (header->cache_version != cache_version)
@@ -1457,7 +1506,11 @@
         return;
     if (header->spv_compiler_version != spirv->compiler_version)
         return;
-    if (header->cross_version != crossc_version())
+    if (header->spvc_compiler_major != spvc_major)
+        return;
+    if (header->spvc_compiler_minor != spvc_minor)
+        return;
+    if (header->spvc_compiler_patch != spvc_patch)
         return;
     if (!dll_version_equal(header->d3d_compiler_version, p->d3d_compiler_ver))
         return;
@@ -1491,10 +1544,15 @@
     struct ra_d3d11 *p = ra->priv;
     struct spirv_compiler *spirv = p->spirv;
 
+    unsigned spvc_major, spvc_minor, spvc_patch;
+    spvc_get_version(&spvc_major, &spvc_minor, &spvc_patch);
+
     struct cache_header header = {
         .cache_version = cache_version,
         .spv_compiler_version = p->spirv->compiler_version,
-        .cross_version = crossc_version(),
+        .spvc_compiler_major = spvc_major,
+        .spvc_compiler_minor = spvc_minor,
+        .spvc_compiler_patch = spvc_patch,
         .d3d_compiler_version = p->d3d_compiler_ver,
         .feature_level = p->fl,
         .vert_bytecode_len = vert_bc.len,
diff -ruN mpv-0.29.1/video/out/drm_atomic.c mpv-master/video/out/drm_atomic.c
--- mpv-0.29.1/video/out/drm_atomic.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/drm_atomic.c	2019-09-19 04:02:03.000000000 +0700
@@ -138,7 +138,8 @@
 }
 
 struct drm_atomic_context *drm_atomic_create_context(struct mp_log *log, int fd, int crtc_id,
-                                                     int connector_id, int osd_plane_id, int video_plane_id)
+                                                     int connector_id,
+                                                     int draw_plane_idx, int drmprime_video_plane_idx)
 {
     drmModePlaneRes *plane_res = NULL;
     drmModeRes *res = NULL;
@@ -228,13 +229,13 @@
                 if ((!overlay_id) && (value == DRM_PLANE_TYPE_OVERLAY))
                     overlay_id = plane_id;
 
-                if (layercount == osd_plane_id) {
-                    ctx->osd_plane = plane;
+                if (layercount == draw_plane_idx) {
+                    ctx->draw_plane = plane;
                     continue;
                 }
 
-                if (layercount == video_plane_id) {
-                    ctx->video_plane = plane;
+                if (layercount == drmprime_video_plane_idx) {
+                    ctx->drmprime_video_plane = plane;
                     continue;
                 }
             }
@@ -244,29 +245,34 @@
         }
     }
 
-    // default OSD plane to primary if unspecified
-    if (!ctx->osd_plane) {
-        if (primary_id) {
-            mp_verbose(log, "Using default plane %d for OSD\n", primary_id);
-            ctx->osd_plane = drm_object_create(log, ctx->fd, primary_id, DRM_MODE_OBJECT_PLANE);
+    // draw plane was specified as either of the special options: any primary plane or any overlay plane
+    if (!ctx->draw_plane) {
+        const int draw_plane_id = (draw_plane_idx == DRM_OPTS_OVERLAY_PLANE) ? overlay_id : primary_id;
+        const char *plane_type = (draw_plane_idx == DRM_OPTS_OVERLAY_PLANE) ? "overlay" : "primary";
+        if (draw_plane_id) {
+            mp_verbose(log, "Using %s plane %d as draw plane\n", plane_type, draw_plane_id);
+            ctx->draw_plane = drm_object_create(log, ctx->fd, draw_plane_id, DRM_MODE_OBJECT_PLANE);
         } else {
-            mp_err(log, "Failed to find OSD plane with id=%d\n", osd_plane_id);
+            mp_err(log, "Failed to find draw plane with idx=%d\n", draw_plane_idx);
             goto fail;
         }
     } else {
-        mp_verbose(log, "Found OSD plane with ID %d\n", ctx->osd_plane->id);
+        mp_verbose(log, "Found draw plane with ID %d\n", ctx->draw_plane->id);
     }
 
-    // default video plane to overlay if unspecified
-    if (!ctx->video_plane) {
-        if (overlay_id) {
-            mp_verbose(log, "Using default plane %d for video\n", overlay_id);
-            ctx->video_plane = drm_object_create(log, ctx->fd, overlay_id, DRM_MODE_OBJECT_PLANE);
+    // drmprime plane was specified as either of the special options: any primary plane or any overlay plane
+    if (!ctx->drmprime_video_plane) {
+        const int drmprime_video_plane_id = (drmprime_video_plane_idx == DRM_OPTS_PRIMARY_PLANE) ? primary_id : overlay_id;
+        const char *plane_type = (drmprime_video_plane_idx == DRM_OPTS_PRIMARY_PLANE) ? "primary" : "overlay";
+
+        if (drmprime_video_plane_id) {
+            mp_verbose(log, "Using %s plane %d as drmprime plane\n", plane_type, drmprime_video_plane_id);
+            ctx->drmprime_video_plane = drm_object_create(log, ctx->fd, drmprime_video_plane_id, DRM_MODE_OBJECT_PLANE);
         } else {
-            mp_verbose(log, "Failed to find video plane with id=%d. drmprime-drm hwdec interop will not work\n", video_plane_id);
+            mp_verbose(log, "Failed to find drmprime plane with idx=%d. drmprime-drm hwdec interop will not work\n", drmprime_video_plane_idx);
         }
     } else {
-        mp_verbose(log, "Found video plane with ID %d\n", ctx->video_plane->id);
+        mp_verbose(log, "Found drmprime plane with ID %d\n", ctx->drmprime_video_plane->id);
     }
 
     drmModeFreePlaneResources(plane_res);
@@ -288,8 +294,8 @@
     drm_mode_destroy_blob(ctx->fd, &ctx->old_state.crtc.mode);
     drm_object_free(ctx->crtc);
     drm_object_free(ctx->connector);
-    drm_object_free(ctx->osd_plane);
-    drm_object_free(ctx->video_plane);
+    drm_object_free(ctx->draw_plane);
+    drm_object_free(ctx->drmprime_video_plane);
     talloc_free(ctx);
 }
 
@@ -381,9 +387,9 @@
     if (0 > drm_object_get_property(ctx->connector, "CRTC_ID", &ctx->old_state.connector.crtc_id))
         ret = false;
 
-    if (!drm_atomic_save_plane_state(ctx->osd_plane, &ctx->old_state.osd_plane))
+    if (!drm_atomic_save_plane_state(ctx->draw_plane, &ctx->old_state.draw_plane))
         ret = false;
-    if (!drm_atomic_save_plane_state(ctx->video_plane, &ctx->old_state.video_plane))
+    if (!drm_atomic_save_plane_state(ctx->drmprime_video_plane, &ctx->old_state.drmprime_video_plane))
         ret = false;
 
     ctx->old_state.saved = true;
@@ -408,9 +414,9 @@
     if (0 > drm_object_set_property(request, ctx->crtc, "ACTIVE", ctx->old_state.crtc.active))
         ret = false;
 
-    if (!drm_atomic_restore_plane_state(request, ctx->osd_plane, &ctx->old_state.osd_plane))
+    if (!drm_atomic_restore_plane_state(request, ctx->draw_plane, &ctx->old_state.draw_plane))
         ret = false;
-    if (!drm_atomic_restore_plane_state(request, ctx->video_plane, &ctx->old_state.video_plane))
+    if (!drm_atomic_restore_plane_state(request, ctx->drmprime_video_plane, &ctx->old_state.drmprime_video_plane))
         ret = false;
 
     ctx->old_state.saved = false;
diff -ruN mpv-0.29.1/video/out/drm_atomic.h mpv-master/video/out/drm_atomic.h
--- mpv-0.29.1/video/out/drm_atomic.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/drm_atomic.h	2019-09-19 04:02:03.000000000 +0700
@@ -25,6 +25,9 @@
 
 #include "common/msg.h"
 
+#define DRM_OPTS_PRIMARY_PLANE -1
+#define DRM_OPTS_OVERLAY_PLANE -2
+
 struct drm_mode {
     drmModeModeInfo mode;
     uint32_t blob_id;
@@ -54,8 +57,8 @@
         struct drm_mode mode;
         uint64_t active;
     } crtc;
-    struct drm_atomic_plane_state osd_plane;
-    struct drm_atomic_plane_state video_plane;
+    struct drm_atomic_plane_state draw_plane;
+    struct drm_atomic_plane_state drmprime_video_plane;
 };
 
 struct drm_object {
@@ -71,8 +74,8 @@
 
     struct drm_object *crtc;
     struct drm_object *connector;
-    struct drm_object *osd_plane;
-    struct drm_object *video_plane;
+    struct drm_object *draw_plane;
+    struct drm_object *drmprime_video_plane;
 
     drmModeAtomicReq *request;
 
@@ -89,7 +92,7 @@
 void drm_object_free(struct drm_object *object);
 void drm_object_print_info(struct mp_log *log, struct drm_object *object);
 struct drm_atomic_context *drm_atomic_create_context(struct mp_log *log, int fd, int crtc_id, int connector_id,
-													 int osd_plane_id, int video_plane_id);
+                                                     int draw_plane_idx, int drmprime_video_plane_idx);
 void drm_atomic_destroy_context(struct drm_atomic_context *ctx);
 
 bool drm_atomic_save_old_state(struct drm_atomic_context *ctx);
diff -ruN mpv-0.29.1/video/out/drm_common.c mpv-master/video/out/drm_common.c
--- mpv-0.29.1/video/out/drm_common.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/drm_common.c	2019-09-19 04:02:03.000000000 +0700
@@ -23,12 +23,15 @@
 #include <sys/stat.h>
 #include <sys/vt.h>
 #include <unistd.h>
+#include <limits.h>
+#include <math.h>
 
 #include "drm_common.h"
 
 #include "common/common.h"
 #include "common/msg.h"
 #include "osdep/io.h"
+#include "misc/ctype.h"
 
 #define EVT_RELEASE 1
 #define EVT_ACQUIRE 2
@@ -41,23 +44,51 @@
 
 static int vt_switcher_pipe[2];
 
+static int drm_validate_connector_opt(
+    struct mp_log *log, const struct m_option *opt, struct bstr name,
+    struct bstr param);
+
+static int drm_validate_mode_opt(
+    struct mp_log *log, const struct m_option *opt, struct bstr name,
+    struct bstr param);
+
+static void kms_show_available_modes(
+    struct mp_log *log, const drmModeConnector *connector);
+
+static void kms_show_available_connectors(struct mp_log *log, int card_no);
+static double mode_get_Hz(const drmModeModeInfo *mode);
+
 #define OPT_BASE_STRUCT struct drm_opts
 const struct m_sub_options drm_conf = {
     .opts = (const struct m_option[]) {
         OPT_STRING_VALIDATE("drm-connector", drm_connector_spec,
                             0, drm_validate_connector_opt),
-        OPT_INT("drm-mode", drm_mode_id, 0),
-        OPT_INT("drm-osd-plane-id", drm_osd_plane_id, 0),
-        OPT_INT("drm-video-plane-id", drm_video_plane_id, 0),
+        OPT_STRING_VALIDATE("drm-mode", drm_mode_spec,
+                            0, drm_validate_mode_opt),
+        OPT_CHOICE("drm-atomic", drm_atomic, 0,
+                   ({"no", 0},
+                    {"auto", 1})),
+        OPT_CHOICE_OR_INT("drm-draw-plane", drm_draw_plane, 0, 0, INT_MAX,
+                          ({"primary", DRM_OPTS_PRIMARY_PLANE},
+                           {"overlay", DRM_OPTS_OVERLAY_PLANE})),
+        OPT_CHOICE_OR_INT("drm-drmprime-video-plane", drm_drmprime_video_plane, 0, 0, INT_MAX,
+                          ({"primary", DRM_OPTS_PRIMARY_PLANE},
+                           {"overlay", DRM_OPTS_OVERLAY_PLANE})),
         OPT_CHOICE("drm-format", drm_format, 0,
                    ({"xrgb8888",    DRM_OPTS_FORMAT_XRGB8888},
                     {"xrgb2101010", DRM_OPTS_FORMAT_XRGB2101010})),
-        OPT_SIZE_BOX("drm-osd-size", drm_osd_size, 0),
+        OPT_SIZE_BOX("drm-draw-surface-size", drm_draw_surface_size, 0),
+
+        OPT_REPLACED("drm-osd-plane-id", "drm-draw-plane"),
+        OPT_REPLACED("drm-video-plane-id", "drm-drmprime-video-plane"),
+        OPT_REPLACED("drm-osd-size", "drm-draw-surface-size"),
         {0},
     },
     .defaults = &(const struct drm_opts) {
-        .drm_osd_plane_id = -1,
-        .drm_video_plane_id = -1,
+        .drm_mode_spec = "preferred",
+        .drm_atomic = 1,
+        .drm_draw_plane = DRM_OPTS_PRIMARY_PLANE,
+        .drm_drmprime_video_plane = DRM_OPTS_OVERLAY_PLANE,
     },
     .size = sizeof(struct drm_opts),
 };
@@ -83,10 +114,23 @@
     "DPI",       // DRM_MODE_CONNECTOR_DPI
 };
 
+struct drm_mode_spec {
+    enum {
+        DRM_MODE_SPEC_BY_IDX,     // Specified by idx
+        DRM_MODE_SPEC_BY_NUMBERS, // Specified by width, height and opt. refresh
+        DRM_MODE_SPEC_PREFERRED,  // Select the preferred mode of the display
+        DRM_MODE_SPEC_HIGHEST,    // Select the mode with the highest resolution
+    } type;
+    unsigned int idx;
+    unsigned int width;
+    unsigned int height;
+    double refresh;
+};
+
 // KMS ------------------------------------------------------------------------
 
-static void get_connector_name(
-    drmModeConnector *connector, char ret[MAX_CONNECTOR_NAME_LEN])
+static void get_connector_name(const drmModeConnector *connector,
+                               char ret[MAX_CONNECTOR_NAME_LEN])
 {
     snprintf(ret, MAX_CONNECTOR_NAME_LEN, "%s-%d",
              connector_names[connector->connector_type],
@@ -227,18 +271,216 @@
     return true;
 }
 
-static bool setup_mode(struct kms *kms, int mode_id)
+static bool all_digits(const char *str)
+{
+    if (str == NULL || str[0] == '\0') {
+        return false;
+    }
+
+    for (const char *c = str; *c != '\0'; ++c) {
+        if (!mp_isdigit(*c))
+            return false;
+    }
+    return true;
+}
+
+static bool parse_mode_spec(const char *spec, struct drm_mode_spec *parse_result)
+{
+    if (spec == NULL || spec[0] == '\0' || strcmp(spec, "preferred") == 0) {
+        if (parse_result) {
+            *parse_result =
+                (struct drm_mode_spec) { .type = DRM_MODE_SPEC_PREFERRED };
+        }
+        return true;
+    }
+
+    if (strcmp(spec, "highest") == 0) {
+        if (parse_result) {
+            *parse_result =
+                (struct drm_mode_spec) { .type = DRM_MODE_SPEC_HIGHEST };
+        }
+        return true;
+    }
+
+    // If the string is made up of only digits, it means that it is an index number
+    if (all_digits(spec)) {
+        if (parse_result) {
+            *parse_result = (struct drm_mode_spec) {
+                .type = DRM_MODE_SPEC_BY_IDX,
+                .idx = strtoul(spec, NULL, 10),
+            };
+        }
+        return true;
+    }
+
+    if (!mp_isdigit(spec[0]))
+        return false;
+    char *height_part, *refresh_part;
+    const unsigned int width = strtoul(spec, &height_part, 10);
+    if (spec == height_part || height_part[0] == '\0' || height_part[0] != 'x')
+        return false;
+
+    height_part += 1;
+    if (!mp_isdigit(height_part[0]))
+        return false;
+    const unsigned int height = strtoul(height_part, &refresh_part, 10);
+    if (height_part == refresh_part)
+        return false;
+
+    char *rest = NULL;
+    double refresh;
+    switch (refresh_part[0]) {
+    case '\0':
+        refresh = nan("");
+        break;
+    case '@':
+        refresh_part += 1;
+        if (!(mp_isdigit(refresh_part[0]) || refresh_part[0] == '.'))
+            return false;
+        refresh = strtod(refresh_part, &rest);
+        if (refresh_part == rest || rest[0] != '\0' || refresh < 0.0)
+            return false;
+        break;
+    default:
+        return false;
+    }
+
+    if (parse_result) {
+        *parse_result = (struct drm_mode_spec) {
+            .type = DRM_MODE_SPEC_BY_NUMBERS,
+            .width = width,
+            .height = height,
+            .refresh = refresh,
+        };
+    }
+    return true;
+}
+
+static bool setup_mode_by_idx(struct kms *kms, unsigned int mode_idx)
 {
-    if (mode_id < 0 || mode_id >= kms->connector->count_modes) {
-        MP_ERR(kms, "Bad mode ID (max = %d).\n",
+    if (mode_idx >= kms->connector->count_modes) {
+        MP_ERR(kms, "Bad mode index (max = %d).\n",
                kms->connector->count_modes - 1);
+        return false;
+    }
+
+    kms->mode.mode = kms->connector->modes[mode_idx];
+    return true;
+}
 
-        kms_show_available_modes(kms->log, kms->connector);
+static bool mode_match(const drmModeModeInfo *mode,
+                       unsigned int width,
+                       unsigned int height,
+                       double refresh)
+{
+    if (isnan(refresh)) {
+        return
+            (mode->hdisplay == width) &&
+            (mode->vdisplay == height);
+    } else {
+        const double mode_refresh = mode_get_Hz(mode);
+        return
+            (mode->hdisplay == width) &&
+            (mode->vdisplay == height) &&
+            ((int)round(refresh*100) == (int)round(mode_refresh*100));
+    }
+}
+
+static bool setup_mode_by_numbers(struct kms *kms,
+                                  unsigned int width,
+                                  unsigned int height,
+                                  double refresh,
+                                  const char *mode_spec)
+{
+    for (unsigned int i = 0; i < kms->connector->count_modes; ++i) {
+        drmModeModeInfo *current_mode = &kms->connector->modes[i];
+        if (mode_match(current_mode, width, height, refresh)) {
+            kms->mode.mode = *current_mode;
+            return true;
+        }
+    }
+
+    MP_ERR(kms, "Could not find mode matching %s\n", mode_spec);
+    return false;
+}
+
+static bool setup_mode_preferred(struct kms *kms)
+{
+    for (unsigned int i = 0; i < kms->connector->count_modes; ++i) {
+        drmModeModeInfo *current_mode = &kms->connector->modes[i];
+        if (current_mode->type & DRM_MODE_TYPE_PREFERRED) {
+            kms->mode.mode = *current_mode;
+            return true;
+        }
+    }
+
+    // Fall back to first mode
+    MP_WARN(kms, "Could not find any preferred mode. Picking the first mode.\n");
+    kms->mode.mode = kms->connector->modes[0];
+    return true;
+}
+
+static bool setup_mode_highest(struct kms *kms)
+{
+    unsigned int area = 0;
+    drmModeModeInfo *highest_resolution_mode = &kms->connector->modes[0];
+    for (unsigned int i = 0; i < kms->connector->count_modes; ++i) {
+        drmModeModeInfo *current_mode = &kms->connector->modes[i];
+
+        const unsigned int current_area =
+            current_mode->hdisplay * current_mode->vdisplay;
+        if (current_area > area) {
+            highest_resolution_mode = current_mode;
+            area = current_area;
+        }
+    }
+
+    kms->mode.mode = *highest_resolution_mode;
+    return true;
+}
+
+static bool setup_mode(struct kms *kms, const char *mode_spec)
+{
+    if (kms->connector->count_modes <= 0) {
+        MP_ERR(kms, "No available modes\n");
         return false;
     }
 
-    kms->mode.mode = kms->connector->modes[mode_id];
+    struct drm_mode_spec parsed;
+    if (!parse_mode_spec(mode_spec, &parsed)) {
+        MP_ERR(kms, "Parse error\n");
+        goto err;
+    }
+
+    switch (parsed.type) {
+    case DRM_MODE_SPEC_BY_IDX:
+        if (!setup_mode_by_idx(kms, parsed.idx))
+            goto err;
+        break;
+    case DRM_MODE_SPEC_BY_NUMBERS:
+        if (!setup_mode_by_numbers(kms, parsed.width, parsed.height, parsed.refresh,
+                                   mode_spec))
+            goto err;
+        break;
+    case DRM_MODE_SPEC_PREFERRED:
+        if (!setup_mode_preferred(kms))
+            goto err;
+        break;
+    case DRM_MODE_SPEC_HIGHEST:
+        if (!setup_mode_highest(kms))
+            goto err;
+        break;
+    default:
+        MP_ERR(kms, "setup_mode: Internal error\n");
+        goto err;
+    }
+
     return true;
+
+err:
+    MP_INFO(kms, "Available modes:\n");
+    kms_show_available_modes(kms->log, kms->connector);
+    return false;
 }
 
 static int open_card(int card_no)
@@ -267,9 +509,10 @@
     }
 }
 
-
 struct kms *kms_create(struct mp_log *log, const char *connector_spec,
-                       int mode_id, int osd_plane_id, int video_plane_id)
+                       const char* mode_spec,
+                       int draw_plane, int drmprime_video_plane,
+                       bool use_atomic)
 {
     int card_no = -1;
     char *connector_name = NULL;
@@ -304,7 +547,7 @@
         goto err;
     if (!setup_crtc(kms, res))
         goto err;
-    if (!setup_mode(kms, mode_id))
+    if (!setup_mode(kms, mode_spec))
         goto err;
 
     // Universal planes allows accessing all the planes (including primary)
@@ -312,12 +555,15 @@
         mp_err(log, "Failed to set Universal planes capability\n");
     }
 
-    if (drmSetClientCap(kms->fd, DRM_CLIENT_CAP_ATOMIC, 1)) {
-        mp_verbose(log, "No DRM Atomic support found\n");
+    if (!use_atomic) {
+        mp_verbose(log, "Using Legacy Modesetting\n");
+    } else if (drmSetClientCap(kms->fd, DRM_CLIENT_CAP_ATOMIC, 1)) {
+        mp_verbose(log, "No DRM Atomic support found. Falling back to legacy modesetting\n");
     } else {
         mp_verbose(log, "DRM Atomic support found\n");
         kms->atomic_context = drm_atomic_create_context(kms->log, kms->fd, kms->crtc_id,
-                                                        kms->connector->connector_id, osd_plane_id, video_plane_id);
+                                                        kms->connector->connector_id,
+                                                        draw_plane, drmprime_video_plane);
         if (!kms->atomic_context) {
             mp_err(log, "Failed to create DRM atomic context\n");
             goto err;
@@ -362,12 +608,11 @@
     return mode->clock * 1000.0 / mode->htotal / mode->vtotal;
 }
 
-void kms_show_available_modes(
+static void kms_show_available_modes(
     struct mp_log *log, const drmModeConnector *connector)
 {
-    mp_info(log, "Available modes:\n");
     for (unsigned int i = 0; i < connector->count_modes; i++) {
-        mp_info(log, "Mode %d: %s (%dx%d@%.2fHz)\n", i,
+        mp_info(log, "  Mode %d: %s (%dx%d@%.2fHz)\n", i,
                 connector->modes[i].name,
                 connector->modes[i].hdisplay,
                 connector->modes[i].vdisplay,
@@ -375,10 +620,10 @@
     }
 }
 
-void kms_show_available_connectors(struct mp_log *log, int card_no)
+static void kms_show_foreach_connector(struct mp_log *log, int card_no,
+                                       void (*show_fn)(struct mp_log*, int,
+                                                       const drmModeConnector*))
 {
-    mp_info(log, "Available connectors for card %d:\n", card_no);
-
     int fd = open_card(card_no);
     if (fd < 0) {
         mp_err(log, "Failed to open card %d\n", card_no);
@@ -396,12 +641,7 @@
             = drmModeGetConnector(fd, res->connectors[i]);
         if (!connector)
             continue;
-        char other_connector_name[MAX_CONNECTOR_NAME_LEN];
-        get_connector_name(connector, other_connector_name);
-        mp_info(log, "%s (%s)\n", other_connector_name,
-                connector->connection == DRM_MODE_CONNECTED
-                    ? "connected"
-                    : "disconnected");
+        show_fn(log, card_no, connector);
         drmModeFreeConnector(connector);
     }
 
@@ -412,24 +652,72 @@
         drmModeFreeResources(res);
 }
 
-void kms_show_available_cards_and_connectors(struct mp_log *log)
+static void kms_show_connector_name_and_state_callback(
+    struct mp_log *log, int card_no, const drmModeConnector *connector)
+{
+    char other_connector_name[MAX_CONNECTOR_NAME_LEN];
+    get_connector_name(connector, other_connector_name);
+    const char *connection_str =
+        (connector->connection == DRM_MODE_CONNECTED) ? "connected" : "disconnected";
+    mp_info(log, "  %s (%s)\n", other_connector_name, connection_str);
+}
+
+static void kms_show_available_connectors(struct mp_log *log, int card_no)
+{
+    mp_info(log, "Available connectors for card %d:\n", card_no);
+    kms_show_foreach_connector(
+        log, card_no, kms_show_connector_name_and_state_callback);
+    mp_info(log, "\n");
+}
+
+static void kms_show_connector_modes_callback(struct mp_log *log, int card_no,
+                                              const drmModeConnector *connector)
+{
+    if (connector->connection != DRM_MODE_CONNECTED)
+        return;
+
+    char other_connector_name[MAX_CONNECTOR_NAME_LEN];
+    get_connector_name(connector, other_connector_name);
+    mp_info(log, "Available modes for drm-connector=%d.%s\n",
+            card_no, other_connector_name);
+    kms_show_available_modes(log, connector);
+    mp_info(log, "\n");
+}
+
+static void kms_show_available_connectors_and_modes(struct mp_log *log, int card_no)
+{
+    kms_show_foreach_connector(log, card_no, kms_show_connector_modes_callback);
+}
+
+static void kms_show_foreach_card(
+    struct mp_log *log, void (*show_fn)(struct mp_log*,int))
 {
     for (int card_no = 0; card_no < DRM_MAX_MINOR; card_no++) {
         int fd = open_card(card_no);
         if (fd < 0)
             break;
         close(fd);
-        kms_show_available_connectors(log, card_no);
+        show_fn(log, card_no);
     }
 }
 
+static void kms_show_available_cards_and_connectors(struct mp_log *log)
+{
+    kms_show_foreach_card(log, kms_show_available_connectors);
+}
+
+static void kms_show_available_cards_connectors_and_modes(struct mp_log *log)
+{
+    kms_show_foreach_card(log, kms_show_available_connectors_and_modes);
+}
+
 double kms_get_display_fps(const struct kms *kms)
 {
     return mode_get_Hz(&kms->mode.mode);
 }
 
-int drm_validate_connector_opt(struct mp_log *log, const struct m_option *opt,
-                               struct bstr name, struct bstr param)
+static int drm_validate_connector_opt(struct mp_log *log, const struct m_option *opt,
+                                      struct bstr name, struct bstr param)
 {
     if (bstr_equals0(param, "help")) {
         kms_show_available_cards_and_connectors(log);
@@ -438,7 +726,24 @@
     return 1;
 }
 
+static int drm_validate_mode_opt(struct mp_log *log, const struct m_option *opt,
+                                 struct bstr name, struct bstr param)
+{
+    if (bstr_equals0(param, "help")) {
+        kms_show_available_cards_connectors_and_modes(log);
+        return M_OPT_EXIT;
+    }
 
+    char *spec = bstrto0(NULL, param);
+    if (!parse_mode_spec(spec, NULL)) {
+        mp_fatal(log, "Invalid value for option drm-mode. Must be a positive number, a string of the format WxH[@R] or 'help'\n");
+        talloc_free(spec);
+        return M_OPT_INVALID;
+    }
+    talloc_free(spec);
+
+    return 1;
+}
 
 // VT switcher ----------------------------------------------------------------
 
diff -ruN mpv-0.29.1/video/out/drm_common.h mpv-master/video/out/drm_common.h
--- mpv-0.29.1/video/out/drm_common.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/drm_common.h	2019-09-19 04:02:03.000000000 +0700
@@ -47,11 +47,12 @@
 
 struct drm_opts {
     char *drm_connector_spec;
-    int drm_mode_id;
-    int drm_osd_plane_id;
-    int drm_video_plane_id;
+    char *drm_mode_spec;
+    int drm_atomic;
+    int drm_draw_plane;
+    int drm_drmprime_video_plane;
     int drm_format;
-    struct m_geometry drm_osd_size;
+    struct m_geometry drm_draw_surface_size;
 };
 
 bool vt_switcher_init(struct vt_switcher *s, struct mp_log *log);
@@ -65,16 +66,10 @@
                          void *user_data);
 
 struct kms *kms_create(struct mp_log *log, const char *connector_spec,
-                       int mode_id, int osd_plane_id, int video_plane_id);
+                       const char *mode_spec,
+                       int draw_plane, int drmprime_video_plane,
+                       bool use_atomic);
 void kms_destroy(struct kms *kms);
 double kms_get_display_fps(const struct kms *kms);
 
-void kms_show_available_connectors(struct mp_log *log, int card_no);
-void kms_show_available_modes(struct mp_log *log,
-                              const drmModeConnector *connector);
-void kms_show_available_cards_and_connectors(struct mp_log *log);
-
-int drm_validate_connector_opt(struct mp_log *log, const struct m_option *opt,
-                               struct bstr name, struct bstr param);
-
 #endif
diff -ruN mpv-0.29.1/video/out/gpu/context.c mpv-master/video/out/gpu/context.c
--- mpv-0.29.1/video/out/gpu/context.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/context.c	2019-09-19 04:02:03.000000000 +0700
@@ -35,7 +35,6 @@
 
 /* OpenGL */
 extern const struct ra_ctx_fns ra_ctx_glx;
-extern const struct ra_ctx_fns ra_ctx_glx_probe;
 extern const struct ra_ctx_fns ra_ctx_x11_egl;
 extern const struct ra_ctx_fns ra_ctx_drm_egl;
 extern const struct ra_ctx_fns ra_ctx_cocoa;
@@ -62,7 +61,7 @@
 #endif
 
 // OpenGL contexts:
-#if HAVE_ANDROID
+#if HAVE_EGL_ANDROID
     &ra_ctx_android,
 #endif
 #if HAVE_RPI
@@ -80,8 +79,8 @@
 #if HAVE_GL_DXINTEROP
     &ra_ctx_dxgl,
 #endif
-#if HAVE_GL_X11
-    &ra_ctx_glx_probe,
+#if HAVE_GL_WAYLAND
+    &ra_ctx_wayland_egl,
 #endif
 #if HAVE_EGL_X11
     &ra_ctx_x11_egl,
@@ -89,9 +88,6 @@
 #if HAVE_GL_X11
     &ra_ctx_glx,
 #endif
-#if HAVE_GL_WAYLAND
-    &ra_ctx_wayland_egl,
-#endif
 #if HAVE_EGL_DRM
     &ra_ctx_drm_egl,
 #endif
diff -ruN mpv-0.29.1/video/out/gpu/context.h mpv-master/video/out/gpu/context.h
--- mpv-0.29.1/video/out/gpu/context.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/context.h	2019-09-19 04:02:03.000000000 +0700
@@ -83,6 +83,9 @@
     // Performs a buffer swap. This blocks for as long as necessary to meet
     // params.swapchain_depth, or until the next vblank (for vsynced contexts)
     void (*swap_buffers)(struct ra_swapchain *sw);
+
+    // See vo. Usually called after swap_buffers().
+    void (*get_vsync)(struct ra_swapchain *sw, struct vo_vsync_info *info);
 };
 
 // Create and destroy a ra_ctx. This also takes care of creating and destroying
diff -ruN mpv-0.29.1/video/out/gpu/error_diffusion.c mpv-master/video/out/gpu/error_diffusion.c
--- mpv-0.29.1/video/out/gpu/error_diffusion.c	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/gpu/error_diffusion.c	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,316 @@
+/*
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+
+#include "error_diffusion.h"
+
+#include "common/common.h"
+
+#define GLSL(...) gl_sc_addf(sc, __VA_ARGS__)
+#define GLSLH(...) gl_sc_haddf(sc, __VA_ARGS__)
+
+// After a (y, x) -> (y, x + y * shift) mapping, find the right most column that
+// will be affected by the current column.
+static int compute_rightmost_shifted_column(const struct error_diffusion_kernel *k)
+{
+    int ret = 0;
+    for (int y = 0; y <= EF_MAX_DELTA_Y; y++) {
+        for (int x = EF_MIN_DELTA_X; x <= EF_MAX_DELTA_X; x++) {
+            if (k->pattern[y][x - EF_MIN_DELTA_X] != 0) {
+                int shifted_x = x + y * k->shift;
+
+                // The shift mapping guarantees current column (or left of it)
+                // won't be affected by error diffusion.
+                assert(shifted_x > 0);
+
+                ret = MPMAX(ret, shifted_x);
+            }
+        }
+    }
+    return ret;
+}
+
+const struct error_diffusion_kernel *mp_find_error_diffusion_kernel(const char *name)
+{
+    if (!name)
+        return NULL;
+    for (const struct error_diffusion_kernel *k = mp_error_diffusion_kernels;
+         k->name;
+         k++) {
+        if (strcmp(k->name, name) == 0)
+            return k;
+    }
+    return NULL;
+}
+
+int mp_ef_compute_shared_memory_size(const struct error_diffusion_kernel *k,
+                                     int height)
+{
+    // We add EF_MAX_DELTA_Y empty lines on the bottom to handle errors
+    // propagated out from bottom side.
+    int rows = height + EF_MAX_DELTA_Y;
+    int shifted_columns = compute_rightmost_shifted_column(k) + 1;
+
+    // The shared memory is an array of size rows*shifted_columns. Each element
+    // is a single uint for three RGB component.
+    return rows * shifted_columns * 4;
+}
+
+void pass_error_diffusion(struct gl_shader_cache *sc,
+                          const struct error_diffusion_kernel *k,
+                          int tex, int width, int height, int depth, int block_size)
+{
+    assert(block_size <= height);
+
+    // The parallel error diffusion works by applying the shift mapping first.
+    // Taking the Floyd and Steinberg algorithm for example. After applying
+    // the (y, x) -> (y, x + y * shift) mapping (with shift=2), all errors are
+    // propagated into the next few columns, which makes parallel processing on
+    // the same column possible.
+    //
+    //           X    7/16                X    7/16
+    //    3/16  5/16  1/16   ==>    0     0    3/16  5/16  1/16
+
+    // Figuring out the size of rectangle containing all shifted pixels.
+    // The rectangle height is not changed.
+    int shifted_width = width + (height - 1) * k->shift;
+
+    // We process all pixels from the shifted rectangles column by column, with
+    // a single global work group of size |block_size|.
+    // Figuring out how many block are required to process all pixels. We need
+    // this explicitly to make the number of barrier() calls match.
+    int blocks = (height * shifted_width + block_size - 1) / block_size;
+
+    // If we figure out how many of the next columns will be affected while the
+    // current columns is being processed. We can store errors of only a few
+    // columns in the shared memory. Using a ring buffer will further save the
+    // cost while iterating to next column.
+    int ring_buffer_rows = height + EF_MAX_DELTA_Y;
+    int ring_buffer_columns = compute_rightmost_shifted_column(k) + 1;
+    int ring_buffer_size = ring_buffer_rows * ring_buffer_columns;
+
+    // Defines the ring buffer in shared memory.
+    GLSLH("shared uint err_rgb8[%d];\n", ring_buffer_size);
+
+    // Initialize the ring buffer.
+    GLSL("for (int i = int(gl_LocalInvocationIndex); i < %d; i += %d) ",
+         ring_buffer_size, block_size);
+    GLSL("err_rgb8[i] = 0;\n");
+
+    GLSL("for (int block_id = 0; block_id < %d; ++block_id) {\n", blocks);
+
+    // Add barrier here to have previous block all processed before starting
+    // the processing of the next.
+    GLSL("groupMemoryBarrier();\n");
+    GLSL("barrier();\n");
+
+    // Compute the coordinate of the pixel we are currently processing, both
+    // before and after the shift mapping.
+    GLSL("int id = int(gl_LocalInvocationIndex) + block_id * %d;\n", block_size);
+    GLSL("int y = id %% %d, x_shifted = id / %d;\n", height, height);
+    GLSL("int x = x_shifted - y * %d;\n", k->shift);
+
+    // Proceed only if we are processing a valid pixel.
+    GLSL("if (0 <= x && x < %d) {\n", width);
+
+    // The index that the current pixel have on the ring buffer.
+    GLSL("int idx = (x_shifted * %d + y) %% %d;\n", ring_buffer_rows, ring_buffer_size);
+
+    // Fetch the current pixel.
+    GLSL("vec3 pix = texelFetch(texture%d, ivec2(x, y), 0).rgb;\n", tex);
+
+    // The dithering will quantize pixel value into multiples of 1/dither_quant.
+    int dither_quant = (1 << depth) - 1;
+
+    // We encode errors in RGB components into a single 32-bit unsigned integer.
+    // The error we propagate from the current pixel is in range of
+    // [-0.5 / dither_quant, 0.5 / dither_quant]. While not quite obvious, the
+    // sum of all errors been propagated into a pixel is also in the same range.
+    // It's possible to map errors in this range into [-127, 127], and use an
+    // unsigned 8-bit integer to store it (using standard two's complement).
+    // The three 8-bit unsigned integers can then be encoded into a single
+    // 32-bit unsigned integer, with two 4-bit padding to prevent addition
+    // operation overflows affecting other component. There are at most 12
+    // addition operations on each pixel, so 4-bit padding should be enough.
+    // The overflow from R component will be discarded.
+    //
+    // The following figure is how the encoding looks like.
+    //
+    //     +------------------------------------+
+    //     |RRRRRRRR|0000|GGGGGGGG|0000|BBBBBBBB|
+    //     +------------------------------------+
+    //
+
+    // The bitshift position for R and G component.
+    int bitshift_r = 24, bitshift_g = 12;
+    // The multiplier we use to map [-0.5, 0.5] to [-127, 127].
+    int uint8_mul = 127 * 2;
+
+    // Adding the error previously propagated into current pixel, and clear it
+    // in the buffer.
+    GLSL("uint err_u32 = err_rgb8[idx] + %uu;\n",
+         (128u << bitshift_r) | (128u << bitshift_g) | 128u);
+    GLSL("pix = pix * %d.0 + vec3("
+         "int((err_u32 >> %d) & 255u) - 128,"
+         "int((err_u32 >> %d) & 255u) - 128,"
+         "int( err_u32        & 255u) - 128"
+         ") / %d.0;\n", dither_quant, bitshift_r, bitshift_g, uint8_mul);
+    GLSL("err_rgb8[idx] = 0;\n");
+
+    // Write the dithered pixel.
+    GLSL("vec3 dithered = round(pix);\n");
+    GLSL("imageStore(out_image, ivec2(x, y), vec4(dithered / %d.0, 0.0));\n",
+         dither_quant);
+
+    GLSL("vec3 err_divided = (pix - dithered) * %d.0 / %d.0;\n",
+         uint8_mul, k->divisor);
+    GLSL("ivec3 tmp;\n");
+
+    // Group error propagation with same weight factor together, in order to
+    // reduce the number of annoying error encoding.
+    for (int dividend = 1; dividend <= k->divisor; dividend++) {
+        bool err_assigned = false;
+
+        for (int y = 0; y <= EF_MAX_DELTA_Y; y++) {
+            for (int x = EF_MIN_DELTA_X; x <= EF_MAX_DELTA_X; x++) {
+                if (k->pattern[y][x - EF_MIN_DELTA_X] != dividend)
+                    continue;
+
+                if (!err_assigned) {
+                    err_assigned = true;
+
+                    GLSL("tmp = ivec3(round(err_divided * %d.0));\n", dividend);
+
+                    GLSL("err_u32 = "
+                         "(uint(tmp.r & 255) << %d)|"
+                         "(uint(tmp.g & 255) << %d)|"
+                         " uint(tmp.b & 255);\n",
+                         bitshift_r, bitshift_g);
+                }
+
+                int shifted_x = x + y * k->shift;
+
+                // Unlike the right border, errors propagated out from left
+                // border will remain in the ring buffer. This will produce
+                // visible artifacts near the left border, especially for
+                // shift=3 kernels.
+                if (x < 0)
+                    GLSL("if (x >= %d) ", -x);
+
+                // Calculate the new position in the ring buffer to propagate
+                // the error into.
+                int ring_buffer_delta = shifted_x * ring_buffer_rows + y;
+                GLSL("atomicAdd(err_rgb8[(idx + %d) %% %d], err_u32);\n",
+                     ring_buffer_delta, ring_buffer_size);
+            }
+        }
+    }
+
+    GLSL("}\n"); // if (0 <= x && x < width)
+
+    GLSL("}\n"); // block_id
+}
+
+// Different kernels for error diffusion.
+// Patterns are from http://www.efg2.com/Lab/Library/ImageProcessing/DHALF.TXT
+const struct error_diffusion_kernel mp_error_diffusion_kernels[] = {
+    {
+        .name = "simple",
+        .shift = 1,
+        .pattern = {{0, 0, 0, 1, 0},
+                    {0, 0, 1, 0, 0},
+                    {0, 0, 0, 0, 0}},
+        .divisor = 2
+    },
+    {
+        // The "false" Floyd-Steinberg kernel
+        .name = "false-fs",
+        .shift = 1,
+        .pattern = {{0, 0, 0, 3, 0},
+                    {0, 0, 3, 2, 0},
+                    {0, 0, 0, 0, 0}},
+        .divisor = 8
+    },
+    {
+        .name = "sierra-lite",
+        .shift = 2,
+        .pattern = {{0, 0, 0, 2, 0},
+                    {0, 1, 1, 0, 0},
+                    {0, 0, 0, 0, 0}},
+        .divisor = 4
+    },
+    {
+        .name = "floyd-steinberg",
+        .shift = 2,
+        .pattern = {{0, 0, 0, 7, 0},
+                    {0, 3, 5, 1, 0},
+                    {0, 0, 0, 0, 0}},
+        .divisor = 16
+    },
+    {
+        .name = "atkinson",
+        .shift = 2,
+        .pattern = {{0, 0, 0, 1, 1},
+                    {0, 1, 1, 1, 0},
+                    {0, 0, 1, 0, 0}},
+        .divisor = 8
+    },
+    // All kernels below have shift value of 3, and probably are too heavy for
+    // low end GPU.
+    {
+        .name = "jarvis-judice-ninke",
+        .shift = 3,
+        .pattern = {{0, 0, 0, 7, 5},
+                    {3, 5, 7, 5, 3},
+                    {1, 3, 5, 3, 1}},
+        .divisor = 48
+    },
+    {
+        .name = "stucki",
+        .shift = 3,
+        .pattern = {{0, 0, 0, 8, 4},
+                    {2, 4, 8, 4, 2},
+                    {1, 2, 4, 2, 1}},
+        .divisor = 42
+    },
+    {
+        .name = "burkes",
+        .shift = 3,
+        .pattern = {{0, 0, 0, 8, 4},
+                    {2, 4, 8, 4, 2},
+                    {0, 0, 0, 0, 0}},
+        .divisor = 32
+    },
+    {
+        .name = "sierra-3",
+        .shift = 3,
+        .pattern = {{0, 0, 0, 5, 3},
+                    {2, 4, 5, 4, 2},
+                    {0, 2, 3, 2, 0}},
+        .divisor = 32
+    },
+    {
+        .name = "sierra-2",
+        .shift = 3,
+        .pattern = {{0, 0, 0, 4, 3},
+                    {1, 2, 3, 2, 1},
+                    {0, 0, 0, 0, 0}},
+        .divisor = 16
+    },
+    {0}
+};
diff -ruN mpv-0.29.1/video/out/gpu/error_diffusion.h mpv-master/video/out/gpu/error_diffusion.h
--- mpv-0.29.1/video/out/gpu/error_diffusion.h	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/gpu/error_diffusion.h	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,48 @@
+/*
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MP_GL_ERROR_DIFFUSION
+#define MP_GL_ERROR_DIFFUSION
+
+#include "shader_cache.h"
+
+// defines the border of all error diffusion kernels
+#define EF_MIN_DELTA_X (-2)
+#define EF_MAX_DELTA_X  (2)
+#define EF_MAX_DELTA_Y  (2)
+
+struct error_diffusion_kernel {
+    const char *name;
+
+    // The minimum value such that a (y, x) -> (y, x + y * shift) mapping will
+    // make all error pushing operations affect next column (and after it) only.
+    int shift;
+
+    // The diffusion factor for (y, x) is pattern[y][x - EF_MIN_DELTA_X] / divisor.
+    int pattern[EF_MAX_DELTA_Y + 1][EF_MAX_DELTA_X - EF_MIN_DELTA_X + 1];
+    int divisor;
+};
+
+extern const struct error_diffusion_kernel mp_error_diffusion_kernels[];
+
+const struct error_diffusion_kernel *mp_find_error_diffusion_kernel(const char *name);
+int mp_ef_compute_shared_memory_size(const struct error_diffusion_kernel *k, int height);
+void pass_error_diffusion(struct gl_shader_cache *sc,
+                          const struct error_diffusion_kernel *k,
+                          int tex, int width, int height, int depth, int block_size);
+
+#endif /* MP_GL_ERROR_DIFFUSION */
diff -ruN mpv-0.29.1/video/out/gpu/hwdec.c mpv-master/video/out/gpu/hwdec.c
--- mpv-0.29.1/video/out/gpu/hwdec.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/hwdec.c	2019-09-19 04:02:03.000000000 +0700
@@ -42,7 +42,7 @@
 extern const struct ra_hwdec_driver ra_hwdec_drmprime_drm;
 
 const struct ra_hwdec_driver *const ra_hwdec_drivers[] = {
-#if HAVE_VAAPI_EGL
+#if HAVE_VAAPI_EGL || HAVE_VAAPI_VULKAN
     &ra_hwdec_vaegl,
 #endif
 #if HAVE_VIDEOTOOLBOX_GL || HAVE_IOS_GL
diff -ruN mpv-0.29.1/video/out/gpu/lcms.c mpv-master/video/out/gpu/lcms.c
--- mpv-0.29.1/video/out/gpu/lcms.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/lcms.c	2019-09-19 04:02:03.000000000 +0700
@@ -83,7 +83,7 @@
         OPT_FLAG("icc-profile-auto", profile_auto, 0),
         OPT_STRING("icc-cache-dir", cache_dir, M_OPT_FILE),
         OPT_INT("icc-intent", intent, 0),
-        OPT_INTRANGE("icc-contrast", contrast, 0, 0, 1000000),
+        OPT_CHOICE_OR_INT("icc-contrast", contrast, 0, 0, 1000000, ({"inf", -1})),
         OPT_STRING_VALIDATE("icc-3dlut-size", size_str, 0, validate_3dlut_size_opt),
 
         OPT_REPLACED("3dlut-size", "icc-3dlut-size"),
diff -ruN mpv-0.29.1/video/out/gpu/libmpv_gpu.c mpv-master/video/out/gpu/libmpv_gpu.c
--- mpv-0.29.1/video/out/gpu/libmpv_gpu.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/libmpv_gpu.c	2019-09-19 04:02:03.000000000 +0700
@@ -32,13 +32,13 @@
         .name = "wl",
         .size = 0,
     },
-    [MPV_RENDER_PARAM_DRM_DISPLAY] = {
-        .name = "drm_params",
-        .size = sizeof (mpv_opengl_drm_params),
+    [MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE] = {
+        .name = "drm_draw_surface_size",
+        .size = sizeof (mpv_opengl_drm_draw_surface_size),
     },
-    [MPV_RENDER_PARAM_DRM_OSD_SIZE] = {
-        .name = "drm_osd_size",
-        .size = sizeof (mpv_opengl_drm_osd_size),
+    [MPV_RENDER_PARAM_DRM_DISPLAY_V2] = {
+        .name = "drm_params_v2",
+        .size = sizeof (mpv_opengl_drm_params_v2),
     },
 };
 
@@ -207,6 +207,14 @@
     gl_video_screenshot(p->renderer, frame, args);
 }
 
+static void perfdata(struct render_backend *ctx,
+                     struct voctrl_performance_data *out)
+{
+    struct priv *p = ctx->priv;
+
+    gl_video_perfdata(p->renderer, out);
+}
+
 static void destroy(struct render_backend *ctx)
 {
     struct priv *p = ctx->priv;
@@ -235,5 +243,6 @@
     .render = render,
     .get_image = get_image,
     .screenshot = screenshot,
+    .perfdata = perfdata,
     .destroy = destroy,
 };
diff -ruN mpv-0.29.1/video/out/gpu/osd.c mpv-master/video/out/gpu/osd.c
--- mpv-0.29.1/video/out/gpu/osd.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/osd.c	2019-09-19 04:02:03.000000000 +0700
@@ -212,7 +212,7 @@
     struct mpgl_osd_part *part = ctx->parts[index];
 
     enum sub_bitmap_format fmt = part->format;
-    if (!fmt || !part->num_subparts)
+    if (!fmt || !part->num_subparts || !part->texture)
         return false;
 
     gl_sc_uniform_texture(sc, "osdtex", part->texture);
diff -ruN mpv-0.29.1/video/out/gpu/ra.h mpv-master/video/out/gpu/ra.h
--- mpv-0.29.1/video/out/gpu/ra.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/ra.h	2019-09-19 04:02:03.000000000 +0700
@@ -107,6 +107,7 @@
                             // only applies to 2-component textures
     bool linear_filter;     // linear filtering available from shader
     bool renderable;        // can be used for render targets
+    bool storable;          // can be used for storage images
     bool dummy_format;      // is not a real ra_format but a fake one (e.g. FBO).
                             // dummy formats cannot be used to create textures
 
@@ -188,6 +189,7 @@
     RA_BUF_TYPE_SHADER_STORAGE, // shader buffer (SSBO), for RA_VARTYPE_BUF_RW
     RA_BUF_TYPE_UNIFORM,        // uniform buffer (UBO), for RA_VARTYPE_BUF_RO
     RA_BUF_TYPE_VERTEX,         // not publicly usable (RA-internal usage)
+    RA_BUF_TYPE_SHARED_MEMORY,  // device memory for sharing with external API
 };
 
 struct ra_buf_params {
@@ -444,7 +446,7 @@
     // Returns an abstract namespace index for a given renderpass input type.
     // This will always be a value >= 0 and < RA_VARTYPE_COUNT. This is used to
     // figure out which inputs may share the same value of `binding`.
-    int (*desc_namespace)(enum ra_vartype type);
+    int (*desc_namespace)(struct ra *ra, enum ra_vartype type);
 
     // Clear the dst with the given color (rgba) and within the given scissor.
     // dst must have dst->params.render_dst==true. Content outside of the
diff -ruN mpv-0.29.1/video/out/gpu/shader_cache.c mpv-master/video/out/gpu/shader_cache.c
--- mpv-0.29.1/video/out/gpu/shader_cache.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/shader_cache.c	2019-09-19 04:02:03.000000000 +0700
@@ -254,7 +254,7 @@
 
 static int gl_sc_next_binding(struct gl_shader_cache *sc, enum ra_vartype type)
 {
-    return sc->next_binding[sc->ra->fns->desc_namespace(type)]++;
+    return sc->next_binding[sc->ra->fns->desc_namespace(sc->ra, type)]++;
 }
 
 void gl_sc_uniform_dynamic(struct gl_shader_cache *sc)
@@ -666,8 +666,7 @@
             struct sc_uniform *u = &sc->uniforms[n];
             if (u->type != SC_UNIFORM_TYPE_PUSHC)
                 continue;
-            // push constants don't support explicit offsets
-            ADD(dst, "/*offset=%zu*/ %s %s;\n", u->offset, u->glsl_type,
+            ADD(dst, "layout(offset=%zu) %s %s;\n", u->offset, u->glsl_type,
                 u->input.name);
         }
         ADD(dst, "};\n");
diff -ruN mpv-0.29.1/video/out/gpu/spirv.c mpv-master/video/out/gpu/spirv.c
--- mpv-0.29.1/video/out/gpu/spirv.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/spirv.c	2019-09-19 04:02:03.000000000 +0700
@@ -5,22 +5,17 @@
 #include "config.h"
 
 extern const struct spirv_compiler_fns spirv_shaderc;
-extern const struct spirv_compiler_fns spirv_nvidia_builtin;
 
 // in probe-order
 enum {
     SPIRV_AUTO = 0,
     SPIRV_SHADERC, // generally preferred, but not packaged everywhere
-    SPIRV_NVIDIA,  // can be useful for testing, only available on nvidia
 };
 
 static const struct spirv_compiler_fns *compilers[] = {
 #if HAVE_SHADERC
     [SPIRV_SHADERC] = &spirv_shaderc,
 #endif
-#if HAVE_VULKAN
-    [SPIRV_NVIDIA]  = &spirv_nvidia_builtin,
-#endif
 };
 
 static const struct m_opt_choice_alternatives compiler_choices[] = {
@@ -28,9 +23,6 @@
 #if HAVE_SHADERC
     {"shaderc",     SPIRV_SHADERC},
 #endif
-#if HAVE_VULKAN
-    {"nvidia",      SPIRV_NVIDIA},
-#endif
     {0}
 };
 
@@ -65,7 +57,7 @@
         ctx->spirv->fns = compilers[i];
 
         const char *name = m_opt_choice_str(compiler_choices, i);
-        strncpy(ctx->spirv->name, name, sizeof(ctx->spirv->name));
+        strncpy(ctx->spirv->name, name, sizeof(ctx->spirv->name) - 1);
         MP_VERBOSE(ctx, "Initializing SPIR-V compiler '%s'\n", name);
         if (ctx->spirv->fns->init(ctx))
             return true;
diff -ruN mpv-0.29.1/video/out/gpu/spirv_shaderc.c mpv-master/video/out/gpu/spirv_shaderc.c
--- mpv-0.29.1/video/out/gpu/spirv_shaderc.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/spirv_shaderc.c	2019-09-19 04:02:03.000000000 +0700
@@ -32,7 +32,7 @@
         goto error;
 
     shaderc_compile_options_set_optimization_level(p->opts,
-                                            shaderc_optimization_level_size);
+                                    shaderc_optimization_level_performance);
     if (ctx->opts.debug)
         shaderc_compile_options_set_generate_debug_info(p->opts);
 
diff -ruN mpv-0.29.1/video/out/gpu/user_shaders.c mpv-master/video/out/gpu/user_shaders.c
--- mpv-0.29.1/video/out/gpu/user_shaders.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/user_shaders.c	2019-09-19 04:02:03.000000000 +0700
@@ -16,6 +16,7 @@
  */
 
 #include <assert.h>
+#include <math.h>
 
 #include "common/msg.h"
 #include "misc/ctype.h"
@@ -52,9 +53,11 @@
         case '-': exp->tag = SZEXP_OP2; exp->val.op = SZEXP_OP_SUB; continue;
         case '*': exp->tag = SZEXP_OP2; exp->val.op = SZEXP_OP_MUL; continue;
         case '/': exp->tag = SZEXP_OP2; exp->val.op = SZEXP_OP_DIV; continue;
+        case '%': exp->tag = SZEXP_OP2; exp->val.op = SZEXP_OP_MOD; continue;
         case '!': exp->tag = SZEXP_OP1; exp->val.op = SZEXP_OP_NOT; continue;
         case '>': exp->tag = SZEXP_OP2; exp->val.op = SZEXP_OP_GT;  continue;
         case '<': exp->tag = SZEXP_OP2; exp->val.op = SZEXP_OP_LT;  continue;
+        case '=': exp->tag = SZEXP_OP2; exp->val.op = SZEXP_OP_EQ;  continue;
         }
 
         if (mp_isdigit(word.start[0])) {
@@ -118,8 +121,10 @@
             case SZEXP_OP_SUB: res = op1 - op2; break;
             case SZEXP_OP_MUL: res = op1 * op2; break;
             case SZEXP_OP_DIV: res = op1 / op2; break;
+            case SZEXP_OP_MOD: res = fmodf(op1, op2); break;
             case SZEXP_OP_GT:  res = op1 > op2; break;
             case SZEXP_OP_LT:  res = op1 < op2; break;
+            case SZEXP_OP_EQ:  res = op1 == op2; break;
             default: abort();
             }
 
@@ -165,6 +170,7 @@
     *out = (struct gl_user_shader_hook){
         .pass_desc = bstr0("(unknown)"),
         .offset = identity_trans,
+        .align_offset = false,
         .width = {{ SZEXP_VAR_W, { .varname = bstr0("HOOKED") }}},
         .height = {{ SZEXP_VAR_H, { .varname = bstr0("HOOKED") }}},
         .cond = {{ SZEXP_CONST, { .cval = 1.0 }}},
@@ -216,13 +222,18 @@
         }
 
         if (bstr_eatstart0(&line, "OFFSET")) {
-            float ox, oy;
-            if (bstr_sscanf(line, "%f %f", &ox, &oy) != 2) {
-                mp_err(log, "Error while parsing OFFSET!\n");
-                return false;
+            line = bstr_strip(line);
+            if (bstr_equals0(line, "ALIGN")) {
+                out->align_offset = true;
+            } else {
+                float ox, oy;
+                if (bstr_sscanf(line, "%f %f", &ox, &oy) != 2) {
+                    mp_err(log, "Error while parsing OFFSET!\n");
+                    return false;
+                }
+                out->offset.t[0] = ox;
+                out->offset.t[1] = oy;
             }
-            out->offset.t[0] = ox;
-            out->offset.t[1] = oy;
             continue;
         }
 
diff -ruN mpv-0.29.1/video/out/gpu/user_shaders.h mpv-master/video/out/gpu/user_shaders.h
--- mpv-0.29.1/video/out/gpu/user_shaders.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/user_shaders.h	2019-09-19 04:02:03.000000000 +0700
@@ -30,9 +30,11 @@
     SZEXP_OP_SUB,
     SZEXP_OP_MUL,
     SZEXP_OP_DIV,
+    SZEXP_OP_MOD,
     SZEXP_OP_NOT,
     SZEXP_OP_GT,
     SZEXP_OP_LT,
+    SZEXP_OP_EQ,
 };
 
 enum szexp_tag {
@@ -67,6 +69,7 @@
     struct bstr save_tex;
     struct bstr pass_body;
     struct gl_transform offset;
+    bool align_offset;
     struct szexp width[MAX_SZEXP_SIZE];
     struct szexp height[MAX_SZEXP_SIZE];
     struct szexp cond[MAX_SZEXP_SIZE];
diff -ruN mpv-0.29.1/video/out/gpu/utils.c mpv-master/video/out/gpu/utils.c
--- mpv-0.29.1/video/out/gpu/utils.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/utils.c	2019-09-19 04:02:03.000000000 +0700
@@ -141,16 +141,17 @@
     // the nearest multiple of vec4
     // 4. Matrices are treated like arrays of vectors
     // 5. Arrays/matrices are laid out with a stride equal to the alignment
-    size_t size = el_size * inp->dim_v;
+    size_t stride = el_size * inp->dim_v;
+    size_t align = stride;
     if (inp->dim_v == 3)
-        size += el_size;
+        align += el_size;
     if (inp->dim_m > 1)
-        size = MP_ALIGN_UP(size, sizeof(float[4]));
+        stride = align = MP_ALIGN_UP(stride, sizeof(float[4]));
 
     return (struct ra_layout) {
-        .align  = size,
-        .stride = size,
-        .size   = size * inp->dim_m,
+        .align  = align,
+        .stride = stride,
+        .size   = stride * inp->dim_m,
     };
 }
 
@@ -160,14 +161,15 @@
 
     // std430 packing rules: like std140, except arrays/matrices are always
     // "tightly" packed, even arrays/matrices of vec3s
-    size_t size = el_size * inp->dim_v;
+    size_t stride = el_size * inp->dim_v;
+    size_t align = stride;
     if (inp->dim_v == 3 && inp->dim_m == 1)
-        size += el_size;
+        align += el_size;
 
     return (struct ra_layout) {
-        .align  = size,
-        .stride = size,
-        .size   = size * inp->dim_m,
+        .align  = align,
+        .stride = stride,
+        .size   = stride * inp->dim_m,
     };
 }
 
@@ -183,7 +185,7 @@
 
     mp_dbg(log, "Resizing texture: %dx%d\n", w, h);
 
-    if (!fmt || !fmt->renderable || !fmt->linear_filter) {
+    if (!fmt || !fmt->renderable || !fmt->linear_filter || !fmt->storable) {
         mp_err(log, "Format %s not supported.\n", fmt ? fmt->name : "(unset)");
         return false;
     }
diff -ruN mpv-0.29.1/video/out/gpu/video.c mpv-master/video/out/gpu/video.c
--- mpv-0.29.1/video/out/gpu/video.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/video.c	2019-09-19 04:02:03.000000000 +0700
@@ -16,11 +16,11 @@
  */
 
 #include <assert.h>
+#include <float.h>
 #include <math.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <string.h>
-#include <assert.h>
 
 #include <libavutil/common.h>
 #include <libavutil/lfg.h>
@@ -38,6 +38,7 @@
 #include "stream/stream.h"
 #include "video_shaders.h"
 #include "user_shaders.h"
+#include "error_diffusion.h"
 #include "video/out/filter_kernels.h"
 #include "video/out/aspect.h"
 #include "video/out/dither.h"
@@ -121,6 +122,7 @@
     const char *hook_tex[SHADER_MAX_HOOKS];
     const char *bind_tex[SHADER_MAX_BINDS];
     int components; // how many components are relevant (0 = same as input)
+    bool align_offset; // whether to align hooked tex with reference.
     void *priv; // this gets talloc_freed when the tex_hook is removed
     void (*hook)(struct gl_video *p, struct image img, // generates GLSL
                  struct gl_transform *trans, void *priv);
@@ -210,6 +212,7 @@
     struct ra_tex *integer_tex[4];
     struct ra_tex *indirect_tex;
     struct ra_tex *blend_subs_tex;
+    struct ra_tex *error_diffusion_tex[2];
     struct ra_tex *screen_tex;
     struct ra_tex *output_tex;
     struct ra_tex *vdpau_deinterleave_tex[2];
@@ -294,6 +297,7 @@
     .dither_depth = -1,
     .dither_size = 6,
     .temporal_dither_period = 1,
+    .error_diffusion = "sierra-lite",
     .fbo_format = "auto",
     .sigmoid_center = 0.75,
     .sigmoid_slope = 6.5,
@@ -313,9 +317,16 @@
     .alpha_mode = ALPHA_BLEND_TILES,
     .background = {0, 0, 0, 255},
     .gamma = 1.0f,
-    .tone_mapping = TONE_MAPPING_HABLE,
-    .tone_mapping_param = NAN,
-    .tone_mapping_desat = 0.5,
+    .tone_map = {
+        .curve = TONE_MAPPING_HABLE,
+        .curve_param = NAN,
+        .max_boost = 1.0,
+        .decay_rate = 100.0,
+        .scene_threshold_low = 5.5,
+        .scene_threshold_high = 10.0,
+        .desat = 0.75,
+        .desat_exp = 1.5,
+    },
     .early_flush = -1,
     .hwdec_interop = "auto",
 };
@@ -326,6 +337,9 @@
 static int validate_window_opt(struct mp_log *log, const m_option_t *opt,
                                struct bstr name, struct bstr param);
 
+static int validate_error_diffusion_opt(struct mp_log *log, const m_option_t *opt,
+                                        struct bstr name, struct bstr param);
+
 #define OPT_BASE_STRUCT struct gl_video_opts
 
 #define SCALER_OPTS(n, i) \
@@ -351,21 +365,30 @@
         OPT_FLAG("gamma-auto", gamma_auto, 0),
         OPT_CHOICE_C("target-prim", target_prim, 0, mp_csp_prim_names),
         OPT_CHOICE_C("target-trc", target_trc, 0, mp_csp_trc_names),
-        OPT_INTRANGE("target-peak", target_peak, 0, 10, 10000),
-        OPT_CHOICE("tone-mapping", tone_mapping, 0,
+        OPT_CHOICE_OR_INT("target-peak", target_peak, 0, 10, 10000,
+                          ({"auto", 0})),
+        OPT_CHOICE("tone-mapping", tone_map.curve, 0,
                    ({"clip",     TONE_MAPPING_CLIP},
                     {"mobius",   TONE_MAPPING_MOBIUS},
                     {"reinhard", TONE_MAPPING_REINHARD},
                     {"hable",    TONE_MAPPING_HABLE},
                     {"gamma",    TONE_MAPPING_GAMMA},
                     {"linear",   TONE_MAPPING_LINEAR})),
-        OPT_CHOICE("hdr-compute-peak", compute_hdr_peak, 0,
+        OPT_CHOICE("hdr-compute-peak", tone_map.compute_peak, 0,
                    ({"auto", 0},
                     {"yes", 1},
                     {"no", -1})),
-        OPT_FLOAT("tone-mapping-param", tone_mapping_param, 0),
-        OPT_FLOAT("tone-mapping-desaturate", tone_mapping_desat, 0),
-        OPT_FLAG("gamut-warning", gamut_warning, 0),
+        OPT_FLOATRANGE("hdr-peak-decay-rate", tone_map.decay_rate, 0, 1.0, 1000.0),
+        OPT_FLOATRANGE("hdr-scene-threshold-low",
+                       tone_map.scene_threshold_low, 0, 0, 20.0),
+        OPT_FLOATRANGE("hdr-scene-threshold-high",
+                       tone_map.scene_threshold_high, 0, 0, 20.0),
+        OPT_FLOAT("tone-mapping-param", tone_map.curve_param, 0),
+        OPT_FLOATRANGE("tone-mapping-max-boost", tone_map.max_boost, 0, 1.0, 10.0),
+        OPT_FLOAT("tone-mapping-desaturate", tone_map.desat, 0),
+        OPT_FLOATRANGE("tone-mapping-desaturate-exponent",
+                       tone_map.desat_exp, 0, 0.0, 20.0),
+        OPT_FLAG("gamut-warning", tone_map.gamut_warning, 0),
         OPT_FLAG("opengl-pbo", pbo, 0),
         SCALER_OPTS("scale",  SCALER_SCALE),
         SCALER_OPTS("dscale", SCALER_DSCALE),
@@ -373,8 +396,9 @@
         SCALER_OPTS("tscale", SCALER_TSCALE),
         OPT_INTRANGE("scaler-lut-size", scaler_lut_size, 0, 4, 10),
         OPT_FLAG("scaler-resizes-only", scaler_resizes_only, 0),
-        OPT_FLAG("linear-scaling", linear_scaling, 0),
         OPT_FLAG("correct-downscaling", correct_downscaling, 0),
+        OPT_FLAG("linear-downscaling", linear_downscaling, 0),
+        OPT_FLAG("linear-upscaling", linear_upscaling, 0),
         OPT_FLAG("sigmoid-upscaling", sigmoid_upscaling, 0),
         OPT_FLOATRANGE("sigmoid-center", sigmoid_center, 0, 0.0, 1.0),
         OPT_FLOATRANGE("sigmoid-slope", sigmoid_slope, 0, 1.0, 20.0),
@@ -384,10 +408,13 @@
         OPT_CHOICE("dither", dither_algo, 0,
                    ({"fruit", DITHER_FRUIT},
                     {"ordered", DITHER_ORDERED},
+                    {"error-diffusion", DITHER_ERROR_DIFFUSION},
                     {"no", DITHER_NONE})),
         OPT_INTRANGE("dither-size-fruit", dither_size, 0, 2, 8),
         OPT_FLAG("temporal-dither", temporal_dither, 0),
         OPT_INTRANGE("temporal-dither-period", temporal_dither_period, 0, 1, 128),
+        OPT_STRING_VALIDATE("error-diffusion", error_diffusion, 0,
+                            validate_error_diffusion_opt),
         OPT_CHOICE("alpha", alpha_mode, 0,
                    ({"no", ALPHA_NO},
                     {"yes", ALPHA_YES},
@@ -423,6 +450,8 @@
         OPT_REPLACED("opengl-fbo-format", "fbo-format"),
         OPT_REPLACED("opengl-dumb-mode", "gpu-dumb-mode"),
         OPT_REPLACED("opengl-gamma", "gamma-factor"),
+        OPT_REMOVED("linear-scaling", "Split into --linear-upscaling and "
+                    "--linear-downscaling"),
         {0}
     },
     .size = sizeof(struct gl_video_opts),
@@ -453,7 +482,7 @@
             return p->files[n].body;
     }
     // not found -> load it
-    struct bstr s = stream_read_file(path, p, p->global, 1024000); // 1024 kB
+    struct bstr s = stream_read_file(path, p, p->global, 1000000000); // 1GB
     if (s.len) {
         struct cached_file new = {
             .path = talloc_strdup(p, path),
@@ -527,6 +556,9 @@
     ra_tex_free(p->ra, &p->screen_tex);
     ra_tex_free(p->ra, &p->output_tex);
 
+    for (int n = 0; n < 2; n++)
+        ra_tex_free(p->ra, &p->error_diffusion_tex[n]);
+
     for (int n = 0; n < SURFACES_MAX; n++)
         ra_tex_free(p->ra, &p->surfaces[n].tex);
 
@@ -1327,6 +1359,7 @@
     GLSLHF("#define %s_pos texcoord%d\n", name, id);
     GLSLHF("#define %s_size texture_size%d\n", name, id);
     GLSLHF("#define %s_rot texture_rot%d\n", name, id);
+    GLSLHF("#define %s_off texture_off%d\n", name, id);
     GLSLHF("#define %s_pt pixel_size%d\n", name, id);
     GLSLHF("#define %s_map texmap%d\n", name, id);
     GLSLHF("#define %s_mul %f\n", name, img.multiplier);
@@ -1463,6 +1496,25 @@
             continue;
         }
 
+        const char *store_name = hook->save_tex ? hook->save_tex : name;
+        bool is_overwrite = strcmp(store_name, name) == 0;
+
+        // If user shader is set to align HOOKED with reference and fix its
+        // offset, it requires HOOKED to be resizable and overwrited.
+        if (is_overwrite && hook->align_offset) {
+            if (!trans) {
+                MP_ERR(p, "Hook tried to align unresizable texture %s!\n",
+                       name);
+                return img;
+            }
+
+            struct gl_transform align_off = identity_trans;
+            align_off.t[0] = trans->t[0];
+            align_off.t[1] = trans->t[1];
+
+            gl_transform_trans(align_off, &img.transform);
+        }
+
         if (!pass_hook_setup_binds(p, name, img, hook))
             continue;
 
@@ -1482,13 +1534,12 @@
 
         struct ra_tex **tex = next_hook_tex(p);
         finish_pass_tex(p, tex, w, h);
-        const char *store_name = hook->save_tex ? hook->save_tex : name;
         struct image saved_img = image_wrap(*tex, img.type, comps);
 
         // If the texture we're saving overwrites the "current" texture, also
         // update the tex parameter so that the future loop cycles will use the
         // updated values, and export the offset
-        if (strcmp(store_name, name) == 0) {
+        if (is_overwrite) {
             if (!trans && !gl_transform_eq(hook_off, identity_trans)) {
                 MP_ERR(p, "Hook tried changing size of unscalable texture %s!\n",
                        name);
@@ -1496,8 +1547,17 @@
             }
 
             img = saved_img;
-            if (trans)
+            if (trans) {
                 gl_transform_trans(hook_off, trans);
+
+                // If user shader is set to align HOOKED, the offset it produces
+                // is dynamic (with static resizing factor though).
+                // Align it with reference manually to get offset fixed.
+                if (hook->align_offset) {
+                    trans->t[0] = 0.0;
+                    trans->t[1] = 0.0;
+                }
+            }
         }
 
         saved_img_store(p, store_name, saved_img);
@@ -1936,6 +1996,7 @@
     struct tex_hook texhook = {
         .save_tex = bstrdup0(copy, hook.save_tex),
         .components = hook.components,
+        .align_offset = hook.align_offset,
         .hook = user_hook,
         .cond = user_hook_cond,
         .priv = copy,
@@ -2053,6 +2114,23 @@
         }
     }
 
+    // The basic idea is we assume the rgb/luma texture is the "reference" and
+    // scale everything else to match, after all planes are finalized.
+    // We find the reference texture first, in order to maintain texture offset
+    // between hooks on different type of planes.
+    int reference_tex_num = 0;
+    for (int n = 0; n < 4; n++) {
+        switch (img[n].type) {
+        case PLANE_RGB:
+        case PLANE_XYZ:
+        case PLANE_LUMA: break;
+        default: continue;
+        }
+
+        reference_tex_num = n;
+        break;
+    }
+
     // Dispatch the hooks for all of these textures, saving and perhaps
     // modifying them in the process
     for (int n = 0; n < 4; n++) {
@@ -2067,26 +2145,18 @@
         }
 
         img[n] = pass_hook(p, name, img[n], &offsets[n]);
+
+        if (reference_tex_num == n) {
+            // The reference texture is finalized now.
+            p->texture_w = img[n].w;
+            p->texture_h = img[n].h;
+            p->texture_offset = offsets[n];
+        }
     }
 
     // At this point all planes are finalized but they may not be at the
     // required size yet. Furthermore, they may have texture offsets that
-    // require realignment. For lack of something better to do, we assume
-    // the rgb/luma texture is the "reference" and scale everything else
-    // to match.
-    for (int n = 0; n < 4; n++) {
-        switch (img[n].type) {
-        case PLANE_RGB:
-        case PLANE_XYZ:
-        case PLANE_LUMA: break;
-        default: continue;
-        }
-
-        p->texture_w = img[n].w;
-        p->texture_h = img[n].h;
-        p->texture_offset = offsets[n];
-        break;
-    }
+    // require realignment.
 
     // Compute the reference rect
     struct mp_rect_f src = {0.0, 0.0, p->image_params.w, p->image_params.h};
@@ -2300,8 +2370,11 @@
     xy[0] /= p->texture_offset.m[0][0];
     xy[1] /= p->texture_offset.m[1][1];
 
-    bool downscaling = xy[0] < 1.0 || xy[1] < 1.0;
-    bool upscaling = !downscaling && (xy[0] > 1.0 || xy[1] > 1.0);
+    // The calculation of scale factor involves 32-bit float(from gl_transform),
+    // use non-strict equality test to tolerate precision loss.
+    bool downscaling = xy[0] < 1.0 - FLT_EPSILON || xy[1] < 1.0 - FLT_EPSILON;
+    bool upscaling = !downscaling && (xy[0] > 1.0 + FLT_EPSILON ||
+                                      xy[1] > 1.0 + FLT_EPSILON);
     double scale_factor = 1.0;
 
     struct scaler *scaler = &p->scaler[SCALER_SCALE];
@@ -2332,13 +2405,18 @@
 
     // Pre-conversion, like linear light/sigmoidization
     GLSLF("// scaler pre-conversion\n");
-    bool use_linear = p->opts.linear_scaling || p->opts.sigmoid_upscaling;
-
-    // Linear light downscaling results in nasty artifacts for HDR curves due
-    // to the potentially extreme brightness differences severely compounding
-    // any ringing. So just scale in gamma light instead.
-    if (mp_trc_is_hdr(p->image_params.color.gamma) && downscaling)
-        use_linear = false;
+    bool use_linear = false;
+    if (downscaling) {
+        use_linear = p->opts.linear_downscaling;
+
+        // Linear light downscaling results in nasty artifacts for HDR curves
+        // due to the potentially extreme brightness differences severely
+        // compounding any ringing. So just scale in gamma light instead.
+        if (mp_trc_is_hdr(p->image_params.color.gamma))
+            use_linear = false;
+    } else if (upscaling) {
+        use_linear = p->opts.linear_upscaling || p->opts.sigmoid_upscaling;
+    }
 
     if (use_linear) {
         p->use_linear = true;
@@ -2357,6 +2435,7 @@
         // values at 1 and 0, and then scale/shift them, respectively.
         sig_offset = 1.0/(1+expf(sig_slope * sig_center));
         sig_scale  = 1.0/(1+expf(sig_slope * (sig_center-1))) - sig_offset;
+        GLSL(color.rgb = clamp(color.rgb, 0.0, 1.0);)
         GLSLF("color.rgb = %f - log(1.0/(color.rgb * %f + %f) - 1.0) * 1.0/%f;\n",
                 sig_center, sig_scale, sig_offset, sig_slope);
         pass_opt_hook_point(p, "SIGMOID", NULL);
@@ -2384,6 +2463,7 @@
     GLSLF("// scaler post-conversion\n");
     if (use_sigmoid) {
         // Inverse of the transformation above
+        GLSL(color.rgb = clamp(color.rgb, 0.0, 1.0);)
         GLSLF("color.rgb = (1.0/(1.0 + exp(%f * (%f - color.rgb))) - %f) * 1.0/%f;\n",
                 sig_slope, sig_center, sig_offset, sig_scale);
     }
@@ -2459,20 +2539,23 @@
     }
 
     // If there's no specific signal peak known for the output display, infer
-    // it from the chosen transfer function
+    // it from the chosen transfer function. Also normalize the src peak, in
+    // case it was unknown
     if (!dst.sig_peak)
         dst.sig_peak = mp_trc_nom_peak(dst.gamma);
+    if (!src.sig_peak)
+        src.sig_peak = mp_trc_nom_peak(src.gamma);
+
+    struct gl_tone_map_opts tone_map = p->opts.tone_map;
+    bool detect_peak = tone_map.compute_peak >= 0 && mp_trc_is_hdr(src.gamma)
+                       && src.sig_peak > dst.sig_peak;
 
-    bool detect_peak = p->opts.compute_hdr_peak >= 0 && mp_trc_is_hdr(src.gamma);
     if (detect_peak && !p->hdr_peak_ssbo) {
         struct {
+            float average[2];
+            int32_t frame_sum;
+            uint32_t frame_max;
             uint32_t counter;
-            uint32_t frame_idx;
-            uint32_t frame_num;
-            uint32_t frame_max[PEAK_DETECT_FRAMES+1];
-            uint32_t frame_sum[PEAK_DETECT_FRAMES+1];
-            uint32_t total_max;
-            uint32_t total_sum;
         } peak_ssbo = {0};
 
         struct ra_buf_params params = {
@@ -2484,8 +2567,8 @@
         p->hdr_peak_ssbo = ra_buf_create(ra, &params);
         if (!p->hdr_peak_ssbo) {
             MP_WARN(p, "Failed to create HDR peak detection SSBO, disabling.\n");
+            tone_map.compute_peak = p->opts.tone_map.compute_peak = -1;
             detect_peak = false;
-            p->opts.compute_hdr_peak = -1;
         }
     }
 
@@ -2493,22 +2576,15 @@
         pass_describe(p, "detect HDR peak");
         pass_is_compute(p, 8, 8, true); // 8x8 is good for performance
         gl_sc_ssbo(p->sc, "PeakDetect", p->hdr_peak_ssbo,
+            "vec2 average;"
+            "int frame_sum;"
+            "uint frame_max;"
             "uint counter;"
-            "uint frame_idx;"
-            "uint frame_num;"
-            "uint frame_max[%d];"
-            "uint frame_avg[%d];"
-            "uint total_max;"
-            "uint total_avg;",
-            PEAK_DETECT_FRAMES + 1,
-            PEAK_DETECT_FRAMES + 1
         );
     }
 
     // Adapt from src to dst as necessary
-    pass_color_map(p->sc, src, dst, p->opts.tone_mapping,
-                   p->opts.tone_mapping_param, p->opts.tone_mapping_desat,
-                   detect_peak, p->opts.gamut_warning, p->use_linear && !osd);
+    pass_color_map(p->sc, p->use_linear && !osd, src, dst, &tone_map);
 
     if (p->use_lut_3d) {
         gl_sc_uniform_texture(p->sc, "lut_3d", p->lut_3d_texture);
@@ -2534,6 +2610,51 @@
     if (p->opts.dither_depth < 0 || p->opts.dither_algo == DITHER_NONE)
         return;
 
+    if (p->opts.dither_algo == DITHER_ERROR_DIFFUSION) {
+        const struct error_diffusion_kernel *kernel =
+            mp_find_error_diffusion_kernel(p->opts.error_diffusion);
+        int o_w = p->dst_rect.x1 - p->dst_rect.x0,
+            o_h = p->dst_rect.y1 - p->dst_rect.y0;
+
+        int shmem_req = mp_ef_compute_shared_memory_size(kernel, o_h);
+        if (shmem_req > p->ra->max_shmem) {
+            MP_WARN(p, "Fallback to dither=fruit because there is no enough "
+                       "shared memory (%d/%d).\n",
+                       shmem_req, (int)p->ra->max_shmem);
+            p->opts.dither_algo = DITHER_FRUIT;
+        } else {
+            finish_pass_tex(p, &p->error_diffusion_tex[0], o_w, o_h);
+
+            struct image img = image_wrap(p->error_diffusion_tex[0], PLANE_RGB, p->components);
+
+            // 1024 is minimal required number of invocation allowed in single
+            // work group in OpenGL. Use it for maximal performance.
+            int block_size = MPMIN(1024, o_h);
+
+            pass_describe(p, "dither=error-diffusion (kernel=%s, depth=%d)",
+                             kernel->name, dst_depth);
+
+            p->pass_compute = (struct compute_info) {
+                .active = true,
+                .threads_w = block_size,
+                .threads_h = 1,
+                .directly_writes = true
+            };
+
+            int tex_id = pass_bind(p, img);
+
+            pass_error_diffusion(p->sc, kernel, tex_id, o_w, o_h,
+                                 dst_depth, block_size);
+
+            finish_pass_tex(p, &p->error_diffusion_tex[1], o_w, o_h);
+
+            img = image_wrap(p->error_diffusion_tex[1], PLANE_RGB, p->components);
+            copy_image(p, &(int){0}, img);
+
+            return;
+        }
+    }
+
     if (!p->dither_texture) {
         MP_VERBOSE(p, "Dither to %d.\n", dst_depth);
 
@@ -3202,10 +3323,14 @@
         if (w < 1 || h < 1)
             return;
 
-        if (p->image_params.rotate % 180 == 90)
+        int src_w = p->image_params.w;
+        int src_h = p->image_params.h;
+        if (p->image_params.rotate % 180 == 90) {
             MPSWAP(int, w, h);
+            MPSWAP(int, src_w, src_h);
+        }
 
-        struct mp_rect src = {0, 0, p->image_params.w, p->image_params.h};
+        struct mp_rect src = {0, 0, src_w, src_h};
         struct mp_rect dst = {0, 0, w, h};
         struct mp_osd_res osd = {.w = w, .h = h, .display_par = 1.0};
         gl_video_resize(p, &src, &dst, &osd);
@@ -3494,8 +3619,8 @@
         return false;
 
     // otherwise, use auto-detection
-    if (o->target_prim || o->target_trc || o->linear_scaling ||
-        o->correct_downscaling || o->sigmoid_upscaling || o->interpolation ||
+    if (o->correct_downscaling || o->linear_downscaling ||
+        o->linear_upscaling || o->sigmoid_upscaling || o->interpolation ||
         o->blend_subs || o->deband || o->unsharp)
         return false;
     // check remaining scalers (tscale is already implicitly excluded above)
@@ -3508,8 +3633,6 @@
     }
     if (o->user_shaders && o->user_shaders[0])
         return false;
-    if (p->use_lut_3d)
-        return false;
     return true;
 }
 
@@ -3573,13 +3696,19 @@
                    "available! See your FBO format configuration!\n");
     }
 
+    if (!have_compute && p->opts.dither_algo == DITHER_ERROR_DIFFUSION) {
+        MP_WARN(p, "Disabling error diffusion dithering because compute shader "
+                   "was not supported. Fallback to dither=fruit instead.\n");
+        p->opts.dither_algo = DITHER_FRUIT;
+    }
+
     bool have_compute_peak = have_compute && have_ssbo;
-    if (!have_compute_peak && p->opts.compute_hdr_peak >= 0) {
-        int msgl = p->opts.compute_hdr_peak == 1 ? MSGL_WARN : MSGL_V;
+    if (!have_compute_peak && p->opts.tone_map.compute_peak >= 0) {
+        int msgl = p->opts.tone_map.compute_peak == 1 ? MSGL_WARN : MSGL_V;
         MP_MSG(p, msgl, "Disabling HDR peak computation (one or more of the "
                         "following is not supported: compute shaders=%d, "
                         "SSBO=%d).\n", have_compute, have_ssbo);
-        p->opts.compute_hdr_peak = -1;
+        p->opts.tone_map.compute_peak = -1;
     }
 
     p->forced_dumb_mode = p->opts.dumb_mode > 0 || !have_fbo || !have_texrg;
@@ -3601,20 +3730,21 @@
             .alpha_mode = p->opts.alpha_mode,
             .use_rectangle = p->opts.use_rectangle,
             .background = p->opts.background,
-            .compute_hdr_peak = p->opts.compute_hdr_peak,
             .dither_algo = p->opts.dither_algo,
             .dither_depth = p->opts.dither_depth,
             .dither_size = p->opts.dither_size,
+            .error_diffusion = p->opts.error_diffusion,
             .temporal_dither = p->opts.temporal_dither,
             .temporal_dither_period = p->opts.temporal_dither_period,
             .tex_pad_x = p->opts.tex_pad_x,
             .tex_pad_y = p->opts.tex_pad_y,
-            .tone_mapping = p->opts.tone_mapping,
-            .tone_mapping_param = p->opts.tone_mapping_param,
-            .tone_mapping_desat = p->opts.tone_mapping_desat,
+            .tone_map = p->opts.tone_map,
             .early_flush = p->opts.early_flush,
             .icc_opts = p->opts.icc_opts,
             .hwdec_interop = p->opts.hwdec_interop,
+            .target_trc = p->opts.target_trc,
+            .target_prim = p->opts.target_prim,
+            .target_peak = p->opts.target_peak,
         };
         for (int n = 0; n < SCALER_COUNT; n++)
             p->opts.scaler[n] = gl_video_opts_def.scaler[n];
@@ -3652,8 +3782,11 @@
                   p->opts.target_trc != MP_CSP_TRC_AUTO || p->use_lut_3d;
 
     // mix() is needed for some gamma functions
-    if (!have_mglsl && (p->opts.linear_scaling || p->opts.sigmoid_upscaling)) {
-        p->opts.linear_scaling = false;
+    if (!have_mglsl && (p->opts.linear_downscaling ||
+                        p->opts.linear_upscaling || p->opts.sigmoid_upscaling))
+    {
+        p->opts.linear_downscaling = false;
+        p->opts.linear_upscaling = false;
         p->opts.sigmoid_upscaling = false;
         MP_WARN(p, "Disabling linear/sigmoid scaling (GLSL version too old).\n");
     }
@@ -3860,7 +3993,9 @@
     gl_video_setup_hooks(p);
     reinit_osd(p);
 
-    if (p->opts.interpolation && !p->global->opts->video_sync && !p->dsi_warned) {
+    int vs;
+    mp_read_option_raw(p->global, "video-sync", &m_option_type_choice, &vs);
+    if (p->opts.interpolation && !vs && !p->dsi_warned) {
         MP_WARN(p, "Interpolation now requires enabling display-sync mode.\n"
                    "E.g.: --video-sync=display-resample\n");
         p->dsi_warned = true;
@@ -3947,6 +4082,29 @@
     return r;
 }
 
+static int validate_error_diffusion_opt(struct mp_log *log, const m_option_t *opt,
+                                        struct bstr name, struct bstr param)
+{
+    char s[20] = {0};
+    int r = 1;
+    if (bstr_equals0(param, "help")) {
+        r = M_OPT_EXIT;
+    } else {
+        snprintf(s, sizeof(s), "%.*s", BSTR_P(param));
+        const struct error_diffusion_kernel *k = mp_find_error_diffusion_kernel(s);
+        if (!k)
+            r = M_OPT_INVALID;
+    }
+    if (r < 1) {
+        mp_info(log, "Available error diffusion kernels:\n");
+        for (int n = 0; mp_error_diffusion_kernels[n].name; n++)
+            mp_info(log, "    %s\n", mp_error_diffusion_kernels[n].name);
+        if (s[0])
+            mp_fatal(log, "No error diffusion kernel named '%s' found!\n", s);
+    }
+    return r;
+}
+
 float gl_video_scale_ambient_lux(float lmin, float lmax,
                                  float rmin, float rmax, float lux)
 {
diff -ruN mpv-0.29.1/video/out/gpu/video.h mpv-master/video/out/gpu/video.h
--- mpv-0.29.1/video/out/gpu/video.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/video.h	2019-09-19 04:02:03.000000000 +0700
@@ -71,6 +71,7 @@
     DITHER_NONE = 0,
     DITHER_FRUIT,
     DITHER_ORDERED,
+    DITHER_ERROR_DIFFUSION,
 };
 
 enum alpha_mode {
@@ -95,8 +96,18 @@
     TONE_MAPPING_LINEAR,
 };
 
-// How many frames to average over for HDR peak detection
-#define PEAK_DETECT_FRAMES 63
+struct gl_tone_map_opts {
+    int curve;
+    float curve_param;
+    float max_boost;
+    int compute_peak;
+    float decay_rate;
+    float scene_threshold_low;
+    float scene_threshold_high;
+    float desat;
+    float desat_exp;
+    int gamut_warning; // bool
+};
 
 struct gl_video_opts {
     int dumb_mode;
@@ -107,13 +118,10 @@
     int target_prim;
     int target_trc;
     int target_peak;
-    int tone_mapping;
-    int compute_hdr_peak;
-    float tone_mapping_param;
-    float tone_mapping_desat;
-    int gamut_warning;
-    int linear_scaling;
+    struct gl_tone_map_opts tone_map;
     int correct_downscaling;
+    int linear_downscaling;
+    int linear_upscaling;
     int sigmoid_upscaling;
     float sigmoid_center;
     float sigmoid_slope;
@@ -124,6 +132,7 @@
     int dither_size;
     int temporal_dither;
     int temporal_dither_period;
+    char *error_diffusion;
     char *fbo_format;
     int alpha_mode;
     int use_rectangle;
diff -ruN mpv-0.29.1/video/out/gpu/video_shaders.c mpv-master/video/out/gpu/video_shaders.c
--- mpv-0.29.1/video/out/gpu/video_shaders.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/video_shaders.c	2019-09-19 04:02:03.000000000 +0700
@@ -380,7 +380,7 @@
         GLSLF("color.rgb = max(color.rgb - vec3(%f), vec3(0.0)) \n"
               "             / (vec3(%f) - vec3(%f) * color.rgb);\n",
               PQ_C1, PQ_C2, PQ_C3);
-        GLSLF("color.rgb = pow(color.rgb, vec3(1.0/%f));\n", PQ_M1);
+        GLSLF("color.rgb = pow(color.rgb, vec3(%f));\n", 1.0 / PQ_M1);
         // PQ's output range is 0-10000, but we need it to be relative to to
         // MP_REF_WHITE instead, so rescale
         GLSLF("color.rgb *= vec3(%f);\n", 10000 / MP_REF_WHITE);
@@ -567,123 +567,106 @@
 // under a typical presentation gamma of about 2.0.
 static const float sdr_avg = 0.25;
 
-// The threshold for which to consider an average luminance difference to be
-// a sign of a scene change.
-static const int scene_threshold = 0.2 * MP_REF_WHITE;
-
-static void hdr_update_peak(struct gl_shader_cache *sc)
+static void hdr_update_peak(struct gl_shader_cache *sc,
+                            const struct gl_tone_map_opts *opts)
 {
-    // For performance, we want to do as few atomic operations on global
-    // memory as possible, so use an atomic in shmem for the work group.
-    GLSLH(shared uint wg_sum;);
-    GLSL(wg_sum = 0;)
+    // Update the sig_peak/sig_avg from the old SSBO state
+    GLSL(if (average.y > 0.0) {)
+    GLSL(    sig_avg  = max(1e-3, average.x);)
+    GLSL(    sig_peak = max(1.00, average.y);)
+    GLSL(})
+
+    // Chosen to avoid overflowing on an 8K buffer
+    const float log_min = 1e-3, log_scale = 400.0, sig_scale = 10000.0;
 
-    // Have each thread update the work group sum with the local value
+    // For performance, and to avoid overflows, we tally up the sub-results per
+    // pixel using shared memory first
+    GLSLH(shared int wg_sum;)
+    GLSLH(shared uint wg_max;)
+    GLSL(wg_sum = 0; wg_max = 0;)
     GLSL(barrier();)
-    GLSLF("atomicAdd(wg_sum, uint(sig * %f));\n", MP_REF_WHITE);
+    GLSLF("float sig_log = log(max(sig_max, %f));\n", log_min);
+    GLSLF("atomicAdd(wg_sum, int(sig_log * %f));\n", log_scale);
+    GLSLF("atomicMax(wg_max, uint(sig_max * %f));\n", sig_scale);
 
-    // Have one thread per work group update the global atomics. We use the
-    // work group average even for the global sum, to make the values slightly
-    // more stable and smooth out tiny super-highlights.
+    // Have one thread per work group update the global atomics
     GLSL(memoryBarrierShared();)
     GLSL(barrier();)
     GLSL(if (gl_LocalInvocationIndex == 0) {)
-    GLSL(    uint wg_avg = wg_sum / (gl_WorkGroupSize.x * gl_WorkGroupSize.y);)
-    GLSL(    atomicMax(frame_max[frame_idx], wg_avg);)
-    GLSL(    atomicAdd(frame_avg[frame_idx], wg_avg);)
+    GLSL(    int wg_avg = wg_sum / int(gl_WorkGroupSize.x * gl_WorkGroupSize.y);)
+    GLSL(    atomicAdd(frame_sum, wg_avg);)
+    GLSL(    atomicMax(frame_max, wg_max);)
+    GLSL(    memoryBarrierBuffer();)
     GLSL(})
-
-    const float refi = 1.0 / MP_REF_WHITE;
-
-    // Update the sig_peak/sig_avg from the old SSBO state
-    GLSL(uint num_wg = gl_NumWorkGroups.x * gl_NumWorkGroups.y;)
-    GLSL(if (frame_num > 0) {)
-    GLSLF("    float peak = %f * float(total_max) / float(frame_num);\n", refi);
-    GLSLF("    float avg = %f * float(total_avg) / float(frame_num);\n", refi);
-    GLSLF("    sig_peak = max(1.0, peak);\n");
-    GLSLF("    sig_avg  = max(%f, avg);\n", sdr_avg);
-    GLSL(});
+    GLSL(barrier();)
 
     // Finally, to update the global state, we increment a counter per dispatch
-    GLSL(memoryBarrierBuffer();)
-    GLSL(barrier();)
+    GLSL(uint num_wg = gl_NumWorkGroups.x * gl_NumWorkGroups.y;)
     GLSL(if (gl_LocalInvocationIndex == 0 && atomicAdd(counter, 1) == num_wg - 1) {)
-
-    // Since we sum up all the workgroups, we also still need to divide the
-    // average by the number of work groups
     GLSL(    counter = 0;)
-    GLSL(    frame_avg[frame_idx] /= num_wg;)
-    GLSL(    uint cur_max = frame_max[frame_idx];)
-    GLSL(    uint cur_avg = frame_avg[frame_idx];)
-
-    // Scene change detection
-    GLSL(    int diff = int(frame_num * cur_avg) - int(total_avg);)
-    GLSLF("  if (abs(diff) > frame_num * %d) {\n", scene_threshold);
-    GLSL(        frame_num = 0;)
-    GLSL(        total_max = total_avg = 0;)
-    GLSLF("      for (uint i = 0; i < %d; i++)\n", PEAK_DETECT_FRAMES+1);
-    GLSL(            frame_max[i] = frame_avg[i] = 0;)
-    GLSL(        frame_max[frame_idx] = cur_max;)
-    GLSL(        frame_avg[frame_idx] = cur_avg;)
-    GLSL(    })
-
-    // Add the current frame, then subtract and reset the next frame
-    GLSLF("  uint next = (frame_idx + 1) %% %d;\n", PEAK_DETECT_FRAMES+1);
-    GLSL(    total_max += cur_max - frame_max[next];)
-    GLSL(    total_avg += cur_avg - frame_avg[next];)
-    GLSL(    frame_max[next] = frame_avg[next] = 0;)
-
-    // Update the index and count
-    GLSL(    frame_idx = next;)
-    GLSLF("  frame_num = min(frame_num + 1, %d);\n", PEAK_DETECT_FRAMES);
+    GLSL(    vec2 cur = vec2(float(frame_sum) / float(num_wg), frame_max);)
+    GLSLF("  cur *= vec2(1.0/%f, 1.0/%f);\n", log_scale, sig_scale);
+    GLSL(    cur.x = exp(cur.x);)
+    GLSL(    if (average.y == 0.0))
+    GLSL(        average = cur;)
+
+    // Use an IIR low-pass filter to smooth out the detected values, with a
+    // configurable decay rate based on the desired time constant (tau)
+    float a = 1.0 - cos(1.0 / opts->decay_rate);
+    float decay = sqrt(a*a + 2*a) - a;
+    GLSLF("  average += %f * (cur - average);\n", decay);
+
+    // Scene change hysteresis
+    float log_db = 10.0 / log(10.0);
+    GLSLF("  float weight = smoothstep(%f, %f, abs(log(cur.x / average.x)));\n",
+          opts->scene_threshold_low / log_db,
+          opts->scene_threshold_high / log_db);
+    GLSL(    average = mix(average, cur, weight);)
+
+    // Reset SSBO state for the next frame
+    GLSL(    frame_sum = 0; frame_max = 0;)
     GLSL(    memoryBarrierBuffer();)
     GLSL(})
 }
 
 // Tone map from a known peak brightness to the range [0,1]. If ref_peak
 // is 0, we will use peak detection instead
-static void pass_tone_map(struct gl_shader_cache *sc, bool detect_peak,
+static void pass_tone_map(struct gl_shader_cache *sc,
                           float src_peak, float dst_peak,
-                          enum tone_mapping algo, float param, float desat)
+                          const struct gl_tone_map_opts *opts)
 {
     GLSLF("// HDR tone mapping\n");
 
     // To prevent discoloration due to out-of-bounds clipping, we need to make
     // sure to reduce the value range as far as necessary to keep the entire
     // signal in range, so tone map based on the brightest component.
-    GLSL(float sig = max(max(color.r, color.g), color.b);)
+    GLSL(int sig_idx = 0;)
+    GLSL(if (color[1] > color[sig_idx]) sig_idx = 1;)
+    GLSL(if (color[2] > color[sig_idx]) sig_idx = 2;)
+    GLSL(float sig_max = color[sig_idx];)
     GLSLF("float sig_peak = %f;\n", src_peak);
     GLSLF("float sig_avg = %f;\n", sdr_avg);
 
-    if (detect_peak)
-        hdr_update_peak(sc);
+    if (opts->compute_peak >= 0)
+        hdr_update_peak(sc, opts);
+
+    GLSLF("vec3 sig = color.rgb;\n");
 
     // Rescale the variables in order to bring it into a representation where
     // 1.0 represents the dst_peak. This is because all of the tone mapping
     // algorithms are defined in such a way that they map to the range [0.0, 1.0].
     if (dst_peak > 1.0) {
-        GLSLF("sig *= %f;\n", 1.0 / dst_peak);
-        GLSLF("sig_peak *= %f;\n", 1.0 / dst_peak);
+        GLSLF("sig *= 1.0/%f;\n", dst_peak);
+        GLSLF("sig_peak *= 1.0/%f;\n", dst_peak);
     }
 
-    GLSL(float sig_orig = sig;)
-    GLSLF("float slope = min(1.0, %f / sig_avg);\n", sdr_avg);
+    GLSL(float sig_orig = sig[sig_idx];)
+    GLSLF("float slope = min(%f, %f / sig_avg);\n", opts->max_boost, sdr_avg);
     GLSL(sig *= slope;)
     GLSL(sig_peak *= slope;)
 
-    // Desaturate the color using a coefficient dependent on the signal.
-    // Do this after peak detection in order to prevent over-desaturating
-    // overly bright souces
-    if (desat > 0) {
-        float base = 0.18 * dst_peak;
-        GLSL(float luma = dot(dst_luma, color.rgb);)
-        GLSLF("float coeff = max(sig - %f, 1e-6) / max(sig, 1e-6);\n", base);
-        GLSLF("coeff = pow(coeff, %f);\n", 10.0 / desat);
-        GLSL(color.rgb = mix(color.rgb, vec3(luma), coeff);)
-        GLSL(sig = mix(sig, luma * slope, coeff);) // also make sure to update `sig`
-    }
-
-    switch (algo) {
+    float param = opts->curve_param;
+    switch (opts->curve) {
     case TONE_MAPPING_CLIP:
         GLSLF("sig = %f * sig;\n", isnan(param) ? 1.0 : param);
         break;
@@ -697,14 +680,15 @@
         GLSLF("float b = (j*j - 2.0*j*sig_peak + sig_peak) / "
               "max(1e-6, sig_peak - 1.0);\n");
         GLSLF("float scale = (b*b + 2.0*b*j + j*j) / (b-a);\n");
-        GLSL(sig = sig > j ? scale * (sig + a) / (sig + b) : sig;)
+        GLSLF("sig = mix(sig, scale * (sig + vec3(a)) / (sig + vec3(b)),"
+              "          greaterThan(sig, vec3(j)));\n");
         GLSLF("}\n");
         break;
 
     case TONE_MAPPING_REINHARD: {
         float contrast = isnan(param) ? 0.5 : param,
               offset = (1.0 - contrast) / contrast;
-        GLSLF("sig = sig / (sig + %f);\n", offset);
+        GLSLF("sig = sig / (sig + vec3(%f));\n", offset);
         GLSLF("float scale = (sig_peak + %f) / sig_peak;\n", offset);
         GLSL(sig *= scale;)
         break;
@@ -712,19 +696,25 @@
 
     case TONE_MAPPING_HABLE: {
         float A = 0.15, B = 0.50, C = 0.10, D = 0.20, E = 0.02, F = 0.30;
-        GLSLHF("float hable(float x) {\n");
-        GLSLHF("return ((x * (%f*x + %f)+%f)/(x * (%f*x + %f) + %f)) - %f;\n",
-               A, C*B, D*E, A, B, D*F, E/F);
+        GLSLHF("vec3 hable(vec3 x) {\n");
+        GLSLHF("return (x * (%f*x + vec3(%f)) + vec3(%f)) / "
+               "       (x * (%f*x + vec3(%f)) + vec3(%f)) "
+               "       - vec3(%f);\n",
+               A, C*B, D*E,
+               A, B, D*F,
+               E/F);
         GLSLHF("}\n");
-        GLSL(sig = hable(sig) / hable(sig_peak);)
+        GLSLF("sig = hable(max(vec3(0.0), sig)) / hable(vec3(sig_peak)).x;\n");
         break;
     }
 
     case TONE_MAPPING_GAMMA: {
         float gamma = isnan(param) ? 1.8 : param;
-        GLSLF("const float cutoff = 0.05, gamma = %f;\n", 1.0/gamma);
-        GLSL(float scale = pow(cutoff / sig_peak, gamma) / cutoff;)
-        GLSL(sig = sig > cutoff ? pow(sig / sig_peak, gamma) : scale * sig;)
+        GLSLF("const float cutoff = 0.05, gamma = 1.0/%f;\n", gamma);
+        GLSL(float scale = pow(cutoff / sig_peak, gamma.x) / cutoff;)
+        GLSLF("sig = mix(scale * sig,"
+              "          pow(sig / sig_peak, vec3(gamma)),"
+              "          greaterThan(sig, vec3(cutoff)));\n");
         break;
     }
 
@@ -738,24 +728,32 @@
         abort();
     }
 
-    // Apply the computed scale factor to the color, linearly to prevent
-    // discoloration
-    GLSL(sig = min(sig, 1.0);)
-    GLSL(color.rgb *= vec3(sig / sig_orig);)
+    GLSL(sig = min(sig, vec3(1.0));)
+    GLSL(vec3 sig_lin = color.rgb * (sig[sig_idx] / sig_orig);)
+
+    // Mix between the per-channel tone mapped and the linear tone mapped
+    // signal based on the desaturation strength
+    if (opts->desat > 0) {
+        float base = 0.18 * dst_peak;
+        GLSLF("float coeff = max(sig[sig_idx] - %f, 1e-6) / "
+              "              max(sig[sig_idx], 1.0);\n", base);
+        GLSLF("coeff = %f * pow(coeff, %f);\n", opts->desat, opts->desat_exp);
+        GLSLF("color.rgb = mix(sig_lin, %f * sig, coeff);\n", dst_peak);
+    } else {
+        GLSL(color.rgb = sig_lin;)
+    }
 }
 
 // Map colors from one source space to another. These source spaces must be
 // known (i.e. not MP_CSP_*_AUTO), as this function won't perform any
 // auto-guessing. If is_linear is true, we assume the input has already been
-// linearized (e.g. for linear-scaling). If `detect_peak` is true, we will
-// detect the peak instead of relying on metadata. Note that this requires
-// the caller to have already bound the appropriate SSBO and set up the
-// compute shader metadata
-void pass_color_map(struct gl_shader_cache *sc,
+// linearized (e.g. for linear-scaling). If `opts->compute_peak` is true, we
+// will detect the peak instead of relying on metadata. Note that this requires
+// the caller to have already bound the appropriate SSBO and set up the compute
+// shader metadata
+void pass_color_map(struct gl_shader_cache *sc, bool is_linear,
                     struct mp_colorspace src, struct mp_colorspace dst,
-                    enum tone_mapping algo, float tone_mapping_param,
-                    float tone_mapping_desat, bool detect_peak,
-                    bool gamut_warning, bool is_linear)
+                    const struct gl_tone_map_opts *opts)
 {
     GLSLF("// color mapping\n");
 
@@ -776,7 +774,7 @@
     // operations needs it
     bool need_linear = src.gamma != dst.gamma ||
                        src.primaries != dst.primaries ||
-                       src.sig_peak > dst.sig_peak ||
+                       src.sig_peak != dst.sig_peak ||
                        need_ootf;
 
     if (need_linear && !is_linear) {
@@ -791,6 +789,10 @@
     if (need_ootf)
         pass_ootf(sc, src.light, src.sig_peak);
 
+    // Tone map to prevent clipping due to excessive brightness
+    if (src.sig_peak > dst.sig_peak)
+        pass_tone_map(sc, src.sig_peak, dst.sig_peak, opts);
+
     // Adapt to the right colorspace if necessary
     if (src.primaries != dst.primaries) {
         struct mp_csp_primaries csp_src = mp_get_csp_primaries(src.primaries),
@@ -801,13 +803,6 @@
         GLSL(color.rgb = cms_matrix * color.rgb;)
     }
 
-    // Tone map to prevent clipping when the source signal peak exceeds the
-    // encodable range or we've reduced the gamut
-    if (src.sig_peak > dst.sig_peak) {
-        pass_tone_map(sc, detect_peak, src.sig_peak, dst.sig_peak, algo,
-                      tone_mapping_param, tone_mapping_desat);
-    }
-
     if (need_ootf)
         pass_inverse_ootf(sc, dst.light, dst.sig_peak);
 
@@ -821,8 +816,9 @@
     GLSLF("color.rgb *= vec3(%f);\n", 1.0 / dst_range);
 
     // Warn for remaining out-of-gamut colors is enabled
-    if (gamut_warning) {
-        GLSL(if (any(greaterThan(color.rgb, vec3(1.01)))))
+    if (opts->gamut_warning) {
+        GLSL(if (any(greaterThan(color.rgb, vec3(1.01))) ||
+                 any(lessThan(color.rgb, vec3(0.0)))))
             GLSL(color.rgb = vec3(1.0) - color.rgb;) // invert
     }
 
@@ -833,10 +829,14 @@
 // Wide usage friendly PRNG, shamelessly stolen from a GLSL tricks forum post.
 // Obtain random numbers by calling rand(h), followed by h = permute(h) to
 // update the state. Assumes the texture was hooked.
+// permute() was modified from the original to avoid "large" numbers in
+// calculations, since low-end mobile GPUs choke on them (overflow).
 static void prng_init(struct gl_shader_cache *sc, AVLFG *lfg)
 {
     GLSLH(float mod289(float x)  { return x - floor(x * 1.0/289.0) * 289.0; })
-    GLSLH(float permute(float x) { return mod289((34.0*x + 1.0) * x); })
+    GLSLHF("float permute(float x) {\n");
+        GLSLH(return mod289( mod289(34.0*x + 1.0) * (fract(x) + 1.0) );)
+    GLSLHF("}\n");
     GLSLH(float rand(float x)    { return fract(x * 1.0/41.0); })
 
     // Initialize the PRNG by hashing the position + a random uniform
diff -ruN mpv-0.29.1/video/out/gpu/video_shaders.h mpv-master/video/out/gpu/video_shaders.h
--- mpv-0.29.1/video/out/gpu/video_shaders.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/gpu/video_shaders.h	2019-09-19 04:02:03.000000000 +0700
@@ -40,11 +40,9 @@
 void pass_linearize(struct gl_shader_cache *sc, enum mp_csp_trc trc);
 void pass_delinearize(struct gl_shader_cache *sc, enum mp_csp_trc trc);
 
-void pass_color_map(struct gl_shader_cache *sc,
+void pass_color_map(struct gl_shader_cache *sc, bool is_linear,
                     struct mp_colorspace src, struct mp_colorspace dst,
-                    enum tone_mapping algo, float tone_mapping_param,
-                    float tone_mapping_desat, bool use_detected_peak,
-                    bool gamut_warning, bool is_linear);
+                    const struct gl_tone_map_opts *opts);
 
 void pass_sample_deband(struct gl_shader_cache *sc, struct deband_opts *opts,
                         AVLFG *lfg, enum mp_csp_trc trc);
diff -ruN mpv-0.29.1/video/out/hwdec/hwdec_cuda.c mpv-master/video/out/hwdec/hwdec_cuda.c
--- mpv-0.29.1/video/out/hwdec/hwdec_cuda.c	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/hwdec/hwdec_cuda.c	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,274 @@
+/*
+ * Copyright (c) 2016 Philip Langdale <philipl@overt.org>
+ *
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * This hwdec implements an optimized output path using CUDA->OpenGL
+ * or CUDA->Vulkan interop for frame data that is stored in CUDA
+ * device memory. Although it is not explicit in the code here, the
+ * only practical way to get data in this form is from the
+ * nvdec/cuvid decoder.
+ */
+
+#include "config.h"
+#include "hwdec_cuda.h"
+
+#include <libavutil/hwcontext.h>
+#include <libavutil/hwcontext_cuda.h>
+
+int check_cu(const struct ra_hwdec *hw, CUresult err, const char *func)
+{
+    const char *err_name;
+    const char *err_string;
+
+    struct cuda_hw_priv *p = hw->priv;
+
+    MP_TRACE(hw, "Calling %s\n", func);
+
+    if (err == CUDA_SUCCESS)
+        return 0;
+
+    p->cu->cuGetErrorName(err, &err_name);
+    p->cu->cuGetErrorString(err, &err_string);
+
+    MP_ERR(hw, "%s failed", func);
+    if (err_name && err_string)
+        MP_ERR(hw, " -> %s: %s", err_name, err_string);
+    MP_ERR(hw, "\n");
+
+    return -1;
+}
+
+#define CHECK_CU(x) check_cu(hw, (x), #x)
+
+const static cuda_interop_init interop_inits[] = {
+#if HAVE_GL
+    cuda_gl_init,
+#endif
+#if HAVE_VULKAN
+    cuda_vk_init,
+#endif
+    NULL
+};
+
+static int cuda_init(struct ra_hwdec *hw)
+{
+    AVBufferRef *hw_device_ctx = NULL;
+    CUcontext dummy;
+    int ret = 0;
+    struct cuda_hw_priv *p = hw->priv;
+    CudaFunctions *cu;
+
+    ret = cuda_load_functions(&p->cu, NULL);
+    if (ret != 0) {
+        MP_VERBOSE(hw, "Failed to load CUDA symbols\n");
+        return -1;
+    }
+    cu = p->cu;
+
+    ret = CHECK_CU(cu->cuInit(0));
+    if (ret < 0)
+        return -1;
+
+    // Initialise CUDA context from backend.
+    for (int i = 0; interop_inits[i]; i++) {
+        if (interop_inits[i](hw)) {
+            break;
+        }
+    }
+
+    if (!p->ext_init || !p->ext_uninit) {
+        MP_VERBOSE(hw, "CUDA hwdec only works with OpenGL or Vulkan backends.\n");
+        return -1;
+    }
+
+    hw_device_ctx = av_hwdevice_ctx_alloc(AV_HWDEVICE_TYPE_CUDA);
+    if (!hw_device_ctx)
+        goto error;
+
+    AVHWDeviceContext *device_ctx = (void *)hw_device_ctx->data;
+
+    AVCUDADeviceContext *device_hwctx = device_ctx->hwctx;
+    device_hwctx->cuda_ctx = p->decode_ctx;
+
+    ret = av_hwdevice_ctx_init(hw_device_ctx);
+    if (ret < 0) {
+        MP_ERR(hw, "av_hwdevice_ctx_init failed\n");
+        goto error;
+    }
+
+    ret = CHECK_CU(cu->cuCtxPopCurrent(&dummy));
+    if (ret < 0)
+        goto error;
+
+    p->hwctx = (struct mp_hwdec_ctx) {
+        .driver_name = hw->driver->name,
+        .av_device_ref = hw_device_ctx,
+    };
+    hwdec_devices_add(hw->devs, &p->hwctx);
+    return 0;
+
+ error:
+    av_buffer_unref(&hw_device_ctx);
+    CHECK_CU(cu->cuCtxPopCurrent(&dummy));
+
+    return -1;
+}
+
+static void cuda_uninit(struct ra_hwdec *hw)
+{
+    struct cuda_hw_priv *p = hw->priv;
+    CudaFunctions *cu = p->cu;
+
+    hwdec_devices_remove(hw->devs, &p->hwctx);
+    av_buffer_unref(&p->hwctx.av_device_ref);
+
+    if (p->decode_ctx && p->decode_ctx != p->display_ctx)
+        CHECK_CU(cu->cuCtxDestroy(p->decode_ctx));
+
+    if (p->display_ctx)
+        CHECK_CU(cu->cuCtxDestroy(p->display_ctx));
+
+    cuda_free_functions(&p->cu);
+}
+
+#undef CHECK_CU
+#define CHECK_CU(x) check_cu((mapper)->owner, (x), #x)
+
+static int mapper_init(struct ra_hwdec_mapper *mapper)
+{
+    struct cuda_hw_priv *p_owner = mapper->owner->priv;
+    struct cuda_mapper_priv *p = mapper->priv;
+    CUcontext dummy;
+    CudaFunctions *cu = p_owner->cu;
+    int ret = 0, eret = 0;
+
+    p->display_ctx = p_owner->display_ctx;
+
+    int imgfmt = mapper->src_params.hw_subfmt;
+    mapper->dst_params = mapper->src_params;
+    mapper->dst_params.imgfmt = imgfmt;
+    mapper->dst_params.hw_subfmt = 0;
+
+    mp_image_set_params(&p->layout, &mapper->dst_params);
+
+    struct ra_imgfmt_desc desc;
+    if (!ra_get_imgfmt_desc(mapper->ra, imgfmt, &desc)) {
+        MP_ERR(mapper, "Unsupported format: %s\n", mp_imgfmt_to_name(imgfmt));
+        return -1;
+    }
+
+    ret = CHECK_CU(cu->cuCtxPushCurrent(p->display_ctx));
+    if (ret < 0)
+        return ret;
+
+    for (int n = 0; n < desc.num_planes; n++) {
+        if (!p_owner->ext_init(mapper, desc.planes[n], n))
+            goto error;
+    }
+
+ error:
+    eret = CHECK_CU(cu->cuCtxPopCurrent(&dummy));
+    if (eret < 0)
+        return eret;
+
+    return ret;
+}
+
+static void mapper_uninit(struct ra_hwdec_mapper *mapper)
+{
+    struct cuda_mapper_priv *p = mapper->priv;
+    struct cuda_hw_priv *p_owner = mapper->owner->priv;
+    CudaFunctions *cu = p_owner->cu;
+    CUcontext dummy;
+
+    // Don't bail if any CUDA calls fail. This is all best effort.
+    CHECK_CU(cu->cuCtxPushCurrent(p->display_ctx));
+    for (int n = 0; n < 4; n++) {
+        p_owner->ext_uninit(mapper, n);
+        ra_tex_free(mapper->ra, &mapper->tex[n]);
+    }
+    CHECK_CU(cu->cuCtxPopCurrent(&dummy));
+}
+
+static void mapper_unmap(struct ra_hwdec_mapper *mapper)
+{
+}
+
+static int mapper_map(struct ra_hwdec_mapper *mapper)
+{
+    struct cuda_mapper_priv *p = mapper->priv;
+    struct cuda_hw_priv *p_owner = mapper->owner->priv;
+    CudaFunctions *cu = p_owner->cu;
+    CUcontext dummy;
+    int ret = 0, eret = 0;
+
+    ret = CHECK_CU(cu->cuCtxPushCurrent(p->display_ctx));
+    if (ret < 0)
+        return ret;
+
+    for (int n = 0; n < p->layout.num_planes; n++) {
+        if (p_owner->ext_wait) {
+            if (!p_owner->ext_wait(mapper, n))
+                goto error;
+        }
+
+        CUDA_MEMCPY2D cpy = {
+            .srcMemoryType = CU_MEMORYTYPE_DEVICE,
+            .srcDevice     = (CUdeviceptr)mapper->src->planes[n],
+            .srcPitch      = mapper->src->stride[n],
+            .srcY          = 0,
+            .dstMemoryType = CU_MEMORYTYPE_ARRAY,
+            .dstArray      = p->cu_array[n],
+            .WidthInBytes  = mp_image_plane_w(&p->layout, n) *
+                             mapper->tex[n]->params.format->pixel_size,
+            .Height        = mp_image_plane_h(&p->layout, n),
+        };
+
+        ret = CHECK_CU(cu->cuMemcpy2DAsync(&cpy, 0));
+        if (ret < 0)
+            goto error;
+
+        if (p_owner->ext_signal) {
+            if (!p_owner->ext_signal(mapper, n))
+                goto error;
+        }
+    }
+
+ error:
+   eret = CHECK_CU(cu->cuCtxPopCurrent(&dummy));
+   if (eret < 0)
+       return eret;
+
+   return ret;
+}
+
+const struct ra_hwdec_driver ra_hwdec_cuda = {
+    .name = "cuda-nvdec",
+    .imgfmts = {IMGFMT_CUDA, 0},
+    .priv_size = sizeof(struct cuda_hw_priv),
+    .init = cuda_init,
+    .uninit = cuda_uninit,
+    .mapper = &(const struct ra_hwdec_mapper_driver){
+        .priv_size = sizeof(struct cuda_mapper_priv),
+        .init = mapper_init,
+        .uninit = mapper_uninit,
+        .map = mapper_map,
+        .unmap = mapper_unmap,
+    },
+};
diff -ruN mpv-0.29.1/video/out/hwdec/hwdec_cuda.h mpv-master/video/out/hwdec/hwdec_cuda.h
--- mpv-0.29.1/video/out/hwdec/hwdec_cuda.h	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/hwdec/hwdec_cuda.h	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2019 Philip Langdale <philipl@overt.org>
+ *
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include <ffnvcodec/dynlink_loader.h>
+
+#include "video/out/gpu/hwdec.h"
+
+struct cuda_hw_priv {
+    struct mp_hwdec_ctx hwctx;
+    CudaFunctions *cu;
+    CUcontext display_ctx;
+    CUcontext decode_ctx;
+
+    // Stored as int to avoid depending on libplacebo enum
+    int handle_type;
+
+    bool (*ext_init)(struct ra_hwdec_mapper *mapper,
+                     const struct ra_format *format, int n);
+    void (*ext_uninit)(const struct ra_hwdec_mapper *mapper, int n);
+
+    // These are only necessary if the gpu api requires synchronisation
+    bool (*ext_wait)(const struct ra_hwdec_mapper *mapper, int n);
+    bool (*ext_signal)(const struct ra_hwdec_mapper *mapper, int n);
+};
+
+struct cuda_mapper_priv {
+    struct mp_image layout;
+    CUarray cu_array[4];
+
+    CUcontext display_ctx;
+
+    void *ext[4];
+};
+
+typedef bool (*cuda_interop_init)(const struct ra_hwdec *hw);
+
+bool cuda_gl_init(const struct ra_hwdec *hw);
+
+bool cuda_vk_init(const struct ra_hwdec *hw);
+
+int check_cu(const struct ra_hwdec *hw, CUresult err, const char *func);
diff -ruN mpv-0.29.1/video/out/hwdec/hwdec_cuda_gl.c mpv-master/video/out/hwdec/hwdec_cuda_gl.c
--- mpv-0.29.1/video/out/hwdec/hwdec_cuda_gl.c	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/hwdec/hwdec_cuda_gl.c	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2019 Philip Langdale <philipl@overt.org>
+ *
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+#include "hwdec_cuda.h"
+#include "options/m_config.h"
+#include "video/out/opengl/formats.h"
+#include "video/out/opengl/ra_gl.h"
+
+#include <libavutil/hwcontext.h>
+#include <libavutil/hwcontext_cuda.h>
+#include <unistd.h>
+
+#define CHECK_CU(x) check_cu((mapper)->owner, (x), #x)
+
+struct ext_gl {
+    CUgraphicsResource cu_res;
+};
+
+static bool cuda_ext_gl_init(struct ra_hwdec_mapper *mapper,
+                             const struct ra_format *format, int n)
+{
+    struct cuda_hw_priv *p_owner = mapper->owner->priv;
+    struct cuda_mapper_priv *p = mapper->priv;
+    CudaFunctions *cu = p_owner->cu;
+    int ret = 0;
+    CUcontext dummy;
+
+    struct ext_gl *egl = talloc_ptrtype(NULL, egl);
+    p->ext[n] = egl;
+
+    struct ra_tex_params params = {
+        .dimensions = 2,
+        .w = mp_image_plane_w(&p->layout, n),
+        .h = mp_image_plane_h(&p->layout, n),
+        .d = 1,
+        .format = format,
+        .render_src = true,
+        .src_linear = format->linear_filter,
+    };
+
+    mapper->tex[n] = ra_tex_create(mapper->ra, &params);
+    if (!mapper->tex[n]) {
+        goto error;
+    }
+
+    GLuint texture;
+    GLenum target;
+    ra_gl_get_raw_tex(mapper->ra, mapper->tex[n], &texture, &target);
+
+    ret = CHECK_CU(cu->cuGraphicsGLRegisterImage(&egl->cu_res, texture, target,
+                                                 CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD));
+    if (ret < 0)
+        goto error;
+
+    ret = CHECK_CU(cu->cuGraphicsMapResources(1, &egl->cu_res, 0));
+    if (ret < 0)
+        goto error;
+
+    ret = CHECK_CU(cu->cuGraphicsSubResourceGetMappedArray(&p->cu_array[n], egl->cu_res,
+                                                           0, 0));
+    if (ret < 0)
+        goto error;
+
+    ret = CHECK_CU(cu->cuGraphicsUnmapResources(1, &egl->cu_res, 0));
+    if (ret < 0)
+        goto error;
+
+    return true;
+
+error:
+    CHECK_CU(cu->cuCtxPopCurrent(&dummy));
+    return false;
+}
+
+static void cuda_ext_gl_uninit(const struct ra_hwdec_mapper *mapper, int n)
+{
+    struct cuda_hw_priv *p_owner = mapper->owner->priv;
+    struct cuda_mapper_priv *p = mapper->priv;
+    CudaFunctions *cu = p_owner->cu;
+
+    struct ext_gl *egl = p->ext[n];
+    if (egl && egl->cu_res) {
+        CHECK_CU(cu->cuGraphicsUnregisterResource(egl->cu_res));
+        egl->cu_res = 0;
+    }
+    talloc_free(egl);
+}
+
+#undef CHECK_CU
+#define CHECK_CU(x) check_cu(hw, (x), #x)
+
+bool cuda_gl_init(const struct ra_hwdec *hw) {
+    int ret = 0;
+    struct cuda_hw_priv *p = hw->priv;
+    CudaFunctions *cu = p->cu;
+
+    if (ra_is_gl(hw->ra)) {
+        GL *gl = ra_gl_get(hw->ra);
+        if (gl->version < 210 && gl->es < 300) {
+            MP_VERBOSE(hw, "need OpenGL >= 2.1 or OpenGL-ES >= 3.0\n");
+            return false;
+        }
+    } else {
+        // This is not an OpenGL RA.
+        return false;
+    }
+
+    CUdevice display_dev;
+    unsigned int device_count;
+    ret = CHECK_CU(cu->cuGLGetDevices(&device_count, &display_dev, 1,
+                                      CU_GL_DEVICE_LIST_ALL));
+    if (ret < 0)
+        return false;
+
+    ret = CHECK_CU(cu->cuCtxCreate(&p->display_ctx, CU_CTX_SCHED_BLOCKING_SYNC,
+                                   display_dev));
+    if (ret < 0)
+        return false;
+
+    p->decode_ctx = p->display_ctx;
+
+    int decode_dev_idx = -1;
+    mp_read_option_raw(hw->global, "cuda-decode-device", &m_option_type_choice,
+                       &decode_dev_idx);
+
+    if (decode_dev_idx > -1) {
+        CUcontext dummy;
+        CUdevice decode_dev;
+        ret = CHECK_CU(cu->cuDeviceGet(&decode_dev, decode_dev_idx));
+        if (ret < 0) {
+            CHECK_CU(cu->cuCtxPopCurrent(&dummy));
+            return false;
+        }
+
+        if (decode_dev != display_dev) {
+            MP_INFO(hw, "Using separate decoder and display devices\n");
+
+            // Pop the display context. We won't use it again during init()
+            ret = CHECK_CU(cu->cuCtxPopCurrent(&dummy));
+            if (ret < 0)
+                return false;
+
+            ret = CHECK_CU(cu->cuCtxCreate(&p->decode_ctx, CU_CTX_SCHED_BLOCKING_SYNC,
+                                           decode_dev));
+            if (ret < 0)
+                return false;
+        }
+    }
+
+    p->ext_init = cuda_ext_gl_init;
+    p->ext_uninit = cuda_ext_gl_uninit;
+
+    return true;
+}
diff -ruN mpv-0.29.1/video/out/hwdec/hwdec_cuda_vk.c mpv-master/video/out/hwdec/hwdec_cuda_vk.c
--- mpv-0.29.1/video/out/hwdec/hwdec_cuda_vk.c	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/hwdec/hwdec_cuda_vk.c	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,346 @@
+/*
+ * Copyright (c) 2019 Philip Langdale <philipl@overt.org>
+ *
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+#include "hwdec_cuda.h"
+#include "video/out/placebo/ra_pl.h"
+
+#include <libavutil/hwcontext.h>
+#include <libavutil/hwcontext_cuda.h>
+#include <unistd.h>
+
+#if HAVE_WIN32_DESKTOP
+#include <versionhelpers.h>
+#endif
+
+#define CHECK_CU(x) check_cu((mapper)->owner, (x), #x)
+
+struct ext_vk {
+    CUexternalMemory mem;
+    CUmipmappedArray mma;
+
+    const struct pl_tex *pltex;
+
+    const struct pl_sync *sync;
+
+    CUexternalSemaphore ss;
+    CUexternalSemaphore ws;
+};
+
+static bool cuda_ext_vk_init(struct ra_hwdec_mapper *mapper,
+                             const struct ra_format *format, int n)
+{
+    struct cuda_hw_priv *p_owner = mapper->owner->priv;
+    struct cuda_mapper_priv *p = mapper->priv;
+    CudaFunctions *cu = p_owner->cu;
+    int mem_fd = -1, wait_fd = -1, signal_fd = -1;
+    int ret = 0;
+
+    struct ext_vk *evk = talloc_ptrtype(NULL, evk);
+    p->ext[n] = evk;
+
+    const struct pl_gpu *gpu = ra_pl_get(mapper->ra);
+
+    struct pl_tex_params tex_params = {
+        .w = mp_image_plane_w(&p->layout, n),
+        .h = mp_image_plane_h(&p->layout, n),
+        .d = 0,
+        .format = ra_pl_fmt_get(format),
+        .sampleable = true,
+        .sample_mode = format->linear_filter ? PL_TEX_SAMPLE_LINEAR
+                                             : PL_TEX_SAMPLE_NEAREST,
+        .export_handle = p_owner->handle_type,
+    };
+
+    evk->pltex = pl_tex_create(gpu, &tex_params);
+    if (!evk->pltex) {
+        goto error;
+    }
+
+    struct ra_tex *ratex = talloc_ptrtype(NULL, ratex);
+    ret = mppl_wrap_tex(mapper->ra, evk->pltex, ratex);
+    if (!ret) {
+        pl_tex_destroy(gpu, &evk->pltex);
+        talloc_free(ratex);
+        goto error;
+    }
+    mapper->tex[n] = ratex;
+
+#if !HAVE_WIN32_DESKTOP
+    if (evk->pltex->params.export_handle == PL_HANDLE_FD) {
+        mem_fd = dup(evk->pltex->shared_mem.handle.fd);
+        if (mem_fd < 0) {
+            goto error;
+        }
+    }
+#endif
+
+    CUDA_EXTERNAL_MEMORY_HANDLE_DESC ext_desc = {
+#if HAVE_WIN32_DESKTOP
+        .type = IsWindows8OrGreater()
+            ? CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32
+            : CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT,
+        .handle.win32.handle = evk->pltex->shared_mem.handle.handle,
+#else
+        .type = CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD,
+        .handle.fd = mem_fd,
+#endif
+        .size = evk->pltex->shared_mem.size,
+        .flags = 0,
+    };
+    ret = CHECK_CU(cu->cuImportExternalMemory(&evk->mem, &ext_desc));
+    if (ret < 0)
+        goto error;
+    // CUDA takes ownership of imported memory
+    mem_fd = -1;
+
+    CUarray_format cufmt;
+    switch (format->pixel_size / format->num_components) {
+    case 1:
+        cufmt = CU_AD_FORMAT_UNSIGNED_INT8;
+        break;
+    case 2:
+        cufmt = CU_AD_FORMAT_UNSIGNED_INT16;
+        break;
+    default:
+        ret = -1;
+        goto error;
+    }
+
+    CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC tex_desc = {
+        .offset = evk->pltex->shared_mem.offset,
+        .arrayDesc = {
+            .Width = mp_image_plane_w(&p->layout, n),
+            .Height = mp_image_plane_h(&p->layout, n),
+            .Depth = 0,
+            .Format = cufmt,
+            .NumChannels = format->num_components,
+            .Flags = 0,
+        },
+        .numLevels = 1,
+    };
+
+    ret = CHECK_CU(cu->cuExternalMemoryGetMappedMipmappedArray(&evk->mma, evk->mem, &tex_desc));
+    if (ret < 0)
+        goto error;
+
+    ret = CHECK_CU(cu->cuMipmappedArrayGetLevel(&p->cu_array[n], evk->mma, 0));
+    if (ret < 0)
+        goto error;
+
+    evk->sync = pl_sync_create(gpu, p_owner->handle_type);
+    if (!evk->sync) {
+        ret = -1;
+        goto error;
+    }
+
+#if !HAVE_WIN32_DESKTOP
+    if (evk->sync->handle_type == PL_HANDLE_FD) {
+        wait_fd = dup(evk->sync->wait_handle.fd);
+        signal_fd = dup(evk->sync->signal_handle.fd);
+    }
+#endif
+
+    CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC w_desc = {
+#if HAVE_WIN32_DESKTOP
+        .type = IsWindows8OrGreater()
+            ? CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32
+            : CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT,
+        .handle.win32.handle = evk->sync->wait_handle.handle,
+#else
+        .type = CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD,
+        .handle.fd = wait_fd,
+#endif
+    };
+    ret = CHECK_CU(cu->cuImportExternalSemaphore(&evk->ws, &w_desc));
+    if (ret < 0)
+        goto error;
+    wait_fd = -1;
+
+    CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC s_desc = {
+#if HAVE_WIN32_DESKTOP
+        .type = IsWindows8OrGreater()
+            ? CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32
+            : CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT,
+        .handle.win32.handle = evk->sync->signal_handle.handle,
+#else
+        .type = CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD,
+        .handle.fd = signal_fd,
+#endif
+    };
+
+    ret = CHECK_CU(cu->cuImportExternalSemaphore(&evk->ss, &s_desc));
+    if (ret < 0)
+        goto error;
+    signal_fd = -1;
+
+    return true;
+
+error:
+    MP_ERR(mapper, "cuda_ext_vk_init failed\n");
+    if (mem_fd > -1)
+        close(mem_fd);
+    if (wait_fd > -1)
+        close(wait_fd);
+    if (signal_fd > -1)
+        close(signal_fd);
+    return false;
+}
+
+static void cuda_ext_vk_uninit(const struct ra_hwdec_mapper *mapper, int n)
+{
+    struct cuda_hw_priv *p_owner = mapper->owner->priv;
+    struct cuda_mapper_priv *p = mapper->priv;
+    CudaFunctions *cu = p_owner->cu;
+
+    struct ext_vk *evk = p->ext[n];
+    if (evk) {
+        if (evk->mma) {
+            CHECK_CU(cu->cuMipmappedArrayDestroy(evk->mma));
+            evk->mma = 0;
+        }
+        if (evk->mem) {
+            CHECK_CU(cu->cuDestroyExternalMemory(evk->mem));
+            evk->mem = 0;
+        }
+        if (evk->ss) {
+            CHECK_CU(cu->cuDestroyExternalSemaphore(evk->ss));
+            evk->ss = 0;
+        }
+        if (evk->ws) {
+            CHECK_CU(cu->cuDestroyExternalSemaphore(evk->ws));
+            evk->ws = 0;
+        }
+        pl_sync_destroy(ra_pl_get(mapper->ra), &evk->sync);
+    }
+    talloc_free(evk);
+}
+
+static bool cuda_ext_vk_wait(const struct ra_hwdec_mapper *mapper, int n)
+{
+    struct cuda_hw_priv *p_owner = mapper->owner->priv;
+    struct cuda_mapper_priv *p = mapper->priv;
+    CudaFunctions *cu = p_owner->cu;
+    int ret;
+    struct ext_vk *evk = p->ext[n];
+
+    ret = pl_tex_export(ra_pl_get(mapper->ra),
+                        evk->pltex, evk->sync);
+    if (!ret)
+        return false;
+
+    CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS wp = { 0, };
+    ret = CHECK_CU(cu->cuWaitExternalSemaphoresAsync(&evk->ws,
+                                                     &wp, 1, 0));
+    return ret == 0;
+}
+
+static bool cuda_ext_vk_signal(const struct ra_hwdec_mapper *mapper, int n)
+{
+    struct cuda_hw_priv *p_owner = mapper->owner->priv;
+    struct cuda_mapper_priv *p = mapper->priv;
+    CudaFunctions *cu = p_owner->cu;
+    int ret;
+    struct ext_vk *evk = p->ext[n];
+
+    CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS sp = { 0, };
+    ret = CHECK_CU(cu->cuSignalExternalSemaphoresAsync(&evk->ss,
+                                                       &sp, 1, 0));
+    return ret == 0;
+}
+
+#undef CHECK_CU
+#define CHECK_CU(x) check_cu(hw, (x), #x)
+
+bool cuda_vk_init(const struct ra_hwdec *hw) {
+    int ret = 0;
+    struct cuda_hw_priv *p = hw->priv;
+    CudaFunctions *cu = p->cu;
+
+    p->handle_type =
+#if HAVE_WIN32_DESKTOP
+        IsWindows8OrGreater() ? PL_HANDLE_WIN32 : PL_HANDLE_WIN32_KMT;
+#else
+        PL_HANDLE_FD;
+#endif
+
+    const struct pl_gpu *gpu = ra_pl_get(hw->ra);
+    if (gpu != NULL) {
+        if (!(gpu->export_caps.tex & p->handle_type)) {
+            MP_VERBOSE(hw, "CUDA hwdec with Vulkan requires exportable texture memory of type 0x%X.\n",
+                       p->handle_type);
+            return false;
+        } else if (!(gpu->export_caps.sync & p->handle_type)) {
+            MP_VERBOSE(hw, "CUDA hwdec with Vulkan requires exportable semaphores of type 0x%X.\n",
+                       p->handle_type);
+            return false;
+        }
+    } else {
+        // This is not a Vulkan RA.
+        return false;
+    }
+
+    if (!cu->cuImportExternalMemory) {
+        MP_ERR(hw, "CUDA hwdec with Vulkan requires driver version 410.48 or newer.\n");
+        return false;
+    }
+
+    int device_count;
+    ret = CHECK_CU(cu->cuDeviceGetCount(&device_count));
+    if (ret < 0)
+        return false;
+
+    CUdevice display_dev = -1;
+    for (int i = 0; i < device_count; i++) {
+        CUdevice dev;
+        ret = CHECK_CU(cu->cuDeviceGet(&dev, i));
+        if (ret < 0)
+            continue;
+
+        CUuuid uuid;
+        ret = CHECK_CU(cu->cuDeviceGetUuid(&uuid, dev));
+        if (ret < 0)
+            continue;
+
+        if (memcmp(gpu->uuid, uuid.bytes, sizeof (gpu->uuid)) == 0) {
+            display_dev = dev;
+            break;
+        }
+    }
+
+    if (display_dev == -1) {
+        MP_ERR(hw, "Could not match Vulkan display device in CUDA.\n");
+        return false;
+    }
+
+    ret = CHECK_CU(cu->cuCtxCreate(&p->display_ctx, CU_CTX_SCHED_BLOCKING_SYNC,
+                                   display_dev));
+    if (ret < 0)
+        return false;
+
+    p->decode_ctx = p->display_ctx;
+
+    p->ext_init = cuda_ext_vk_init;
+    p->ext_uninit = cuda_ext_vk_uninit;
+    p->ext_wait = cuda_ext_vk_wait;
+    p->ext_signal = cuda_ext_vk_signal;
+
+    return true;
+}
+
diff -ruN mpv-0.29.1/video/out/hwdec/hwdec_vaapi.c mpv-master/video/out/hwdec/hwdec_vaapi.c
--- mpv-0.29.1/video/out/hwdec/hwdec_vaapi.c	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/hwdec/hwdec_vaapi.c	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,406 @@
+/*
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stddef.h>
+#include <string.h>
+#include <assert.h>
+#include <unistd.h>
+
+#include <libavutil/hwcontext.h>
+#include <libavutil/hwcontext_vaapi.h>
+
+#include "config.h"
+
+#include "video/out/hwdec/hwdec_vaapi.h"
+
+#if HAVE_VAAPI_DRM
+#include "libmpv/render_gl.h"
+#endif
+
+#if HAVE_VAAPI_X11
+#include <va/va_x11.h>
+
+static VADisplay *create_x11_va_display(struct ra *ra)
+{
+    Display *x11 = ra_get_native_resource(ra, "x11");
+    return x11 ? vaGetDisplay(x11) : NULL;
+}
+#endif
+
+#if HAVE_VAAPI_WAYLAND
+#include <va/va_wayland.h>
+
+static VADisplay *create_wayland_va_display(struct ra *ra)
+{
+    struct wl_display *wl = ra_get_native_resource(ra, "wl");
+    return wl ? vaGetDisplayWl(wl) : NULL;
+}
+#endif
+
+#if HAVE_VAAPI_DRM
+#include <va/va_drm.h>
+
+static VADisplay *create_drm_va_display(struct ra *ra)
+{
+    mpv_opengl_drm_params_v2 *params = ra_get_native_resource(ra, "drm_params_v2");
+    if (!params || params->render_fd == -1)
+        return NULL;
+
+    return vaGetDisplayDRM(params->render_fd);
+}
+#endif
+
+struct va_create_native {
+    const char *name;
+    VADisplay *(*create)(struct ra *ra);
+};
+
+static const struct va_create_native create_native_cbs[] = {
+#if HAVE_VAAPI_X11
+    {"x11",     create_x11_va_display},
+#endif
+#if HAVE_VAAPI_WAYLAND
+    {"wayland", create_wayland_va_display},
+#endif
+#if HAVE_VAAPI_DRM
+    {"drm",     create_drm_va_display},
+#endif
+};
+
+static VADisplay *create_native_va_display(struct ra *ra, struct mp_log *log)
+{
+    for (int n = 0; n < MP_ARRAY_SIZE(create_native_cbs); n++) {
+        const struct va_create_native *disp = &create_native_cbs[n];
+        mp_verbose(log, "Trying to open a %s VA display...\n", disp->name);
+        VADisplay *display = disp->create(ra);
+        if (display)
+            return display;
+    }
+    return NULL;
+}
+
+static void determine_working_formats(struct ra_hwdec *hw);
+
+static void uninit(struct ra_hwdec *hw)
+{
+    struct priv_owner *p = hw->priv;
+    if (p->ctx)
+        hwdec_devices_remove(hw->devs, &p->ctx->hwctx);
+    va_destroy(p->ctx);
+}
+
+const static vaapi_interop_init interop_inits[] = {
+#if HAVE_GL
+    vaapi_gl_init,
+#endif
+#if HAVE_VULKAN
+    vaapi_vk_init,
+#endif
+    NULL
+};
+
+static int init(struct ra_hwdec *hw)
+{
+    struct priv_owner *p = hw->priv;
+
+    for (int i = 0; interop_inits[i]; i++) {
+        if (interop_inits[i](hw)) {
+            break;
+        }
+    }
+
+    if (!p->interop_map || !p->interop_unmap) {
+        MP_VERBOSE(hw, "VAAPI hwdec only works with OpenGL or Vulkan backends.\n");
+        return -1;
+    }
+
+    p->display = create_native_va_display(hw->ra, hw->log);
+    if (!p->display) {
+        MP_VERBOSE(hw, "Could not create a VA display.\n");
+        return -1;
+    }
+
+    p->ctx = va_initialize(p->display, hw->log, true);
+    if (!p->ctx) {
+        vaTerminate(p->display);
+        return -1;
+    }
+    if (!p->ctx->av_device_ref) {
+        MP_VERBOSE(hw, "libavutil vaapi code rejected the driver?\n");
+        return -1;
+    }
+
+    if (hw->probing && va_guess_if_emulated(p->ctx)) {
+        return -1;
+    }
+
+    determine_working_formats(hw);
+    if (!p->formats || !p->formats[0]) {
+        return -1;
+    }
+
+    p->ctx->hwctx.supported_formats = p->formats;
+    p->ctx->hwctx.driver_name = hw->driver->name;
+    hwdec_devices_add(hw->devs, &p->ctx->hwctx);
+    return 0;
+}
+
+static void mapper_unmap(struct ra_hwdec_mapper *mapper)
+{
+    struct priv_owner *p_owner = mapper->owner->priv;
+    VADisplay *display = p_owner->display;
+    struct priv *p = mapper->priv;
+    VAStatus status;
+
+    p_owner->interop_unmap(mapper);
+
+#if VA_CHECK_VERSION(1, 1, 0)
+    if (p->surface_acquired) {
+        for (int n = 0; n < p->desc.num_objects; n++)
+            close(p->desc.objects[n].fd);
+        p->surface_acquired = false;
+    }
+#endif
+
+    if (p->buffer_acquired) {
+        status = vaReleaseBufferHandle(display, p->current_image.buf);
+        CHECK_VA_STATUS(mapper, "vaReleaseBufferHandle()");
+        p->buffer_acquired = false;
+    }
+    if (p->current_image.image_id != VA_INVALID_ID) {
+        status = vaDestroyImage(display, p->current_image.image_id);
+        CHECK_VA_STATUS(mapper, "vaDestroyImage()");
+        p->current_image.image_id = VA_INVALID_ID;
+    }
+}
+
+static void mapper_uninit(struct ra_hwdec_mapper *mapper)
+{
+    struct priv_owner *p_owner = mapper->owner->priv;
+    if (p_owner->interop_uninit) {
+        p_owner->interop_uninit(mapper);
+    }
+}
+
+static bool check_fmt(struct ra_hwdec_mapper *mapper, int fmt)
+{
+    struct priv_owner *p_owner = mapper->owner->priv;
+    for (int n = 0; p_owner->formats && p_owner->formats[n]; n++) {
+        if (p_owner->formats[n] == fmt)
+            return true;
+    }
+    return false;
+}
+
+static int mapper_init(struct ra_hwdec_mapper *mapper)
+{
+    struct priv_owner *p_owner = mapper->owner->priv;
+    struct priv *p = mapper->priv;
+
+    p->current_image.buf = p->current_image.image_id = VA_INVALID_ID;
+
+    mapper->dst_params = mapper->src_params;
+    mapper->dst_params.imgfmt = mapper->src_params.hw_subfmt;
+    mapper->dst_params.hw_subfmt = 0;
+
+    struct ra_imgfmt_desc desc = {0};
+
+    if (!ra_get_imgfmt_desc(mapper->ra, mapper->dst_params.imgfmt, &desc))
+        return -1;
+
+    p->num_planes = desc.num_planes;
+    mp_image_set_params(&p->layout, &mapper->dst_params);
+
+    if (p_owner->interop_init)
+        if (!p_owner->interop_init(mapper, &desc))
+            return -1;
+
+    if (!p_owner->probing_formats && !check_fmt(mapper, mapper->dst_params.imgfmt))
+    {
+        MP_FATAL(mapper, "unsupported VA image format %s\n",
+                 mp_imgfmt_to_name(mapper->dst_params.imgfmt));
+        return -1;
+    }
+
+    return 0;
+}
+
+static int mapper_map(struct ra_hwdec_mapper *mapper)
+{
+    struct priv_owner *p_owner = mapper->owner->priv;
+    struct priv *p = mapper->priv;
+    VAStatus status;
+    VADisplay *display = p_owner->display;
+
+#if VA_CHECK_VERSION(1, 1, 0)
+    if (p->esh_not_implemented)
+        goto esh_failed;
+
+    status = vaExportSurfaceHandle(display, va_surface_id(mapper->src),
+                                   VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME_2,
+                                   VA_EXPORT_SURFACE_READ_ONLY |
+                                   VA_EXPORT_SURFACE_SEPARATE_LAYERS,
+                                   &p->desc);
+    if (!CHECK_VA_STATUS_LEVEL(mapper, "vaExportSurfaceHandle()",
+                               p_owner->probing_formats ? MSGL_V : MSGL_ERR)) {
+        if (status == VA_STATUS_ERROR_UNIMPLEMENTED)
+            p->esh_not_implemented = true;
+        goto esh_failed;
+    }
+    vaSyncSurface(display, va_surface_id(mapper->src));
+    // No need to error out if sync fails, but good to know if it did.
+    CHECK_VA_STATUS(mapper, "vaSyncSurface()");
+    p->surface_acquired = true;
+
+    if (!p_owner->interop_map(mapper))
+        goto esh_failed;
+
+    if (p->desc.fourcc == VA_FOURCC_YV12)
+        MPSWAP(struct ra_tex*, mapper->tex[1], mapper->tex[2]);
+
+    return 0;
+
+esh_failed:
+    if (p->surface_acquired) {
+        for (int n = 0; n < p->desc.num_objects; n++)
+            close(p->desc.objects[n].fd);
+        p->surface_acquired = false;
+    }
+#endif // VA_CHECK_VERSION
+
+    if (p_owner->interop_map_legacy) {
+        VAImage *va_image = &p->current_image;
+        status = vaDeriveImage(display, va_surface_id(mapper->src), va_image);
+        if (!CHECK_VA_STATUS(mapper, "vaDeriveImage()"))
+            goto err;
+
+        VABufferInfo buffer_info = {.mem_type = VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME};
+        status = vaAcquireBufferHandle(display, va_image->buf, &buffer_info);
+        if (!CHECK_VA_STATUS(mapper, "vaAcquireBufferHandle()"))
+            goto err;
+        p->buffer_acquired = true;
+
+        int drm_fmts[8] = {
+            // 1 bytes per component, 1-4 components
+            MKTAG('R', '8', ' ', ' '),       // DRM_FORMAT_R8
+            MKTAG('G', 'R', '8', '8'),       // DRM_FORMAT_GR88
+            0,                               // untested (DRM_FORMAT_RGB888?)
+            0,                               // untested (DRM_FORMAT_RGBA8888?)
+            // 2 bytes per component, 1-4 components
+            MKTAG('R', '1', '6', ' '),       // proposed DRM_FORMAT_R16
+            MKTAG('G', 'R', '3', '2'),       // proposed DRM_FORMAT_GR32
+            0,                               // N/A
+            0,                               // N/A
+        };
+
+        if (!p_owner->interop_map_legacy(mapper, &buffer_info, drm_fmts))
+            goto err;
+
+        if (va_image->format.fourcc == VA_FOURCC_YV12)
+            MPSWAP(struct ra_tex*, mapper->tex[1], mapper->tex[2]);
+
+        return 0;
+    } else {
+        mapper_unmap(mapper);
+        goto err;
+    }
+
+err:
+    if (!p_owner->probing_formats)
+        MP_FATAL(mapper, "mapping VAAPI EGL image failed\n");
+    return -1;
+}
+
+static bool try_format(struct ra_hwdec *hw, struct mp_image *surface)
+{
+    bool ok = false;
+    struct ra_hwdec_mapper *mapper = ra_hwdec_mapper_create(hw, &surface->params);
+    if (mapper)
+        ok = ra_hwdec_mapper_map(mapper, surface) >= 0;
+    ra_hwdec_mapper_free(&mapper);
+    return ok;
+}
+
+static void determine_working_formats(struct ra_hwdec *hw)
+{
+    struct priv_owner *p = hw->priv;
+    int num_formats = 0;
+    int *formats = NULL;
+
+    p->probing_formats = true;
+
+    AVHWFramesConstraints *fc =
+            av_hwdevice_get_hwframe_constraints(p->ctx->av_device_ref, NULL);
+    if (!fc) {
+        MP_WARN(hw, "failed to retrieve libavutil frame constraints\n");
+        goto done;
+    }
+    for (int n = 0; fc->valid_sw_formats[n] != AV_PIX_FMT_NONE; n++) {
+        AVBufferRef *fref = NULL;
+        struct mp_image *s = NULL;
+        AVFrame *frame = NULL;
+        fref = av_hwframe_ctx_alloc(p->ctx->av_device_ref);
+        if (!fref)
+            goto err;
+        AVHWFramesContext *fctx = (void *)fref->data;
+        fctx->format = AV_PIX_FMT_VAAPI;
+        fctx->sw_format = fc->valid_sw_formats[n];
+        fctx->width = 128;
+        fctx->height = 128;
+        if (av_hwframe_ctx_init(fref) < 0)
+            goto err;
+        frame = av_frame_alloc();
+        if (!frame)
+            goto err;
+        if (av_hwframe_get_buffer(fref, frame, 0) < 0)
+            goto err;
+        s = mp_image_from_av_frame(frame);
+        if (!s || !mp_image_params_valid(&s->params))
+            goto err;
+        if (try_format(hw, s))
+            MP_TARRAY_APPEND(p, formats, num_formats, s->params.hw_subfmt);
+    err:
+        talloc_free(s);
+        av_frame_free(&frame);
+        av_buffer_unref(&fref);
+    }
+    av_hwframe_constraints_free(&fc);
+
+done:
+    MP_TARRAY_APPEND(p, formats, num_formats, 0); // terminate it
+    p->formats = formats;
+    p->probing_formats = false;
+
+    MP_VERBOSE(hw, "Supported formats:\n");
+    for (int n = 0; formats[n]; n++)
+        MP_VERBOSE(hw, " %s\n", mp_imgfmt_to_name(formats[n]));
+}
+
+const struct ra_hwdec_driver ra_hwdec_vaegl = {
+    .name = "vaapi-egl",
+    .priv_size = sizeof(struct priv_owner),
+    .imgfmts = {IMGFMT_VAAPI, 0},
+    .init = init,
+    .uninit = uninit,
+    .mapper = &(const struct ra_hwdec_mapper_driver){
+        .priv_size = sizeof(struct priv),
+        .init = mapper_init,
+        .uninit = mapper_uninit,
+        .map = mapper_map,
+        .unmap = mapper_unmap,
+    },
+};
diff -ruN mpv-0.29.1/video/out/hwdec/hwdec_vaapi.h mpv-master/video/out/hwdec/hwdec_vaapi.h
--- mpv-0.29.1/video/out/hwdec/hwdec_vaapi.h	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/hwdec/hwdec_vaapi.h	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,64 @@
+/*
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include <va/va_drmcommon.h>
+
+#include "config.h"
+#include "video/vaapi.h"
+#include "video/out/gpu/hwdec.h"
+
+struct priv_owner {
+    struct mp_vaapi_ctx *ctx;
+    VADisplay *display;
+    int *formats;
+    bool probing_formats; // temporary during init
+
+    bool (*interop_init)(struct ra_hwdec_mapper *mapper,
+                         const struct ra_imgfmt_desc *desc);
+    void (*interop_uninit)(const struct ra_hwdec_mapper *mapper);
+
+    bool (*interop_map)(struct ra_hwdec_mapper *mapper);
+    bool (*interop_map_legacy)(struct ra_hwdec_mapper *mapper,
+                               const VABufferInfo *buffer_info,
+                               const int *drm_fmts);
+    void (*interop_unmap)(struct ra_hwdec_mapper *mapper);
+};
+
+struct priv {
+    int num_planes;
+    struct mp_image layout;
+    struct ra_tex *tex[4];
+
+    VAImage current_image;
+    bool buffer_acquired;
+
+#if VA_CHECK_VERSION(1, 1, 0)
+    bool esh_not_implemented;
+    VADRMPRIMESurfaceDescriptor desc;
+    bool surface_acquired;
+#endif
+
+    void *interop_mapper_priv;
+};
+
+typedef bool (*vaapi_interop_init)(const struct ra_hwdec *hw);
+
+bool vaapi_gl_init(const struct ra_hwdec *hw);
+
+bool vaapi_vk_init(const struct ra_hwdec *hw);
diff -ruN mpv-0.29.1/video/out/hwdec/hwdec_vaapi_gl.c mpv-master/video/out/hwdec/hwdec_vaapi_gl.c
--- mpv-0.29.1/video/out/hwdec/hwdec_vaapi_gl.c	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/hwdec/hwdec_vaapi_gl.c	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,264 @@
+/*
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+#include "hwdec_vaapi.h"
+
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#include "video/out/opengl/ra_gl.h"
+
+#ifndef GL_OES_EGL_image
+typedef void* GLeglImageOES;
+#endif
+#ifndef EGL_KHR_image
+typedef void *EGLImageKHR;
+#endif
+
+#ifndef EGL_LINUX_DMA_BUF_EXT
+#define EGL_LINUX_DMA_BUF_EXT             0x3270
+#define EGL_LINUX_DRM_FOURCC_EXT          0x3271
+#define EGL_DMA_BUF_PLANE0_FD_EXT         0x3272
+#define EGL_DMA_BUF_PLANE0_OFFSET_EXT     0x3273
+#define EGL_DMA_BUF_PLANE0_PITCH_EXT      0x3274
+#endif
+
+struct vaapi_gl_mapper_priv {
+    GLuint gl_textures[4];
+    EGLImageKHR images[4];
+
+    EGLImageKHR (EGLAPIENTRY *CreateImageKHR)(EGLDisplay, EGLContext,
+                                              EGLenum, EGLClientBuffer,
+                                              const EGLint *);
+    EGLBoolean (EGLAPIENTRY *DestroyImageKHR)(EGLDisplay, EGLImageKHR);
+    void (EGLAPIENTRY *EGLImageTargetTexture2DOES)(GLenum, GLeglImageOES);
+};
+
+static bool vaapi_gl_mapper_init(struct ra_hwdec_mapper *mapper,
+                                 const struct ra_imgfmt_desc *desc)
+{
+    struct priv *p_mapper = mapper->priv;
+    struct vaapi_gl_mapper_priv *p = talloc_ptrtype(NULL, p);
+    p_mapper->interop_mapper_priv = p;
+
+    // EGL_KHR_image_base
+    p->CreateImageKHR = (void *)eglGetProcAddress("eglCreateImageKHR");
+    p->DestroyImageKHR = (void *)eglGetProcAddress("eglDestroyImageKHR");
+    // GL_OES_EGL_image
+    p->EGLImageTargetTexture2DOES =
+        (void *)eglGetProcAddress("glEGLImageTargetTexture2DOES");
+
+    if (!p->CreateImageKHR || !p->DestroyImageKHR ||
+        !p->EGLImageTargetTexture2DOES)
+        return false;
+
+    GL *gl = ra_gl_get(mapper->ra);
+    gl->GenTextures(4, p->gl_textures);
+    for (int n = 0; n < desc->num_planes; n++) {
+        gl->BindTexture(GL_TEXTURE_2D, p->gl_textures[n]);
+        gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+        gl->BindTexture(GL_TEXTURE_2D, 0);
+
+        struct ra_tex_params params = {
+            .dimensions = 2,
+            .w = mp_image_plane_w(&p_mapper->layout, n),
+            .h = mp_image_plane_h(&p_mapper->layout, n),
+            .d = 1,
+            .format = desc->planes[n],
+            .render_src = true,
+            .src_linear = true,
+        };
+
+        if (params.format->ctype != RA_CTYPE_UNORM)
+            return false;
+
+        p_mapper->tex[n] = ra_create_wrapped_tex(mapper->ra, &params,
+                                                 p->gl_textures[n]);
+        if (!p_mapper->tex[n])
+            return false;
+    }
+
+    return true;
+}
+
+static void vaapi_gl_mapper_uninit(const struct ra_hwdec_mapper *mapper)
+{
+    struct priv *p_mapper = mapper->priv;
+    struct vaapi_gl_mapper_priv *p = p_mapper->interop_mapper_priv;
+
+    if (p) {
+        GL *gl = ra_gl_get(mapper->ra);
+        gl->DeleteTextures(4, p->gl_textures);
+        for (int n = 0; n < 4; n++) {
+            p->gl_textures[n] = 0;
+            ra_tex_free(mapper->ra, &p_mapper->tex[n]);
+        }
+        talloc_free(p);
+        p_mapper->interop_mapper_priv = NULL;
+    }
+}
+
+#define ADD_ATTRIB(name, value)                         \
+    do {                                                \
+    assert(num_attribs + 3 < MP_ARRAY_SIZE(attribs));   \
+    attribs[num_attribs++] = (name);                    \
+    attribs[num_attribs++] = (value);                   \
+    attribs[num_attribs] = EGL_NONE;                    \
+    } while(0)
+
+#define ADD_PLANE_ATTRIBS(plane) do { \
+            ADD_ATTRIB(EGL_DMA_BUF_PLANE ## plane ## _FD_EXT, \
+                        p_mapper->desc.objects[p_mapper->desc.layers[n].object_index[plane]].fd); \
+            ADD_ATTRIB(EGL_DMA_BUF_PLANE ## plane ## _OFFSET_EXT, \
+                        p_mapper->desc.layers[n].offset[plane]); \
+            ADD_ATTRIB(EGL_DMA_BUF_PLANE ## plane ## _PITCH_EXT, \
+                        p_mapper->desc.layers[n].pitch[plane]); \
+        } while (0)
+
+static bool vaapi_gl_map(struct ra_hwdec_mapper *mapper)
+{
+#if VA_CHECK_VERSION(1, 1, 0)
+    struct priv *p_mapper = mapper->priv;
+    struct vaapi_gl_mapper_priv *p = p_mapper->interop_mapper_priv;
+
+    GL *gl = ra_gl_get(mapper->ra);
+
+    for (int n = 0; n < p_mapper->num_planes; n++) {
+        int attribs[20] = {EGL_NONE};
+        int num_attribs = 0;
+
+        ADD_ATTRIB(EGL_LINUX_DRM_FOURCC_EXT, p_mapper->desc.layers[n].drm_format);
+        ADD_ATTRIB(EGL_WIDTH,  p_mapper->tex[n]->params.w);
+        ADD_ATTRIB(EGL_HEIGHT, p_mapper->tex[n]->params.h);
+
+        ADD_PLANE_ATTRIBS(0);
+        if (p_mapper->desc.layers[n].num_planes > 1)
+            ADD_PLANE_ATTRIBS(1);
+        if (p_mapper->desc.layers[n].num_planes > 2)
+            ADD_PLANE_ATTRIBS(2);
+        if (p_mapper->desc.layers[n].num_planes > 3)
+            ADD_PLANE_ATTRIBS(3);
+
+        p->images[n] = p->CreateImageKHR(eglGetCurrentDisplay(),
+            EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, NULL, attribs);
+        if (!p->images[n])
+            return false;
+
+        gl->BindTexture(GL_TEXTURE_2D, p->gl_textures[n]);
+        p->EGLImageTargetTexture2DOES(GL_TEXTURE_2D, p->images[n]);
+
+        mapper->tex[n] = p_mapper->tex[n];
+    }
+    gl->BindTexture(GL_TEXTURE_2D, 0);
+#endif
+    return true;
+}
+
+static bool vaapi_gl_map_legacy(struct ra_hwdec_mapper *mapper,
+                                const VABufferInfo *buffer_info,
+                                const int *drm_fmts) {
+    struct priv *p_mapper = mapper->priv;
+    struct vaapi_gl_mapper_priv *p = p_mapper->interop_mapper_priv;
+
+    GL *gl = ra_gl_get(mapper->ra);
+
+    VAImage *va_image = &p_mapper->current_image;
+
+    for (int n = 0; n < p_mapper->num_planes; n++) {
+        int attribs[20] = {EGL_NONE};
+        int num_attribs = 0;
+
+        const struct ra_format *fmt = p_mapper->tex[n]->params.format;
+        int n_comp = fmt->num_components;
+        int comp_s = fmt->component_size[n] / 8;
+        if (n_comp < 1 || n_comp > 3 || comp_s < 1 || comp_s > 2)
+            return false;
+        int drm_fmt = drm_fmts[n_comp - 1 + (comp_s - 1) * 4];
+        if (!drm_fmt)
+            return false;
+
+        ADD_ATTRIB(EGL_LINUX_DRM_FOURCC_EXT, drm_fmt);
+        ADD_ATTRIB(EGL_WIDTH, p_mapper->tex[n]->params.w);
+        ADD_ATTRIB(EGL_HEIGHT, p_mapper->tex[n]->params.h);
+        ADD_ATTRIB(EGL_DMA_BUF_PLANE0_FD_EXT, buffer_info->handle);
+        ADD_ATTRIB(EGL_DMA_BUF_PLANE0_OFFSET_EXT, va_image->offsets[n]);
+        ADD_ATTRIB(EGL_DMA_BUF_PLANE0_PITCH_EXT, va_image->pitches[n]);
+
+        p->images[n] = p->CreateImageKHR(eglGetCurrentDisplay(),
+            EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, NULL, attribs);
+        if (!p->images[n])
+            return false;
+
+        gl->BindTexture(GL_TEXTURE_2D, p->gl_textures[n]);
+        p->EGLImageTargetTexture2DOES(GL_TEXTURE_2D, p->images[n]);
+
+        mapper->tex[n] = p_mapper->tex[n];
+    }
+    gl->BindTexture(GL_TEXTURE_2D, 0);
+
+    return true;
+}
+
+static void vaapi_gl_unmap(struct ra_hwdec_mapper *mapper)
+{
+    struct priv *p_mapper = mapper->priv;
+    struct vaapi_gl_mapper_priv *p = p_mapper->interop_mapper_priv;
+
+    if (p) {
+        for (int n = 0; n < 4; n++) {
+            if (p->images[n])
+                p->DestroyImageKHR(eglGetCurrentDisplay(), p->images[n]);
+            p->images[n] = 0;
+        }
+    }
+}
+
+bool vaapi_gl_init(const struct ra_hwdec *hw)
+{
+    struct priv_owner *p = hw->priv;
+    if (!ra_is_gl(hw->ra)) {
+        // This is not an OpenGL RA.
+        return false;
+    }
+
+    if (!eglGetCurrentContext())
+        return false;
+
+    const char *exts = eglQueryString(eglGetCurrentDisplay(), EGL_EXTENSIONS);
+    if (!exts)
+        return false;
+
+    GL *gl = ra_gl_get(hw->ra);
+    if (!strstr(exts, "EXT_image_dma_buf_import") ||
+        !strstr(exts, "EGL_KHR_image_base") ||
+        !strstr(gl->extensions, "GL_OES_EGL_image") ||
+        !(gl->mpgl_caps & MPGL_CAP_TEX_RG))
+        return false;
+
+    MP_VERBOSE(hw, "using VAAPI EGL interop\n");
+
+    p->interop_init = vaapi_gl_mapper_init;
+    p->interop_uninit = vaapi_gl_mapper_uninit;
+    p->interop_map = vaapi_gl_map;
+    p->interop_map_legacy = vaapi_gl_map_legacy;
+    p->interop_unmap = vaapi_gl_unmap;
+
+    return true;
+}
\ No newline at end of file
diff -ruN mpv-0.29.1/video/out/hwdec/hwdec_vaapi_vk.c mpv-master/video/out/hwdec/hwdec_vaapi_vk.c
--- mpv-0.29.1/video/out/hwdec/hwdec_vaapi_vk.c	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/hwdec/hwdec_vaapi_vk.c	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,110 @@
+/*
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+#include "hwdec_vaapi.h"
+#include "video/out/placebo/ra_pl.h"
+
+static bool vaapi_vk_map(struct ra_hwdec_mapper *mapper)
+{
+    struct priv *p = mapper->priv;
+    const struct pl_gpu *gpu = ra_pl_get(mapper->ra);
+
+    struct ra_imgfmt_desc desc = {0};
+    if (!ra_get_imgfmt_desc(mapper->ra, mapper->dst_params.imgfmt, &desc))
+        return false;
+
+    for (int n = 0; n < p->num_planes; n++) {
+        if (p->desc.layers[n].num_planes > 1) {
+            // Should never happen because we request separate layers
+            MP_ERR(mapper, "Multi-plane VA surfaces are not supported\n");
+            return false;
+        }
+
+        const struct ra_format *format = desc.planes[n];
+        int id = p->desc.layers[n].object_index[0];
+        int fd = p->desc.objects[id].fd;
+        uint32_t size = p->desc.objects[id].size;
+        uint32_t offset = p->desc.layers[n].offset[0];
+
+        struct pl_tex_params tex_params = {
+            .w = mp_image_plane_w(&p->layout, n),
+            .h = mp_image_plane_h(&p->layout, n),
+            .d = 0,
+            .format = format->priv,
+            .sampleable = true,
+            .sample_mode = format->linear_filter ? PL_TEX_SAMPLE_LINEAR
+                                                    : PL_TEX_SAMPLE_NEAREST,
+            .import_handle = PL_HANDLE_DMA_BUF,
+            .shared_mem = (struct pl_shared_mem) {
+                .handle = {
+                    .fd = fd,
+                },
+                .size = size,
+                .offset = offset,
+            },
+        };
+
+        const struct pl_tex *pltex = pl_tex_create(gpu, &tex_params);
+        if (!pltex) {
+            return false;
+        }
+
+        struct ra_tex *ratex = talloc_ptrtype(NULL, ratex);
+        int ret = mppl_wrap_tex(mapper->ra, pltex, ratex);
+        if (!ret) {
+            pl_tex_destroy(gpu, &pltex);
+            talloc_free(ratex);
+            return false;
+        }
+        mapper->tex[n] = ratex;
+
+        MP_TRACE(mapper, "Object %d with fd %d imported as %p\n",
+                id, fd, ratex);
+    }
+    return true;
+}
+
+static void vaapi_vk_unmap(struct ra_hwdec_mapper *mapper)
+{
+    for (int n = 0; n < 4; n++)
+        ra_tex_free(mapper->ra, &mapper->tex[n]);
+}
+
+bool vaapi_vk_init(const struct ra_hwdec *hw)
+{
+   struct priv_owner *p = hw->priv;
+
+    const struct pl_gpu *gpu = ra_pl_get(hw->ra);
+    if (!gpu) {
+        // This is not a Vulkan RA;
+        return false;
+    }
+
+    if (!(gpu->import_caps.tex & PL_HANDLE_DMA_BUF)) {
+        MP_VERBOSE(hw, "VAAPI Vulkan interop requires support for "
+                        "dma_buf import in Vulkan.\n");
+        return false;
+    }
+
+    MP_VERBOSE(hw, "using VAAPI Vulkan interop\n");
+
+    p->interop_map = vaapi_vk_map;
+    p->interop_unmap = vaapi_vk_unmap;
+
+    return true;
+}
\ No newline at end of file
diff -ruN mpv-0.29.1/video/out/libmpv.h mpv-master/video/out/libmpv.h
--- mpv-0.29.1/video/out/libmpv.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/libmpv.h	2019-09-19 04:02:03.000000000 +0700
@@ -54,6 +54,8 @@
     void (*reset)(struct render_backend *ctx);
     void (*screenshot)(struct render_backend *ctx, struct vo_frame *frame,
                        struct voctrl_screenshot *args);
+    void (*perfdata)(struct render_backend *ctx,
+                     struct voctrl_performance_data *out);
     // Like vo_driver.get_image().
     struct mp_image *(*get_image)(struct render_backend *ctx, int imgfmt,
                                   int w, int h, int stride_align);
diff -ruN mpv-0.29.1/video/out/opengl/common.c mpv-master/video/out/opengl/common.c
--- mpv-0.29.1/video/out/opengl/common.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/opengl/common.c	2019-09-19 04:02:03.000000000 +0700
@@ -262,6 +262,7 @@
     },
     {
         .ver_core = 320,
+        .ver_es_core = 300,
         .extension = "GL_ARB_sync",
         .functions = (const struct gl_function[]) {
             DEF_FN(FenceSync),
diff -ruN mpv-0.29.1/video/out/opengl/context.c mpv-master/video/out/opengl/context.c
--- mpv-0.29.1/video/out/opengl/context.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/opengl/context.c	2019-09-19 04:02:03.000000000 +0700
@@ -313,9 +313,18 @@
     }
 }
 
+static void ra_gl_ctx_get_vsync(struct ra_swapchain *sw,
+                                struct vo_vsync_info *info)
+{
+    struct priv *p = sw->priv;
+    if (p->params.get_vsync)
+        p->params.get_vsync(sw->ctx, info);
+}
+
 static const struct ra_swapchain_fns ra_gl_swapchain_fns = {
     .color_depth   = ra_gl_ctx_color_depth,
     .start_frame   = ra_gl_ctx_start_frame,
     .submit_frame  = ra_gl_ctx_submit_frame,
     .swap_buffers  = ra_gl_ctx_swap_buffers,
+    .get_vsync     = ra_gl_ctx_get_vsync,
 };
diff -ruN mpv-0.29.1/video/out/opengl/context.h mpv-master/video/out/opengl/context.h
--- mpv-0.29.1/video/out/opengl/context.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/opengl/context.h	2019-09-19 04:02:03.000000000 +0700
@@ -23,6 +23,9 @@
     // function or if you override it yourself.
     void (*swap_buffers)(struct ra_ctx *ctx);
 
+    // See ra_swapchain_fns.get_vsync.
+    void (*get_vsync)(struct ra_ctx *ctx, struct vo_vsync_info *info);
+
     // Set to false if the implementation follows normal GL semantics, which is
     // upside down. Set to true if it does *not*, i.e. if rendering is right
     // side up
diff -ruN mpv-0.29.1/video/out/opengl/context_drm_egl.c mpv-master/video/out/opengl/context_drm_egl.c
--- mpv-0.29.1/video/out/opengl/context_drm_egl.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/opengl/context_drm_egl.c	2019-09-19 04:02:03.000000000 +0700
@@ -46,12 +46,24 @@
     uint32_t id;
 };
 
+struct vsync_tuple
+{
+    uint64_t ust;
+    unsigned int msc;
+    unsigned int sbc;
+};
+
+struct gbm_frame {
+    struct gbm_bo *bo;
+    struct vsync_tuple vsync;
+};
+
 struct gbm
 {
     struct gbm_surface *surface;
     struct gbm_device *device;
-    struct gbm_bo *bo;
-    struct gbm_bo *next_bo;
+    struct gbm_frame **bo_queue;
+    unsigned int num_bos;
 };
 
 struct egl
@@ -72,6 +84,9 @@
     struct gbm gbm;
     struct framebuffer *fb;
 
+    GLsync *vsync_fences;
+    unsigned int num_vsync_fences;
+
     uint32_t gbm_format;
 
     bool active;
@@ -80,8 +95,19 @@
     bool vt_switcher_active;
     struct vt_switcher vt_switcher;
 
-    struct mpv_opengl_drm_params drm_params;
-    struct mpv_opengl_drm_osd_size osd_size;
+    bool still;
+    bool paused;
+
+    struct vsync_tuple vsync;
+    struct vo_vsync_info vsync_info;
+
+    struct mpv_opengl_drm_params_v2 drm_params;
+    struct mpv_opengl_drm_draw_surface_size draw_surface_size;
+};
+
+struct pflip_cb_closure {
+    struct priv *priv;
+    struct gbm_frame *frame;
 };
 
 // Not general. Limited to only the formats being used in this module
@@ -195,11 +221,11 @@
     }
 
     MP_VERBOSE(ctx->vo, "Initializing GBM surface (%d x %d)\n",
-        p->osd_size.width, p->osd_size.height);
+        p->draw_surface_size.width, p->draw_surface_size.height);
     p->gbm.surface = gbm_surface_create(
         p->gbm.device,
-        p->osd_size.width,
-        p->osd_size.height,
+        p->draw_surface_size.width,
+        p->draw_surface_size.height,
         p->gbm_format,
         GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING);
     if (!p->gbm.surface) {
@@ -280,16 +306,16 @@
         goto err;
     }
 
-    drm_object_set_property(request, atomic_ctx->osd_plane, "FB_ID", p->fb->id);
-    drm_object_set_property(request, atomic_ctx->osd_plane, "CRTC_ID", p->kms->crtc_id);
-    drm_object_set_property(request, atomic_ctx->osd_plane, "SRC_X",   0);
-    drm_object_set_property(request, atomic_ctx->osd_plane, "SRC_Y",   0);
-    drm_object_set_property(request, atomic_ctx->osd_plane, "SRC_W",   p->osd_size.width << 16);
-    drm_object_set_property(request, atomic_ctx->osd_plane, "SRC_H",   p->osd_size.height << 16);
-    drm_object_set_property(request, atomic_ctx->osd_plane, "CRTC_X",  0);
-    drm_object_set_property(request, atomic_ctx->osd_plane, "CRTC_Y",  0);
-    drm_object_set_property(request, atomic_ctx->osd_plane, "CRTC_W",  p->kms->mode.mode.hdisplay);
-    drm_object_set_property(request, atomic_ctx->osd_plane, "CRTC_H",  p->kms->mode.mode.vdisplay);
+    drm_object_set_property(request, atomic_ctx->draw_plane, "FB_ID", p->fb->id);
+    drm_object_set_property(request, atomic_ctx->draw_plane, "CRTC_ID", p->kms->crtc_id);
+    drm_object_set_property(request, atomic_ctx->draw_plane, "SRC_X",   0);
+    drm_object_set_property(request, atomic_ctx->draw_plane, "SRC_Y",   0);
+    drm_object_set_property(request, atomic_ctx->draw_plane, "SRC_W",   p->draw_surface_size.width << 16);
+    drm_object_set_property(request, atomic_ctx->draw_plane, "SRC_H",   p->draw_surface_size.height << 16);
+    drm_object_set_property(request, atomic_ctx->draw_plane, "CRTC_X",  0);
+    drm_object_set_property(request, atomic_ctx->draw_plane, "CRTC_Y",  0);
+    drm_object_set_property(request, atomic_ctx->draw_plane, "CRTC_W",  p->kms->mode.mode.hdisplay);
+    drm_object_set_property(request, atomic_ctx->draw_plane, "CRTC_H",  p->kms->mode.mode.vdisplay);
 
     int ret = drmModeAtomicCommit(p->kms->fd, request, DRM_MODE_ATOMIC_ALLOW_MODESET, NULL);
     if (ret)
@@ -355,15 +381,6 @@
         return;
     p->active = false;
 
-    // wait for current page flip
-    while (p->waiting_for_flip) {
-        int ret = drmHandleEvent(p->kms->fd, &p->ev);
-        if (ret) {
-            MP_ERR(ctx->vo, "drmHandleEvent failed: %i\n", ret);
-            break;
-        }
-    }
-
     if (p->kms->atomic_context) {
         if (p->kms->atomic_context->old_state.saved) {
             if (!crtc_release_atomic(ctx))
@@ -414,77 +431,182 @@
     crtc_setup(ctx);
 }
 
-static bool drm_atomic_egl_start_frame(struct ra_swapchain *sw, struct ra_fbo *out_fbo)
-{
-    struct priv *p = sw->ctx->priv;
-    if (p->kms->atomic_context) {
-        if (!p->kms->atomic_context->request) {
-            p->kms->atomic_context->request = drmModeAtomicAlloc();
-            p->drm_params.atomic_request_ptr = &p->kms->atomic_context->request;
-        }
-        return ra_gl_ctx_start_frame(sw, out_fbo);
-    }
-    return false;
-}
-
-static const struct ra_swapchain_fns drm_atomic_swapchain = {
-    .start_frame   = drm_atomic_egl_start_frame,
-};
-
-static void drm_egl_swap_buffers(struct ra_ctx *ctx)
+static void queue_flip(struct ra_ctx *ctx, struct gbm_frame *frame)
 {
     struct priv *p = ctx->priv;
     struct drm_atomic_context *atomic_ctx = p->kms->atomic_context;
     int ret;
 
-    if (!p->active)
-        return;
+    update_framebuffer_from_bo(ctx, frame->bo);
 
-    eglSwapBuffers(p->egl.display, p->egl.surface);
-    p->gbm.next_bo = gbm_surface_lock_front_buffer(p->gbm.surface);
-    p->waiting_for_flip = true;
-    update_framebuffer_from_bo(ctx, p->gbm.next_bo);
+    // Alloc and fill the data struct for the page flip callback
+    struct pflip_cb_closure *data = talloc(ctx, struct pflip_cb_closure);
+    data->priv = p;
+    data->frame = frame;
 
     if (atomic_ctx) {
-        drm_object_set_property(atomic_ctx->request, atomic_ctx->osd_plane, "FB_ID", p->fb->id);
-        drm_object_set_property(atomic_ctx->request, atomic_ctx->osd_plane, "CRTC_ID", atomic_ctx->crtc->id);
-        drm_object_set_property(atomic_ctx->request, atomic_ctx->osd_plane, "ZPOS", 1);
+        drm_object_set_property(atomic_ctx->request, atomic_ctx->draw_plane, "FB_ID", p->fb->id);
+        drm_object_set_property(atomic_ctx->request, atomic_ctx->draw_plane, "CRTC_ID", atomic_ctx->crtc->id);
+        drm_object_set_property(atomic_ctx->request, atomic_ctx->draw_plane, "ZPOS", 1);
 
         ret = drmModeAtomicCommit(p->kms->fd, atomic_ctx->request,
-                                  DRM_MODE_ATOMIC_NONBLOCK | DRM_MODE_PAGE_FLIP_EVENT, NULL);
-        if (ret)
+                                  DRM_MODE_ATOMIC_NONBLOCK | DRM_MODE_PAGE_FLIP_EVENT, data);
+        if (ret) {
             MP_WARN(ctx->vo, "Failed to commit atomic request (%d)\n", ret);
+            talloc_free(data);
+        }
     } else {
         ret = drmModePageFlip(p->kms->fd, p->kms->crtc_id, p->fb->id,
-                                  DRM_MODE_PAGE_FLIP_EVENT, p);
+                              DRM_MODE_PAGE_FLIP_EVENT, data);
         if (ret) {
             MP_WARN(ctx->vo, "Failed to queue page flip: %s\n", mp_strerror(errno));
+            talloc_free(data);
         }
     }
+    p->waiting_for_flip = true;
+
+    if (atomic_ctx) {
+        drmModeAtomicFree(atomic_ctx->request);
+        atomic_ctx->request = drmModeAtomicAlloc();
+    }
+}
+
+static void wait_on_flip(struct ra_ctx *ctx)
+{
+    struct priv *p = ctx->priv;
 
     // poll page flip finish event
-    const int timeout_ms = 3000;
-    struct pollfd fds[1] = { { .events = POLLIN, .fd = p->kms->fd } };
-    poll(fds, 1, timeout_ms);
-    if (fds[0].revents & POLLIN) {
-        ret = drmHandleEvent(p->kms->fd, &p->ev);
-        if (ret != 0) {
-            MP_ERR(ctx->vo, "drmHandleEvent failed: %i\n", ret);
-            p->waiting_for_flip = false;
-            return;
+    while (p->waiting_for_flip) {
+        const int timeout_ms = 3000;
+        struct pollfd fds[1] = { { .events = POLLIN, .fd = p->kms->fd } };
+        poll(fds, 1, timeout_ms);
+        if (fds[0].revents & POLLIN) {
+            const int ret = drmHandleEvent(p->kms->fd, &p->ev);
+            if (ret != 0)
+                MP_ERR(ctx->vo, "drmHandleEvent failed: %i\n", ret);
         }
     }
-    p->waiting_for_flip = false;
+}
 
-    if (atomic_ctx) {
-        drmModeAtomicFree(atomic_ctx->request);
-        atomic_ctx->request = drmModeAtomicAlloc();
+static void enqueue_bo(struct ra_ctx *ctx, struct gbm_bo *bo)
+{
+    struct priv *p = ctx->priv;
+
+    p->vsync.sbc++;
+    struct gbm_frame *new_frame = talloc(p, struct gbm_frame);
+    new_frame->bo = bo;
+    new_frame->vsync = p->vsync;
+    MP_TARRAY_APPEND(p, p->gbm.bo_queue, p->gbm.num_bos, new_frame);
+}
+
+static void dequeue_bo(struct ra_ctx *ctx)
+{
+    struct priv *p = ctx->priv;
+
+    talloc_free(p->gbm.bo_queue[0]);
+    MP_TARRAY_REMOVE_AT(p->gbm.bo_queue, p->gbm.num_bos, 0);
+}
+
+static void swapchain_step(struct ra_ctx *ctx)
+{
+    struct priv *p = ctx->priv;
+
+    if (!(p->gbm.num_bos > 0))
+        return;
+
+    if (p->gbm.bo_queue[0]->bo)
+        gbm_surface_release_buffer(p->gbm.surface, p->gbm.bo_queue[0]->bo);
+    dequeue_bo(ctx);
+}
+
+static void new_fence(struct ra_ctx *ctx)
+{
+    struct priv *p = ctx->priv;
+
+    if (p->gl.FenceSync) {
+        GLsync fence = p->gl.FenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
+        if (fence)
+            MP_TARRAY_APPEND(p, p->vsync_fences, p->num_vsync_fences, fence);
+    }
+}
+
+static void wait_fence(struct ra_ctx *ctx)
+{
+    struct priv *p = ctx->priv;
+
+    while (p->num_vsync_fences && (p->num_vsync_fences >= p->gbm.num_bos)) {
+        p->gl.ClientWaitSync(p->vsync_fences[0], GL_SYNC_FLUSH_COMMANDS_BIT, 1e9);
+        p->gl.DeleteSync(p->vsync_fences[0]);
+        MP_TARRAY_REMOVE_AT(p->vsync_fences, p->num_vsync_fences, 0);
+    }
+}
+
+static bool drm_egl_start_frame(struct ra_swapchain *sw, struct ra_fbo *out_fbo)
+{
+    struct ra_ctx *ctx = sw->ctx;
+    struct priv *p = ctx->priv;
+
+    if (p->kms->atomic_context && !p->kms->atomic_context->request) {
+        p->kms->atomic_context->request = drmModeAtomicAlloc();
+        p->drm_params.atomic_request_ptr = &p->kms->atomic_context->request;
+    }
+
+    return ra_gl_ctx_start_frame(sw, out_fbo);
+}
+
+static bool drm_egl_submit_frame(struct ra_swapchain *sw, const struct vo_frame *frame)
+{
+    struct ra_ctx *ctx = sw->ctx;
+    struct priv *p = ctx->priv;
+
+    p->still = frame->still;
+
+    return ra_gl_ctx_submit_frame(sw, frame);
+}
+
+static void drm_egl_swap_buffers(struct ra_swapchain *sw)
+{
+    struct ra_ctx *ctx = sw->ctx;
+    struct priv *p = ctx->priv;
+    const bool drain = p->paused || p->still;  // True when we need to drain the swapchain
+
+    if (!p->active)
+        return;
+
+    wait_fence(ctx);
+
+    eglSwapBuffers(p->egl.display, p->egl.surface);
+
+    struct gbm_bo *new_bo = gbm_surface_lock_front_buffer(p->gbm.surface);
+    if (!new_bo) {
+        MP_ERR(ctx->vo, "Couldn't lock front buffer\n");
+        return;
     }
+    enqueue_bo(ctx, new_bo);
+    new_fence(ctx);
 
-    gbm_surface_release_buffer(p->gbm.surface, p->gbm.bo);
-    p->gbm.bo = p->gbm.next_bo;
+    while (drain || p->gbm.num_bos > ctx->opts.swapchain_depth || !gbm_surface_has_free_buffers(p->gbm.surface)) {
+        if (p->waiting_for_flip) {
+            wait_on_flip(ctx);
+            swapchain_step(ctx);
+        }
+        if (p->gbm.num_bos <= 1)
+            break;
+        if (!p->gbm.bo_queue[1] || !p->gbm.bo_queue[1]->bo) {
+            MP_ERR(ctx->vo, "Hole in swapchain?\n");
+            swapchain_step(ctx);
+            continue;
+        }
+        queue_flip(ctx, p->gbm.bo_queue[1]);
+    }
 }
 
+static const struct ra_swapchain_fns drm_egl_swapchain = {
+    .start_frame   = drm_egl_start_frame,
+    .submit_frame  = drm_egl_submit_frame,
+    .swap_buffers  = drm_egl_swap_buffers,
+};
+
 static void drm_egl_uninit(struct ra_ctx *ctx)
 {
     struct priv *p = ctx->priv;
@@ -503,6 +625,12 @@
     if (p->vt_switcher_active)
         vt_switcher_destroy(&p->vt_switcher);
 
+    // According to GBM documentation all BO:s must be released before
+    // gbm_surface_destroy can be called on the surface.
+    while (p->gbm.num_bos) {
+        swapchain_step(ctx);
+    }
+
     eglMakeCurrent(p->egl.display, EGL_NO_SURFACE, EGL_NO_SURFACE,
                    EGL_NO_CONTEXT);
     eglDestroyContext(p->egl.display, p->egl.context);
@@ -521,24 +649,24 @@
     }
 }
 
-// If the OSD plane supports ARGB we want to use that, but if it doesn't we fall
-// back on XRGB. If the driver does not support atomic there is no particular
-// reason to be using ARGB (drmprime hwdec will not work without atomic,
-// anyway), so we fall back to XRGB (another reason is that we do not have the
-// convenient atomic_ctx and its convenient plane fields).
+// If the draw plane supports ARGB we want to use that, but if it doesn't we
+// fall back on XRGB. If we do not have atomic there is no particular reason to
+// be using ARGB (drmprime hwdec will not work without atomic, anyway), so we
+// fall back to XRGB (another reason is that we do not have the convenient
+// atomic_ctx and its convenient plane fields).
 static bool probe_gbm_format(struct ra_ctx *ctx, uint32_t argb_format, uint32_t xrgb_format)
 {
     struct priv *p = ctx->priv;
 
     if (!p->kms->atomic_context) {
         p->gbm_format = xrgb_format;
-        MP_VERBOSE(ctx->vo, "Not using DRM Atomic: Use %s for OSD plane.\n",
+        MP_VERBOSE(ctx->vo, "Not using DRM Atomic: Use %s for draw plane.\n",
                    gbm_format_to_string(xrgb_format));
         return true;
     }
 
     drmModePlane *drmplane =
-        drmModeGetPlane(p->kms->fd, p->kms->atomic_context->osd_plane->id);
+        drmModeGetPlane(p->kms->fd, p->kms->atomic_context->draw_plane->id);
     bool have_argb = false;
     bool have_xrgb = false;
     bool result = false;
@@ -552,11 +680,11 @@
 
     if (have_argb) {
         p->gbm_format = argb_format;
-        MP_VERBOSE(ctx->vo, "%s supported by OSD plane.\n", gbm_format_to_string(argb_format));
+        MP_VERBOSE(ctx->vo, "%s supported by draw plane.\n", gbm_format_to_string(argb_format));
         result = true;
     } else if (have_xrgb) {
         p->gbm_format = xrgb_format;
-        MP_VERBOSE(ctx->vo, "%s not supported by OSD plane: Falling back to %s.\n",
+        MP_VERBOSE(ctx->vo, "%s not supported by draw plane: Falling back to %s.\n",
                    gbm_format_to_string(argb_format), gbm_format_to_string(xrgb_format));
         result = true;
     }
@@ -565,6 +693,56 @@
     return result;
 }
 
+static void page_flipped(int fd, unsigned int msc, unsigned int sec,
+                         unsigned int usec, void *data)
+{
+    struct pflip_cb_closure *closure = data;
+    struct priv *p = closure->priv;
+
+    // frame->vsync.ust is the timestamp of the pageflip that happened just before this flip was queued
+    // frame->vsync.msc is the sequence number of the pageflip that happened just before this flip was queued
+    // frame->vsync.sbc is the sequence number for the frame that was just flipped to screen
+    struct gbm_frame *frame = closure->frame;
+
+    const bool ready =
+        (p->vsync.msc != 0) &&
+        (frame->vsync.ust != 0) && (frame->vsync.msc != 0);
+
+    const uint64_t ust = (sec * 1000000LL) + usec;
+
+    const unsigned int msc_since_last_flip = msc - p->vsync.msc;
+
+    p->vsync.ust = ust;
+    p->vsync.msc = msc;
+
+    if (ready) {
+        // Convert to mp_time
+        struct timespec ts;
+        if (clock_gettime(CLOCK_MONOTONIC, &ts))
+            goto fail;
+        const uint64_t now_monotonic = ts.tv_sec * 1000000LL + ts.tv_nsec / 1000;
+        const uint64_t ust_mp_time = mp_time_us() - (now_monotonic - p->vsync.ust);
+
+        const uint64_t     ust_since_enqueue = p->vsync.ust - frame->vsync.ust;
+        const unsigned int msc_since_enqueue = p->vsync.msc - frame->vsync.msc;
+        const unsigned int sbc_since_enqueue = p->vsync.sbc - frame->vsync.sbc;
+
+        p->vsync_info.vsync_duration = ust_since_enqueue / msc_since_enqueue;
+        p->vsync_info.skipped_vsyncs = msc_since_last_flip - 1; // Valid iff swap_buffers is called every vsync
+        p->vsync_info.last_queue_display_time = ust_mp_time + (sbc_since_enqueue * p->vsync_info.vsync_duration);
+    }
+
+fail:
+    p->waiting_for_flip = false;
+    talloc_free(closure);
+}
+
+static void drm_egl_get_vsync(struct ra_ctx *ctx, struct vo_vsync_info *info)
+{
+    struct priv *p = ctx->priv;
+    *info = p->vsync_info;
+}
+
 static bool drm_egl_init(struct ra_ctx *ctx)
 {
     if (ctx->opts.probing) {
@@ -574,6 +752,7 @@
 
     struct priv *p = ctx->priv = talloc_zero(ctx, struct priv);
     p->ev.version = DRM_EVENT_CONTEXT_VERSION;
+    p->ev.page_flip_handler = page_flipped;
 
     p->vt_switcher_active = vt_switcher_init(&p->vt_switcher, ctx->vo->log);
     if (p->vt_switcher_active) {
@@ -585,26 +764,27 @@
 
     MP_VERBOSE(ctx, "Initializing KMS\n");
     p->kms = kms_create(ctx->log, ctx->vo->opts->drm_opts->drm_connector_spec,
-                        ctx->vo->opts->drm_opts->drm_mode_id,
-                        ctx->vo->opts->drm_opts->drm_osd_plane_id,
-                        ctx->vo->opts->drm_opts->drm_video_plane_id);
+                        ctx->vo->opts->drm_opts->drm_mode_spec,
+                        ctx->vo->opts->drm_opts->drm_draw_plane,
+                        ctx->vo->opts->drm_opts->drm_drmprime_video_plane,
+                        ctx->vo->opts->drm_opts->drm_atomic);
     if (!p->kms) {
         MP_ERR(ctx, "Failed to create KMS.\n");
         return false;
     }
 
-    if (ctx->vo->opts->drm_opts->drm_osd_size.wh_valid) {
+    if (ctx->vo->opts->drm_opts->drm_draw_surface_size.wh_valid) {
         if (p->kms->atomic_context) {
-            p->osd_size.width = ctx->vo->opts->drm_opts->drm_osd_size.w;
-            p->osd_size.height = ctx->vo->opts->drm_opts->drm_osd_size.h;
+            p->draw_surface_size.width = ctx->vo->opts->drm_opts->drm_draw_surface_size.w;
+            p->draw_surface_size.height = ctx->vo->opts->drm_opts->drm_draw_surface_size.h;
         } else {
-            p->osd_size.width = p->kms->mode.mode.hdisplay;
-            p->osd_size.height = p->kms->mode.mode.vdisplay;
-            MP_WARN(ctx, "Setting OSD size is only available with DRM atomic, defaulting to screen resolution\n");
+            p->draw_surface_size.width = p->kms->mode.mode.hdisplay;
+            p->draw_surface_size.height = p->kms->mode.mode.vdisplay;
+            MP_WARN(ctx, "Setting draw plane size is only available with DRM atomic, defaulting to screen resolution\n");
         }
     } else {
-        p->osd_size.width = p->kms->mode.mode.hdisplay;
-        p->osd_size.height = p->kms->mode.mode.vdisplay;
+        p->draw_surface_size.width = p->kms->mode.mode.hdisplay;
+        p->draw_surface_size.height = p->kms->mode.mode.vdisplay;
     }
 
     uint32_t argb_format;
@@ -618,7 +798,7 @@
     }
 
     if (!probe_gbm_format(ctx, argb_format, xrgb_format)) {
-        MP_ERR(ctx->vo, "No suitable format found on DRM primary plane (tried: %s and %s).\n",
+        MP_ERR(ctx->vo, "No suitable format found on draw plane (tried: %s and %s).\n",
                gbm_format_to_string(argb_format), gbm_format_to_string(xrgb_format));
         return false;
     }
@@ -644,12 +824,13 @@
     eglSwapBuffers(p->egl.display, p->egl.surface);
 
     MP_VERBOSE(ctx, "Preparing framebuffer\n");
-    p->gbm.bo = gbm_surface_lock_front_buffer(p->gbm.surface);
-    if (!p->gbm.bo) {
+    struct gbm_bo *new_bo = gbm_surface_lock_front_buffer(p->gbm.surface);
+    if (!new_bo) {
         MP_ERR(ctx, "Failed to lock GBM surface.\n");
         return false;
     }
-    update_framebuffer_from_bo(ctx, p->gbm.bo);
+    enqueue_bo(ctx, new_bo);
+    update_framebuffer_from_bo(ctx, new_bo);
     if (!p->fb || !p->fb->id) {
         MP_ERR(ctx, "Failed to create framebuffer.\n");
         return false;
@@ -670,7 +851,7 @@
     if (rendernode_path) {
         MP_VERBOSE(ctx, "Opening render node \"%s\"\n", rendernode_path);
         p->drm_params.render_fd = open(rendernode_path, O_RDWR | O_CLOEXEC);
-        if (p->drm_params.render_fd < 0) {
+        if (p->drm_params.render_fd == -1) {
             MP_WARN(ctx, "Cannot open render node \"%s\": %s. VAAPI hwdec will be disabled\n",
                     rendernode_path, mp_strerror(errno));
         }
@@ -681,15 +862,18 @@
     }
 
     struct ra_gl_ctx_params params = {
-        .swap_buffers = drm_egl_swap_buffers,
-        .external_swapchain = p->kms->atomic_context ? &drm_atomic_swapchain :
-                                                       NULL,
+        .external_swapchain = &drm_egl_swapchain,
+        .get_vsync          = &drm_egl_get_vsync,
     };
     if (!ra_gl_ctx_init(ctx, &p->gl, params))
         return false;
 
-    ra_add_native_resource(ctx->ra, "drm_params", &p->drm_params);
-    ra_add_native_resource(ctx->ra, "drm_osd_size", &p->osd_size);
+    ra_add_native_resource(ctx->ra, "drm_params_v2", &p->drm_params);
+    ra_add_native_resource(ctx->ra, "drm_draw_surface_size", &p->draw_surface_size);
+
+    p->vsync_info.vsync_duration = 0;
+    p->vsync_info.skipped_vsyncs = -1;
+    p->vsync_info.last_queue_display_time = -1;
 
     return true;
 }
@@ -715,6 +899,17 @@
         *(double*)arg = fps;
         return VO_TRUE;
     }
+    case VOCTRL_PAUSE:
+        ctx->vo->want_redraw = true;
+        p->paused = true;
+        return VO_TRUE;
+    case VOCTRL_RESUME:
+        p->paused = false;
+        p->vsync_info.last_queue_display_time = -1;
+        p->vsync_info.skipped_vsyncs = 0;
+        p->vsync.ust = 0;
+        p->vsync.msc = 0;
+        return VO_TRUE;
     }
     return VO_NOTIMPL;
 }
diff -ruN mpv-0.29.1/video/out/opengl/context_glx.c mpv-master/video/out/opengl/context_glx.c
--- mpv-0.29.1/video/out/opengl/context_glx.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/opengl/context_glx.c	2019-09-19 04:02:03.000000000 +0700
@@ -37,8 +37,10 @@
 #define GLX_CONTEXT_ES2_PROFILE_BIT_EXT         0x00000004
 #endif
 
+#include "osdep/timer.h"
 #include "video/out/x11_common.h"
 #include "context.h"
+#include "oml_sync.h"
 #include "utils.h"
 
 struct priv {
@@ -46,6 +48,9 @@
     XVisualInfo *vinfo;
     GLXContext context;
     GLXFBConfig fbc;
+
+    Bool (*XGetSyncValues)(Display*, GLXDrawable, int64_t*, int64_t*, int64_t*);
+    struct oml_sync sync;
 };
 
 static void glx_uninit(struct ra_ctx *ctx)
@@ -161,6 +166,13 @@
 
     mpgl_load_functions(gl, (void *)glXGetProcAddressARB, glxstr, vo->log);
 
+    if (gl_check_extension(glxstr, "GLX_OML_sync_control")) {
+        p->XGetSyncValues =
+            (void *)glXGetProcAddressARB((const GLubyte *)"glXGetSyncValuesOML");
+    }
+    if (p->XGetSyncValues)
+        MP_VERBOSE(vo, "Using GLX_OML_sync_control.\n");
+
     return true;
 }
 
@@ -208,9 +220,34 @@
     }
 }
 
+static void update_vsync_oml(struct ra_ctx *ctx)
+{
+    struct priv *p = ctx->priv;
+
+    assert(p->XGetSyncValues);
+
+    int64_t ust, msc, sbc;
+    if (!p->XGetSyncValues(ctx->vo->x11->display, ctx->vo->x11->window,
+                           &ust, &msc, &sbc))
+        ust = msc = sbc = -1;
+
+    oml_sync_swap(&p->sync, ust, msc, sbc);
+}
+
 static void glx_swap_buffers(struct ra_ctx *ctx)
 {
+    struct priv *p = ctx->priv;
+
     glXSwapBuffers(ctx->vo->x11->display, ctx->vo->x11->window);
+
+    if (p->XGetSyncValues)
+        update_vsync_oml(ctx);
+}
+
+static void glx_get_vsync(struct ra_ctx *ctx, struct vo_vsync_info *info)
+{
+    struct priv *p = ctx->priv;
+    oml_sync_get_info(&p->sync, info);
 }
 
 static bool glx_init(struct ra_ctx *ctx)
@@ -296,6 +333,7 @@
 
     struct ra_gl_ctx_params params = {
         .swap_buffers = glx_swap_buffers,
+        .get_vsync    = glx_get_vsync,
     };
 
     if (!ra_gl_ctx_init(ctx, gl, params))
@@ -308,20 +346,6 @@
     return false;
 }
 
-static bool glx_init_probe(struct ra_ctx *ctx)
-{
-    if (!glx_init(ctx))
-        return false;
-
-    struct priv *p = ctx->priv;
-    if (!(p->gl.mpgl_caps & MPGL_CAP_VDPAU)) {
-        MP_VERBOSE(ctx, "No vdpau support found - probing more things.\n");
-        glx_uninit(ctx);
-        return false;
-    }
-
-    return true;
-}
 
 static void resize(struct ra_ctx *ctx)
 {
@@ -363,14 +387,3 @@
     .init           = glx_init,
     .uninit         = glx_uninit,
 };
-
-const struct ra_ctx_fns ra_ctx_glx_probe = {
-    .type           = "opengl",
-    .name           = "x11probe",
-    .reconfig       = glx_reconfig,
-    .control        = glx_control,
-    .wakeup         = glx_wakeup,
-    .wait_events    = glx_wait_events,
-    .init           = glx_init_probe,
-    .uninit         = glx_uninit,
-};
diff -ruN mpv-0.29.1/video/out/opengl/context_wayland.c mpv-master/video/out/opengl/context_wayland.c
--- mpv-0.29.1/video/out/opengl/context_wayland.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/opengl/context_wayland.c	2019-09-19 04:02:03.000000000 +0700
@@ -45,7 +45,9 @@
     const int32_t height = wl->scaling*mp_rect_h(wl->geometry);
 
     wl_surface_set_buffer_scale(wl->surface, wl->scaling);
-    wl_egl_window_resize(p->egl_window, width, height, 0, 0);
+
+    if (p->egl_window)
+        wl_egl_window_resize(p->egl_window, width, height, 0, 0);
 
     wl->vo->dwidth  = width;
     wl->vo->dheight = height;
diff -ruN mpv-0.29.1/video/out/opengl/context_x11egl.c mpv-master/video/out/opengl/context_x11egl.c
--- mpv-0.29.1/video/out/opengl/context_x11egl.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/opengl/context_x11egl.c	2019-09-19 04:02:03.000000000 +0700
@@ -30,12 +30,18 @@
 #include "video/out/x11_common.h"
 #include "context.h"
 #include "egl_helpers.h"
+#include "oml_sync.h"
+#include "utils.h"
 
 struct priv {
     GL gl;
     EGLDisplay egl_display;
     EGLContext egl_context;
     EGLSurface egl_surface;
+
+    EGLBoolean (*GetSyncValues)(EGLDisplay, EGLSurface,
+                                int64_t*, int64_t*, int64_t*);
+    struct oml_sync sync;
 };
 
 static void mpegl_uninit(struct ra_ctx *ctx)
@@ -79,6 +85,19 @@
 {
     struct priv *p = ctx->priv;
     eglSwapBuffers(p->egl_display, p->egl_surface);
+
+    int64_t ust, msc, sbc;
+    if (!p->GetSyncValues || !p->GetSyncValues(p->egl_display, p->egl_surface,
+                                               &ust, &msc, &sbc))
+        ust = msc = sbc = -1;
+
+    oml_sync_swap(&p->sync, ust, msc, sbc);
+}
+
+static void mpegl_get_vsync(struct ra_ctx *ctx, struct vo_vsync_info *info)
+{
+    struct priv *p = ctx->priv;
+    oml_sync_get_info(&p->sync, info);
 }
 
 static bool mpegl_init(struct ra_ctx *ctx)
@@ -142,11 +161,16 @@
 
     struct ra_gl_ctx_params params = {
         .swap_buffers = mpegl_swap_buffers,
+        .get_vsync    = mpegl_get_vsync,
     };
 
     if (!ra_gl_ctx_init(ctx, &p->gl, params))
         goto uninit;
 
+    const char *exts = eglQueryString(eglGetCurrentDisplay(), EGL_EXTENSIONS);
+    if (gl_check_extension(exts, "EGL_CHROMIUM_sync_control"))
+        p->GetSyncValues = (void *)eglGetProcAddress("eglGetSyncValuesCHROMIUM");
+
     ra_add_native_resource(ctx->ra, "x11", vo->x11->display);
 
     return true;
diff -ruN mpv-0.29.1/video/out/opengl/hwdec_cuda.c mpv-master/video/out/opengl/hwdec_cuda.c
--- mpv-0.29.1/video/out/opengl/hwdec_cuda.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/opengl/hwdec_cuda.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,350 +0,0 @@
-/*
- * Copyright (c) 2016 Philip Langdale <philipl@overt.org>
- *
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/*
- * This hwdec implements an optimized output path using CUDA->OpenGL
- * interop for frame data that is stored in CUDA device memory.
- * Although it is not explicit in the code here, the only practical way
- * to get data in this form is from the 'cuvid' decoder (aka NvDecode).
- *
- * For now, cuvid/NvDecode will always return images in NV12 format, even
- * when decoding 10bit streams (there is some hardware dithering going on).
- */
-
-#include <ffnvcodec/dynlink_loader.h>
-#include <libavutil/hwcontext.h>
-#include <libavutil/hwcontext_cuda.h>
-
-#include "video/out/gpu/hwdec.h"
-#include "formats.h"
-#include "options/m_config.h"
-#include "ra_gl.h"
-
-struct priv_owner {
-    struct mp_hwdec_ctx hwctx;
-    CudaFunctions *cu;
-    CUcontext display_ctx;
-    CUcontext decode_ctx;
-};
-
-struct priv {
-    struct mp_image layout;
-    CUgraphicsResource cu_res[4];
-    CUarray cu_array[4];
-
-    CUcontext display_ctx;
-};
-
-static int check_cu(struct ra_hwdec *hw, CUresult err, const char *func)
-{
-    const char *err_name;
-    const char *err_string;
-
-    struct priv_owner *p = hw->priv;
-
-    MP_TRACE(hw, "Calling %s\n", func);
-
-    if (err == CUDA_SUCCESS)
-        return 0;
-
-    p->cu->cuGetErrorName(err, &err_name);
-    p->cu->cuGetErrorString(err, &err_string);
-
-    MP_ERR(hw, "%s failed", func);
-    if (err_name && err_string)
-        MP_ERR(hw, " -> %s: %s", err_name, err_string);
-    MP_ERR(hw, "\n");
-
-    return -1;
-}
-
-#define CHECK_CU(x) check_cu(hw, (x), #x)
-
-static int cuda_init(struct ra_hwdec *hw)
-{
-    CUdevice display_dev;
-    AVBufferRef *hw_device_ctx = NULL;
-    CUcontext dummy;
-    unsigned int device_count;
-    int ret = 0;
-    struct priv_owner *p = hw->priv;
-    CudaFunctions *cu;
-
-    if (!ra_is_gl(hw->ra))
-        return -1;
-
-    GL *gl = ra_gl_get(hw->ra);
-    if (gl->version < 210 && gl->es < 300) {
-        MP_VERBOSE(hw, "need OpenGL >= 2.1 or OpenGL-ES >= 3.0\n");
-        return -1;
-    }
-
-    ret = cuda_load_functions(&p->cu, NULL);
-    if (ret != 0) {
-        MP_VERBOSE(hw, "Failed to load CUDA symbols\n");
-        return -1;
-    }
-    cu = p->cu;
-
-    ret = CHECK_CU(cu->cuInit(0));
-    if (ret < 0)
-        goto error;
-
-    // Allocate display context
-    ret = CHECK_CU(cu->cuGLGetDevices(&device_count, &display_dev, 1,
-                                      CU_GL_DEVICE_LIST_ALL));
-    if (ret < 0)
-        goto error;
-
-    ret = CHECK_CU(cu->cuCtxCreate(&p->display_ctx, CU_CTX_SCHED_BLOCKING_SYNC,
-                                   display_dev));
-    if (ret < 0)
-        goto error;
-
-    p->decode_ctx = p->display_ctx;
-
-    int decode_dev_idx = -1;
-    mp_read_option_raw(hw->global, "cuda-decode-device", &m_option_type_choice,
-                       &decode_dev_idx);
-
-    if (decode_dev_idx > -1) {
-        CUdevice decode_dev;
-        ret = CHECK_CU(cu->cuDeviceGet(&decode_dev, decode_dev_idx));
-        if (ret < 0)
-            goto error;
-
-        if (decode_dev != display_dev) {
-            MP_INFO(hw, "Using separate decoder and display devices\n");
-
-            // Pop the display context. We won't use it again during init()
-            ret = CHECK_CU(cu->cuCtxPopCurrent(&dummy));
-            if (ret < 0)
-                goto error;
-
-            ret = CHECK_CU(cu->cuCtxCreate(&p->decode_ctx, CU_CTX_SCHED_BLOCKING_SYNC,
-                                           decode_dev));
-            if (ret < 0)
-                goto error;
-        }
-    }
-
-    hw_device_ctx = av_hwdevice_ctx_alloc(AV_HWDEVICE_TYPE_CUDA);
-    if (!hw_device_ctx)
-        goto error;
-
-    AVHWDeviceContext *device_ctx = (void *)hw_device_ctx->data;
-
-    AVCUDADeviceContext *device_hwctx = device_ctx->hwctx;
-    device_hwctx->cuda_ctx = p->decode_ctx;
-
-    ret = av_hwdevice_ctx_init(hw_device_ctx);
-    if (ret < 0) {
-        MP_ERR(hw, "av_hwdevice_ctx_init failed\n");
-        goto error;
-    }
-
-    ret = CHECK_CU(cu->cuCtxPopCurrent(&dummy));
-    if (ret < 0)
-        goto error;
-
-    p->hwctx = (struct mp_hwdec_ctx) {
-        .driver_name = hw->driver->name,
-        .av_device_ref = hw_device_ctx,
-    };
-    hwdec_devices_add(hw->devs, &p->hwctx);
-    return 0;
-
- error:
-    av_buffer_unref(&hw_device_ctx);
-    CHECK_CU(cu->cuCtxPopCurrent(&dummy));
-
-    return -1;
-}
-
-static void cuda_uninit(struct ra_hwdec *hw)
-{
-    struct priv_owner *p = hw->priv;
-    CudaFunctions *cu = p->cu;
-
-    hwdec_devices_remove(hw->devs, &p->hwctx);
-    av_buffer_unref(&p->hwctx.av_device_ref);
-
-    if (p->decode_ctx && p->decode_ctx != p->display_ctx)
-        CHECK_CU(cu->cuCtxDestroy(p->decode_ctx));
-
-    if (p->display_ctx)
-        CHECK_CU(cu->cuCtxDestroy(p->display_ctx));
-
-    cuda_free_functions(&p->cu);
-}
-
-#undef CHECK_CU
-#define CHECK_CU(x) check_cu((mapper)->owner, (x), #x)
-
-static int mapper_init(struct ra_hwdec_mapper *mapper)
-{
-    struct priv_owner *p_owner = mapper->owner->priv;
-    struct priv *p = mapper->priv;
-    CUcontext dummy;
-    CudaFunctions *cu = p_owner->cu;
-    int ret = 0, eret = 0;
-
-    p->display_ctx = p_owner->display_ctx;
-
-    int imgfmt = mapper->src_params.hw_subfmt;
-    mapper->dst_params = mapper->src_params;
-    mapper->dst_params.imgfmt = imgfmt;
-    mapper->dst_params.hw_subfmt = 0;
-
-    mp_image_set_params(&p->layout, &mapper->dst_params);
-
-    struct ra_imgfmt_desc desc;
-    if (!ra_get_imgfmt_desc(mapper->ra, imgfmt, &desc)) {
-        MP_ERR(mapper, "Unsupported format: %s\n", mp_imgfmt_to_name(imgfmt));
-        return -1;
-    }
-
-    ret = CHECK_CU(cu->cuCtxPushCurrent(p->display_ctx));
-    if (ret < 0)
-        return ret;
-
-    for (int n = 0; n < desc.num_planes; n++) {
-        const struct ra_format *format = desc.planes[n];
-
-        struct ra_tex_params params = {
-            .dimensions = 2,
-            .w = mp_image_plane_w(&p->layout, n),
-            .h = mp_image_plane_h(&p->layout, n),
-            .d = 1,
-            .format = format,
-            .render_src = true,
-            .src_linear = format->linear_filter,
-        };
-
-        mapper->tex[n] = ra_tex_create(mapper->ra, &params);
-        if (!mapper->tex[n]) {
-            ret = -1;
-            goto error;
-        }
-
-        GLuint texture;
-        GLenum target;
-        ra_gl_get_raw_tex(mapper->ra, mapper->tex[n], &texture, &target);
-
-        ret = CHECK_CU(cu->cuGraphicsGLRegisterImage(&p->cu_res[n], texture, target,
-                                                     CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD));
-        if (ret < 0)
-            goto error;
-
-        ret = CHECK_CU(cu->cuGraphicsMapResources(1, &p->cu_res[n], 0));
-        if (ret < 0)
-            goto error;
-
-        ret = CHECK_CU(cu->cuGraphicsSubResourceGetMappedArray(&p->cu_array[n], p->cu_res[n],
-                                                               0, 0));
-        if (ret < 0)
-            goto error;
-
-        ret = CHECK_CU(cu->cuGraphicsUnmapResources(1, &p->cu_res[n], 0));
-        if (ret < 0)
-            goto error;
-    }
-
- error:
-    eret = CHECK_CU(cu->cuCtxPopCurrent(&dummy));
-    if (eret < 0)
-        return eret;
-
-    return ret;
-}
-
-static void mapper_uninit(struct ra_hwdec_mapper *mapper)
-{
-    struct priv *p = mapper->priv;
-    struct priv_owner *p_owner = mapper->owner->priv;
-    CudaFunctions *cu = p_owner->cu;
-    CUcontext dummy;
-
-    // Don't bail if any CUDA calls fail. This is all best effort.
-    CHECK_CU(cu->cuCtxPushCurrent(p->display_ctx));
-    for (int n = 0; n < 4; n++) {
-        if (p->cu_res[n] > 0)
-            CHECK_CU(cu->cuGraphicsUnregisterResource(p->cu_res[n]));
-        p->cu_res[n] = 0;
-        ra_tex_free(mapper->ra, &mapper->tex[n]);
-    }
-    CHECK_CU(cu->cuCtxPopCurrent(&dummy));
-}
-
-static void mapper_unmap(struct ra_hwdec_mapper *mapper)
-{
-}
-
-static int mapper_map(struct ra_hwdec_mapper *mapper)
-{
-    struct priv *p = mapper->priv;
-    struct priv_owner *p_owner = mapper->owner->priv;
-    CudaFunctions *cu = p_owner->cu;
-    CUcontext dummy;
-    int ret = 0, eret = 0;
-
-    ret = CHECK_CU(cu->cuCtxPushCurrent(p->display_ctx));
-    if (ret < 0)
-        return ret;
-
-    for (int n = 0; n < p->layout.num_planes; n++) {
-        CUDA_MEMCPY2D cpy = {
-            .srcMemoryType = CU_MEMORYTYPE_DEVICE,
-            .dstMemoryType = CU_MEMORYTYPE_ARRAY,
-            .srcDevice     = (CUdeviceptr)mapper->src->planes[n],
-            .srcPitch      = mapper->src->stride[n],
-            .srcY          = 0,
-            .dstArray      = p->cu_array[n],
-            .WidthInBytes  = mp_image_plane_w(&p->layout, n) *
-                             mapper->tex[n]->params.format->pixel_size,
-            .Height        = mp_image_plane_h(&p->layout, n),
-        };
-        ret = CHECK_CU(cu->cuMemcpy2D(&cpy));
-        if (ret < 0)
-            goto error;
-    }
-
-
- error:
-   eret = CHECK_CU(cu->cuCtxPopCurrent(&dummy));
-   if (eret < 0)
-       return eret;
-
-   return ret;
-}
-
-const struct ra_hwdec_driver ra_hwdec_cuda = {
-    .name = "cuda-nvdec",
-    .imgfmts = {IMGFMT_CUDA, 0},
-    .priv_size = sizeof(struct priv_owner),
-    .init = cuda_init,
-    .uninit = cuda_uninit,
-    .mapper = &(const struct ra_hwdec_mapper_driver){
-        .priv_size = sizeof(struct priv),
-        .init = mapper_init,
-        .uninit = mapper_uninit,
-        .map = mapper_map,
-        .unmap = mapper_unmap,
-    },
-};
diff -ruN mpv-0.29.1/video/out/opengl/hwdec_drmprime_drm.c mpv-master/video/out/opengl/hwdec_drmprime_drm.c
--- mpv-0.29.1/video/out/opengl/hwdec_drmprime_drm.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/opengl/hwdec_drmprime_drm.c	2019-09-19 04:02:03.000000000 +0700
@@ -114,14 +114,17 @@
     if (!p->ctx)
         return;
 
-    // Disabling video plane is needed on some devices when using the
-    // primary plane for video. Primary buffer can't be active with no
-    // framebuffer associated. So we need this function to commit it
-    // right away as mpv will free all framebuffers on playback end.
+    if (!p->ctx->drmprime_video_plane)
+        return;
+
+    // Disabling the drmprime video plane is needed on some devices when using
+    // the primary plane for video. Primary buffer can't be active with no
+    // framebuffer associated. So we need this function to commit it right away
+    // as mpv will free all framebuffers on playback end.
     drmModeAtomicReqPtr request = drmModeAtomicAlloc();
     if (request) {
-        drm_object_set_property(request, p->ctx->video_plane, "FB_ID", 0);
-        drm_object_set_property(request, p->ctx->video_plane, "CRTC_ID", 0);
+        drm_object_set_property(request, p->ctx->drmprime_video_plane, "FB_ID", 0);
+        drm_object_set_property(request, p->ctx->drmprime_video_plane, "CRTC_ID", 0);
 
         int ret = drmModeAtomicCommit(p->ctx->fd, request,
                                   DRM_MODE_ATOMIC_NONBLOCK, NULL);
@@ -143,8 +146,8 @@
 
     // grab atomic request from native resources
     if (p->ctx) {
-        struct mpv_opengl_drm_params *drm_params;
-        drm_params = (mpv_opengl_drm_params *)ra_get_native_resource(hw->ra, "drm_params");
+        struct mpv_opengl_drm_params_v2 *drm_params;
+        drm_params = (mpv_opengl_drm_params_v2 *)ra_get_native_resource(hw->ra, "drm_params_v2");
         if (!drm_params) {
             MP_ERR(hw, "Failed to retrieve drm params from native resources\n");
             return -1;
@@ -159,11 +162,11 @@
 
     if (hw_image) {
 
-        // grab osd windowing info to eventually upscale the overlay
-        // as egl windows could be upscaled to osd plane.
-        struct mpv_opengl_drm_osd_size *osd_size = ra_get_native_resource(hw->ra, "drm_osd_size");
-        if (osd_size) {
-            scale_dst_rect(hw, osd_size->width, osd_size->height, dst, &p->dst);
+        // grab draw plane windowing info to eventually upscale the overlay
+        // as egl windows could be upscaled to draw plane.
+        struct mpv_opengl_drm_draw_surface_size *draw_surface_size = ra_get_native_resource(hw->ra, "drm_draw_surface_size");
+        if (draw_surface_size) {
+            scale_dst_rect(hw, draw_surface_size->width, draw_surface_size->height, dst, &p->dst);
         } else {
             p->dst = *dst;
         }
@@ -184,24 +187,24 @@
             }
 
             if (request) {
-                drm_object_set_property(request, p->ctx->video_plane, "FB_ID", next_frame.fb.fb_id);
-                drm_object_set_property(request,  p->ctx->video_plane, "CRTC_ID", p->ctx->crtc->id);
-                drm_object_set_property(request,  p->ctx->video_plane, "SRC_X",   p->src.x0 << 16);
-                drm_object_set_property(request,  p->ctx->video_plane, "SRC_Y",   p->src.y0 << 16);
-                drm_object_set_property(request,  p->ctx->video_plane, "SRC_W",   srcw << 16);
-                drm_object_set_property(request,  p->ctx->video_plane, "SRC_H",   srch << 16);
-                drm_object_set_property(request,  p->ctx->video_plane, "CRTC_X",  MP_ALIGN_DOWN(p->dst.x0, 2));
-                drm_object_set_property(request,  p->ctx->video_plane, "CRTC_Y",  MP_ALIGN_DOWN(p->dst.y0, 2));
-                drm_object_set_property(request,  p->ctx->video_plane, "CRTC_W",  dstw);
-                drm_object_set_property(request,  p->ctx->video_plane, "CRTC_H",  dsth);
-                drm_object_set_property(request,  p->ctx->video_plane, "ZPOS",    0);
+                drm_object_set_property(request, p->ctx->drmprime_video_plane, "FB_ID", next_frame.fb.fb_id);
+                drm_object_set_property(request, p->ctx->drmprime_video_plane, "CRTC_ID", p->ctx->crtc->id);
+                drm_object_set_property(request, p->ctx->drmprime_video_plane, "SRC_X",   p->src.x0 << 16);
+                drm_object_set_property(request, p->ctx->drmprime_video_plane, "SRC_Y",   p->src.y0 << 16);
+                drm_object_set_property(request, p->ctx->drmprime_video_plane, "SRC_W",   srcw << 16);
+                drm_object_set_property(request, p->ctx->drmprime_video_plane, "SRC_H",   srch << 16);
+                drm_object_set_property(request, p->ctx->drmprime_video_plane, "CRTC_X",  MP_ALIGN_DOWN(p->dst.x0, 2));
+                drm_object_set_property(request, p->ctx->drmprime_video_plane, "CRTC_Y",  MP_ALIGN_DOWN(p->dst.y0, 2));
+                drm_object_set_property(request, p->ctx->drmprime_video_plane, "CRTC_W",  dstw);
+                drm_object_set_property(request, p->ctx->drmprime_video_plane, "CRTC_H",  dsth);
+                drm_object_set_property(request, p->ctx->drmprime_video_plane, "ZPOS",    0);
             } else {
-                ret = drmModeSetPlane(p->ctx->fd, p->ctx->video_plane->id, p->ctx->crtc->id, next_frame.fb.fb_id, 0,
+                ret = drmModeSetPlane(p->ctx->fd, p->ctx->drmprime_video_plane->id, p->ctx->crtc->id, next_frame.fb.fb_id, 0,
                                       MP_ALIGN_DOWN(p->dst.x0, 2), MP_ALIGN_DOWN(p->dst.y0, 2), dstw, dsth,
                                       p->src.x0 << 16, p->src.y0 << 16 , srcw << 16, srch << 16);
                 if (ret < 0) {
-                    MP_ERR(hw, "Failed to set the plane %d (buffer %d).\n", p->ctx->video_plane->id,
-                                next_frame.fb.fb_id);
+                    MP_ERR(hw, "Failed to set the drmprime video plane %d (buffer %d).\n",
+                           p->ctx->drmprime_video_plane->id, next_frame.fb.fb_id);
                     goto fail;
                 }
             }
@@ -237,28 +240,28 @@
 static int init(struct ra_hwdec *hw)
 {
     struct priv *p = hw->priv;
-    int osd_plane_id, video_plane_id;
+    int draw_plane, drmprime_video_plane;
 
     p->log = hw->log;
 
     void *tmp = talloc_new(NULL);
     struct drm_opts *opts = mp_get_config_group(tmp, hw->global, &drm_conf);
-    osd_plane_id = opts->drm_osd_plane_id;
-    video_plane_id = opts->drm_video_plane_id;
+    draw_plane = opts->drm_draw_plane;
+    drmprime_video_plane = opts->drm_drmprime_video_plane;
     talloc_free(tmp);
 
-    struct mpv_opengl_drm_params *drm_params;
+    struct mpv_opengl_drm_params_v2 *drm_params;
 
-    drm_params = ra_get_native_resource(hw->ra, "drm_params");
+    drm_params = ra_get_native_resource(hw->ra, "drm_params_v2");
     if (drm_params) {
         p->ctx = drm_atomic_create_context(p->log, drm_params->fd, drm_params->crtc_id,
-                                           drm_params->connector_id, osd_plane_id, video_plane_id);
+                                           drm_params->connector_id, draw_plane, drmprime_video_plane);
         if (!p->ctx) {
             mp_err(p->log, "Failed to retrieve DRM atomic context.\n");
             goto err;
         }
-        if (!p->ctx->video_plane) {
-            mp_warn(p->log, "No video plane. You might need to specify it manually using --drm-video-plane-id\n");
+        if (!p->ctx->drmprime_video_plane) {
+            mp_warn(p->log, "No drmprime video plane. You might need to specify it manually using --drm-drmprime-video-plane\n");
             goto err;
         }
     } else {
diff -ruN mpv-0.29.1/video/out/opengl/hwdec_vaegl.c mpv-master/video/out/opengl/hwdec_vaegl.c
--- mpv-0.29.1/video/out/opengl/hwdec_vaegl.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/opengl/hwdec_vaegl.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,558 +0,0 @@
-/*
- * This file is part of mpv.
- *
- * mpv is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * mpv is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stddef.h>
-#include <string.h>
-#include <assert.h>
-#include <unistd.h>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-
-#include <va/va_drmcommon.h>
-
-#include <libavutil/common.h>
-#include <libavutil/hwcontext.h>
-#include <libavutil/hwcontext_vaapi.h>
-
-#include "config.h"
-
-#include "video/out/gpu/hwdec.h"
-#include "video/mp_image_pool.h"
-#include "video/vaapi.h"
-#include "common.h"
-#include "ra_gl.h"
-#include "libmpv/render_gl.h"
-
-#ifndef GL_OES_EGL_image
-typedef void* GLeglImageOES;
-#endif
-#ifndef EGL_KHR_image
-typedef void *EGLImageKHR;
-#endif
-
-#ifndef EGL_LINUX_DMA_BUF_EXT
-#define EGL_LINUX_DMA_BUF_EXT             0x3270
-#define EGL_LINUX_DRM_FOURCC_EXT          0x3271
-#define EGL_DMA_BUF_PLANE0_FD_EXT         0x3272
-#define EGL_DMA_BUF_PLANE0_OFFSET_EXT     0x3273
-#define EGL_DMA_BUF_PLANE0_PITCH_EXT      0x3274
-#endif
-
-#if HAVE_VAAPI_X11
-#include <va/va_x11.h>
-
-static VADisplay *create_x11_va_display(struct ra *ra)
-{
-    Display *x11 = ra_get_native_resource(ra, "x11");
-    return x11 ? vaGetDisplay(x11) : NULL;
-}
-#endif
-
-#if HAVE_VAAPI_WAYLAND
-#include <va/va_wayland.h>
-
-static VADisplay *create_wayland_va_display(struct ra *ra)
-{
-    struct wl_display *wl = ra_get_native_resource(ra, "wl");
-    return wl ? vaGetDisplayWl(wl) : NULL;
-}
-#endif
-
-#if HAVE_VAAPI_DRM
-#include <va/va_drm.h>
-
-static VADisplay *create_drm_va_display(struct ra *ra)
-{
-    mpv_opengl_drm_params *params = ra_get_native_resource(ra, "drm_params");
-    if (!params || params->render_fd < 0)
-        return NULL;
-
-    return vaGetDisplayDRM(params->render_fd);
-}
-#endif
-
-struct va_create_native {
-    const char *name;
-    VADisplay *(*create)(struct ra *ra);
-};
-
-static const struct va_create_native create_native_cbs[] = {
-#if HAVE_VAAPI_X11
-    {"x11",     create_x11_va_display},
-#endif
-#if HAVE_VAAPI_WAYLAND
-    {"wayland", create_wayland_va_display},
-#endif
-#if HAVE_VAAPI_DRM
-    {"drm",     create_drm_va_display},
-#endif
-};
-
-static VADisplay *create_native_va_display(struct ra *ra, struct mp_log *log)
-{
-    for (int n = 0; n < MP_ARRAY_SIZE(create_native_cbs); n++) {
-        const struct va_create_native *disp = &create_native_cbs[n];
-        mp_verbose(log, "Trying to open a %s VA display...\n", disp->name);
-        VADisplay *display = disp->create(ra);
-        if (display)
-            return display;
-    }
-    return NULL;
-}
-
-struct priv_owner {
-    struct mp_vaapi_ctx *ctx;
-    VADisplay *display;
-    int *formats;
-    bool probing_formats; // temporary during init
-};
-
-struct priv {
-    int num_planes;
-    struct ra_tex *tex[4];
-    GLuint gl_textures[4];
-    EGLImageKHR images[4];
-    VAImage current_image;
-    bool buffer_acquired;
-#if VA_CHECK_VERSION(1, 1, 0)
-    bool esh_not_implemented;
-    VADRMPRIMESurfaceDescriptor desc;
-    bool surface_acquired;
-#endif
-
-    EGLImageKHR (EGLAPIENTRY *CreateImageKHR)(EGLDisplay, EGLContext,
-                                              EGLenum, EGLClientBuffer,
-                                              const EGLint *);
-    EGLBoolean (EGLAPIENTRY *DestroyImageKHR)(EGLDisplay, EGLImageKHR);
-    void (EGLAPIENTRY *EGLImageTargetTexture2DOES)(GLenum, GLeglImageOES);
-};
-
-static void determine_working_formats(struct ra_hwdec *hw);
-
-static void uninit(struct ra_hwdec *hw)
-{
-    struct priv_owner *p = hw->priv;
-    if (p->ctx)
-        hwdec_devices_remove(hw->devs, &p->ctx->hwctx);
-    va_destroy(p->ctx);
-}
-
-static int init(struct ra_hwdec *hw)
-{
-    struct priv_owner *p = hw->priv;
-
-    if (!ra_is_gl(hw->ra) || !eglGetCurrentContext())
-        return -1;
-
-    const char *exts = eglQueryString(eglGetCurrentDisplay(), EGL_EXTENSIONS);
-    if (!exts)
-        return -1;
-
-    GL *gl = ra_gl_get(hw->ra);
-    if (!strstr(exts, "EXT_image_dma_buf_import") ||
-        !strstr(exts, "EGL_KHR_image_base") ||
-        !strstr(gl->extensions, "GL_OES_EGL_image") ||
-        !(gl->mpgl_caps & MPGL_CAP_TEX_RG))
-        return -1;
-
-    p->display = create_native_va_display(hw->ra, hw->log);
-    if (!p->display) {
-        MP_VERBOSE(hw, "Could not create a VA display.\n");
-        return -1;
-    }
-
-    p->ctx = va_initialize(p->display, hw->log, true);
-    if (!p->ctx) {
-        vaTerminate(p->display);
-        return -1;
-    }
-    if (!p->ctx->av_device_ref) {
-        MP_VERBOSE(hw, "libavutil vaapi code rejected the driver?\n");
-        return -1;
-    }
-
-    if (hw->probing && va_guess_if_emulated(p->ctx)) {
-        return -1;
-    }
-
-    MP_VERBOSE(hw, "using VAAPI EGL interop\n");
-
-    determine_working_formats(hw);
-    if (!p->formats || !p->formats[0]) {
-        return -1;
-    }
-
-    p->ctx->hwctx.supported_formats = p->formats;
-    p->ctx->hwctx.driver_name = hw->driver->name;
-    hwdec_devices_add(hw->devs, &p->ctx->hwctx);
-    return 0;
-}
-
-static void mapper_unmap(struct ra_hwdec_mapper *mapper)
-{
-    struct priv_owner *p_owner = mapper->owner->priv;
-    VADisplay *display = p_owner->display;
-    struct priv *p = mapper->priv;
-    VAStatus status;
-
-    for (int n = 0; n < 4; n++) {
-        if (p->images[n])
-            p->DestroyImageKHR(eglGetCurrentDisplay(), p->images[n]);
-        p->images[n] = 0;
-    }
-
-#if VA_CHECK_VERSION(1, 1, 0)
-    if (p->surface_acquired) {
-        for (int n = 0; n < p->desc.num_objects; n++)
-            close(p->desc.objects[n].fd);
-        p->surface_acquired = false;
-    }
-#endif
-
-    if (p->buffer_acquired) {
-        status = vaReleaseBufferHandle(display, p->current_image.buf);
-        CHECK_VA_STATUS(mapper, "vaReleaseBufferHandle()");
-        p->buffer_acquired = false;
-    }
-    if (p->current_image.image_id != VA_INVALID_ID) {
-        status = vaDestroyImage(display, p->current_image.image_id);
-        CHECK_VA_STATUS(mapper, "vaDestroyImage()");
-        p->current_image.image_id = VA_INVALID_ID;
-    }
-}
-
-static void mapper_uninit(struct ra_hwdec_mapper *mapper)
-{
-    struct priv *p = mapper->priv;
-    GL *gl = ra_gl_get(mapper->ra);
-
-    gl->DeleteTextures(4, p->gl_textures);
-    for (int n = 0; n < 4; n++) {
-        p->gl_textures[n] = 0;
-        ra_tex_free(mapper->ra, &p->tex[n]);
-    }
-}
-
-static bool check_fmt(struct ra_hwdec_mapper *mapper, int fmt)
-{
-    struct priv_owner *p_owner = mapper->owner->priv;
-    for (int n = 0; p_owner->formats && p_owner->formats[n]; n++) {
-        if (p_owner->formats[n] == fmt)
-            return true;
-    }
-    return false;
-}
-
-static int mapper_init(struct ra_hwdec_mapper *mapper)
-{
-    struct priv_owner *p_owner = mapper->owner->priv;
-    struct priv *p = mapper->priv;
-    GL *gl = ra_gl_get(mapper->ra);
-
-    p->current_image.buf = p->current_image.image_id = VA_INVALID_ID;
-
-    // EGL_KHR_image_base
-    p->CreateImageKHR = (void *)eglGetProcAddress("eglCreateImageKHR");
-    p->DestroyImageKHR = (void *)eglGetProcAddress("eglDestroyImageKHR");
-    // GL_OES_EGL_image
-    p->EGLImageTargetTexture2DOES =
-        (void *)eglGetProcAddress("glEGLImageTargetTexture2DOES");
-
-    if (!p->CreateImageKHR || !p->DestroyImageKHR ||
-        !p->EGLImageTargetTexture2DOES)
-        return -1;
-
-    mapper->dst_params = mapper->src_params;
-    mapper->dst_params.imgfmt = mapper->src_params.hw_subfmt;
-    mapper->dst_params.hw_subfmt = 0;
-
-    struct ra_imgfmt_desc desc = {0};
-    struct mp_image layout = {0};
-
-    if (!ra_get_imgfmt_desc(mapper->ra, mapper->dst_params.imgfmt, &desc))
-        return -1;
-
-    p->num_planes = desc.num_planes;
-    mp_image_set_params(&layout, &mapper->dst_params);
-
-    gl->GenTextures(4, p->gl_textures);
-    for (int n = 0; n < desc.num_planes; n++) {
-        gl->BindTexture(GL_TEXTURE_2D, p->gl_textures[n]);
-        gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-        gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-        gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-        gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-        gl->BindTexture(GL_TEXTURE_2D, 0);
-
-        struct ra_tex_params params = {
-            .dimensions = 2,
-            .w = mp_image_plane_w(&layout, n),
-            .h = mp_image_plane_h(&layout, n),
-            .d = 1,
-            .format = desc.planes[n],
-            .render_src = true,
-            .src_linear = true,
-        };
-
-        if (params.format->ctype != RA_CTYPE_UNORM)
-            return -1;
-
-        p->tex[n] = ra_create_wrapped_tex(mapper->ra, &params,
-                                          p->gl_textures[n]);
-        if (!p->tex[n])
-            return -1;
-    }
-
-    if (!p_owner->probing_formats && !check_fmt(mapper, mapper->dst_params.imgfmt))
-    {
-        MP_FATAL(mapper, "unsupported VA image format %s\n",
-                 mp_imgfmt_to_name(mapper->dst_params.imgfmt));
-        return -1;
-    }
-
-    return 0;
-}
-
-#define ADD_ATTRIB(name, value)                         \
-    do {                                                \
-    assert(num_attribs + 3 < MP_ARRAY_SIZE(attribs));   \
-    attribs[num_attribs++] = (name);                    \
-    attribs[num_attribs++] = (value);                   \
-    attribs[num_attribs] = EGL_NONE;                    \
-    } while(0)
-
-static int mapper_map(struct ra_hwdec_mapper *mapper)
-{
-    struct priv_owner *p_owner = mapper->owner->priv;
-    struct priv *p = mapper->priv;
-    GL *gl = ra_gl_get(mapper->ra);
-    VAStatus status;
-    VAImage *va_image = &p->current_image;
-    VADisplay *display = p_owner->display;
-
-#if VA_CHECK_VERSION(1, 1, 0)
-    if (p->esh_not_implemented)
-        goto esh_failed;
-
-    status = vaExportSurfaceHandle(display, va_surface_id(mapper->src),
-                                   VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME_2,
-                                   VA_EXPORT_SURFACE_READ_ONLY |
-                                   VA_EXPORT_SURFACE_SEPARATE_LAYERS,
-                                   &p->desc);
-    if (!CHECK_VA_STATUS(mapper, "vaAcquireSurfaceHandle()")) {
-        if (status == VA_STATUS_ERROR_UNIMPLEMENTED)
-            p->esh_not_implemented = true;
-        goto esh_failed;
-    }
-    p->surface_acquired = true;
-
-    for (int n = 0; n < p->num_planes; n++) {
-        int attribs[20] = {EGL_NONE};
-        int num_attribs = 0;
-
-        ADD_ATTRIB(EGL_LINUX_DRM_FOURCC_EXT, p->desc.layers[n].drm_format);
-        ADD_ATTRIB(EGL_WIDTH,  p->tex[n]->params.w);
-        ADD_ATTRIB(EGL_HEIGHT, p->tex[n]->params.h);
-
-#define ADD_PLANE_ATTRIBS(plane) do { \
-            ADD_ATTRIB(EGL_DMA_BUF_PLANE ## plane ## _FD_EXT, \
-                       p->desc.objects[p->desc.layers[n].object_index[plane]].fd); \
-            ADD_ATTRIB(EGL_DMA_BUF_PLANE ## plane ## _OFFSET_EXT, \
-                       p->desc.layers[n].offset[plane]); \
-            ADD_ATTRIB(EGL_DMA_BUF_PLANE ## plane ## _PITCH_EXT, \
-                       p->desc.layers[n].pitch[plane]); \
-        } while (0)
-
-        ADD_PLANE_ATTRIBS(0);
-        if (p->desc.layers[n].num_planes > 1)
-            ADD_PLANE_ATTRIBS(1);
-        if (p->desc.layers[n].num_planes > 2)
-            ADD_PLANE_ATTRIBS(2);
-        if (p->desc.layers[n].num_planes > 3)
-            ADD_PLANE_ATTRIBS(3);
-
-        p->images[n] = p->CreateImageKHR(eglGetCurrentDisplay(),
-            EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, NULL, attribs);
-        if (!p->images[n])
-            goto esh_failed;
-
-        gl->BindTexture(GL_TEXTURE_2D, p->gl_textures[n]);
-        p->EGLImageTargetTexture2DOES(GL_TEXTURE_2D, p->images[n]);
-
-        mapper->tex[n] = p->tex[n];
-    }
-    gl->BindTexture(GL_TEXTURE_2D, 0);
-
-    if (p->desc.fourcc == VA_FOURCC_YV12)
-        MPSWAP(struct ra_tex*, mapper->tex[1], mapper->tex[2]);
-
-    return 0;
-
-esh_failed:
-    if (p->surface_acquired) {
-        for (int n = 0; n < p->desc.num_objects; n++)
-            close(p->desc.objects[n].fd);
-        p->surface_acquired = false;
-    }
-#endif
-
-    status = vaDeriveImage(display, va_surface_id(mapper->src), va_image);
-    if (!CHECK_VA_STATUS(mapper, "vaDeriveImage()"))
-        goto err;
-
-    VABufferInfo buffer_info = {.mem_type = VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME};
-    status = vaAcquireBufferHandle(display, va_image->buf, &buffer_info);
-    if (!CHECK_VA_STATUS(mapper, "vaAcquireBufferHandle()"))
-        goto err;
-    p->buffer_acquired = true;
-
-    int drm_fmts[8] = {
-        // 1 bytes per component, 1-4 components
-        MKTAG('R', '8', ' ', ' '),       // DRM_FORMAT_R8
-        MKTAG('G', 'R', '8', '8'),       // DRM_FORMAT_GR88
-        0,                               // untested (DRM_FORMAT_RGB888?)
-        0,                               // untested (DRM_FORMAT_RGBA8888?)
-        // 2 bytes per component, 1-4 components
-        MKTAG('R', '1', '6', ' '),       // proposed DRM_FORMAT_R16
-        MKTAG('G', 'R', '3', '2'),       // proposed DRM_FORMAT_GR32
-        0,                               // N/A
-        0,                               // N/A
-    };
-
-    for (int n = 0; n < p->num_planes; n++) {
-        int attribs[20] = {EGL_NONE};
-        int num_attribs = 0;
-
-        const struct ra_format *fmt = p->tex[n]->params.format;
-        int n_comp = fmt->num_components;
-        int comp_s = fmt->component_size[n] / 8;
-        if (n_comp < 1 || n_comp > 3 || comp_s < 1 || comp_s > 2)
-            goto err;
-        int drm_fmt = drm_fmts[n_comp - 1 + (comp_s - 1) * 4];
-        if (!drm_fmt)
-            goto err;
-
-        ADD_ATTRIB(EGL_LINUX_DRM_FOURCC_EXT, drm_fmt);
-        ADD_ATTRIB(EGL_WIDTH, p->tex[n]->params.w);
-        ADD_ATTRIB(EGL_HEIGHT, p->tex[n]->params.h);
-        ADD_ATTRIB(EGL_DMA_BUF_PLANE0_FD_EXT, buffer_info.handle);
-        ADD_ATTRIB(EGL_DMA_BUF_PLANE0_OFFSET_EXT, va_image->offsets[n]);
-        ADD_ATTRIB(EGL_DMA_BUF_PLANE0_PITCH_EXT, va_image->pitches[n]);
-
-        p->images[n] = p->CreateImageKHR(eglGetCurrentDisplay(),
-            EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, NULL, attribs);
-        if (!p->images[n])
-            goto err;
-
-        gl->BindTexture(GL_TEXTURE_2D, p->gl_textures[n]);
-        p->EGLImageTargetTexture2DOES(GL_TEXTURE_2D, p->images[n]);
-
-        mapper->tex[n] = p->tex[n];
-    }
-    gl->BindTexture(GL_TEXTURE_2D, 0);
-
-    if (va_image->format.fourcc == VA_FOURCC_YV12)
-        MPSWAP(struct ra_tex*, mapper->tex[1], mapper->tex[2]);
-
-    return 0;
-
-err:
-    if (!p_owner->probing_formats)
-        MP_FATAL(mapper, "mapping VAAPI EGL image failed\n");
-    return -1;
-}
-
-static bool try_format(struct ra_hwdec *hw, struct mp_image *surface)
-{
-    bool ok = false;
-    struct ra_hwdec_mapper *mapper = ra_hwdec_mapper_create(hw, &surface->params);
-    if (mapper)
-        ok = ra_hwdec_mapper_map(mapper, surface) >= 0;
-    ra_hwdec_mapper_free(&mapper);
-    return ok;
-}
-
-static void determine_working_formats(struct ra_hwdec *hw)
-{
-    struct priv_owner *p = hw->priv;
-    int num_formats = 0;
-    int *formats = NULL;
-
-    p->probing_formats = true;
-
-    AVHWFramesConstraints *fc =
-            av_hwdevice_get_hwframe_constraints(p->ctx->av_device_ref, NULL);
-    if (!fc) {
-        MP_WARN(hw, "failed to retrieve libavutil frame constraints\n");
-        goto done;
-    }
-    for (int n = 0; fc->valid_sw_formats[n] != AV_PIX_FMT_NONE; n++) {
-        AVBufferRef *fref = NULL;
-        struct mp_image *s = NULL;
-        AVFrame *frame = NULL;
-        fref = av_hwframe_ctx_alloc(p->ctx->av_device_ref);
-        if (!fref)
-            goto err;
-        AVHWFramesContext *fctx = (void *)fref->data;
-        fctx->format = AV_PIX_FMT_VAAPI;
-        fctx->sw_format = fc->valid_sw_formats[n];
-        fctx->width = 128;
-        fctx->height = 128;
-        if (av_hwframe_ctx_init(fref) < 0)
-            goto err;
-        frame = av_frame_alloc();
-        if (!frame)
-            goto err;
-        if (av_hwframe_get_buffer(fref, frame, 0) < 0)
-            goto err;
-        s = mp_image_from_av_frame(frame);
-        if (!s || !mp_image_params_valid(&s->params))
-            goto err;
-        if (try_format(hw, s))
-            MP_TARRAY_APPEND(p, formats, num_formats, s->params.hw_subfmt);
-    err:
-        talloc_free(s);
-        av_frame_free(&frame);
-        av_buffer_unref(&fref);
-    }
-    av_hwframe_constraints_free(&fc);
-
-done:
-    MP_TARRAY_APPEND(p, formats, num_formats, 0); // terminate it
-    p->formats = formats;
-    p->probing_formats = false;
-
-    MP_VERBOSE(hw, "Supported formats:\n");
-    for (int n = 0; formats[n]; n++)
-        MP_VERBOSE(hw, " %s\n", mp_imgfmt_to_name(formats[n]));
-}
-
-const struct ra_hwdec_driver ra_hwdec_vaegl = {
-    .name = "vaapi-egl",
-    .priv_size = sizeof(struct priv_owner),
-    .imgfmts = {IMGFMT_VAAPI, 0},
-    .init = init,
-    .uninit = uninit,
-    .mapper = &(const struct ra_hwdec_mapper_driver){
-        .priv_size = sizeof(struct priv),
-        .init = mapper_init,
-        .uninit = mapper_uninit,
-        .map = mapper_map,
-        .unmap = mapper_unmap,
-    },
-};
diff -ruN mpv-0.29.1/video/out/opengl/hwdec_vdpau.c mpv-master/video/out/opengl/hwdec_vdpau.c
--- mpv-0.29.1/video/out/opengl/hwdec_vdpau.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/opengl/hwdec_vdpau.c	2019-09-19 04:02:03.000000000 +0700
@@ -42,6 +42,7 @@
     GLvdpauSurfaceNV vdpgl_surface;
     VdpOutputSurface vdp_surface;
     struct mp_vdpau_mixer *mixer;
+    struct ra_imgfmt_desc direct_desc;
     bool direct_mode;
     bool mapped;
 };
@@ -162,13 +163,21 @@
     p->vdpgl_initialized = true;
 
     p->direct_mode = mapper->dst_params.hw_subfmt == IMGFMT_NV12 ||
-                     mapper->dst_params.hw_subfmt == IMGFMT_420P;
+                     mapper->dst_params.hw_subfmt == IMGFMT_NV24 ||
+                     mapper->dst_params.hw_subfmt == IMGFMT_420P ||
+                     mapper->dst_params.hw_subfmt == IMGFMT_444P;
     mapper->vdpau_fields = p->direct_mode;
 
     gl->GenTextures(4, p->gl_textures);
 
     if (p->direct_mode) {
-        mapper->dst_params.imgfmt = IMGFMT_NV12;
+        int imgfmt = mapper->dst_params.hw_subfmt;
+        if (!ra_get_imgfmt_desc(mapper->ra, imgfmt, &p->direct_desc)) {
+            MP_ERR(mapper, "Unsupported format: %s\n", mp_imgfmt_to_name(imgfmt));
+            return -1;
+        }
+        mapper->dst_params.imgfmt = p->direct_desc.chroma_w == 1 ?
+                                    IMGFMT_NV24 : IMGFMT_NV12;
         mapper->dst_params.hw_subfmt = 0;
 
         for (int n = 0; n < 4; n++) {
@@ -250,11 +259,13 @@
 
         for (int n = 0; n < 4; n++) {
             bool chroma = n >= 2;
+            int w_scale = chroma ? p->direct_desc.chroma_w : 1;
+            int h_scale = chroma ? p->direct_desc.chroma_h * 2 : 2;
 
             struct ra_tex_params params = {
                 .dimensions = 2,
-                .w = s_w / (chroma ? 2 : 1),
-                .h = s_h / (chroma ? 4 : 2),
+                .w = s_w / w_scale,
+                .h = s_h / h_scale,
                 .d = 1,
                 .format = ra_find_unorm_format(mapper->ra, 1, chroma ? 2 : 1),
                 .render_src = true,
diff -ruN mpv-0.29.1/video/out/opengl/oml_sync.c mpv-master/video/out/opengl/oml_sync.c
--- mpv-0.29.1/video/out/opengl/oml_sync.c	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/opengl/oml_sync.c	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,112 @@
+#include <time.h>
+
+#include "osdep/timer.h"
+#include "oml_sync.h"
+#include "video/out/vo.h"
+
+// General nonsense about the associated extension.
+//
+// This extension returns two unrelated values:
+//  (ust, msc): clock time and incrementing counter of last vsync (this is
+//              reported continuously, even if we don't swap)
+//  sbc:        swap counter of frame that was last displayed (every swap
+//              increments the user_sbc, and the reported sbc is the sbc
+//              of the frame that was just displayed)
+// Invariants:
+//  - ust and msc change in lockstep (no value can change with the other)
+//  - msc is incremented; if you query it in a loop, and your thread isn't
+//    frozen or starved by the scheduler, it will usually not change or
+//    be incremented by 1 (while the ust will be incremented by vsync
+//    duration)
+//  - sbc is never higher than the user_sbc
+//  - (ust, msc) are equal to or higher by vsync increments than the display
+//    time of the frame referenced by the sbc
+// Note that (ust, msc) and sbc are not locked to each other. The following
+// can easily happen if vsync skips occur:
+//  - you draw a frame, in the meantime hardware swaps sbc_1
+//  - another display vsync happens during drawing
+//  - you call swap()
+//  - query (ust, msc) and sbc
+//  - sbc contains sbc_1, but (ust, msc) contains the vsync after it
+// As a consequence, it's hard to detect the latency or vsync skips.
+
+static void oml_sync_reset(struct oml_sync *oml)
+{
+    oml->vsync_duration = -1;
+    oml->last_skipped_vsyncs = -1;
+    oml->last_queue_display_time = -1;
+}
+
+void oml_sync_swap(struct oml_sync *oml, int64_t ust, int64_t msc, int64_t sbc)
+{
+    if (!oml->state_ok)
+        oml_sync_reset(oml);
+
+    oml->last_skipped_vsyncs = 0;
+    oml->user_sbc += 1;
+
+    if (sbc < 0)
+        return;
+
+    oml->state_ok = true;
+
+    int64_t ust_passed = oml->last_ust ? ust - oml->last_ust : 0;
+    oml->last_ust = ust;
+
+    int64_t msc_passed = oml->last_msc ? msc - oml->last_msc : 0;
+    oml->last_msc = msc;
+
+    int64_t sbc_passed = sbc - oml->last_sbc;
+    oml->last_sbc = sbc;
+
+    // Display frame duration. This makes assumptions about UST (see below).
+    if (msc_passed && ust_passed)
+        oml->vsync_duration = ust_passed / msc_passed;
+
+    // Only if a new frame was displayed (sbc increased) we have sort-of a
+    // chance that the current (ust, msc) is for the sbc. But this is racy,
+    // because skipped frames drops could have increased the msc right after the
+    // display event and before we queried the values. This code hopes for the
+    // best and ignores this.
+    if (sbc_passed) {
+        // The GLX extension spec doesn't define what the UST is (not even its
+        // unit). Simply assume UST is a simple CLOCK_MONOTONIC usec value. This
+        // is what Mesa does, and what the Google EGL extension seems to imply
+        // (they mention CLOCK_MONOTONIC, but not the unit).
+        // The swap buffer call happened "some" but very small time ago, so we
+        // can get away with querying the current time. There is also the
+        // implicit assumption that mpv's timer and the UST use the same clock
+        // (which it does on POSIX).
+        struct timespec ts;
+        if (clock_gettime(CLOCK_MONOTONIC, &ts))
+            return;
+        uint64_t now_monotonic = ts.tv_sec * 1000000LL + ts.tv_nsec / 1000;
+        uint64_t ust_mp_time = mp_time_us() - (now_monotonic - ust);
+
+        // Assume this is exactly when the actual display event for this sbc
+        // happened. This is subject to the race mentioned above.
+        oml->last_sbc_mp_time = ust_mp_time;
+    }
+
+    // At least one frame needs to be actually displayed before
+    // oml->last_sbc_mp_time is set.
+    if (!sbc)
+        return;
+
+    // Extrapolate from the last sbc time (when a frame was actually displayed),
+    // and by adding the number of frames that were queued since to it.
+    // For every unit the sbc is smaller than user_sbc, the actual display
+    // is one frame ahead (assumes oml_sync_swap() is called for every
+    // vsync).
+    oml->last_queue_display_time =
+        oml->last_sbc_mp_time + (oml->user_sbc - sbc) * oml->vsync_duration;
+}
+
+void oml_sync_get_info(struct oml_sync *oml, struct vo_vsync_info *info)
+{
+    if (!oml->state_ok)
+        oml_sync_reset(oml);
+    info->vsync_duration = oml->vsync_duration;
+    info->skipped_vsyncs = oml->last_skipped_vsyncs;
+    info->last_queue_display_time = oml->last_queue_display_time;
+}
diff -ruN mpv-0.29.1/video/out/opengl/oml_sync.h mpv-master/video/out/opengl/oml_sync.h
--- mpv-0.29.1/video/out/opengl/oml_sync.h	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/opengl/oml_sync.h	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,28 @@
+#pragma once
+
+#include <stdbool.h>
+#include <stdint.h>
+
+// Must be initialized to {0} by user.
+struct oml_sync {
+    bool state_ok;
+    int64_t last_ust;
+    int64_t last_msc;
+    int64_t last_sbc;
+    int64_t last_sbc_mp_time;
+    int64_t user_sbc;
+    int64_t vsync_duration;
+    int64_t last_skipped_vsyncs;
+    int64_t last_queue_display_time;
+};
+
+struct vo_vsync_info;
+
+// This must be called on every SwapBuffer call. Pass the ust/msc/sbc values
+// returned by a successful GetSyncValues call. Pass -1 for all these 3 values
+// if GetSyncValues returned failure (but note that you need to set them to -1
+// manually).
+void oml_sync_swap(struct oml_sync *oml, int64_t ust, int64_t msc, int64_t sbc);
+
+// Can be called any time; returns state determined by last oml_sync_swap() call.
+void oml_sync_get_info(struct oml_sync *oml, struct vo_vsync_info *info);
diff -ruN mpv-0.29.1/video/out/opengl/ra_gl.c mpv-master/video/out/opengl/ra_gl.c
--- mpv-0.29.1/video/out/opengl/ra_gl.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/opengl/ra_gl.c	2019-09-19 04:02:03.000000000 +0700
@@ -124,6 +124,12 @@
     if (gl->BlitFramebuffer)
         ra->caps |= RA_CAP_BLIT;
 
+    // Disable compute shaders for GLSL < 420. This work-around is needed since
+    // some buggy OpenGL drivers expose compute shaders for lower GLSL versions,
+    // despite the spec requiring 420+.
+    if (ra->glsl_version < 420)
+        ra->caps &= ~RA_CAP_COMPUTE;
+
     int gl_fmt_features = gl_format_feature_flags(gl);
 
     for (int n = 0; gl_formats[n].internal_format; n++) {
@@ -144,6 +150,9 @@
             .linear_filter  = gl_fmt->flags & F_TF,
             .renderable     = (gl_fmt->flags & F_CR) &&
                               (gl->mpgl_caps & MPGL_CAP_FB),
+            // TODO: Check whether it's a storable format
+            // https://www.khronos.org/opengl/wiki/Image_Load_Store
+            .storable       = true,
         };
 
         int csize = gl_component_size(gl_fmt->type) * 8;
@@ -542,7 +551,9 @@
     GL *gl = ra_gl_get(ra);
     struct ra_buf_gl *buf_gl = buf->priv;
 
-    gl->DeleteSync(buf_gl->fence);
+    if (buf_gl->fence)
+        gl->DeleteSync(buf_gl->fence);
+
     if (buf->data) {
         gl->BindBuffer(buf_gl->target, buf_gl->buffer);
         gl->UnmapBuffer(buf_gl->target);
@@ -685,7 +696,7 @@
     gl->BindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
 }
 
-static int gl_desc_namespace(enum ra_vartype type)
+static int gl_desc_namespace(struct ra *ra, enum ra_vartype type)
 {
     return type;
 }
diff -ruN mpv-0.29.1/video/out/placebo/ra_pl.c mpv-master/video/out/placebo/ra_pl.c
--- mpv-0.29.1/video/out/placebo/ra_pl.c	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/placebo/ra_pl.c	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,634 @@
+#include "common/common.h"
+#include "common/msg.h"
+
+#include "ra_pl.h"
+#include "utils.h"
+
+struct ra_pl {
+    const struct pl_gpu *gpu;
+};
+
+static inline const struct pl_gpu *get_gpu(const struct ra *ra)
+{
+    struct ra_pl *p = ra->priv;
+    return p->gpu;
+}
+
+static struct ra_fns ra_fns_pl;
+
+const struct pl_gpu *ra_pl_get(const struct ra *ra)
+{
+    return ra->fns == &ra_fns_pl ? get_gpu(ra) : NULL;
+}
+
+struct ra *ra_create_pl(const struct pl_gpu *gpu, struct mp_log *log)
+{
+    assert(gpu);
+
+    struct ra *ra = talloc_zero(NULL, struct ra);
+    ra->log = log;
+    ra->fns = &ra_fns_pl;
+
+    struct ra_pl *p = ra->priv = talloc_zero(ra, struct ra_pl);
+    p->gpu = gpu;
+
+    ra->glsl_version = gpu->glsl.version;
+    ra->glsl_vulkan = gpu->glsl.vulkan;
+    ra->glsl_es = gpu->glsl.gles;
+
+    ra->caps = RA_CAP_DIRECT_UPLOAD | RA_CAP_NESTED_ARRAY | RA_CAP_FRAGCOORD;
+
+    if (gpu->caps & PL_GPU_CAP_COMPUTE)
+        ra->caps |= RA_CAP_COMPUTE | RA_CAP_NUM_GROUPS;
+    if (gpu->caps & PL_GPU_CAP_PARALLEL_COMPUTE)
+        ra->caps |= RA_CAP_PARALLEL_COMPUTE;
+    if (gpu->caps & PL_GPU_CAP_INPUT_VARIABLES)
+        ra->caps |= RA_CAP_GLOBAL_UNIFORM;
+
+    if (gpu->limits.max_tex_1d_dim)
+        ra->caps |= RA_CAP_TEX_1D;
+    if (gpu->limits.max_tex_3d_dim)
+        ra->caps |= RA_CAP_TEX_3D;
+    if (gpu->limits.max_ubo_size)
+        ra->caps |= RA_CAP_BUF_RO;
+    if (gpu->limits.max_ssbo_size)
+        ra->caps |= RA_CAP_BUF_RW;
+    if (gpu->limits.min_gather_offset && gpu->limits.max_gather_offset)
+        ra->caps |= RA_CAP_GATHER;
+
+    // Semi-hack: assume all textures are blittable if r8 is
+    const struct pl_fmt *r8 = pl_find_named_fmt(gpu, "r8");
+    if (r8->caps & PL_FMT_CAP_BLITTABLE)
+        ra->caps |= RA_CAP_BLIT;
+
+    ra->max_texture_wh = gpu->limits.max_tex_2d_dim;
+    ra->max_shmem = gpu->limits.max_shmem_size;
+    ra->max_pushc_size = gpu->limits.max_pushc_size;
+
+    // Set up format wrappers
+    for (int i = 0; i < gpu->num_formats; i++) {
+        const struct pl_fmt *plfmt = gpu->formats[i];
+        static const enum ra_ctype fmt_type_map[PL_FMT_TYPE_COUNT] = {
+            [PL_FMT_UNORM]  = RA_CTYPE_UNORM,
+            [PL_FMT_UINT]   = RA_CTYPE_UINT,
+            [PL_FMT_FLOAT]  = RA_CTYPE_FLOAT,
+        };
+
+        enum ra_ctype type = fmt_type_map[plfmt->type];
+        if (!type || !(plfmt->caps & PL_FMT_CAP_SAMPLEABLE))
+            continue;
+
+        struct ra_format *rafmt = talloc_zero(ra, struct ra_format);
+        *rafmt = (struct ra_format) {
+            .name = plfmt->name,
+            .priv = (void *) plfmt,
+            .ctype = type,
+            .ordered = pl_fmt_is_ordered(plfmt),
+            .num_components = plfmt->num_components,
+            .pixel_size = plfmt->texel_size,
+            .linear_filter = plfmt->caps & PL_FMT_CAP_LINEAR,
+            .renderable = plfmt->caps & PL_FMT_CAP_RENDERABLE,
+            .storable = plfmt->caps & PL_FMT_CAP_STORABLE,
+            .glsl_format = plfmt->glsl_format,
+        };
+
+        for (int c = 0; c < plfmt->num_components; c++) {
+            rafmt->component_size[c] = plfmt->host_bits[c];
+            rafmt->component_depth[c] = plfmt->component_depth[c];
+        }
+
+        MP_TARRAY_APPEND(ra, ra->formats, ra->num_formats, rafmt);
+    }
+
+    return ra;
+}
+
+static void destroy_ra_pl(struct ra *ra)
+{
+    talloc_free(ra);
+}
+
+static struct ra_format *map_fmt(struct ra *ra, const struct pl_fmt *plfmt)
+{
+    for (int i = 0; i < ra->num_formats; i++) {
+        if (ra->formats[i]->priv == plfmt)
+            return ra->formats[i];
+    }
+
+    MP_ERR(ra, "Failed mapping pl_fmt '%s' to ra_fmt?\n", plfmt->name);
+    return NULL;
+}
+
+bool mppl_wrap_tex(struct ra *ra, const struct pl_tex *pltex,
+                   struct ra_tex *out_tex)
+{
+    if (!pltex)
+        return false;
+
+    *out_tex = (struct ra_tex) {
+        .params = {
+            .dimensions = pl_tex_params_dimension(pltex->params),
+            .w = pltex->params.w,
+            .h = pltex->params.h,
+            .d = pltex->params.d,
+            .format = map_fmt(ra, pltex->params.format),
+            .render_src = pltex->params.sampleable,
+            .render_dst = pltex->params.renderable,
+            .storage_dst = pltex->params.storable,
+            .blit_src = pltex->params.blit_src,
+            .blit_dst = pltex->params.blit_dst,
+            .host_mutable = pltex->params.host_writable,
+            .downloadable = pltex->params.host_readable,
+            .src_linear = pltex->params.sample_mode == PL_TEX_SAMPLE_LINEAR,
+            .src_repeat = pltex->params.address_mode == PL_TEX_ADDRESS_REPEAT,
+        },
+        .priv = (void *) pltex,
+    };
+
+    return !!out_tex->params.format;
+}
+
+static struct ra_tex *tex_create_pl(struct ra *ra,
+                                    const struct ra_tex_params *params)
+{
+    const struct pl_gpu *gpu = get_gpu(ra);
+
+    // Check size limits
+    bool ok = false;
+    switch (params->dimensions) {
+    case 1:
+        ok = params->w <= gpu->limits.max_tex_1d_dim;
+        break;
+
+    case 2:
+        ok = params->w <= gpu->limits.max_tex_2d_dim &&
+             params->h <= gpu->limits.max_tex_2d_dim;
+        break;
+
+    case 3:
+        ok = params->w <= gpu->limits.max_tex_2d_dim &&
+             params->h <= gpu->limits.max_tex_2d_dim &&
+             params->d <= gpu->limits.max_tex_2d_dim;
+        break;
+    };
+
+    if (!ok) {
+        MP_ERR(ra, "Texture size %dx%dx%d exceeds dimension limits!\n",
+               params->w, params->h, params->d);
+        return NULL;
+    }
+
+    const struct pl_tex *pltex = pl_tex_create(gpu, &(struct pl_tex_params) {
+        .w = params->w,
+        .h = params->dimensions >= 2 ? params->h : 0,
+        .d = params->dimensions >= 3 ? params->d : 0,
+        .format = params->format->priv,
+        .sampleable = params->render_src,
+        .renderable = params->render_dst,
+        .storable = params->storage_dst,
+        .blit_src = params->blit_src,
+        .blit_dst = params->blit_dst || params->render_dst,
+        .host_writable = params->host_mutable,
+        .host_readable = params->downloadable,
+        .sample_mode = params->src_linear ? PL_TEX_SAMPLE_LINEAR
+                                          : PL_TEX_SAMPLE_NEAREST,
+        .address_mode = params->src_repeat ? PL_TEX_ADDRESS_REPEAT
+                                           : PL_TEX_ADDRESS_CLAMP,
+        .initial_data = params->initial_data,
+    });
+
+    struct ra_tex *ratex = talloc_ptrtype(NULL, ratex);
+    if (!mppl_wrap_tex(ra, pltex, ratex)) {
+        pl_tex_destroy(gpu, &pltex);
+        talloc_free(ratex);
+        return NULL;
+    }
+
+    return ratex;
+}
+
+static void tex_destroy_pl(struct ra *ra, struct ra_tex *tex)
+{
+    if (!tex)
+        return;
+
+    pl_tex_destroy(get_gpu(ra), (const struct pl_tex **) &tex->priv);
+    talloc_free(tex);
+}
+
+static int texel_stride_w(size_t stride, const struct pl_tex *tex)
+{
+    size_t texel_size = tex->params.format->texel_size;
+    int texels = stride / texel_size;
+    assert(texels * texel_size == stride);
+    return texels;
+}
+
+static bool tex_upload_pl(struct ra *ra, const struct ra_tex_upload_params *params)
+{
+    const struct pl_tex *tex = params->tex->priv;
+    struct pl_tex_transfer_params pl_params = {
+        .tex = tex,
+        .buf = params->buf ? params->buf->priv : NULL,
+        .buf_offset = params->buf_offset,
+        .ptr = (void *) params->src,
+    };
+
+    if (params->tex->params.dimensions == 2) {
+        pl_params.stride_w = texel_stride_w(params->stride, tex);
+        if (params->rc) {
+            pl_params.rc = (struct pl_rect3d) {
+                .x0 = params->rc->x0, .x1 = params->rc->x1,
+                .y0 = params->rc->y0, .y1 = params->rc->y1,
+            };
+        }
+    }
+
+    return pl_tex_upload(get_gpu(ra), &pl_params);
+}
+
+static bool tex_download_pl(struct ra *ra, struct ra_tex_download_params *params)
+{
+    const struct pl_tex *tex = params->tex->priv;
+    struct pl_tex_transfer_params pl_params = {
+        .tex = tex,
+        .ptr = params->dst,
+        .stride_w = texel_stride_w(params->stride, tex),
+    };
+
+    return pl_tex_download(get_gpu(ra), &pl_params);
+}
+
+static struct ra_buf *buf_create_pl(struct ra *ra,
+                                    const struct ra_buf_params *params)
+{
+    static const enum pl_buf_type buf_type[] = {
+        [RA_BUF_TYPE_TEX_UPLOAD]     = PL_BUF_TEX_TRANSFER,
+        [RA_BUF_TYPE_SHADER_STORAGE] = PL_BUF_STORAGE,
+        [RA_BUF_TYPE_UNIFORM]        = PL_BUF_UNIFORM,
+        [RA_BUF_TYPE_SHARED_MEMORY]  = 0,
+    };
+
+    const struct pl_gpu *gpu = get_gpu(ra);
+    size_t max_size[] = {
+        [PL_BUF_TEX_TRANSFER] = gpu->limits.max_xfer_size,
+        [PL_BUF_UNIFORM]      = gpu->limits.max_ubo_size,
+        [PL_BUF_STORAGE]      = gpu->limits.max_ssbo_size,
+    };
+
+    if (params->size > max_size[buf_type[params->type]]) {
+        MP_ERR(ra, "Buffer size %zu exceeds size limits!\n", params->size);
+        return NULL;
+    }
+
+    const struct pl_buf *plbuf = pl_buf_create(gpu, &(struct pl_buf_params) {
+        .type = buf_type[params->type],
+        .size = params->size,
+        .host_mapped = params->host_mapped,
+        .host_writable = params->host_mutable,
+        .initial_data = params->initial_data,
+    });
+
+    if (!plbuf)
+        return NULL;
+
+    struct ra_buf *rabuf = talloc_ptrtype(NULL, rabuf);
+    *rabuf = (struct ra_buf) {
+        .params = *params,
+        .data = plbuf->data,
+        .priv = (void *) plbuf,
+    };
+
+    rabuf->params.initial_data = NULL;
+    return rabuf;
+}
+
+static void buf_destroy_pl(struct ra *ra, struct ra_buf *buf)
+{
+    if (!buf)
+        return;
+
+    pl_buf_destroy(get_gpu(ra), (const struct pl_buf **) &buf->priv);
+    talloc_free(buf);
+}
+
+static void buf_update_pl(struct ra *ra, struct ra_buf *buf, ptrdiff_t offset,
+                          const void *data, size_t size)
+{
+    pl_buf_write(get_gpu(ra), buf->priv, offset, data, size);
+}
+
+static bool buf_poll_pl(struct ra *ra, struct ra_buf *buf)
+{
+    return !pl_buf_poll(get_gpu(ra), buf->priv, 0);
+}
+
+static void clear_pl(struct ra *ra, struct ra_tex *dst, float color[4],
+                     struct mp_rect *scissor)
+{
+    // TODO: implement scissor clearing by bltting a 1x1 tex instead
+    pl_tex_clear(get_gpu(ra), dst->priv, color);
+}
+
+static void blit_pl(struct ra *ra, struct ra_tex *dst, struct ra_tex *src,
+                    struct mp_rect *dst_rc, struct mp_rect *src_rc)
+{
+    struct pl_rect3d plsrc = {0}, pldst = {0};
+    if (src_rc) {
+        plsrc.x0 = MPMIN(MPMAX(src_rc->x0, 0), src->params.w);
+        plsrc.y0 = MPMIN(MPMAX(src_rc->y0, 0), src->params.h);
+        plsrc.x1 = MPMIN(MPMAX(src_rc->x1, 0), src->params.w);
+        plsrc.y1 = MPMIN(MPMAX(src_rc->y1, 0), src->params.h);
+    }
+
+    if (dst_rc) {
+        pldst.x0 = MPMIN(MPMAX(dst_rc->x0, 0), dst->params.w);
+        pldst.y0 = MPMIN(MPMAX(dst_rc->y0, 0), dst->params.h);
+        pldst.x1 = MPMIN(MPMAX(dst_rc->x1, 0), dst->params.w);
+        pldst.y1 = MPMIN(MPMAX(dst_rc->y1, 0), dst->params.h);
+    }
+
+    pl_tex_blit(get_gpu(ra), dst->priv, src->priv, pldst, plsrc);
+}
+
+static const enum pl_var_type var_type[RA_VARTYPE_COUNT] = {
+    [RA_VARTYPE_INT]    = PL_VAR_SINT,
+    [RA_VARTYPE_FLOAT]  = PL_VAR_FLOAT,
+};
+
+static const enum pl_desc_type desc_type[RA_VARTYPE_COUNT] = {
+    [RA_VARTYPE_TEX]    = PL_DESC_SAMPLED_TEX,
+    [RA_VARTYPE_IMG_W]  = PL_DESC_STORAGE_IMG,
+    [RA_VARTYPE_BUF_RO] = PL_DESC_BUF_UNIFORM,
+    [RA_VARTYPE_BUF_RW] = PL_DESC_BUF_STORAGE,
+};
+
+static const enum pl_fmt_type fmt_type[RA_VARTYPE_COUNT] = {
+    [RA_VARTYPE_INT]        = PL_FMT_SINT,
+    [RA_VARTYPE_FLOAT]      = PL_FMT_FLOAT,
+    [RA_VARTYPE_BYTE_UNORM] = PL_FMT_UNORM,
+};
+
+static const size_t var_size[RA_VARTYPE_COUNT] = {
+    [RA_VARTYPE_INT]        = sizeof(int),
+    [RA_VARTYPE_FLOAT]      = sizeof(float),
+    [RA_VARTYPE_BYTE_UNORM] = sizeof(uint8_t),
+};
+
+static struct ra_layout uniform_layout_pl(struct ra_renderpass_input *inp)
+{
+    // To get the alignment requirements, we try laying this out with
+    // an offset of 1 and then see where it ends up. This will always be
+    // the minimum alignment requirement.
+    struct pl_var_layout layout = pl_buf_uniform_layout(1, &(struct pl_var) {
+        .name = inp->name,
+        .type = var_type[inp->type],
+        .dim_v = inp->dim_v,
+        .dim_m = inp->dim_m,
+        .dim_a = 1,
+    });
+
+    return (struct ra_layout) {
+        .align = layout.offset,
+        .stride = layout.stride,
+        .size = layout.size,
+    };
+}
+
+static struct ra_layout push_constant_layout_pl(struct ra_renderpass_input *inp)
+{
+    struct pl_var_layout layout = pl_push_constant_layout(1, &(struct pl_var) {
+        .name = inp->name,
+        .type = var_type[inp->type],
+        .dim_v = inp->dim_v,
+        .dim_m = inp->dim_m,
+        .dim_a = 1,
+    });
+
+    return (struct ra_layout) {
+        .align = layout.offset,
+        .stride = layout.stride,
+        .size = layout.size,
+    };
+}
+
+static int desc_namespace_pl(struct ra *ra, enum ra_vartype type)
+{
+    return pl_desc_namespace(get_gpu(ra), desc_type[type]);
+}
+
+struct pass_priv {
+    const struct pl_pass *pl_pass;
+    uint16_t *inp_index; // index translation map
+    // Space to hold the descriptor bindings and variable updates
+    struct pl_desc_binding *binds;
+    struct pl_var_update *varups;
+    int num_varups;
+};
+
+static struct ra_renderpass *renderpass_create_pl(struct ra *ra,
+                                    const struct ra_renderpass_params *params)
+{
+    void *tmp = talloc_new(NULL);
+    const struct pl_gpu *gpu = get_gpu(ra);
+    struct ra_renderpass *pass = NULL;
+
+    static const enum pl_pass_type pass_type[] = {
+        [RA_RENDERPASS_TYPE_RASTER]  = PL_PASS_RASTER,
+        [RA_RENDERPASS_TYPE_COMPUTE] = PL_PASS_COMPUTE,
+    };
+
+    struct pl_var *vars = NULL;
+    struct pl_desc *descs = NULL;
+    int num_vars = 0, num_descs = 0;
+
+    struct pass_priv *priv = talloc_ptrtype(tmp, priv);
+    priv->inp_index = talloc_zero_array(priv, uint16_t, params->num_inputs);
+
+    for (int i = 0; i < params->num_inputs; i++) {
+        const struct ra_renderpass_input *inp = &params->inputs[i];
+        if (var_type[inp->type]) {
+            priv->inp_index[i] = num_vars;
+            MP_TARRAY_APPEND(tmp, vars, num_vars, (struct pl_var) {
+                .name = inp->name,
+                .type = var_type[inp->type],
+                .dim_v = inp->dim_v,
+                .dim_m = inp->dim_m,
+                .dim_a = 1,
+            });
+        } else if (desc_type[inp->type]) {
+            priv->inp_index[i] = num_descs;
+            MP_TARRAY_APPEND(tmp, descs, num_descs, (struct pl_desc) {
+                .name = inp->name,
+                .type = desc_type[inp->type],
+                .binding = inp->binding,
+                .access = inp->type == RA_VARTYPE_IMG_W ? PL_DESC_ACCESS_WRITEONLY
+                        : inp->type == RA_VARTYPE_BUF_RW ? PL_DESC_ACCESS_READWRITE
+                        : PL_DESC_ACCESS_READONLY,
+            });
+        }
+    }
+
+    // Allocate space to store the bindings map persistently
+    priv->binds = talloc_zero_array(priv, struct pl_desc_binding, num_descs);
+
+    struct pl_pass_params pl_params = {
+        .type = pass_type[params->type],
+        .variables = vars,
+        .num_variables = num_vars,
+        .descriptors = descs,
+        .num_descriptors = num_descs,
+        .push_constants_size = params->push_constants_size,
+        .glsl_shader = params->type == RA_RENDERPASS_TYPE_COMPUTE
+                            ? params->compute_shader
+                            : params->frag_shader,
+        .cached_program = params->cached_program.start,
+        .cached_program_len = params->cached_program.len,
+    };
+
+    struct pl_blend_params blend_params;
+
+    if (params->type == RA_RENDERPASS_TYPE_RASTER) {
+        pl_params.vertex_shader = params->vertex_shader;
+        pl_params.vertex_type = PL_PRIM_TRIANGLE_LIST;
+        pl_params.vertex_stride = params->vertex_stride;
+        pl_params.target_dummy.params.format = params->target_format->priv;
+        pl_params.load_target = !params->invalidate_target;
+
+        if (params->enable_blend) {
+            pl_params.blend_params = &blend_params;
+            blend_params = (struct pl_blend_params) {
+                // Same enum order as ra_blend
+                .src_rgb = (enum ra_blend) params->blend_src_rgb,
+                .dst_rgb = (enum ra_blend) params->blend_dst_rgb,
+                .src_alpha = (enum ra_blend) params->blend_src_alpha,
+                .dst_alpha = (enum ra_blend) params->blend_dst_alpha,
+            };
+        }
+
+        for (int i = 0; i < params->num_vertex_attribs; i++) {
+            const struct ra_renderpass_input *inp = &params->vertex_attribs[i];
+            struct pl_vertex_attrib attrib = {
+                .name = inp->name,
+                .offset = inp->offset,
+                .location = i,
+                .fmt = pl_find_fmt(gpu, fmt_type[inp->type], inp->dim_v, 0,
+                                   var_size[inp->type] * 8, PL_FMT_CAP_VERTEX),
+            };
+
+            if (!attrib.fmt) {
+                MP_ERR(ra, "Failed mapping vertex attrib '%s' to pl_fmt?\n",
+                       inp->name);
+                goto error;
+            }
+
+            MP_TARRAY_APPEND(tmp, pl_params.vertex_attribs,
+                             pl_params.num_vertex_attribs, attrib);
+        }
+    }
+
+    priv->pl_pass = pl_pass_create(gpu, &pl_params);
+    if (!priv->pl_pass)
+        goto error;
+
+    pass = talloc_ptrtype(NULL, pass);
+    *pass = (struct ra_renderpass) {
+        .params = *ra_renderpass_params_copy(pass, params),
+        .priv = talloc_steal(pass, priv),
+    };
+
+    pass->params.cached_program = (struct bstr) {
+        .start = (void *) priv->pl_pass->params.cached_program,
+        .len = priv->pl_pass->params.cached_program_len,
+    };
+
+    // fall through
+error:
+    talloc_free(tmp);
+    return pass;
+}
+
+static void renderpass_destroy_pl(struct ra *ra, struct ra_renderpass *pass)
+{
+    if (!pass)
+        return;
+
+    struct pass_priv *priv = pass->priv;
+    pl_pass_destroy(get_gpu(ra), (const struct pl_pass **) &priv->pl_pass);
+    talloc_free(pass);
+}
+
+static void renderpass_run_pl(struct ra *ra,
+                              const struct ra_renderpass_run_params *params)
+{
+    struct pass_priv *p = params->pass->priv;
+    p->num_varups = 0;
+
+    for (int i = 0; i < params->num_values; i++) {
+        const struct ra_renderpass_input_val *val = &params->values[i];
+        const struct ra_renderpass_input *inp = &params->pass->params.inputs[i];
+        if (var_type[inp->type]) {
+            MP_TARRAY_APPEND(p, p->varups, p->num_varups, (struct pl_var_update) {
+                .index = p->inp_index[val->index],
+                .data = val->data,
+            });
+        } else {
+            struct pl_desc_binding bind;
+            switch (inp->type) {
+            case RA_VARTYPE_TEX:
+            case RA_VARTYPE_IMG_W:
+                bind.object = (* (struct ra_tex **) val->data)->priv;
+                break;
+            case RA_VARTYPE_BUF_RO:
+            case RA_VARTYPE_BUF_RW:
+                bind.object = (* (struct ra_buf **) val->data)->priv;
+                break;
+            default: abort();
+            };
+
+            p->binds[p->inp_index[val->index]] = bind;
+        };
+    }
+
+    struct pl_pass_run_params pl_params = {
+        .pass = p->pl_pass,
+        .var_updates = p->varups,
+        .num_var_updates = p->num_varups,
+        .desc_bindings = p->binds,
+        .push_constants = params->push_constants,
+    };
+
+    if (p->pl_pass->params.type == PL_PASS_RASTER) {
+        pl_params.target = params->target->priv;
+        pl_params.viewport = mp_rect2d_to_pl(params->viewport);
+        pl_params.scissors = mp_rect2d_to_pl(params->scissors);
+        pl_params.vertex_data = params->vertex_data;
+        pl_params.vertex_count = params->vertex_count;
+    } else {
+        for (int i = 0; i < MP_ARRAY_SIZE(pl_params.compute_groups); i++)
+            pl_params.compute_groups[i] = params->compute_groups[i];
+    }
+
+    pl_pass_run(get_gpu(ra), &pl_params);
+}
+
+static struct ra_fns ra_fns_pl = {
+    .destroy                = destroy_ra_pl,
+    .tex_create             = tex_create_pl,
+    .tex_destroy            = tex_destroy_pl,
+    .tex_upload             = tex_upload_pl,
+    .tex_download           = tex_download_pl,
+    .buf_create             = buf_create_pl,
+    .buf_destroy            = buf_destroy_pl,
+    .buf_update             = buf_update_pl,
+    .buf_poll               = buf_poll_pl,
+    .clear                  = clear_pl,
+    .blit                   = blit_pl,
+    .uniform_layout         = uniform_layout_pl,
+    .push_constant_layout   = push_constant_layout_pl,
+    .desc_namespace         = desc_namespace_pl,
+    .renderpass_create      = renderpass_create_pl,
+    .renderpass_destroy     = renderpass_destroy_pl,
+    .renderpass_run         = renderpass_run_pl,
+};
+
diff -ruN mpv-0.29.1/video/out/placebo/ra_pl.h mpv-master/video/out/placebo/ra_pl.h
--- mpv-0.29.1/video/out/placebo/ra_pl.h	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/placebo/ra_pl.h	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "video/out/gpu/ra.h"
+#include <libplacebo/gpu.h>
+
+struct ra *ra_create_pl(const struct pl_gpu *gpu, struct mp_log *log);
+
+const struct pl_gpu *ra_pl_get(const struct ra *ra);
+
+static inline const struct pl_fmt *ra_pl_fmt_get(const struct ra_format *format)
+{
+    return format->priv;
+}
+
+// Wrap a pl_tex into a ra_tex struct, returns if successful
+bool mppl_wrap_tex(struct ra *ra, const struct pl_tex *pltex,
+                   struct ra_tex *out_tex);
diff -ruN mpv-0.29.1/video/out/placebo/utils.c mpv-master/video/out/placebo/utils.c
--- mpv-0.29.1/video/out/placebo/utils.c	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/placebo/utils.c	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,62 @@
+#include "common/common.h"
+#include "utils.h"
+
+static const int pl_log_to_msg_lev[PL_LOG_ALL+1] = {
+    [PL_LOG_FATAL] = MSGL_FATAL,
+    [PL_LOG_ERR]   = MSGL_ERR,
+    [PL_LOG_WARN]  = MSGL_WARN,
+    [PL_LOG_INFO]  = MSGL_V,
+    [PL_LOG_DEBUG] = MSGL_DEBUG,
+    [PL_LOG_TRACE] = MSGL_TRACE,
+};
+
+static const enum pl_log_level msg_lev_to_pl_log[MSGL_MAX+1] = {
+    [MSGL_FATAL]   = PL_LOG_FATAL,
+    [MSGL_ERR]     = PL_LOG_ERR,
+    [MSGL_WARN]    = PL_LOG_WARN,
+    [MSGL_INFO]    = PL_LOG_WARN,
+    [MSGL_STATUS]  = PL_LOG_WARN,
+    [MSGL_V]       = PL_LOG_INFO,
+    [MSGL_DEBUG]   = PL_LOG_DEBUG,
+    [MSGL_TRACE]   = PL_LOG_TRACE,
+    [MSGL_MAX]     = PL_LOG_ALL,
+};
+
+// translates log levels while probing
+static const enum pl_log_level probing_map(enum pl_log_level level)
+{
+    switch (level) {
+    case PL_LOG_FATAL:
+        return PL_LOG_ERR;
+
+    case PL_LOG_ERR:
+    case PL_LOG_WARN:
+        return PL_LOG_INFO;
+
+    default:
+        return level;
+    }
+}
+
+static void log_cb(void *priv, enum pl_log_level level, const char *msg)
+{
+    struct mp_log *log = priv;
+    mp_msg(log, pl_log_to_msg_lev[level], "%s\n", msg);
+}
+
+static void log_cb_probing(void *priv, enum pl_log_level level, const char *msg)
+{
+    struct mp_log *log = priv;
+    mp_msg(log, pl_log_to_msg_lev[probing_map(level)], "%s\n", msg);
+}
+
+void mppl_ctx_set_log(struct pl_context *ctx, struct mp_log *log, bool probing)
+{
+    assert(log);
+
+    pl_context_update(ctx, &(struct pl_context_params) {
+        .log_cb      = probing ? log_cb_probing : log_cb,
+        .log_level   = msg_lev_to_pl_log[mp_msg_level(log)],
+        .log_priv    = log,
+    });
+}
diff -ruN mpv-0.29.1/video/out/placebo/utils.h mpv-master/video/out/placebo/utils.h
--- mpv-0.29.1/video/out/placebo/utils.h	1970-01-01 07:00:00.000000000 +0700
+++ mpv-master/video/out/placebo/utils.h	2019-09-19 04:02:03.000000000 +0700
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "common/common.h"
+#include "common/msg.h"
+
+#include <libplacebo/common.h>
+
+void mppl_ctx_set_log(struct pl_context *ctx, struct mp_log *log, bool probing);
+
+static inline struct pl_rect2d mp_rect2d_to_pl(struct mp_rect rc)
+{
+    return (struct pl_rect2d) {
+        .x0 = rc.x0,
+        .y0 = rc.y0,
+        .x1 = rc.x1,
+        .y1 = rc.y1,
+    };
+}
diff -ruN mpv-0.29.1/video/out/vo.c mpv-master/video/out/vo.c
--- mpv-0.29.1/video/out/vo.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vo.c	2019-09-19 04:02:03.000000000 +0700
@@ -300,11 +300,9 @@
     m_config_cache_set_dispatch_change_cb(vo->opts_cache, vo->in->dispatch,
                                           update_opts, vo);
 
-#if HAVE_GL
     vo->gl_opts_cache = m_config_cache_alloc(NULL, global, &gl_video_conf);
     m_config_cache_set_dispatch_change_cb(vo->gl_opts_cache, vo->in->dispatch,
                                           update_opts, vo);
-#endif
 
     vo->eq_opts_cache = m_config_cache_alloc(NULL, global, &mp_csp_equalizer_conf);
     m_config_cache_set_dispatch_change_cb(vo->eq_opts_cache, vo->in->dispatch,
@@ -332,7 +330,9 @@
 
 struct vo *init_best_video_out(struct mpv_global *global, struct vo_extra *ex)
 {
-    struct m_obj_settings *vo_list = global->opts->vo->video_driver_list;
+    struct mp_vo_opts *opts = mp_get_config_group(NULL, global, &vo_sub_opts);
+    struct m_obj_settings *vo_list = opts->video_driver_list;
+    struct vo *vo = NULL;
     // first try the preferred drivers, with their optional subdevice param:
     if (vo_list && vo_list[0].name) {
         for (int n = 0; vo_list[n].name; n++) {
@@ -340,11 +340,11 @@
             if (strlen(vo_list[n].name) == 0)
                 goto autoprobe;
             bool p = !!vo_list[n + 1].name;
-            struct vo *vo = vo_create(p, global, ex, vo_list[n].name);
+            vo = vo_create(p, global, ex, vo_list[n].name);
             if (vo)
-                return vo;
+                goto done;
         }
-        return NULL;
+        goto done;
     }
 autoprobe:
     // now try the rest...
@@ -352,11 +352,13 @@
         const struct vo_driver *driver = video_out_drivers[i];
         if (driver == &video_out_null)
             break;
-        struct vo *vo = vo_create(true, global, ex, (char *)driver->name);
+        vo = vo_create(true, global, ex, (char *)driver->name);
         if (vo)
-            return vo;
+            goto done;
     }
-    return NULL;
+done:
+    talloc_free(opts);
+    return vo;
 }
 
 static void terminate_vo(void *p)
@@ -472,14 +474,14 @@
 }
 
 // Always called locked.
-static void update_vsync_timing_after_swap(struct vo *vo)
+static void update_vsync_timing_after_swap(struct vo *vo,
+                                           struct vo_vsync_info *vsync)
 {
     struct vo_internal *in = vo->in;
 
-    int64_t now = mp_time_us();
+    int64_t vsync_time = vsync->last_queue_display_time;
     int64_t prev_vsync = in->prev_vsync;
-
-    in->prev_vsync = now;
+    in->prev_vsync = vsync_time;
 
     if (!in->expecting_vsync) {
         reset_vsync_timings(vo);
@@ -493,13 +495,13 @@
     if (in->num_vsync_samples >= MAX_VSYNC_SAMPLES)
         in->num_vsync_samples -= 1;
     MP_TARRAY_INSERT_AT(in, in->vsync_samples, in->num_vsync_samples, 0,
-                        now - prev_vsync);
+                        vsync_time - prev_vsync);
     in->drop_point = MPMIN(in->drop_point + 1, in->num_vsync_samples);
     in->num_total_vsync_samples += 1;
     if (in->base_vsync) {
         in->base_vsync += in->vsync_interval;
     } else {
-        in->base_vsync = now;
+        in->base_vsync = vsync_time;
     }
 
     double avg = 0;
@@ -908,13 +910,24 @@
 
         vo->driver->flip_page(vo);
 
+        struct vo_vsync_info vsync = {
+            .last_queue_display_time = -1,
+            .skipped_vsyncs = -1,
+        };
+        if (vo->driver->get_vsync)
+            vo->driver->get_vsync(vo, &vsync);
+
+        // Make up some crap if presentation feedback is missing.
+        if (vsync.last_queue_display_time < 0)
+            vsync.last_queue_display_time = mp_time_us();
+
         MP_STATS(vo, "end video-flip");
 
         pthread_mutex_lock(&in->lock);
         in->dropped_frame = prev_drop_count < vo->in->drop_count;
         in->rendering = false;
 
-        update_vsync_timing_after_swap(vo);
+        update_vsync_timing_after_swap(vo, &vsync);
     }
 
     if (vo->driver->caps & VO_CAP_NORETAIN) {
diff -ruN mpv-0.29.1/video/out/vo.h mpv-master/video/out/vo.h
--- mpv-0.29.1/video/out/vo.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vo.h	2019-09-19 04:02:03.000000000 +0700
@@ -263,6 +263,35 @@
     uint64_t frame_id;
 };
 
+// Presentation feedback. See get_vsync() for how backends should fill this
+// struct.
+struct vo_vsync_info {
+    // mp_time_us() timestamp at which the last queued frame will likely be
+    // displayed (this is in the future, unless the frame is instantly output).
+    // -1 if unset or unsupported.
+    // This implies the latency of the output.
+    int64_t last_queue_display_time;
+
+    // Time between 2 vsync events in microseconds. The difference should be the
+    // from 2 times sampled from the same reference point (it should not be the
+    // difference between e.g. the end of scanout and the start of the next one;
+    // it must be continuous).
+    // -1 if unsupported.
+    //  0 if supported, but no value available yet. It is assumed that the value
+    //    becomes available after enough swap_buffers() calls were done.
+    // >0 values are taken for granted. Very bad things will happen if it's
+    //    inaccurate.
+    int64_t vsync_duration;
+
+    // Number of skipped physical vsyncs at some point in time. Typically, this
+    // value is some time in the past by an offset that equals to the latency.
+    // This value is reset and newly sampled at every swap_buffers() call.
+    // This can be used to detect delayed frames iff you try to call
+    // swap_buffers() for every physical vsync.
+    // -1 if unset or unsupported.
+    int64_t skipped_vsyncs;
+};
+
 struct vo_driver {
     // Encoding functionality, which can be invoked via --o only.
     bool encode;
@@ -374,6 +403,15 @@
      */
     void (*flip_page)(struct vo *vo);
 
+    /*
+     * Return presentation feedback. The implementation should not touch fields
+     * it doesn't support; the info fields are preinitialized to neutral values.
+     * Usually called once after flip_page(), but can be called any time.
+     * The values returned by this are always relative to the last flip_page()
+     * call.
+     */
+    void (*get_vsync)(struct vo *vo, struct vo_vsync_info *info);
+
     /* These optional callbacks can be provided if the GUI framework used by
      * the VO requires entering a message loop for receiving events and does
      * not call vo_wakeup() from a separate thread when there are new events.
diff -ruN mpv-0.29.1/video/out/vo_drm.c mpv-master/video/out/vo_drm.c
--- mpv-0.29.1/video/out/vo_drm.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vo_drm.c	2019-09-19 04:02:03.000000000 +0700
@@ -417,11 +417,10 @@
         MP_WARN(vo, "Failed to set up VT switcher. Terminal switching will be unavailable.\n");
     }
 
-    p->kms = kms_create(
-        vo->log, vo->opts->drm_opts->drm_connector_spec,
-                 vo->opts->drm_opts->drm_mode_id,
-                 vo->opts->drm_opts->drm_osd_plane_id,
-                 vo->opts->drm_opts->drm_video_plane_id);
+    p->kms = kms_create(vo->log,
+                        vo->opts->drm_opts->drm_connector_spec,
+                        vo->opts->drm_opts->drm_mode_spec,
+                        0, 0, false);
     if (!p->kms) {
         MP_ERR(vo, "Failed to create KMS.\n");
         goto err;
diff -ruN mpv-0.29.1/video/out/vo_gpu.c mpv-master/video/out/vo_gpu.c
--- mpv-0.29.1/video/out/vo_gpu.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vo_gpu.c	2019-09-19 04:02:03.000000000 +0700
@@ -98,6 +98,14 @@
     sw->fns->swap_buffers(sw);
 }
 
+static void get_vsync(struct vo *vo, struct vo_vsync_info *info)
+{
+    struct gpu_priv *p = vo->priv;
+    struct ra_swapchain *sw = p->ctx->swapchain;
+    if (sw->fns->get_vsync)
+        sw->fns->get_vsync(sw, info);
+}
+
 static int query_format(struct vo *vo, int format)
 {
     struct gpu_priv *p = vo->priv;
@@ -326,6 +334,7 @@
     .get_image = get_image,
     .draw_frame = draw_frame,
     .flip_page = flip_page,
+    .get_vsync = get_vsync,
     .wait_events = wait_events,
     .wakeup = wakeup,
     .uninit = uninit,
diff -ruN mpv-0.29.1/video/out/vo_libmpv.c mpv-master/video/out/vo_libmpv.c
--- mpv-0.29.1/video/out/vo_libmpv.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vo_libmpv.c	2019-09-19 04:02:03.000000000 +0700
@@ -297,9 +297,11 @@
 
     forget_frames(ctx, true);
 
-    ctx->renderer->fns->destroy(ctx->renderer);
-    talloc_free(ctx->renderer->priv);
-    talloc_free(ctx->renderer);
+    if (ctx->renderer) {
+        ctx->renderer->fns->destroy(ctx->renderer);
+        talloc_free(ctx->renderer->priv);
+        talloc_free(ctx->renderer);
+    }
     talloc_free(ctx->dr);
     talloc_free(ctx->dispatch);
 
@@ -573,6 +575,13 @@
         talloc_free(frame);
         break;
     }
+    case VOCTRL_PERFORMANCE_DATA: {
+        if (ctx->renderer->fns->perfdata) {
+            ctx->renderer->fns->perfdata(ctx->renderer, data);
+            ret = VO_TRUE;
+        }
+        break;
+    }
     }
 
     *(int *)args[3] = ret;
@@ -620,6 +629,13 @@
             mp_dispatch_run(ctx->dispatch, run_control_on_render_thread, args);
             return ret;
         }
+    case VOCTRL_PERFORMANCE_DATA:
+        if (ctx->dispatch) {
+            int ret;
+            void *args[] = {ctx, (void *)(intptr_t)request, data, &ret};
+            mp_dispatch_run(ctx->dispatch, run_control_on_render_thread, args);
+            return ret;
+        }
     }
 
     int r = VO_NOTIMPL;
diff -ruN mpv-0.29.1/video/out/vo_vaapi.c mpv-master/video/out/vo_vaapi.c
--- mpv-0.29.1/video/out/vo_vaapi.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vo_vaapi.c	2019-09-19 04:02:03.000000000 +0700
@@ -866,6 +866,11 @@
     vo->hwdec_devs = hwdec_devices_create();
     hwdec_devices_add(vo->hwdec_devs, &p->mpvaapi->hwctx);
 
+    MP_WARN(vo, "Warning: this compatibility VO is low quality and may "
+                "have issues with OSD, scaling, screenshots and more.\n"
+                "vo=gpu is the preferred choice in any case and "
+                "includes VA-API support via hwdec=vaapi or vaapi-copy.\n");
+
     return 0;
 
 fail:
diff -ruN mpv-0.29.1/video/out/vo_vdpau.c mpv-master/video/out/vo_vdpau.c
--- mpv-0.29.1/video/out/vo_vdpau.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vo_vdpau.c	2019-09-19 04:02:03.000000000 +0700
@@ -1046,6 +1046,11 @@
     vc->vdp->bitmap_surface_query_capabilities(vc->vdp_device, VDP_RGBA_FORMAT_A8,
                             &vc->supports_a8, &(uint32_t){0}, &(uint32_t){0});
 
+    MP_WARN(vo, "Warning: this compatibility VO is low quality and may "
+                "have issues with OSD, scaling, screenshots and more.\n"
+                "vo=gpu is the preferred choice in any case and "
+                "includes VDPAU support via hwdec=vdpau or vdpau-copy.\n");
+
     return 0;
 }
 
diff -ruN mpv-0.29.1/video/out/vo_x11.c mpv-master/video/out/vo_x11.c
--- mpv-0.29.1/video/out/vo_x11.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vo_x11.c	2019-09-19 04:02:03.000000000 +0700
@@ -226,7 +226,7 @@
 
     for (int i = 0; i < 2; i++) {
         if (!getMyXImage(p, i))
-            return -1;
+            return false;
     }
 
     const struct fmt_entry *fmte = mp_to_x_fmt;
@@ -241,7 +241,7 @@
     }
     if (!fmte->mpfmt) {
         MP_ERR(vo, "X server image format not supported, use another VO.\n");
-        return -1;
+        return false;
     }
 
     mp_sws_set_from_cmdline(p->sws, vo->global);
diff -ruN mpv-0.29.1/video/out/vulkan/common.h mpv-master/video/out/vulkan/common.h
--- mpv-0.29.1/video/out/vulkan/common.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/common.h	2019-09-19 04:02:03.000000000 +0700
@@ -23,54 +23,14 @@
 #define VK_USE_PLATFORM_WIN32_KHR
 #endif
 
-#include <vulkan/vulkan.h>
-
-// Vulkan allows the optional use of a custom allocator. We don't need one but
-// mark this parameter with a better name in case we ever decide to change this
-// in the future. (And to make the code more readable)
-#define MPVK_ALLOCATOR NULL
-
-// A lot of things depend on streaming resources across frames. Depending on
-// how many frames we render ahead of time, we need to pick enough to avoid
-// any conflicts, so make all of these tunable relative to this constant in
-// order to centralize them.
-#define MPVK_MAX_STREAMING_DEPTH 8
+#include <libplacebo/vulkan.h>
 
 // Shared struct used to hold vulkan context information
 struct mpvk_ctx {
-    struct mp_log *log;
-    VkInstance inst;
-    VkPhysicalDevice physd;
-    VkDebugReportCallbackEXT dbg;
-    VkDevice dev;
-
-    // Surface, must be initialized fter the context itself
-    VkSurfaceKHR surf;
-    VkSurfaceFormatKHR surf_format; // picked at surface initialization time
-
-    struct vk_malloc *alloc;      // memory allocator for this device
-    struct spirv_compiler *spirv; // GLSL -> SPIR-V compiler
-    struct vk_cmdpool **pools;    // command pools (one per queue family)
-    int num_pools;
-    struct vk_cmd *last_cmd;      // most recently submitted command
-
-    // Queued/pending commands. These are shared for the entire mpvk_ctx to
-    // ensure submission and callbacks are FIFO
-    struct vk_cmd **cmds_queued;  // recorded but not yet submitted
-    struct vk_cmd **cmds_pending; // submitted but not completed
-    int num_cmds_queued;
-    int num_cmds_pending;
-
-    // Pointers into *pools
-    struct vk_cmdpool *pool_graphics; // required
-    struct vk_cmdpool *pool_compute;  // optional
-    struct vk_cmdpool *pool_transfer; // optional
-
-    // Common pool of signals, to avoid having to re-create these objects often
-    struct vk_signal **signals;
-    int num_signals;
-
-    // Cached capabilities
-    VkPhysicalDeviceLimits limits;
-    VkPhysicalDeviceFeatures features;
+    struct mp_log *pl_log;
+    struct pl_context *ctx;
+    const struct pl_vk_inst *vkinst;
+    const struct pl_vulkan *vulkan;
+    const struct pl_gpu *gpu; // points to vulkan->gpu for convenience
+    VkSurfaceKHR surface;
 };
diff -ruN mpv-0.29.1/video/out/vulkan/context.c mpv-master/video/out/vulkan/context.c
--- mpv-0.29.1/video/out/vulkan/context.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/context.c	2019-09-19 04:02:03.000000000 +0700
@@ -16,25 +16,17 @@
  */
 
 #include "options/m_config.h"
-#include "video/out/gpu/spirv.h"
+#include "video/out/placebo/ra_pl.h"
 
 #include "context.h"
-#include "ra_vk.h"
 #include "utils.h"
 
-enum {
-    SWAP_AUTO = 0,
-    SWAP_FIFO,
-    SWAP_FIFO_RELAXED,
-    SWAP_MAILBOX,
-    SWAP_IMMEDIATE,
-    SWAP_COUNT,
-};
-
 struct vulkan_opts {
-    struct mpvk_device_opts dev_opts; // logical device options
     char *device; // force a specific GPU
     int swap_mode;
+    int queue_count;
+    int async_transfer;
+    int async_compute;
 };
 
 static int vk_validate_dev(struct mp_log *log, const struct m_option *opt,
@@ -52,18 +44,18 @@
     VkPhysicalDevice *devices = NULL;
     uint32_t num = 0;
 
-    res = vkCreateInstance(&info, MPVK_ALLOCATOR, &inst);
+    res = vkCreateInstance(&info, NULL, &inst);
     if (res != VK_SUCCESS)
-        goto error;
+        goto done;
 
     res = vkEnumeratePhysicalDevices(inst, &num, NULL);
     if (res != VK_SUCCESS)
-        goto error;
+        goto done;
 
     devices = talloc_array(NULL, VkPhysicalDevice, num);
     vkEnumeratePhysicalDevices(inst, &num, devices);
     if (res != VK_SUCCESS)
-        goto error;
+        goto done;
 
     bool help = bstr_equals0(param, "help");
     if (help) {
@@ -80,14 +72,14 @@
                     (unsigned)prop.vendorID, (unsigned)prop.deviceID);
         } else if (bstr_equals0(param, prop.deviceName)) {
             ret = 0;
-            break;
+            goto done;
         }
     }
 
     if (!help)
         mp_err(log, "No device with name '%.*s'!\n", BSTR_P(param));
 
-error:
+done:
     talloc_free(devices);
     return ret;
 }
@@ -97,42 +89,30 @@
     .opts = (const struct m_option[]) {
         OPT_STRING_VALIDATE("vulkan-device", device, 0, vk_validate_dev),
         OPT_CHOICE("vulkan-swap-mode", swap_mode, 0,
-                   ({"auto",        SWAP_AUTO},
-                   {"fifo",         SWAP_FIFO},
-                   {"fifo-relaxed", SWAP_FIFO_RELAXED},
-                   {"mailbox",      SWAP_MAILBOX},
-                   {"immediate",    SWAP_IMMEDIATE})),
-        OPT_INTRANGE("vulkan-queue-count", dev_opts.queue_count, 0, 1, 8,
-                     OPTDEF_INT(1)),
-        OPT_FLAG("vulkan-async-transfer", dev_opts.async_transfer, 0),
-        OPT_FLAG("vulkan-async-compute", dev_opts.async_compute, 0),
+                   ({"auto",        -1},
+                   {"fifo",         VK_PRESENT_MODE_FIFO_KHR},
+                   {"fifo-relaxed", VK_PRESENT_MODE_FIFO_RELAXED_KHR},
+                   {"mailbox",      VK_PRESENT_MODE_MAILBOX_KHR},
+                   {"immediate",    VK_PRESENT_MODE_IMMEDIATE_KHR})),
+        OPT_INTRANGE("vulkan-queue-count", queue_count, 0, 1, 8),
+        OPT_FLAG("vulkan-async-transfer", async_transfer, 0),
+        OPT_FLAG("vulkan-async-compute", async_compute, 0),
         {0}
     },
     .size = sizeof(struct vulkan_opts),
     .defaults = &(struct vulkan_opts) {
-        .dev_opts = {
-            .async_transfer = 1,
-        },
+        .swap_mode = -1,
+        .queue_count = 1,
+        .async_transfer = true,
+        .async_compute = true,
     },
 };
 
 struct priv {
     struct mpvk_ctx *vk;
     struct vulkan_opts *opts;
-    // Swapchain metadata:
-    int w, h;                 // current size
-    VkSwapchainCreateInfoKHR protoInfo; // partially filled-in prototype
-    VkSwapchainKHR swapchain;
-    VkSwapchainKHR old_swapchain;
-    int frames_in_flight;
-    // state of the images:
-    struct ra_tex **images;   // ra_tex wrappers for the vkimages
-    int num_images;           // size of images
-    VkSemaphore *sems_in;     // pool of semaphores used to synchronize images
-    VkSemaphore *sems_out;    // outgoing semaphores (rendering complete)
-    int num_sems;
-    int idx_sems;             // index of next free semaphore pair
-    int last_imgidx;          // the image index last acquired (for submit)
+    const struct pl_swapchain *swapchain;
+    struct ra_tex proxy_tex;
 };
 
 static const struct ra_swapchain_fns vulkan_swapchain;
@@ -146,133 +126,26 @@
     return p->vk;
 }
 
-static bool update_swapchain_info(struct priv *p,
-                                  VkSwapchainCreateInfoKHR *info)
-{
-    struct mpvk_ctx *vk = p->vk;
-
-    // Query the supported capabilities and update this struct as needed
-    VkSurfaceCapabilitiesKHR caps;
-    VK(vkGetPhysicalDeviceSurfaceCapabilitiesKHR(vk->physd, vk->surf, &caps));
-
-    // Sorted by preference
-    static const VkCompositeAlphaFlagsKHR alphaModes[] = {
-        VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,
-        VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
-    };
-
-    for (int i = 0; i < MP_ARRAY_SIZE(alphaModes); i++) {
-        if (caps.supportedCompositeAlpha & alphaModes[i]) {
-            info->compositeAlpha = alphaModes[i];
-            break;
-        }
-    }
-
-    if (!info->compositeAlpha) {
-        MP_ERR(vk, "Failed picking alpha compositing mode (caps: 0x%x)\n",
-               caps.supportedCompositeAlpha);
-        goto error;
-    }
-
-    static const VkSurfaceTransformFlagsKHR rotModes[] = {
-        VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,
-        VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR,
-    };
-
-    for (int i = 0; i < MP_ARRAY_SIZE(rotModes); i++) {
-        if (caps.supportedTransforms & rotModes[i]) {
-            info->preTransform = rotModes[i];
-            break;
-        }
-    }
-
-    if (!info->preTransform) {
-        MP_ERR(vk, "Failed picking surface transform mode (caps: 0x%x)\n",
-               caps.supportedTransforms);
-        goto error;
-    }
-
-    // Image count as required
-    MP_VERBOSE(vk, "Requested image count: %d (min %d max %d)\n",
-               (int)info->minImageCount, (int)caps.minImageCount,
-               (int)caps.maxImageCount);
-
-    info->minImageCount = MPMAX(info->minImageCount, caps.minImageCount);
-    if (caps.maxImageCount)
-        info->minImageCount = MPMIN(info->minImageCount, caps.maxImageCount);
-
-    // Check the extent against the allowed parameters
-    if (caps.currentExtent.width != info->imageExtent.width &&
-        caps.currentExtent.width != 0xFFFFFFFF)
-    {
-        MP_WARN(vk, "Requested width %d does not match current width %d\n",
-                (int)info->imageExtent.width, (int)caps.currentExtent.width);
-        info->imageExtent.width = caps.currentExtent.width;
-    }
-
-    if (caps.currentExtent.height != info->imageExtent.height &&
-        caps.currentExtent.height != 0xFFFFFFFF)
-    {
-        MP_WARN(vk, "Requested height %d does not match current height %d\n",
-                (int)info->imageExtent.height, (int)caps.currentExtent.height);
-        info->imageExtent.height = caps.currentExtent.height;
-    }
-
-    if (caps.minImageExtent.width  > info->imageExtent.width ||
-        caps.minImageExtent.height > info->imageExtent.height)
-    {
-        MP_ERR(vk, "Requested size %dx%d smaller than device minimum %d%d\n",
-               (int)info->imageExtent.width, (int)info->imageExtent.height,
-               (int)caps.minImageExtent.width, (int)caps.minImageExtent.height);
-        goto error;
-    }
-
-    if (caps.maxImageExtent.width  < info->imageExtent.width ||
-        caps.maxImageExtent.height < info->imageExtent.height)
-    {
-        MP_ERR(vk, "Requested size %dx%d larger than device maximum %d%d\n",
-               (int)info->imageExtent.width, (int)info->imageExtent.height,
-               (int)caps.maxImageExtent.width, (int)caps.maxImageExtent.height);
-        goto error;
-    }
-
-    // We just request whatever usage we can, and let the ra_vk decide what
-    // ra_tex_params that translates to. This makes the images as flexible
-    // as possible.
-    info->imageUsage = caps.supportedUsageFlags;
-    return true;
-
-error:
-    return false;
-}
-
 void ra_vk_ctx_uninit(struct ra_ctx *ctx)
 {
-    if (ctx->ra) {
-        struct priv *p = ctx->swapchain->priv;
-        struct mpvk_ctx *vk = p->vk;
+    if (!ctx->swapchain)
+        return;
 
-        mpvk_flush_commands(vk);
-        mpvk_poll_commands(vk, UINT64_MAX);
-
-        for (int i = 0; i < p->num_images; i++)
-            ra_tex_free(ctx->ra, &p->images[i]);
-        for (int i = 0; i < p->num_sems; i++) {
-            vkDestroySemaphore(vk->dev, p->sems_in[i], MPVK_ALLOCATOR);
-            vkDestroySemaphore(vk->dev, p->sems_out[i], MPVK_ALLOCATOR);
-        }
+    struct priv *p = ctx->swapchain->priv;
+    struct mpvk_ctx *vk = p->vk;
 
-        vkDestroySwapchainKHR(vk->dev, p->swapchain, MPVK_ALLOCATOR);
+    if (ctx->ra) {
+        pl_gpu_finish(vk->gpu);
+        pl_swapchain_destroy(&p->swapchain);
         ctx->ra->fns->destroy(ctx->ra);
         ctx->ra = NULL;
     }
 
-    talloc_free(ctx->swapchain);
-    ctx->swapchain = NULL;
+    vk->gpu = NULL;
+    pl_vulkan_destroy(&vk->vulkan);
+    TA_FREEP(&ctx->swapchain);
 }
 
-static const struct ra_swapchain_fns vulkan_swapchain;
-
 bool ra_vk_ctx_init(struct ra_ctx *ctx, struct mpvk_ctx *vk,
                     VkPresentModeKHR preferred_mode)
 {
@@ -284,56 +157,37 @@
     p->vk = vk;
     p->opts = mp_get_config_group(p, ctx->global, &vulkan_conf);
 
-    if (!mpvk_find_phys_device(vk, p->opts->device, ctx->opts.allow_sw))
-        goto error;
-    if (!spirv_compiler_init(ctx))
-        goto error;
-    vk->spirv = ctx->spirv;
-    if (!mpvk_pick_surface_format(vk))
-        goto error;
-    if (!mpvk_device_init(vk, p->opts->dev_opts))
+    assert(vk->ctx);
+    assert(vk->vkinst);
+    vk->vulkan = pl_vulkan_create(vk->ctx, &(struct pl_vulkan_params) {
+        .instance = vk->vkinst->instance,
+        .surface = vk->surface,
+        .async_transfer = p->opts->async_transfer,
+        .async_compute = p->opts->async_compute,
+        .queue_count = p->opts->queue_count,
+        .device_name = p->opts->device,
+    });
+    if (!vk->vulkan)
         goto error;
 
-    ctx->ra = ra_create_vk(vk, ctx->log);
+    vk->gpu = vk->vulkan->gpu;
+    ctx->ra = ra_create_pl(vk->gpu, ctx->log);
     if (!ctx->ra)
         goto error;
 
-    static const VkPresentModeKHR present_modes[SWAP_COUNT] = {
-        [SWAP_FIFO]         = VK_PRESENT_MODE_FIFO_KHR,
-        [SWAP_FIFO_RELAXED] = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
-        [SWAP_MAILBOX]      = VK_PRESENT_MODE_MAILBOX_KHR,
-        [SWAP_IMMEDIATE]    = VK_PRESENT_MODE_IMMEDIATE_KHR,
+    // Create the swapchain
+    struct pl_vulkan_swapchain_params params = {
+        .surface = vk->surface,
+        .present_mode = preferred_mode,
+        .swapchain_depth = ctx->opts.swapchain_depth,
     };
 
-    p->protoInfo = (VkSwapchainCreateInfoKHR) {
-        .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
-        .surface = vk->surf,
-        .imageFormat = vk->surf_format.format,
-        .imageColorSpace = vk->surf_format.colorSpace,
-        .imageArrayLayers = 1, // non-stereoscopic
-        .imageSharingMode = VK_SHARING_MODE_EXCLUSIVE,
-        .minImageCount = ctx->opts.swapchain_depth + 1, // +1 for FB
-        .presentMode = p->opts->swap_mode ? present_modes[p->opts->swap_mode]
-                                          : preferred_mode,
-        .clipped = true,
-    };
+    if (p->opts->swap_mode >= 0) // user override
+        params.present_mode = p->opts->swap_mode;
 
-    // Make sure the swapchain present mode is supported
-    int num_modes;
-    VK(vkGetPhysicalDeviceSurfacePresentModesKHR(vk->physd, vk->surf,
-                                                 &num_modes, NULL));
-    VkPresentModeKHR *modes = talloc_array(NULL, VkPresentModeKHR, num_modes);
-    VK(vkGetPhysicalDeviceSurfacePresentModesKHR(vk->physd, vk->surf,
-                                                 &num_modes, modes));
-    bool supported = false;
-    for (int i = 0; i < num_modes; i++)
-        supported |= (modes[i] == p->protoInfo.presentMode);
-    talloc_free(modes);
-
-    if (!supported) {
-        MP_ERR(ctx, "Requested swap mode unsupported by this device!\n");
+    p->swapchain = pl_vulkan_create_swapchain(vk->vulkan, &params);
+    if (!p->swapchain)
         goto error;
-    }
 
     return true;
 
@@ -342,226 +196,49 @@
     return false;
 }
 
-static void destroy_swapchain(struct mpvk_ctx *vk, struct priv *p)
+bool ra_vk_ctx_resize(struct ra_ctx *ctx, int width, int height)
 {
-    assert(p->old_swapchain);
-    vkDestroySwapchainKHR(vk->dev, p->old_swapchain, MPVK_ALLOCATOR);
-    p->old_swapchain = NULL;
-}
-
-bool ra_vk_ctx_resize(struct ra_swapchain *sw, int w, int h)
-{
-    struct priv *p = sw->priv;
-    if (w == p->w && h == p->h)
-        return true;
-
-    struct ra *ra = sw->ctx->ra;
-    struct mpvk_ctx *vk = p->vk;
-    VkImage *vkimages = NULL;
-
-    // It's invalid to trigger another swapchain recreation while there's
-    // more than one swapchain already active, so we need to flush any pending
-    // asynchronous swapchain release operations that may be ongoing.
-    while (p->old_swapchain)
-        mpvk_poll_commands(vk, 100000); // 100μs
-
-    VkSwapchainCreateInfoKHR sinfo = p->protoInfo;
-    sinfo.imageExtent  = (VkExtent2D){ w, h };
-    sinfo.oldSwapchain = p->swapchain;
-
-    if (!update_swapchain_info(p, &sinfo))
-        goto error;
-
-    VK(vkCreateSwapchainKHR(vk->dev, &sinfo, MPVK_ALLOCATOR, &p->swapchain));
-    p->w = w;
-    p->h = h;
-
-    // Freeing the old swapchain while it's still in use is an error, so do
-    // it asynchronously once the device is idle.
-    if (sinfo.oldSwapchain) {
-        p->old_swapchain = sinfo.oldSwapchain;
-        vk_dev_callback(vk, (vk_cb) destroy_swapchain, vk, p);
-    }
-
-    // Get the new swapchain images
-    int num;
-    VK(vkGetSwapchainImagesKHR(vk->dev, p->swapchain, &num, NULL));
-    vkimages = talloc_array(NULL, VkImage, num);
-    VK(vkGetSwapchainImagesKHR(vk->dev, p->swapchain, &num, vkimages));
-
-    // If needed, allocate some more semaphores
-    while (num > p->num_sems) {
-        VkSemaphore sem_in, sem_out;
-        static const VkSemaphoreCreateInfo seminfo = {
-            .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
-        };
-        VK(vkCreateSemaphore(vk->dev, &seminfo, MPVK_ALLOCATOR, &sem_in));
-        VK(vkCreateSemaphore(vk->dev, &seminfo, MPVK_ALLOCATOR, &sem_out));
-
-        int idx = p->num_sems++;
-        MP_TARRAY_GROW(p, p->sems_in, idx);
-        MP_TARRAY_GROW(p, p->sems_out, idx);
-        p->sems_in[idx] = sem_in;
-        p->sems_out[idx] = sem_out;
-    }
-
-    // Recreate the ra_tex wrappers
-    for (int i = 0; i < p->num_images; i++)
-        ra_tex_free(ra, &p->images[i]);
+    struct priv *p = ctx->swapchain->priv;
 
-    p->num_images = num;
-    MP_TARRAY_GROW(p, p->images, p->num_images);
-    for (int i = 0; i < num; i++) {
-        p->images[i] = ra_vk_wrap_swapchain_img(ra, vkimages[i], sinfo);
-        if (!p->images[i])
-            goto error;
-    }
+    bool ok = pl_swapchain_resize(p->swapchain, &width, &height);
+    ctx->vo->dwidth = width;
+    ctx->vo->dheight = height;
 
-    talloc_free(vkimages);
-    return true;
-
-error:
-    talloc_free(vkimages);
-    vkDestroySwapchainKHR(vk->dev, p->swapchain, MPVK_ALLOCATOR);
-    p->swapchain = NULL;
-    return false;
+    return ok;
 }
 
 static int color_depth(struct ra_swapchain *sw)
 {
-    struct priv *p = sw->priv;
-    int bits = 0;
-
-    if (!p->num_images)
-        return bits;
-
-    // The channel with the most bits is probably the most authoritative about
-    // the actual color information (consider e.g. a2bgr10). Slight downside
-    // in that it results in rounding r/b for e.g. rgb565, but we don't pick
-    // surfaces with fewer than 8 bits anyway.
-    const struct ra_format *fmt = p->images[0]->params.format;
-    for (int i = 0; i < fmt->num_components; i++) {
-        int depth = fmt->component_depth[i];
-        bits = MPMAX(bits, depth ? depth : fmt->component_size[i]);
-    }
-
-    return bits;
+    return 0; // TODO: implement this somehow?
 }
 
 static bool start_frame(struct ra_swapchain *sw, struct ra_fbo *out_fbo)
 {
     struct priv *p = sw->priv;
-    struct mpvk_ctx *vk = p->vk;
-    if (!p->swapchain)
+    struct pl_swapchain_frame frame;
+    if (!pl_swapchain_start_frame(p->swapchain, &frame))
+        return false;
+    if (!mppl_wrap_tex(sw->ctx->ra, frame.fbo, &p->proxy_tex))
         return false;
 
-    VkSemaphore sem_in = p->sems_in[p->idx_sems];
-    MP_TRACE(vk, "vkAcquireNextImageKHR signals %p\n", (void *)sem_in);
-
-    for (int attempts = 0; attempts < 2; attempts++) {
-        uint32_t imgidx = 0;
-        VkResult res = vkAcquireNextImageKHR(vk->dev, p->swapchain, UINT64_MAX,
-                                             sem_in, NULL, &imgidx);
-
-        switch (res) {
-        case VK_SUCCESS:
-            p->last_imgidx = imgidx;
-            *out_fbo = (struct ra_fbo) {
-                .tex = p->images[imgidx],
-                .flip = false,
-            };
-            ra_tex_vk_external_dep(sw->ctx->ra, out_fbo->tex, sem_in);
-            return true;
-
-        case VK_ERROR_OUT_OF_DATE_KHR: {
-            // In these cases try recreating the swapchain
-            int w = p->w, h = p->h;
-            p->w = p->h = 0; // invalidate the current state
-            if (!ra_vk_ctx_resize(sw, w, h))
-                return false;
-            continue;
-        }
-
-        default:
-            MP_ERR(vk, "Failed acquiring swapchain image: %s\n", vk_err(res));
-            return false;
-        }
-    }
-
-    // If we've exhausted the number of attempts to recreate the swapchain,
-    // just give up silently.
-    return false;
-}
+    *out_fbo = (struct ra_fbo) {
+        .tex = &p->proxy_tex,
+        .flip = frame.flipped,
+    };
 
-static void present_cb(struct priv *p, void *arg)
-{
-    p->frames_in_flight--;
+    return true;
 }
 
 static bool submit_frame(struct ra_swapchain *sw, const struct vo_frame *frame)
 {
     struct priv *p = sw->priv;
-    struct ra *ra = sw->ctx->ra;
-    struct mpvk_ctx *vk = p->vk;
-    if (!p->swapchain)
-        return false;
-
-    struct vk_cmd *cmd = ra_vk_submit(ra, p->images[p->last_imgidx]);
-    if (!cmd)
-        return false;
-
-    VkSemaphore sem_out = p->sems_out[p->idx_sems++];
-    p->idx_sems %= p->num_sems;
-    vk_cmd_sig(cmd, sem_out);
-
-    p->frames_in_flight++;
-    vk_cmd_callback(cmd, (vk_cb) present_cb, p, NULL);
-
-    vk_cmd_queue(vk, cmd);
-    if (!mpvk_flush_commands(vk))
-        return false;
-
-    // Older nvidia drivers can spontaneously combust when submitting to the
-    // same queue as we're rendering from, in a multi-queue scenario. Safest
-    // option is to flush the commands first and then submit to the next queue.
-    // We can drop this hack in the future, I suppose.
-    struct vk_cmdpool *pool = vk->pool_graphics;
-    VkQueue queue = pool->queues[pool->idx_queues];
-
-    VkPresentInfoKHR pinfo = {
-        .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
-        .waitSemaphoreCount = 1,
-        .pWaitSemaphores = &sem_out,
-        .swapchainCount = 1,
-        .pSwapchains = &p->swapchain,
-        .pImageIndices = &p->last_imgidx,
-    };
-
-    MP_TRACE(vk, "vkQueuePresentKHR waits on %p\n", (void *)sem_out);
-    VkResult res = vkQueuePresentKHR(queue, &pinfo);
-    switch (res) {
-    case VK_SUCCESS:
-    case VK_SUBOPTIMAL_KHR:
-        return true;
-
-    case VK_ERROR_OUT_OF_DATE_KHR:
-        // We can silently ignore this error, since the next start_frame will
-        // recreate the swapchain automatically.
-        return true;
-
-    default:
-        MP_ERR(vk, "Failed presenting to queue %p: %s\n", (void *)queue,
-               vk_err(res));
-        return false;
-    }
+    return pl_swapchain_submit_frame(p->swapchain);
 }
 
 static void swap_buffers(struct ra_swapchain *sw)
 {
     struct priv *p = sw->priv;
-
-    while (p->frames_in_flight >= sw->ctx->opts.swapchain_depth)
-        mpvk_poll_commands(p->vk, 100000); // 100μs
+    pl_swapchain_swap_buffers(p->swapchain);
 }
 
 static const struct ra_swapchain_fns vulkan_swapchain = {
diff -ruN mpv-0.29.1/video/out/vulkan/context.h mpv-master/video/out/vulkan/context.h
--- mpv-0.29.1/video/out/vulkan/context.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/context.h	2019-09-19 04:02:03.000000000 +0700
@@ -7,7 +7,9 @@
 void ra_vk_ctx_uninit(struct ra_ctx *ctx);
 bool ra_vk_ctx_init(struct ra_ctx *ctx, struct mpvk_ctx *vk,
                     VkPresentModeKHR preferred_mode);
-bool ra_vk_ctx_resize(struct ra_swapchain *sw, int w, int h);
+
+// Handles a resize request, and updates ctx->vo->dwidth/dheight
+bool ra_vk_ctx_resize(struct ra_ctx *ctx, int width, int height);
 
 // May be called on a ra_ctx of any type.
 struct mpvk_ctx *ra_vk_ctx_get(struct ra_ctx *ctx);
diff -ruN mpv-0.29.1/video/out/vulkan/context_wayland.c mpv-master/video/out/vulkan/context_wayland.c
--- mpv-0.29.1/video/out/vulkan/context_wayland.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/context_wayland.c	2019-09-19 04:02:03.000000000 +0700
@@ -41,8 +41,7 @@
     struct mpvk_ctx *vk = &p->vk;
     int msgl = ctx->opts.probing ? MSGL_V : MSGL_ERR;
 
-    if (!mpvk_instance_init(vk, ctx->log, VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME,
-                            ctx->opts.debug))
+    if (!mpvk_init(vk, ctx, VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME))
         goto error;
 
     if (!vo_wayland_init(ctx->vo))
@@ -54,10 +53,10 @@
          .surface = ctx->vo->wl->surface,
     };
 
-    VkResult res = vkCreateWaylandSurfaceKHR(vk->inst, &wlinfo, MPVK_ALLOCATOR,
-                                             &vk->surf);
+    VkInstance inst = vk->vkinst->instance;
+    VkResult res = vkCreateWaylandSurfaceKHR(inst, &wlinfo, NULL, &vk->surface);
     if (res != VK_SUCCESS) {
-        MP_MSG(ctx, msgl, "Failed creating Wayland surface: %s\n", vk_err(res));
+        MP_MSG(ctx, msgl, "Failed creating Wayland surface\n");
         goto error;
     }
 
@@ -70,6 +69,8 @@
     if (!ra_vk_ctx_init(ctx, vk, VK_PRESENT_MODE_MAILBOX_KHR))
         goto error;
 
+    ra_add_native_resource(ctx->ra, "wl", ctx->vo->wl->display);
+
     return true;
 
 error:
@@ -77,7 +78,7 @@
     return false;
 }
 
-static void resize(struct ra_ctx *ctx)
+static bool resize(struct ra_ctx *ctx)
 {
     struct vo_wayland_state *wl = ctx->vo->wl;
 
@@ -87,9 +88,7 @@
     const int32_t height = wl->scaling*mp_rect_h(wl->geometry);
 
     wl_surface_set_buffer_scale(wl->surface, wl->scaling);
-
-    wl->vo->dwidth  = width;
-    wl->vo->dheight = height;
+    return ra_vk_ctx_resize(ctx, width, height);
 }
 
 static bool wayland_vk_reconfig(struct ra_ctx *ctx)
@@ -104,8 +103,7 @@
 {
     int ret = vo_wayland_control(ctx->vo, events, request, arg);
     if (*events & VO_EVENT_RESIZE) {
-        resize(ctx);
-        if (ra_vk_ctx_resize(ctx->swapchain, ctx->vo->dwidth, ctx->vo->dheight))
+        if (!resize(ctx))
             return VO_ERROR;
     }
     return ret;
diff -ruN mpv-0.29.1/video/out/vulkan/context_win.c mpv-master/video/out/vulkan/context_win.c
--- mpv-0.29.1/video/out/vulkan/context_win.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/context_win.c	2019-09-19 04:02:03.000000000 +0700
@@ -44,8 +44,7 @@
     struct mpvk_ctx *vk = &p->vk;
     int msgl = ctx->opts.probing ? MSGL_V : MSGL_ERR;
 
-    if (!mpvk_instance_init(vk, ctx->log, VK_KHR_WIN32_SURFACE_EXTENSION_NAME,
-                            ctx->opts.debug))
+    if (!mpvk_init(vk, ctx, VK_KHR_WIN32_SURFACE_EXTENSION_NAME))
         goto error;
 
     if (!vo_w32_init(ctx->vo))
@@ -57,10 +56,10 @@
          .hwnd = vo_w32_hwnd(ctx->vo),
     };
 
-    VkResult res = vkCreateWin32SurfaceKHR(vk->inst, &wininfo, MPVK_ALLOCATOR,
-                                           &vk->surf);
+    VkInstance inst = vk->vkinst->instance;
+    VkResult res = vkCreateWin32SurfaceKHR(inst, &wininfo, NULL, &vk->surface);
     if (res != VK_SUCCESS) {
-        MP_MSG(ctx, msgl, "Failed creating Windows surface: %s\n", vk_err(res));
+        MP_MSG(ctx, msgl, "Failed creating Windows surface\n");
         goto error;
     }
 
@@ -76,7 +75,7 @@
 
 static bool resize(struct ra_ctx *ctx)
 {
-    return ra_vk_ctx_resize(ctx->swapchain, ctx->vo->dwidth, ctx->vo->dheight);
+    return ra_vk_ctx_resize(ctx, ctx->vo->dwidth, ctx->vo->dheight);
 }
 
 static bool win_reconfig(struct ra_ctx *ctx)
diff -ruN mpv-0.29.1/video/out/vulkan/context_xlib.c mpv-master/video/out/vulkan/context_xlib.c
--- mpv-0.29.1/video/out/vulkan/context_xlib.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/context_xlib.c	2019-09-19 04:02:03.000000000 +0700
@@ -41,8 +41,7 @@
     struct mpvk_ctx *vk = &p->vk;
     int msgl = ctx->opts.probing ? MSGL_V : MSGL_ERR;
 
-    if (!mpvk_instance_init(vk, ctx->log, VK_KHR_XLIB_SURFACE_EXTENSION_NAME,
-                            ctx->opts.debug))
+    if (!mpvk_init(vk, ctx, VK_KHR_XLIB_SURFACE_EXTENSION_NAME))
         goto error;
 
     if (!vo_x11_init(ctx->vo))
@@ -57,16 +56,18 @@
          .window = ctx->vo->x11->window,
     };
 
-    VkResult res = vkCreateXlibSurfaceKHR(vk->inst, &xinfo, MPVK_ALLOCATOR,
-                                          &vk->surf);
+    VkInstance inst = vk->vkinst->instance;
+    VkResult res = vkCreateXlibSurfaceKHR(inst, &xinfo, NULL, &vk->surface);
     if (res != VK_SUCCESS) {
-        MP_MSG(ctx, msgl, "Failed creating Xlib surface: %s\n", vk_err(res));
+        MP_MSG(ctx, msgl, "Failed creating Xlib surface\n");
         goto error;
     }
 
     if (!ra_vk_ctx_init(ctx, vk, VK_PRESENT_MODE_FIFO_KHR))
         goto error;
 
+    ra_add_native_resource(ctx->ra, "x11", ctx->vo->x11->display);
+
     return true;
 
 error:
@@ -76,7 +77,7 @@
 
 static bool resize(struct ra_ctx *ctx)
 {
-    return ra_vk_ctx_resize(ctx->swapchain, ctx->vo->dwidth, ctx->vo->dheight);
+    return ra_vk_ctx_resize(ctx, ctx->vo->dwidth, ctx->vo->dheight);
 }
 
 static bool xlib_reconfig(struct ra_ctx *ctx)
diff -ruN mpv-0.29.1/video/out/vulkan/formats.c mpv-master/video/out/vulkan/formats.c
--- mpv-0.29.1/video/out/vulkan/formats.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/formats.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,55 +0,0 @@
-#include "formats.h"
-
-const struct vk_format vk_formats[] = {
-    // Regular, byte-aligned integer formats
-    {"r8",       VK_FORMAT_R8_UNORM,                  1,  1,   {8             }, RA_CTYPE_UNORM },
-    {"rg8",      VK_FORMAT_R8G8_UNORM,                2,  2,   {8,  8         }, RA_CTYPE_UNORM },
-    {"rgb8",     VK_FORMAT_R8G8B8_UNORM,              3,  3,   {8,  8,  8     }, RA_CTYPE_UNORM },
-    {"rgba8",    VK_FORMAT_R8G8B8A8_UNORM,            4,  4,   {8,  8,  8,  8 }, RA_CTYPE_UNORM },
-    {"r16",      VK_FORMAT_R16_UNORM,                 1,  2,   {16            }, RA_CTYPE_UNORM },
-    {"rg16",     VK_FORMAT_R16G16_UNORM,              2,  4,   {16, 16        }, RA_CTYPE_UNORM },
-    {"rgb16",    VK_FORMAT_R16G16B16_UNORM,           3,  6,   {16, 16, 16    }, RA_CTYPE_UNORM },
-    {"rgba16",   VK_FORMAT_R16G16B16A16_UNORM,        4,  8,   {16, 16, 16, 16}, RA_CTYPE_UNORM },
-
-    // Special, integer-only formats
-    {"r32ui",    VK_FORMAT_R32_UINT,                  1,  4,   {32            }, RA_CTYPE_UINT },
-    {"rg32ui",   VK_FORMAT_R32G32_UINT,               2,  8,   {32, 32        }, RA_CTYPE_UINT },
-    {"rgb32ui",  VK_FORMAT_R32G32B32_UINT,            3,  12,  {32, 32, 32    }, RA_CTYPE_UINT },
-    {"rgba32ui", VK_FORMAT_R32G32B32A32_UINT,         4,  16,  {32, 32, 32, 32}, RA_CTYPE_UINT },
-    {"r64ui",    VK_FORMAT_R64_UINT,                  1,  8,   {64            }, RA_CTYPE_UINT },
-    {"rg64ui",   VK_FORMAT_R64G64_UINT,               2,  16,  {64, 64        }, RA_CTYPE_UINT },
-    {"rgb64ui",  VK_FORMAT_R64G64B64_UINT,            3,  24,  {64, 64, 64    }, RA_CTYPE_UINT },
-    {"rgba64ui", VK_FORMAT_R64G64B64A64_UINT,         4,  32,  {64, 64, 64, 64}, RA_CTYPE_UINT },
-
-    // Packed integer formats
-    {"rg4",      VK_FORMAT_R4G4_UNORM_PACK8,          2,  1,   {4,  4         }, RA_CTYPE_UNORM },
-    {"rgba4",    VK_FORMAT_R4G4B4A4_UNORM_PACK16,     4,  2,   {4,  4,  4,  4 }, RA_CTYPE_UNORM },
-    {"rgb565",   VK_FORMAT_R5G6B5_UNORM_PACK16,       3,  2,   {5,  6,  5     }, RA_CTYPE_UNORM },
-    {"rgb5a1",   VK_FORMAT_R5G5B5A1_UNORM_PACK16,     4,  2,   {5,  5,  5,  1 }, RA_CTYPE_UNORM },
-
-    // Float formats (native formats, hf = half float, df = double float)
-    {"r16hf",    VK_FORMAT_R16_SFLOAT,                1,  2,   {16            }, RA_CTYPE_FLOAT },
-    {"rg16hf",   VK_FORMAT_R16G16_SFLOAT,             2,  4,   {16, 16        }, RA_CTYPE_FLOAT },
-    {"rgb16hf",  VK_FORMAT_R16G16B16_SFLOAT,          3,  6,   {16, 16, 16    }, RA_CTYPE_FLOAT },
-    {"rgba16hf", VK_FORMAT_R16G16B16A16_SFLOAT,       4,  8,   {16, 16, 16, 16}, RA_CTYPE_FLOAT },
-    {"r32f",     VK_FORMAT_R32_SFLOAT,                1,  4,   {32            }, RA_CTYPE_FLOAT },
-    {"rg32f",    VK_FORMAT_R32G32_SFLOAT,             2,  8,   {32, 32        }, RA_CTYPE_FLOAT },
-    {"rgb32f",   VK_FORMAT_R32G32B32_SFLOAT,          3, 12,   {32, 32, 32    }, RA_CTYPE_FLOAT },
-    {"rgba32f",  VK_FORMAT_R32G32B32A32_SFLOAT,       4, 16,   {32, 32, 32, 32}, RA_CTYPE_FLOAT },
-    {"r64df",    VK_FORMAT_R64_SFLOAT,                1,  8,   {64            }, RA_CTYPE_FLOAT },
-    {"rg64df",   VK_FORMAT_R64G64_SFLOAT,             2, 16,   {64, 64        }, RA_CTYPE_FLOAT },
-    {"rgb64df",  VK_FORMAT_R64G64B64_SFLOAT,          3, 24,   {64, 64, 64    }, RA_CTYPE_FLOAT },
-    {"rgba64df", VK_FORMAT_R64G64B64A64_SFLOAT,       4, 32,   {64, 64, 64, 64}, RA_CTYPE_FLOAT },
-
-    // "Swapped" component order images
-    {"bgr8",     VK_FORMAT_B8G8R8_UNORM,              3,  3,   {8,  8,  8     }, RA_CTYPE_UNORM, true },
-    {"bgra8",    VK_FORMAT_B8G8R8A8_UNORM,            4,  4,   {8,  8,  8,  8 }, RA_CTYPE_UNORM, true },
-    {"bgra4",    VK_FORMAT_B4G4R4A4_UNORM_PACK16,     4,  2,   {4,  4,  4,  4 }, RA_CTYPE_UNORM, true },
-    {"bgr565",   VK_FORMAT_B5G6R5_UNORM_PACK16,       3,  2,   {5,  6,  5     }, RA_CTYPE_UNORM, true },
-    {"bgr5a1",   VK_FORMAT_B5G5R5A1_UNORM_PACK16,     4,  2,   {5,  5,  5,  1 }, RA_CTYPE_UNORM, true },
-    {"a1rgb5",   VK_FORMAT_A1R5G5B5_UNORM_PACK16,     4,  2,   {1,  5,  5,  5 }, RA_CTYPE_UNORM, true },
-    {"a2rgb10",  VK_FORMAT_A2R10G10B10_UNORM_PACK32,  4,  4,   {2,  10, 10, 10}, RA_CTYPE_UNORM, true },
-    {"a2bgr10",  VK_FORMAT_A2B10G10R10_UNORM_PACK32,  4,  4,   {2,  10, 10, 10}, RA_CTYPE_UNORM, true },
-    {"abgr8",    VK_FORMAT_A8B8G8R8_UNORM_PACK32,     4,  4,   {8,  8,  8,  8 }, RA_CTYPE_UNORM, true },
-    {0}
-};
diff -ruN mpv-0.29.1/video/out/vulkan/formats.h mpv-master/video/out/vulkan/formats.h
--- mpv-0.29.1/video/out/vulkan/formats.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/formats.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,16 +0,0 @@
-#pragma once
-
-#include "video/out/gpu/ra.h"
-#include "common.h"
-
-struct vk_format {
-    const char *name;
-    VkFormat iformat;    // vulkan format enum
-    int components;      // how many components are there
-    int bytes;           // how many bytes is a texel
-    int bits[4];         // how many bits per component
-    enum ra_ctype ctype; // format representation type
-    bool fucked_order;   // used for formats which are not simply rgba
-};
-
-extern const struct vk_format vk_formats[];
diff -ruN mpv-0.29.1/video/out/vulkan/malloc.c mpv-master/video/out/vulkan/malloc.c
--- mpv-0.29.1/video/out/vulkan/malloc.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/malloc.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,434 +0,0 @@
-#include "malloc.h"
-#include "utils.h"
-#include "osdep/timer.h"
-
-// Controls the multiplication factor for new slab allocations. The new slab
-// will always be allocated such that the size of the slab is this factor times
-// the previous slab. Higher values make it grow faster.
-#define MPVK_HEAP_SLAB_GROWTH_RATE 4
-
-// Controls the minimum slab size, to reduce the frequency at which very small
-// slabs would need to get allocated when allocating the first few buffers.
-// (Default: 1 MB)
-#define MPVK_HEAP_MINIMUM_SLAB_SIZE (1 << 20)
-
-// Controls the maximum slab size, to reduce the effect of unbounded slab
-// growth exhausting memory. If the application needs a single allocation
-// that's bigger than this value, it will be allocated directly from the
-// device. (Default: 512 MB)
-#define MPVK_HEAP_MAXIMUM_SLAB_SIZE (1 << 29)
-
-// Controls the minimum free region size, to reduce thrashing the free space
-// map with lots of small buffers during uninit. (Default: 1 KB)
-#define MPVK_HEAP_MINIMUM_REGION_SIZE (1 << 10)
-
-// Represents a region of available memory
-struct vk_region {
-    size_t start; // first offset in region
-    size_t end;   // first offset *not* in region
-};
-
-static inline size_t region_len(struct vk_region r)
-{
-    return r.end - r.start;
-}
-
-// A single slab represents a contiguous region of allocated memory. Actual
-// allocations are served as slices of this. Slabs are organized into linked
-// lists, which represent individual heaps.
-struct vk_slab {
-    VkDeviceMemory mem;   // underlying device allocation
-    size_t size;          // total size of `slab`
-    size_t used;          // number of bytes actually in use (for GC accounting)
-    bool dedicated;       // slab is allocated specifically for one object
-    // free space map: a sorted list of memory regions that are available
-    struct vk_region *regions;
-    int num_regions;
-    // optional, depends on the memory type:
-    VkBuffer buffer;      // buffer spanning the entire slab
-    void *data;           // mapped memory corresponding to `mem`
-};
-
-// Represents a single memory heap. We keep track of a vk_heap for each
-// combination of buffer type and memory selection parameters. This shouldn't
-// actually be that many in practice, because some combinations simply never
-// occur, and others will generally be the same for the same objects.
-struct vk_heap {
-    VkBufferUsageFlags usage;    // the buffer usage type (or 0)
-    VkMemoryPropertyFlags flags; // the memory type flags (or 0)
-    uint32_t typeBits;           // the memory type index requirements (or 0)
-    struct vk_slab **slabs;      // array of slabs sorted by size
-    int num_slabs;
-};
-
-// The overall state of the allocator, which keeps track of a vk_heap for each
-// memory type.
-struct vk_malloc {
-    VkPhysicalDeviceMemoryProperties props;
-    struct vk_heap *heaps;
-    int num_heaps;
-};
-
-static void slab_free(struct mpvk_ctx *vk, struct vk_slab *slab)
-{
-    if (!slab)
-        return;
-
-    assert(slab->used == 0);
-
-    int64_t start = mp_time_us();
-    vkDestroyBuffer(vk->dev, slab->buffer, MPVK_ALLOCATOR);
-    // also implicitly unmaps the memory if needed
-    vkFreeMemory(vk->dev, slab->mem, MPVK_ALLOCATOR);
-    int64_t stop = mp_time_us();
-
-    MP_VERBOSE(vk, "Freeing slab of size %zu took %lld μs.\n",
-               slab->size, (long long)(stop - start));
-
-    talloc_free(slab);
-}
-
-static bool find_best_memtype(struct mpvk_ctx *vk, uint32_t typeBits,
-                              VkMemoryPropertyFlags flags,
-                              VkMemoryType *out_type, int *out_index)
-{
-    struct vk_malloc *ma = vk->alloc;
-
-    // The vulkan spec requires memory types to be sorted in the "optimal"
-    // order, so the first matching type we find will be the best/fastest one.
-    for (int i = 0; i < ma->props.memoryTypeCount; i++) {
-        // The memory type flags must include our properties
-        if ((ma->props.memoryTypes[i].propertyFlags & flags) != flags)
-            continue;
-        // The memory type must be supported by the requirements (bitfield)
-        if (typeBits && !(typeBits & (1 << i)))
-            continue;
-        *out_type = ma->props.memoryTypes[i];
-        *out_index = i;
-        return true;
-    }
-
-    MP_ERR(vk, "Found no memory type matching property flags 0x%x and type "
-               "bits 0x%x!\n", (unsigned)flags, (unsigned)typeBits);
-    return false;
-}
-
-static struct vk_slab *slab_alloc(struct mpvk_ctx *vk, struct vk_heap *heap,
-                                  size_t size)
-{
-    struct vk_slab *slab = talloc_ptrtype(NULL, slab);
-    *slab = (struct vk_slab) {
-        .size = size,
-    };
-
-    MP_TARRAY_APPEND(slab, slab->regions, slab->num_regions, (struct vk_region) {
-        .start = 0,
-        .end   = slab->size,
-    });
-
-    VkMemoryAllocateInfo minfo = {
-        .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
-        .allocationSize = slab->size,
-    };
-
-    uint32_t typeBits = heap->typeBits ? heap->typeBits : UINT32_MAX;
-    if (heap->usage) {
-        // FIXME: Since we can't keep track of queue family ownership properly,
-        // and we don't know in advance what types of queue families this buffer
-        // will belong to, we're forced to share all of our buffers between all
-        // command pools.
-        uint32_t qfs[3] = {0};
-        for (int i = 0; i < vk->num_pools; i++)
-            qfs[i] = vk->pools[i]->qf;
-
-        VkBufferCreateInfo binfo = {
-            .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
-            .size  = slab->size,
-            .usage = heap->usage,
-            .sharingMode = vk->num_pools > 1 ? VK_SHARING_MODE_CONCURRENT
-                                             : VK_SHARING_MODE_EXCLUSIVE,
-            .queueFamilyIndexCount = vk->num_pools,
-            .pQueueFamilyIndices = qfs,
-        };
-
-        VK(vkCreateBuffer(vk->dev, &binfo, MPVK_ALLOCATOR, &slab->buffer));
-
-        VkMemoryRequirements reqs;
-        vkGetBufferMemoryRequirements(vk->dev, slab->buffer, &reqs);
-        minfo.allocationSize = reqs.size; // this can be larger than slab->size
-        typeBits &= reqs.memoryTypeBits;  // this can restrict the types
-    }
-
-    VkMemoryType type;
-    int index;
-    if (!find_best_memtype(vk, typeBits, heap->flags, &type, &index))
-        goto error;
-
-    MP_VERBOSE(vk, "Allocating %zu memory of type 0x%x (id %d) in heap %d.\n",
-               slab->size, (unsigned)type.propertyFlags, index, (int)type.heapIndex);
-
-    minfo.memoryTypeIndex = index;
-    VK(vkAllocateMemory(vk->dev, &minfo, MPVK_ALLOCATOR, &slab->mem));
-
-    if (heap->flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
-        VK(vkMapMemory(vk->dev, slab->mem, 0, VK_WHOLE_SIZE, 0, &slab->data));
-
-    if (slab->buffer)
-        VK(vkBindBufferMemory(vk->dev, slab->buffer, slab->mem, 0));
-
-    return slab;
-
-error:
-    slab_free(vk, slab);
-    return NULL;
-}
-
-static void insert_region(struct vk_slab *slab, struct vk_region region)
-{
-    if (region.start == region.end)
-        return;
-
-    bool big_enough = region_len(region) >= MPVK_HEAP_MINIMUM_REGION_SIZE;
-
-    // Find the index of the first region that comes after this
-    for (int i = 0; i < slab->num_regions; i++) {
-        struct vk_region *r = &slab->regions[i];
-
-        // Check for a few special cases which can be coalesced
-        if (r->end == region.start) {
-            // The new region is at the tail of this region. In addition to
-            // modifying this region, we also need to coalesce all the following
-            // regions for as long as possible
-            r->end = region.end;
-
-            struct vk_region *next = &slab->regions[i+1];
-            while (i+1 < slab->num_regions && r->end == next->start) {
-                r->end = next->end;
-                MP_TARRAY_REMOVE_AT(slab->regions, slab->num_regions, i+1);
-            }
-            return;
-        }
-
-        if (r->start == region.end) {
-            // The new region is at the head of this region. We don't need to
-            // do anything special here - because if this could be further
-            // coalesced backwards, the previous loop iteration would already
-            // have caught it.
-            r->start = region.start;
-            return;
-        }
-
-        if (r->start > region.start) {
-            // The new region comes somewhere before this region, so insert
-            // it into this index in the array.
-            if (big_enough) {
-                MP_TARRAY_INSERT_AT(slab, slab->regions, slab->num_regions,
-                                    i, region);
-            }
-            return;
-        }
-    }
-
-    // If we've reached the end of this loop, then all of the regions
-    // come before the new region, and are disconnected - so append it
-    if (big_enough)
-        MP_TARRAY_APPEND(slab, slab->regions, slab->num_regions, region);
-}
-
-static void heap_uninit(struct mpvk_ctx *vk, struct vk_heap *heap)
-{
-    for (int i = 0; i < heap->num_slabs; i++)
-        slab_free(vk, heap->slabs[i]);
-
-    talloc_free(heap->slabs);
-    *heap = (struct vk_heap){0};
-}
-
-void vk_malloc_init(struct mpvk_ctx *vk)
-{
-    assert(vk->physd);
-    vk->alloc = talloc_zero(NULL, struct vk_malloc);
-    vkGetPhysicalDeviceMemoryProperties(vk->physd, &vk->alloc->props);
-}
-
-void vk_malloc_uninit(struct mpvk_ctx *vk)
-{
-    struct vk_malloc *ma = vk->alloc;
-    if (!ma)
-        return;
-
-    for (int i = 0; i < ma->num_heaps; i++)
-        heap_uninit(vk, &ma->heaps[i]);
-
-    talloc_free(ma);
-    vk->alloc = NULL;
-}
-
-void vk_free_memslice(struct mpvk_ctx *vk, struct vk_memslice slice)
-{
-    struct vk_slab *slab = slice.priv;
-    if (!slab)
-        return;
-
-    assert(slab->used >= slice.size);
-    slab->used -= slice.size;
-
-    MP_DBG(vk, "Freeing slice %zu + %zu from slab with size %zu\n",
-           slice.offset, slice.size, slab->size);
-
-    if (slab->dedicated) {
-        // If the slab was purpose-allocated for this memslice, we can just
-        // free it here
-        slab_free(vk, slab);
-    } else {
-        // Return the allocation to the free space map
-        insert_region(slab, (struct vk_region) {
-            .start = slice.offset,
-            .end   = slice.offset + slice.size,
-        });
-    }
-}
-
-// reqs: can be NULL
-static struct vk_heap *find_heap(struct mpvk_ctx *vk, VkBufferUsageFlags usage,
-                                 VkMemoryPropertyFlags flags,
-                                 VkMemoryRequirements *reqs)
-{
-    struct vk_malloc *ma = vk->alloc;
-    int typeBits = reqs ? reqs->memoryTypeBits : 0;
-
-    for (int i = 0; i < ma->num_heaps; i++) {
-        if (ma->heaps[i].usage != usage)
-            continue;
-        if (ma->heaps[i].flags != flags)
-            continue;
-        if (ma->heaps[i].typeBits != typeBits)
-            continue;
-        return &ma->heaps[i];
-    }
-
-    // Not found => add it
-    MP_TARRAY_GROW(ma, ma->heaps, ma->num_heaps + 1);
-    struct vk_heap *heap = &ma->heaps[ma->num_heaps++];
-    *heap = (struct vk_heap) {
-        .usage    = usage,
-        .flags    = flags,
-        .typeBits = typeBits,
-    };
-    return heap;
-}
-
-static inline bool region_fits(struct vk_region r, size_t size, size_t align)
-{
-    return MP_ALIGN_UP(r.start, align) + size <= r.end;
-}
-
-// Finds the best-fitting region in a heap. If the heap is too small or too
-// fragmented, a new slab will be allocated under the hood.
-static bool heap_get_region(struct mpvk_ctx *vk, struct vk_heap *heap,
-                            size_t size, size_t align,
-                            struct vk_slab **out_slab, int *out_index)
-{
-    struct vk_slab *slab = NULL;
-
-    // If the allocation is very big, serve it directly instead of bothering
-    // with the heap
-    if (size > MPVK_HEAP_MAXIMUM_SLAB_SIZE) {
-        slab = slab_alloc(vk, heap, size);
-        *out_slab = slab;
-        *out_index = 0;
-        return !!slab;
-    }
-
-    for (int i = 0; i < heap->num_slabs; i++) {
-        slab = heap->slabs[i];
-        if (slab->size < size)
-            continue;
-
-        // Attempt a best fit search
-        int best = -1;
-        for (int n = 0; n < slab->num_regions; n++) {
-            struct vk_region r = slab->regions[n];
-            if (!region_fits(r, size, align))
-                continue;
-            if (best >= 0 && region_len(r) > region_len(slab->regions[best]))
-                continue;
-            best = n;
-        }
-
-        if (best >= 0) {
-            *out_slab = slab;
-            *out_index = best;
-            return true;
-        }
-    }
-
-    // Otherwise, allocate a new vk_slab and append it to the list.
-    size_t cur_size = MPMAX(size, slab ? slab->size : 0);
-    size_t slab_size = MPVK_HEAP_SLAB_GROWTH_RATE * cur_size;
-    slab_size = MPMAX(MPVK_HEAP_MINIMUM_SLAB_SIZE, slab_size);
-    slab_size = MPMIN(MPVK_HEAP_MAXIMUM_SLAB_SIZE, slab_size);
-    assert(slab_size >= size);
-    slab = slab_alloc(vk, heap, slab_size);
-    if (!slab)
-        return false;
-    MP_TARRAY_APPEND(NULL, heap->slabs, heap->num_slabs, slab);
-
-    // Return the only region there is in a newly allocated slab
-    assert(slab->num_regions == 1);
-    *out_slab = slab;
-    *out_index = 0;
-    return true;
-}
-
-static bool slice_heap(struct mpvk_ctx *vk, struct vk_heap *heap, size_t size,
-                       size_t alignment, struct vk_memslice *out)
-{
-    struct vk_slab *slab;
-    int index;
-    alignment = MP_ALIGN_UP(alignment, vk->limits.bufferImageGranularity);
-    if (!heap_get_region(vk, heap, size, alignment, &slab, &index))
-        return false;
-
-    struct vk_region reg = slab->regions[index];
-    MP_TARRAY_REMOVE_AT(slab->regions, slab->num_regions, index);
-    *out = (struct vk_memslice) {
-        .vkmem = slab->mem,
-        .offset = MP_ALIGN_UP(reg.start, alignment),
-        .size = size,
-        .priv = slab,
-    };
-
-    MP_DBG(vk, "Sub-allocating slice %zu + %zu from slab with size %zu\n",
-           out->offset, out->size, slab->size);
-
-    size_t out_end = out->offset + out->size;
-    insert_region(slab, (struct vk_region) { reg.start, out->offset });
-    insert_region(slab, (struct vk_region) { out_end, reg.end });
-
-    slab->used += size;
-    return true;
-}
-
-bool vk_malloc_generic(struct mpvk_ctx *vk, VkMemoryRequirements reqs,
-                       VkMemoryPropertyFlags flags, struct vk_memslice *out)
-{
-    struct vk_heap *heap = find_heap(vk, 0, flags, &reqs);
-    return slice_heap(vk, heap, reqs.size, reqs.alignment, out);
-}
-
-bool vk_malloc_buffer(struct mpvk_ctx *vk, VkBufferUsageFlags bufFlags,
-                      VkMemoryPropertyFlags memFlags, VkDeviceSize size,
-                      VkDeviceSize alignment, struct vk_bufslice *out)
-{
-    struct vk_heap *heap = find_heap(vk, bufFlags, memFlags, NULL);
-    if (!slice_heap(vk, heap, size, alignment, &out->mem))
-        return false;
-
-    struct vk_slab *slab = out->mem.priv;
-    out->buf = slab->buffer;
-    if (slab->data)
-        out->data = (void *)((uintptr_t)slab->data + (ptrdiff_t)out->mem.offset);
-
-    return true;
-}
diff -ruN mpv-0.29.1/video/out/vulkan/malloc.h mpv-master/video/out/vulkan/malloc.h
--- mpv-0.29.1/video/out/vulkan/malloc.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/malloc.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,35 +0,0 @@
-#pragma once
-
-#include "common.h"
-
-void vk_malloc_init(struct mpvk_ctx *vk);
-void vk_malloc_uninit(struct mpvk_ctx *vk);
-
-// Represents a single "slice" of generic (non-buffer) memory, plus some
-// metadata for accounting. This struct is essentially read-only.
-struct vk_memslice {
-    VkDeviceMemory vkmem;
-    size_t offset;
-    size_t size;
-    void *priv;
-};
-
-void vk_free_memslice(struct mpvk_ctx *vk, struct vk_memslice slice);
-bool vk_malloc_generic(struct mpvk_ctx *vk, VkMemoryRequirements reqs,
-                       VkMemoryPropertyFlags flags, struct vk_memslice *out);
-
-// Represents a single "slice" of a larger buffer
-struct vk_bufslice {
-    struct vk_memslice mem; // must be freed by the user when done
-    VkBuffer buf;           // the buffer this memory was sliced from
-    // For persistently mapped buffers, this points to the first usable byte of
-    // this slice.
-    void *data;
-};
-
-// Allocate a buffer slice. This is more efficient than vk_malloc_generic for
-// when the user needs lots of buffers, since it doesn't require
-// creating/destroying lots of (little) VkBuffers.
-bool vk_malloc_buffer(struct mpvk_ctx *vk, VkBufferUsageFlags bufFlags,
-                      VkMemoryPropertyFlags memFlags, VkDeviceSize size,
-                      VkDeviceSize alignment, struct vk_bufslice *out);
diff -ruN mpv-0.29.1/video/out/vulkan/ra_vk.c mpv-master/video/out/vulkan/ra_vk.c
--- mpv-0.29.1/video/out/vulkan/ra_vk.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/ra_vk.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,1901 +0,0 @@
-#include "video/out/gpu/utils.h"
-#include "video/out/gpu/spirv.h"
-
-#include "ra_vk.h"
-#include "malloc.h"
-
-static struct ra_fns ra_fns_vk;
-
-enum queue_type {
-    GRAPHICS,
-    COMPUTE,
-    TRANSFER,
-};
-
-// For ra.priv
-struct ra_vk {
-    struct mpvk_ctx *vk;
-    struct ra_tex *clear_tex; // stupid hack for clear()
-    struct vk_cmd *cmd;       // currently recording cmd
-};
-
-struct mpvk_ctx *ra_vk_get(struct ra *ra)
-{
-    if (ra->fns != &ra_fns_vk)
-        return NULL;
-
-    struct ra_vk *p = ra->priv;
-    return p->vk;
-}
-
-static void vk_submit(struct ra *ra)
-{
-    struct ra_vk *p = ra->priv;
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-
-    if (p->cmd) {
-        vk_cmd_queue(vk, p->cmd);
-        p->cmd = NULL;
-    }
-}
-
-// Returns a command buffer, or NULL on error
-static struct vk_cmd *vk_require_cmd(struct ra *ra, enum queue_type type)
-{
-    struct ra_vk *p = ra->priv;
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-
-    struct vk_cmdpool *pool;
-    switch (type) {
-    case GRAPHICS: pool = vk->pool_graphics; break;
-    case COMPUTE:  pool = vk->pool_compute;  break;
-
-    // GRAPHICS and COMPUTE also imply TRANSFER capability (vulkan spec)
-    case TRANSFER:
-        pool = vk->pool_transfer;
-        if (!pool)
-            pool = vk->pool_compute;
-        if (!pool)
-            pool = vk->pool_graphics;
-        break;
-    default: abort();
-    }
-
-    assert(pool);
-    if (p->cmd && p->cmd->pool == pool)
-        return p->cmd;
-
-    vk_submit(ra);
-    p->cmd = vk_cmd_begin(vk, pool);
-    return p->cmd;
-}
-
-#define MAKE_LAZY_DESTRUCTOR(fun, argtype)                  \
-    static void fun##_lazy(struct ra *ra, argtype *arg) {   \
-        struct ra_vk *p = ra->priv;                         \
-        struct mpvk_ctx *vk = ra_vk_get(ra);                \
-        if (p->cmd) {                                       \
-            vk_cmd_callback(p->cmd, (vk_cb) fun, ra, arg);  \
-        } else {                                            \
-            vk_dev_callback(vk, (vk_cb) fun, ra, arg);      \
-        }                                                   \
-    }
-
-static void vk_destroy_ra(struct ra *ra)
-{
-    struct ra_vk *p = ra->priv;
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-
-    vk_submit(ra);
-    mpvk_flush_commands(vk);
-    mpvk_poll_commands(vk, UINT64_MAX);
-    ra_tex_free(ra, &p->clear_tex);
-
-    talloc_free(ra);
-}
-
-static bool vk_setup_formats(struct ra *ra)
-{
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-
-    for (const struct vk_format *vk_fmt = vk_formats; vk_fmt->name; vk_fmt++) {
-        VkFormatProperties prop;
-        vkGetPhysicalDeviceFormatProperties(vk->physd, vk_fmt->iformat, &prop);
-
-        // As a bare minimum, we need to sample from an allocated image
-        VkFormatFeatureFlags flags = prop.optimalTilingFeatures;
-        if (!(flags & VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT))
-            continue;
-
-        VkFormatFeatureFlags linear_bits, render_bits;
-        linear_bits = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT;
-        render_bits = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT |
-                      VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT;
-
-        struct ra_format *fmt = talloc_zero(ra, struct ra_format);
-        *fmt = (struct ra_format) {
-            .name            = vk_fmt->name,
-            .priv            = (void *)vk_fmt,
-            .ctype           = vk_fmt->ctype,
-            .ordered         = !vk_fmt->fucked_order,
-            .num_components  = vk_fmt->components,
-            .pixel_size      = vk_fmt->bytes,
-            .linear_filter   = !!(flags & linear_bits),
-            .renderable      = !!(flags & render_bits),
-        };
-
-        for (int i = 0; i < 4; i++)
-            fmt->component_size[i] = fmt->component_depth[i] = vk_fmt->bits[i];
-
-        fmt->glsl_format = ra_fmt_glsl_format(fmt);
-
-        MP_TARRAY_APPEND(ra, ra->formats, ra->num_formats, fmt);
-    }
-
-    // Populate some other capabilities related to formats while we're at it
-    VkImageType imgType[3] = {
-        VK_IMAGE_TYPE_1D,
-        VK_IMAGE_TYPE_2D,
-        VK_IMAGE_TYPE_3D
-    };
-
-    // R8_UNORM is supported on literally every single vulkan implementation
-    const VkFormat testfmt = VK_FORMAT_R8_UNORM;
-
-    for (int d = 0; d < 3; d++) {
-        VkImageFormatProperties iprop;
-        VkResult res = vkGetPhysicalDeviceImageFormatProperties(vk->physd,
-                testfmt, imgType[d], VK_IMAGE_TILING_OPTIMAL,
-                VK_IMAGE_USAGE_SAMPLED_BIT, 0, &iprop);
-
-        switch (imgType[d]) {
-        case VK_IMAGE_TYPE_1D:
-            if (res == VK_SUCCESS)
-                ra->caps |= RA_CAP_TEX_1D;
-            break;
-        case VK_IMAGE_TYPE_2D:
-            // 2D formats must be supported by RA, so ensure this is the case
-            VK_ASSERT(res, "Querying 2D format limits");
-            ra->max_texture_wh = MPMIN(iprop.maxExtent.width, iprop.maxExtent.height);
-            break;
-        case VK_IMAGE_TYPE_3D:
-            if (res == VK_SUCCESS)
-                ra->caps |= RA_CAP_TEX_3D;
-            break;
-        }
-    }
-
-    // RA_CAP_BLIT implies both blitting between images as well as blitting
-    // directly to the swapchain image, so check for all three operations
-    bool blittable = true;
-    VkFormatProperties prop;
-    vkGetPhysicalDeviceFormatProperties(vk->physd, testfmt, &prop);
-    if (!(prop.optimalTilingFeatures & VK_FORMAT_FEATURE_BLIT_SRC_BIT))
-        blittable = false;
-    if (!(prop.optimalTilingFeatures & VK_FORMAT_FEATURE_BLIT_DST_BIT))
-        blittable = false;
-
-    vkGetPhysicalDeviceFormatProperties(vk->physd, vk->surf_format.format, &prop);
-    if (!(prop.optimalTilingFeatures & VK_FORMAT_FEATURE_BLIT_DST_BIT))
-        blittable = false;
-
-    if (blittable)
-        ra->caps |= RA_CAP_BLIT;
-
-    return true;
-
-error:
-    return false;
-}
-
-static struct ra_fns ra_fns_vk;
-
-struct ra *ra_create_vk(struct mpvk_ctx *vk, struct mp_log *log)
-{
-    assert(vk->dev);
-    assert(vk->alloc);
-
-    struct ra *ra = talloc_zero(NULL, struct ra);
-    ra->log = log;
-    ra->fns = &ra_fns_vk;
-
-    struct ra_vk *p = ra->priv = talloc_zero(ra, struct ra_vk);
-    p->vk = vk;
-
-    ra->caps |= vk->spirv->ra_caps;
-    ra->glsl_version = vk->spirv->glsl_version;
-    ra->glsl_vulkan = true;
-    ra->max_shmem = vk->limits.maxComputeSharedMemorySize;
-    ra->max_pushc_size = vk->limits.maxPushConstantsSize;
-
-    if (vk->pool_compute) {
-        ra->caps |= RA_CAP_COMPUTE | RA_CAP_NUM_GROUPS;
-        // If we have more compute queues than graphics queues, we probably
-        // want to be using them. (This seems mostly relevant for AMD)
-        if (vk->pool_compute->num_queues > vk->pool_graphics->num_queues)
-            ra->caps |= RA_CAP_PARALLEL_COMPUTE;
-    }
-
-    if (!vk_setup_formats(ra))
-        goto error;
-
-    // UBO support is required
-    ra->caps |= RA_CAP_BUF_RO | RA_CAP_FRAGCOORD;
-
-    // textureGather requires the ImageGatherExtended capability
-    if (vk->features.shaderImageGatherExtended)
-        ra->caps |= RA_CAP_GATHER;
-
-    // Try creating a shader storage buffer
-    struct ra_buf_params ssbo_params = {
-        .type = RA_BUF_TYPE_SHADER_STORAGE,
-        .size = 16,
-    };
-
-    struct ra_buf *ssbo = ra_buf_create(ra, &ssbo_params);
-    if (ssbo) {
-        ra->caps |= RA_CAP_BUF_RW;
-        ra_buf_free(ra, &ssbo);
-    }
-
-    // To support clear() by region, we need to allocate a dummy 1x1 image that
-    // will be used as the source of blit operations
-    struct ra_tex_params clear_params = {
-        .dimensions = 1, // no point in using a 2D image if height = 1
-        .w = 1,
-        .h = 1,
-        .d = 1,
-        .format = ra_find_float16_format(ra, 4),
-        .blit_src = 1,
-        .host_mutable = 1,
-    };
-
-    p->clear_tex = ra_tex_create(ra, &clear_params);
-    if (!p->clear_tex) {
-        MP_ERR(ra, "Failed creating 1x1 dummy texture for clear()!\n");
-        goto error;
-    }
-
-    return ra;
-
-error:
-    vk_destroy_ra(ra);
-    return NULL;
-}
-
-// Boilerplate wrapper around vkCreateRenderPass to ensure passes remain
-// compatible. The renderpass will automatically transition the image out of
-// initialLayout and into finalLayout.
-static VkResult vk_create_render_pass(VkDevice dev, const struct ra_format *fmt,
-                                      VkAttachmentLoadOp loadOp,
-                                      VkImageLayout initialLayout,
-                                      VkImageLayout finalLayout,
-                                      VkRenderPass *out)
-{
-    struct vk_format *vk_fmt = fmt->priv;
-    assert(fmt->renderable);
-
-    VkRenderPassCreateInfo rinfo = {
-        .sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
-        .attachmentCount = 1,
-        .pAttachments = &(VkAttachmentDescription) {
-            .format = vk_fmt->iformat,
-            .samples = VK_SAMPLE_COUNT_1_BIT,
-            .loadOp = loadOp,
-            .storeOp = VK_ATTACHMENT_STORE_OP_STORE,
-            .initialLayout = initialLayout,
-            .finalLayout = finalLayout,
-        },
-        .subpassCount = 1,
-        .pSubpasses = &(VkSubpassDescription) {
-            .pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS,
-            .colorAttachmentCount = 1,
-            .pColorAttachments = &(VkAttachmentReference) {
-                .attachment = 0,
-                .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
-            },
-        },
-    };
-
-    return vkCreateRenderPass(dev, &rinfo, MPVK_ALLOCATOR, out);
-}
-
-// For ra_tex.priv
-struct ra_tex_vk {
-    bool external_img;
-    enum queue_type upload_queue;
-    VkImageType type;
-    VkImage img;
-    struct vk_memslice mem;
-    // for sampling
-    VkImageView view;
-    VkSampler sampler;
-    // for rendering
-    VkFramebuffer framebuffer;
-    VkRenderPass dummyPass;
-    // for uploading
-    struct ra_buf_pool pbo;
-    // "current" metadata, can change during the course of execution
-    VkImageLayout current_layout;
-    VkAccessFlags current_access;
-    // the signal guards reuse, and can be NULL
-    struct vk_signal *sig;
-    VkPipelineStageFlags sig_stage;
-    VkSemaphore ext_dep; // external semaphore, not owned by the ra_tex
-};
-
-void ra_tex_vk_external_dep(struct ra *ra, struct ra_tex *tex, VkSemaphore dep)
-{
-    struct ra_tex_vk *tex_vk = tex->priv;
-    assert(!tex_vk->ext_dep);
-    tex_vk->ext_dep = dep;
-}
-
-// Small helper to ease image barrier creation. if `discard` is set, the contents
-// of the image will be undefined after the barrier
-static void tex_barrier(struct ra *ra, struct vk_cmd *cmd, struct ra_tex *tex,
-                        VkPipelineStageFlags stage, VkAccessFlags newAccess,
-                        VkImageLayout newLayout, bool discard)
-{
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-    struct ra_tex_vk *tex_vk = tex->priv;
-
-    if (tex_vk->ext_dep) {
-        vk_cmd_dep(cmd, tex_vk->ext_dep, stage);
-        tex_vk->ext_dep = NULL;
-    }
-
-    VkImageMemoryBarrier imgBarrier = {
-        .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
-        .oldLayout = tex_vk->current_layout,
-        .newLayout = newLayout,
-        .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .srcAccessMask = tex_vk->current_access,
-        .dstAccessMask = newAccess,
-        .image = tex_vk->img,
-        .subresourceRange = vk_range,
-    };
-
-    if (discard) {
-        imgBarrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
-        imgBarrier.srcAccessMask = 0;
-    }
-
-    VkEvent event = NULL;
-    vk_cmd_wait(vk, cmd, &tex_vk->sig, stage, &event);
-
-    bool need_trans = tex_vk->current_layout != newLayout ||
-                      tex_vk->current_access != newAccess;
-
-    // Transitioning to VK_IMAGE_LAYOUT_UNDEFINED is a pseudo-operation
-    // that for us means we don't need to perform the actual transition
-    if (need_trans && newLayout != VK_IMAGE_LAYOUT_UNDEFINED) {
-        if (event) {
-            vkCmdWaitEvents(cmd->buf, 1, &event, tex_vk->sig_stage,
-                            stage, 0, NULL, 0, NULL, 1, &imgBarrier);
-        } else {
-            // If we're not using an event, then the source stage is irrelevant
-            // because we're coming from a different queue anyway, so we can
-            // safely set it to TOP_OF_PIPE.
-            imgBarrier.srcAccessMask = 0;
-            vkCmdPipelineBarrier(cmd->buf, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
-                                 stage, 0, 0, NULL, 0, NULL, 1, &imgBarrier);
-        }
-    }
-
-    tex_vk->current_layout = newLayout;
-    tex_vk->current_access = newAccess;
-}
-
-static void tex_signal(struct ra *ra, struct vk_cmd *cmd, struct ra_tex *tex,
-                       VkPipelineStageFlags stage)
-{
-    struct ra_tex_vk *tex_vk = tex->priv;
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-    assert(!tex_vk->sig);
-
-    tex_vk->sig = vk_cmd_signal(vk, cmd, stage);
-    tex_vk->sig_stage = stage;
-}
-
-static void vk_tex_destroy(struct ra *ra, struct ra_tex *tex)
-{
-    if (!tex)
-        return;
-
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-    struct ra_tex_vk *tex_vk = tex->priv;
-
-    ra_buf_pool_uninit(ra, &tex_vk->pbo);
-    vk_signal_destroy(vk, &tex_vk->sig);
-    vkDestroyFramebuffer(vk->dev, tex_vk->framebuffer, MPVK_ALLOCATOR);
-    vkDestroyRenderPass(vk->dev, tex_vk->dummyPass, MPVK_ALLOCATOR);
-    vkDestroySampler(vk->dev, tex_vk->sampler, MPVK_ALLOCATOR);
-    vkDestroyImageView(vk->dev, tex_vk->view, MPVK_ALLOCATOR);
-    if (!tex_vk->external_img) {
-        vkDestroyImage(vk->dev, tex_vk->img, MPVK_ALLOCATOR);
-        vk_free_memslice(vk, tex_vk->mem);
-    }
-
-    talloc_free(tex);
-}
-
-MAKE_LAZY_DESTRUCTOR(vk_tex_destroy, struct ra_tex);
-
-// Initializes non-VkImage values like the image view, samplers, etc.
-static bool vk_init_image(struct ra *ra, struct ra_tex *tex)
-{
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-
-    struct ra_tex_params *params = &tex->params;
-    struct ra_tex_vk *tex_vk = tex->priv;
-    assert(tex_vk->img);
-
-    tex_vk->current_layout = VK_IMAGE_LAYOUT_UNDEFINED;
-    tex_vk->current_access = 0;
-
-    if (params->render_src || params->render_dst) {
-        static const VkImageViewType viewType[] = {
-            [VK_IMAGE_TYPE_1D] = VK_IMAGE_VIEW_TYPE_1D,
-            [VK_IMAGE_TYPE_2D] = VK_IMAGE_VIEW_TYPE_2D,
-            [VK_IMAGE_TYPE_3D] = VK_IMAGE_VIEW_TYPE_3D,
-        };
-
-        const struct vk_format *fmt = params->format->priv;
-        VkImageViewCreateInfo vinfo = {
-            .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
-            .image = tex_vk->img,
-            .viewType = viewType[tex_vk->type],
-            .format = fmt->iformat,
-            .subresourceRange = vk_range,
-        };
-
-        VK(vkCreateImageView(vk->dev, &vinfo, MPVK_ALLOCATOR, &tex_vk->view));
-    }
-
-    if (params->render_src) {
-        assert(params->format->linear_filter || !params->src_linear);
-        VkFilter filter = params->src_linear
-            ? VK_FILTER_LINEAR
-            : VK_FILTER_NEAREST;
-        VkSamplerAddressMode wrap = params->src_repeat
-            ? VK_SAMPLER_ADDRESS_MODE_REPEAT
-            : VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
-        VkSamplerCreateInfo sinfo = {
-            .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
-            .magFilter = filter,
-            .minFilter = filter,
-            .addressModeU = wrap,
-            .addressModeV = wrap,
-            .addressModeW = wrap,
-            .maxAnisotropy = 1.0,
-        };
-
-        VK(vkCreateSampler(vk->dev, &sinfo, MPVK_ALLOCATOR, &tex_vk->sampler));
-    }
-
-    if (params->render_dst) {
-        // Framebuffers need to be created against a specific render pass
-        // layout, so we need to temporarily create a skeleton/dummy render
-        // pass for vulkan to figure out the compatibility
-        VK(vk_create_render_pass(vk->dev, params->format,
-                                 VK_ATTACHMENT_LOAD_OP_DONT_CARE,
-                                 VK_IMAGE_LAYOUT_UNDEFINED,
-                                 VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
-                                 &tex_vk->dummyPass));
-
-        VkFramebufferCreateInfo finfo = {
-            .sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
-            .renderPass = tex_vk->dummyPass,
-            .attachmentCount = 1,
-            .pAttachments = &tex_vk->view,
-            .width = tex->params.w,
-            .height = tex->params.h,
-            .layers = 1,
-        };
-
-        VK(vkCreateFramebuffer(vk->dev, &finfo, MPVK_ALLOCATOR,
-                               &tex_vk->framebuffer));
-
-        // NOTE: Normally we would free the dummyPass again here, but a bug
-        // in the nvidia vulkan driver causes a segfault if you do.
-    }
-
-    return true;
-
-error:
-    return false;
-}
-
-static struct ra_tex *vk_tex_create(struct ra *ra,
-                                    const struct ra_tex_params *params)
-{
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-    assert(!params->format->dummy_format);
-
-    struct ra_tex *tex = talloc_zero(NULL, struct ra_tex);
-    tex->params = *params;
-    tex->params.initial_data = NULL;
-
-    struct ra_tex_vk *tex_vk = tex->priv = talloc_zero(tex, struct ra_tex_vk);
-    tex_vk->upload_queue = GRAPHICS;
-
-    const struct vk_format *fmt = params->format->priv;
-    switch (params->dimensions) {
-    case 1: tex_vk->type = VK_IMAGE_TYPE_1D; break;
-    case 2: tex_vk->type = VK_IMAGE_TYPE_2D; break;
-    case 3: tex_vk->type = VK_IMAGE_TYPE_3D; break;
-    default: abort();
-    }
-
-    VkImageUsageFlags usage = 0;
-    if (params->render_src)
-        usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
-    if (params->render_dst)
-        usage |= VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
-    if (params->storage_dst)
-        usage |= VK_IMAGE_USAGE_STORAGE_BIT;
-    if (params->blit_src)
-        usage |= VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
-    if (params->host_mutable || params->blit_dst || params->initial_data)
-        usage |= VK_IMAGE_USAGE_TRANSFER_DST_BIT;
-
-    // Always use the transfer pool if available, for efficiency
-    if (params->host_mutable && vk->pool_transfer)
-        tex_vk->upload_queue = TRANSFER;
-
-    // Double-check image usage support and fail immediately if invalid
-    VkImageFormatProperties iprop;
-    VkResult res = vkGetPhysicalDeviceImageFormatProperties(vk->physd,
-            fmt->iformat, tex_vk->type, VK_IMAGE_TILING_OPTIMAL, usage, 0,
-            &iprop);
-    if (res == VK_ERROR_FORMAT_NOT_SUPPORTED) {
-        return NULL;
-    } else {
-        VK_ASSERT(res, "Querying image format properties");
-    }
-
-    VkFormatProperties prop;
-    vkGetPhysicalDeviceFormatProperties(vk->physd, fmt->iformat, &prop);
-    VkFormatFeatureFlags flags = prop.optimalTilingFeatures;
-
-    bool has_blit_src   = flags & VK_FORMAT_FEATURE_BLIT_SRC_BIT,
-         has_src_linear = flags & VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT;
-
-    if (params->w > iprop.maxExtent.width ||
-        params->h > iprop.maxExtent.height ||
-        params->d > iprop.maxExtent.depth ||
-        (params->blit_src && !has_blit_src) ||
-        (params->src_linear && !has_src_linear))
-    {
-        return NULL;
-    }
-
-    // FIXME: Since we can't keep track of queue family ownership properly,
-    // and we don't know in advance what types of queue families this image
-    // will belong to, we're forced to share all of our images between all
-    // command pools.
-    uint32_t qfs[3] = {0};
-    for (int i = 0; i < vk->num_pools; i++)
-        qfs[i] = vk->pools[i]->qf;
-
-    VkImageCreateInfo iinfo = {
-        .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
-        .imageType = tex_vk->type,
-        .format = fmt->iformat,
-        .extent = (VkExtent3D) { params->w, params->h, params->d },
-        .mipLevels = 1,
-        .arrayLayers = 1,
-        .samples = VK_SAMPLE_COUNT_1_BIT,
-        .tiling = VK_IMAGE_TILING_OPTIMAL,
-        .usage = usage,
-        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
-        .sharingMode = vk->num_pools > 1 ? VK_SHARING_MODE_CONCURRENT
-                                         : VK_SHARING_MODE_EXCLUSIVE,
-        .queueFamilyIndexCount = vk->num_pools,
-        .pQueueFamilyIndices = qfs,
-    };
-
-    VK(vkCreateImage(vk->dev, &iinfo, MPVK_ALLOCATOR, &tex_vk->img));
-
-    VkMemoryPropertyFlags memFlags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
-    VkMemoryRequirements reqs;
-    vkGetImageMemoryRequirements(vk->dev, tex_vk->img, &reqs);
-
-    struct vk_memslice *mem = &tex_vk->mem;
-    if (!vk_malloc_generic(vk, reqs, memFlags, mem))
-        goto error;
-
-    VK(vkBindImageMemory(vk->dev, tex_vk->img, mem->vkmem, mem->offset));
-
-    if (!vk_init_image(ra, tex))
-        goto error;
-
-    if (params->initial_data) {
-        struct ra_tex_upload_params ul_params = {
-            .tex = tex,
-            .invalidate = true,
-            .src = params->initial_data,
-            .stride = params->w * fmt->bytes,
-        };
-        if (!ra->fns->tex_upload(ra, &ul_params))
-            goto error;
-    }
-
-    return tex;
-
-error:
-    vk_tex_destroy(ra, tex);
-    return NULL;
-}
-
-struct ra_tex *ra_vk_wrap_swapchain_img(struct ra *ra, VkImage vkimg,
-                                        VkSwapchainCreateInfoKHR info)
-{
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-    struct ra_tex *tex = NULL;
-
-    const struct ra_format *format = NULL;
-    for (int i = 0; i < ra->num_formats; i++) {
-        const struct vk_format *fmt = ra->formats[i]->priv;
-        if (fmt->iformat == vk->surf_format.format) {
-            format = ra->formats[i];
-            break;
-        }
-    }
-
-    if (!format) {
-        MP_ERR(ra, "Could not find ra_format suitable for wrapped swchain image "
-                   "with surface format 0x%x\n", vk->surf_format.format);
-        goto error;
-    }
-
-    tex = talloc_zero(NULL, struct ra_tex);
-    tex->params = (struct ra_tex_params) {
-        .format = format,
-        .dimensions = 2,
-        .w = info.imageExtent.width,
-        .h = info.imageExtent.height,
-        .d = 1,
-        .blit_src    = !!(info.imageUsage & VK_IMAGE_USAGE_TRANSFER_SRC_BIT),
-        .blit_dst    = !!(info.imageUsage & VK_IMAGE_USAGE_TRANSFER_DST_BIT),
-        .render_src  = !!(info.imageUsage & VK_IMAGE_USAGE_SAMPLED_BIT),
-        .render_dst  = !!(info.imageUsage & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT),
-        .storage_dst = !!(info.imageUsage & VK_IMAGE_USAGE_STORAGE_BIT),
-    };
-
-    struct ra_tex_vk *tex_vk = tex->priv = talloc_zero(tex, struct ra_tex_vk);
-    tex_vk->type = VK_IMAGE_TYPE_2D;
-    tex_vk->external_img = true;
-    tex_vk->img = vkimg;
-
-    if (!vk_init_image(ra, tex))
-        goto error;
-
-    return tex;
-
-error:
-    vk_tex_destroy(ra, tex);
-    return NULL;
-}
-
-// For ra_buf.priv
-struct ra_buf_vk {
-    struct vk_bufslice slice;
-    int refcount; // 1 = object allocated but not in use, > 1 = in use
-    bool needsflush;
-    enum queue_type update_queue;
-    // "current" metadata, can change during course of execution
-    VkPipelineStageFlags current_stage;
-    VkAccessFlags current_access;
-};
-
-static void vk_buf_deref(struct ra *ra, struct ra_buf *buf)
-{
-    if (!buf)
-        return;
-
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-    struct ra_buf_vk *buf_vk = buf->priv;
-
-    if (--buf_vk->refcount == 0) {
-        vk_free_memslice(vk, buf_vk->slice.mem);
-        talloc_free(buf);
-    }
-}
-
-static void buf_barrier(struct ra *ra, struct vk_cmd *cmd, struct ra_buf *buf,
-                        VkPipelineStageFlags newStage,
-                        VkAccessFlags newAccess, int offset, size_t size)
-{
-    struct ra_buf_vk *buf_vk = buf->priv;
-
-    VkBufferMemoryBarrier buffBarrier = {
-        .sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
-        .srcAccessMask = buf_vk->current_access,
-        .dstAccessMask = newAccess,
-        .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
-        .buffer = buf_vk->slice.buf,
-        .offset = offset,
-        .size = size,
-    };
-
-    if (buf_vk->needsflush || buf->params.host_mapped) {
-        buffBarrier.srcAccessMask = VK_ACCESS_HOST_WRITE_BIT;
-        buf_vk->current_stage = VK_PIPELINE_STAGE_HOST_BIT;
-        buf_vk->needsflush = false;
-    }
-
-    if (buffBarrier.srcAccessMask != buffBarrier.dstAccessMask) {
-        vkCmdPipelineBarrier(cmd->buf, buf_vk->current_stage, newStage, 0,
-                             0, NULL, 1, &buffBarrier, 0, NULL);
-    }
-
-    buf_vk->current_stage = newStage;
-    buf_vk->current_access = newAccess;
-    buf_vk->refcount++;
-    vk_cmd_callback(cmd, (vk_cb) vk_buf_deref, ra, buf);
-}
-
-#define vk_buf_destroy vk_buf_deref
-MAKE_LAZY_DESTRUCTOR(vk_buf_destroy, struct ra_buf);
-
-static void vk_buf_update(struct ra *ra, struct ra_buf *buf, ptrdiff_t offset,
-                          const void *data, size_t size)
-{
-    assert(buf->params.host_mutable || buf->params.initial_data);
-    struct ra_buf_vk *buf_vk = buf->priv;
-
-    // For host-mapped buffers, we can just directly memcpy the buffer contents.
-    // Otherwise, we can update the buffer from the GPU using a command buffer.
-    if (buf_vk->slice.data) {
-        assert(offset + size <= buf->params.size);
-        uintptr_t addr = (uintptr_t)buf_vk->slice.data + offset;
-        memcpy((void *)addr, data, size);
-        buf_vk->needsflush = true;
-    } else {
-        struct vk_cmd *cmd = vk_require_cmd(ra, buf_vk->update_queue);
-        if (!cmd) {
-            MP_ERR(ra, "Failed updating buffer!\n");
-            return;
-        }
-
-        buf_barrier(ra, cmd, buf, VK_PIPELINE_STAGE_TRANSFER_BIT,
-                    VK_ACCESS_TRANSFER_WRITE_BIT, offset, size);
-
-        VkDeviceSize bufOffset = buf_vk->slice.mem.offset + offset;
-        assert(bufOffset == MP_ALIGN_UP(bufOffset, 4));
-        vkCmdUpdateBuffer(cmd->buf, buf_vk->slice.buf, bufOffset, size, data);
-    }
-}
-
-static struct ra_buf *vk_buf_create(struct ra *ra,
-                                    const struct ra_buf_params *params)
-{
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-
-    struct ra_buf *buf = talloc_zero(NULL, struct ra_buf);
-    buf->params = *params;
-
-    struct ra_buf_vk *buf_vk = buf->priv = talloc_zero(buf, struct ra_buf_vk);
-    buf_vk->current_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
-    buf_vk->current_access = 0;
-    buf_vk->refcount = 1;
-
-    VkBufferUsageFlags bufFlags = 0;
-    VkMemoryPropertyFlags memFlags = 0;
-    VkDeviceSize align = 4; // alignment 4 is needed for buf_update
-
-    switch (params->type) {
-    case RA_BUF_TYPE_TEX_UPLOAD:
-        bufFlags |= VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
-        memFlags |= VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
-        // Use TRANSFER-style updates for large enough buffers for efficiency
-        if (params->size > 1024*1024) // 1 MB
-            buf_vk->update_queue = TRANSFER;
-        break;
-    case RA_BUF_TYPE_UNIFORM:
-        bufFlags |= VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
-        memFlags |= VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
-        align = MP_ALIGN_UP(align, vk->limits.minUniformBufferOffsetAlignment);
-        break;
-    case RA_BUF_TYPE_SHADER_STORAGE:
-        bufFlags |= VK_BUFFER_USAGE_STORAGE_BUFFER_BIT;
-        memFlags |= VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
-        align = MP_ALIGN_UP(align, vk->limits.minStorageBufferOffsetAlignment);
-        buf_vk->update_queue = COMPUTE;
-        break;
-    case RA_BUF_TYPE_VERTEX:
-        bufFlags |= VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
-        memFlags |= VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
-        break;
-    default: abort();
-    }
-
-    if (params->host_mutable || params->initial_data) {
-        bufFlags |= VK_BUFFER_USAGE_TRANSFER_DST_BIT;
-        align = MP_ALIGN_UP(align, vk->limits.optimalBufferCopyOffsetAlignment);
-    }
-
-    if (params->host_mapped) {
-        memFlags |= VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
-                    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT |
-                    VK_MEMORY_PROPERTY_HOST_CACHED_BIT;
-    }
-
-    if (!vk_malloc_buffer(vk, bufFlags, memFlags, params->size, align,
-                          &buf_vk->slice))
-    {
-        goto error;
-    }
-
-    if (params->host_mapped)
-        buf->data = buf_vk->slice.data;
-
-    if (params->initial_data)
-        vk_buf_update(ra, buf, 0, params->initial_data, params->size);
-
-    buf->params.initial_data = NULL; // do this after vk_buf_update
-    return buf;
-
-error:
-    vk_buf_destroy(ra, buf);
-    return NULL;
-}
-
-static bool vk_buf_poll(struct ra *ra, struct ra_buf *buf)
-{
-    struct ra_buf_vk *buf_vk = buf->priv;
-    return buf_vk->refcount == 1;
-}
-
-static bool vk_tex_upload(struct ra *ra,
-                          const struct ra_tex_upload_params *params)
-{
-    struct ra_tex *tex = params->tex;
-    struct ra_tex_vk *tex_vk = tex->priv;
-
-    if (!params->buf)
-        return ra_tex_upload_pbo(ra, &tex_vk->pbo, params);
-
-    assert(!params->src);
-    assert(params->buf);
-    struct ra_buf *buf = params->buf;
-    struct ra_buf_vk *buf_vk = buf->priv;
-
-    VkBufferImageCopy region = {
-        .bufferOffset = buf_vk->slice.mem.offset + params->buf_offset,
-        .bufferRowLength = tex->params.w,
-        .bufferImageHeight = tex->params.h,
-        .imageSubresource = vk_layers,
-        .imageExtent = (VkExtent3D){tex->params.w, tex->params.h, tex->params.d},
-    };
-
-    if (tex->params.dimensions == 2) {
-        int pix_size = tex->params.format->pixel_size;
-        region.bufferRowLength = params->stride / pix_size;
-        if (region.bufferRowLength * pix_size != params->stride) {
-            MP_ERR(ra, "Texture upload strides must be a multiple of the texel "
-                       "size!\n");
-            goto error;
-        }
-
-        if (params->rc) {
-            struct mp_rect *rc = params->rc;
-            region.imageOffset = (VkOffset3D){rc->x0, rc->y0, 0};
-            region.imageExtent = (VkExtent3D){mp_rect_w(*rc), mp_rect_h(*rc), 1};
-        }
-    }
-
-    uint64_t size = region.bufferRowLength * region.bufferImageHeight *
-                    region.imageExtent.depth;
-
-    struct vk_cmd *cmd = vk_require_cmd(ra, tex_vk->upload_queue);
-    if (!cmd)
-        goto error;
-
-    buf_barrier(ra, cmd, buf, VK_PIPELINE_STAGE_TRANSFER_BIT,
-                VK_ACCESS_TRANSFER_READ_BIT, region.bufferOffset, size);
-
-    tex_barrier(ra, cmd, tex, VK_PIPELINE_STAGE_TRANSFER_BIT,
-                VK_ACCESS_TRANSFER_WRITE_BIT,
-                VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
-                params->invalidate);
-
-    vkCmdCopyBufferToImage(cmd->buf, buf_vk->slice.buf, tex_vk->img,
-                           tex_vk->current_layout, 1, &region);
-
-    tex_signal(ra, cmd, tex, VK_PIPELINE_STAGE_TRANSFER_BIT);
-
-    return true;
-
-error:
-    return false;
-}
-
-#define MPVK_NUM_DS MPVK_MAX_STREAMING_DEPTH
-
-// For ra_renderpass.priv
-struct ra_renderpass_vk {
-    // Pipeline / render pass
-    VkPipeline pipe;
-    VkPipelineLayout pipeLayout;
-    VkRenderPass renderPass;
-    VkImageLayout initialLayout;
-    VkImageLayout finalLayout;
-    // Descriptor set (bindings)
-    VkDescriptorSetLayout dsLayout;
-    VkDescriptorPool dsPool;
-    VkDescriptorSet dss[MPVK_NUM_DS];
-    int dindex;
-    // Vertex buffers (vertices)
-    struct ra_buf_pool vbo;
-
-    // For updating
-    VkWriteDescriptorSet *dswrite;
-    VkDescriptorImageInfo *dsiinfo;
-    VkDescriptorBufferInfo *dsbinfo;
-};
-
-static void vk_renderpass_destroy(struct ra *ra, struct ra_renderpass *pass)
-{
-    if (!pass)
-        return;
-
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-    struct ra_renderpass_vk *pass_vk = pass->priv;
-
-    ra_buf_pool_uninit(ra, &pass_vk->vbo);
-    vkDestroyPipeline(vk->dev, pass_vk->pipe, MPVK_ALLOCATOR);
-    vkDestroyRenderPass(vk->dev, pass_vk->renderPass, MPVK_ALLOCATOR);
-    vkDestroyPipelineLayout(vk->dev, pass_vk->pipeLayout, MPVK_ALLOCATOR);
-    vkDestroyDescriptorPool(vk->dev, pass_vk->dsPool, MPVK_ALLOCATOR);
-    vkDestroyDescriptorSetLayout(vk->dev, pass_vk->dsLayout, MPVK_ALLOCATOR);
-
-    talloc_free(pass);
-}
-
-MAKE_LAZY_DESTRUCTOR(vk_renderpass_destroy, struct ra_renderpass);
-
-static const VkDescriptorType dsType[] = {
-    [RA_VARTYPE_TEX]    = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
-    [RA_VARTYPE_IMG_W]  = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
-    [RA_VARTYPE_BUF_RO] = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
-    [RA_VARTYPE_BUF_RW] = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
-};
-
-static bool vk_get_input_format(struct ra *ra, struct ra_renderpass_input *inp,
-                                VkFormat *out_fmt)
-{
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-
-    enum ra_ctype ctype;
-    switch (inp->type) {
-    case RA_VARTYPE_FLOAT:      ctype = RA_CTYPE_FLOAT; break;
-    case RA_VARTYPE_BYTE_UNORM: ctype = RA_CTYPE_UNORM; break;
-    default: abort();
-    }
-
-    assert(inp->dim_m == 1);
-    for (const struct vk_format *fmt = vk_formats; fmt->name; fmt++) {
-        if (fmt->ctype != ctype)
-            continue;
-        if (fmt->components != inp->dim_v)
-            continue;
-        if (fmt->bytes != ra_renderpass_input_layout(inp).size)
-            continue;
-
-        // Ensure this format is valid for vertex attributes
-        VkFormatProperties prop;
-        vkGetPhysicalDeviceFormatProperties(vk->physd, fmt->iformat, &prop);
-        if (!(prop.bufferFeatures & VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT))
-            continue;
-
-        *out_fmt = fmt->iformat;
-        return true;
-    }
-
-    return false;
-}
-
-static const char vk_cache_magic[4] = {'R','A','V','K'};
-static const int vk_cache_version = 2;
-
-struct vk_cache_header {
-    char magic[sizeof(vk_cache_magic)];
-    int cache_version;
-    char compiler[SPIRV_NAME_MAX_LEN];
-    int compiler_version;
-    size_t vert_spirv_len;
-    size_t frag_spirv_len;
-    size_t comp_spirv_len;
-    size_t pipecache_len;
-};
-
-static bool vk_use_cached_program(const struct ra_renderpass_params *params,
-                                  const struct spirv_compiler *spirv,
-                                  struct bstr *vert_spirv,
-                                  struct bstr *frag_spirv,
-                                  struct bstr *comp_spirv,
-                                  struct bstr *pipecache)
-{
-    struct bstr cache = params->cached_program;
-    if (cache.len < sizeof(struct vk_cache_header))
-        return false;
-
-    struct vk_cache_header *header = (struct vk_cache_header *)cache.start;
-    cache = bstr_cut(cache, sizeof(*header));
-
-    if (strncmp(header->magic, vk_cache_magic, sizeof(vk_cache_magic)) != 0)
-        return false;
-    if (header->cache_version != vk_cache_version)
-        return false;
-    if (strncmp(header->compiler, spirv->name, sizeof(header->compiler)) != 0)
-        return false;
-    if (header->compiler_version != spirv->compiler_version)
-        return false;
-
-#define GET(ptr) \
-    if (cache.len < header->ptr##_len)                      \
-            return false;                                   \
-        *ptr = bstr_splice(cache, 0, header->ptr##_len);    \
-        cache = bstr_cut(cache, ptr->len);
-
-    GET(vert_spirv);
-    GET(frag_spirv);
-    GET(comp_spirv);
-    GET(pipecache);
-    return true;
-}
-
-static VkResult vk_compile_glsl(struct ra *ra, void *tactx,
-                                enum glsl_shader type, const char *glsl,
-                                struct bstr *spirv)
-{
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-    VkResult ret = VK_SUCCESS;
-    int msgl = MSGL_DEBUG;
-
-    if (!vk->spirv->fns->compile_glsl(vk->spirv, tactx, type, glsl, spirv)) {
-        ret = VK_ERROR_INVALID_SHADER_NV;
-        msgl = MSGL_ERR;
-    }
-
-    static const char *shader_names[] = {
-        [GLSL_SHADER_VERTEX]   = "vertex",
-        [GLSL_SHADER_FRAGMENT] = "fragment",
-        [GLSL_SHADER_COMPUTE]  = "compute",
-    };
-
-    if (mp_msg_test(ra->log, msgl)) {
-        MP_MSG(ra, msgl, "%s shader source:\n", shader_names[type]);
-        mp_log_source(ra->log, msgl, glsl);
-    }
-    return ret;
-}
-
-static const VkShaderStageFlags stageFlags[] = {
-    [RA_RENDERPASS_TYPE_RASTER]  = VK_SHADER_STAGE_FRAGMENT_BIT,
-    [RA_RENDERPASS_TYPE_COMPUTE] = VK_SHADER_STAGE_COMPUTE_BIT,
-};
-
-static struct ra_renderpass *vk_renderpass_create(struct ra *ra,
-                                    const struct ra_renderpass_params *params)
-{
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-    bool success = false;
-    assert(vk->spirv);
-
-    struct ra_renderpass *pass = talloc_zero(NULL, struct ra_renderpass);
-    pass->params = *ra_renderpass_params_copy(pass, params);
-    pass->params.cached_program = (bstr){0};
-    struct ra_renderpass_vk *pass_vk = pass->priv =
-        talloc_zero(pass, struct ra_renderpass_vk);
-
-    // temporary allocations/objects
-    void *tmp = talloc_new(NULL);
-    VkPipelineCache pipeCache = NULL;
-    VkShaderModule vert_shader = NULL;
-    VkShaderModule frag_shader = NULL;
-    VkShaderModule comp_shader = NULL;
-
-    static int dsCount[RA_VARTYPE_COUNT] = {0};
-    VkDescriptorSetLayoutBinding *bindings = NULL;
-    int num_bindings = 0;
-
-    for (int i = 0; i < params->num_inputs; i++) {
-        struct ra_renderpass_input *inp = &params->inputs[i];
-        switch (inp->type) {
-        case RA_VARTYPE_TEX:
-        case RA_VARTYPE_IMG_W:
-        case RA_VARTYPE_BUF_RO:
-        case RA_VARTYPE_BUF_RW: {
-            VkDescriptorSetLayoutBinding desc = {
-                .binding = inp->binding,
-                .descriptorType = dsType[inp->type],
-                .descriptorCount = 1,
-                .stageFlags = stageFlags[params->type],
-            };
-
-            MP_TARRAY_APPEND(tmp, bindings, num_bindings, desc);
-            dsCount[inp->type]++;
-            break;
-        }
-        default: abort();
-        }
-    }
-
-    VkDescriptorPoolSize *dsPoolSizes = NULL;
-    int poolSizeCount = 0;
-
-    for (enum ra_vartype t = 0; t < RA_VARTYPE_COUNT; t++) {
-        if (dsCount[t] > 0) {
-            VkDescriptorPoolSize dssize = {
-                .type = dsType[t],
-                .descriptorCount = dsCount[t] * MPVK_NUM_DS,
-            };
-
-            MP_TARRAY_APPEND(tmp, dsPoolSizes, poolSizeCount, dssize);
-        }
-    }
-
-    VkDescriptorPoolCreateInfo pinfo = {
-        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
-        .maxSets = MPVK_NUM_DS,
-        .pPoolSizes = dsPoolSizes,
-        .poolSizeCount = poolSizeCount,
-    };
-
-    VK(vkCreateDescriptorPool(vk->dev, &pinfo, MPVK_ALLOCATOR, &pass_vk->dsPool));
-
-    pass_vk->dswrite = talloc_array(pass, VkWriteDescriptorSet, num_bindings);
-    pass_vk->dsiinfo = talloc_array(pass, VkDescriptorImageInfo, num_bindings);
-    pass_vk->dsbinfo = talloc_array(pass, VkDescriptorBufferInfo, num_bindings);
-
-    VkDescriptorSetLayoutCreateInfo dinfo = {
-        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
-        .pBindings = bindings,
-        .bindingCount = num_bindings,
-    };
-
-    VK(vkCreateDescriptorSetLayout(vk->dev, &dinfo, MPVK_ALLOCATOR,
-                                   &pass_vk->dsLayout));
-
-    VkDescriptorSetLayout layouts[MPVK_NUM_DS];
-    for (int i = 0; i < MPVK_NUM_DS; i++)
-        layouts[i] = pass_vk->dsLayout;
-
-    VkDescriptorSetAllocateInfo ainfo = {
-        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
-        .descriptorPool = pass_vk->dsPool,
-        .descriptorSetCount = MPVK_NUM_DS,
-        .pSetLayouts = layouts,
-    };
-
-    VK(vkAllocateDescriptorSets(vk->dev, &ainfo, pass_vk->dss));
-
-    VkPipelineLayoutCreateInfo linfo = {
-        .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
-        .setLayoutCount = 1,
-        .pSetLayouts = &pass_vk->dsLayout,
-        .pushConstantRangeCount = params->push_constants_size ? 1 : 0,
-        .pPushConstantRanges = &(VkPushConstantRange){
-            .stageFlags = stageFlags[params->type],
-            .offset = 0,
-            .size = params->push_constants_size,
-        },
-    };
-
-    VK(vkCreatePipelineLayout(vk->dev, &linfo, MPVK_ALLOCATOR,
-                              &pass_vk->pipeLayout));
-
-    struct bstr vert = {0}, frag = {0}, comp = {0}, pipecache = {0};
-    if (vk_use_cached_program(params, vk->spirv, &vert, &frag, &comp, &pipecache)) {
-        MP_VERBOSE(ra, "Using cached SPIR-V and VkPipeline.\n");
-    } else {
-        pipecache.len = 0;
-        switch (params->type) {
-        case RA_RENDERPASS_TYPE_RASTER:
-            VK(vk_compile_glsl(ra, tmp, GLSL_SHADER_VERTEX,
-                               params->vertex_shader, &vert));
-            VK(vk_compile_glsl(ra, tmp, GLSL_SHADER_FRAGMENT,
-                               params->frag_shader, &frag));
-            comp.len = 0;
-            break;
-        case RA_RENDERPASS_TYPE_COMPUTE:
-            VK(vk_compile_glsl(ra, tmp, GLSL_SHADER_COMPUTE,
-                               params->compute_shader, &comp));
-            frag.len = 0;
-            vert.len = 0;
-            break;
-        }
-    }
-
-    VkPipelineCacheCreateInfo pcinfo = {
-        .sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
-        .pInitialData = pipecache.start,
-        .initialDataSize = pipecache.len,
-    };
-
-    VK(vkCreatePipelineCache(vk->dev, &pcinfo, MPVK_ALLOCATOR, &pipeCache));
-
-    VkShaderModuleCreateInfo sinfo = {
-        .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
-    };
-
-    switch (params->type) {
-    case RA_RENDERPASS_TYPE_RASTER: {
-        sinfo.pCode = (uint32_t *)vert.start;
-        sinfo.codeSize = vert.len;
-        VK(vkCreateShaderModule(vk->dev, &sinfo, MPVK_ALLOCATOR, &vert_shader));
-
-        sinfo.pCode = (uint32_t *)frag.start;
-        sinfo.codeSize = frag.len;
-        VK(vkCreateShaderModule(vk->dev, &sinfo, MPVK_ALLOCATOR, &frag_shader));
-
-        VkVertexInputAttributeDescription *attrs = talloc_array(tmp,
-                VkVertexInputAttributeDescription, params->num_vertex_attribs);
-
-        for (int i = 0; i < params->num_vertex_attribs; i++) {
-            struct ra_renderpass_input *inp = &params->vertex_attribs[i];
-            attrs[i] = (VkVertexInputAttributeDescription) {
-                .location = i,
-                .binding = 0,
-                .offset = inp->offset,
-            };
-
-            if (!vk_get_input_format(ra, inp, &attrs[i].format)) {
-                MP_ERR(ra, "No suitable VkFormat for vertex attrib '%s'!\n",
-                       inp->name);
-                goto error;
-            }
-        }
-
-        // This is the most common case, so optimize towards it. In this case,
-        // the renderpass will take care of almost all layout transitions
-        pass_vk->initialLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
-        pass_vk->finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
-        VkAttachmentLoadOp loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
-
-        // If we're blending, then we need to explicitly load the previous
-        // contents of the color attachment
-        if (pass->params.enable_blend)
-            loadOp = VK_ATTACHMENT_LOAD_OP_LOAD;
-
-        // If we're invalidating the target, we don't need to load or transition
-        if (pass->params.invalidate_target) {
-            pass_vk->initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
-            loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
-        }
-
-        VK(vk_create_render_pass(vk->dev, params->target_format, loadOp,
-                                 pass_vk->initialLayout, pass_vk->finalLayout,
-                                 &pass_vk->renderPass));
-
-        static const VkBlendFactor blendFactors[] = {
-            [RA_BLEND_ZERO]                = VK_BLEND_FACTOR_ZERO,
-            [RA_BLEND_ONE]                 = VK_BLEND_FACTOR_ONE,
-            [RA_BLEND_SRC_ALPHA]           = VK_BLEND_FACTOR_SRC_ALPHA,
-            [RA_BLEND_ONE_MINUS_SRC_ALPHA] = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
-        };
-
-        VkGraphicsPipelineCreateInfo cinfo = {
-            .sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
-            .stageCount = 2,
-            .pStages = (VkPipelineShaderStageCreateInfo[]) {
-                {
-                    .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
-                    .stage = VK_SHADER_STAGE_VERTEX_BIT,
-                    .module = vert_shader,
-                    .pName = "main",
-                }, {
-                    .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
-                    .stage = VK_SHADER_STAGE_FRAGMENT_BIT,
-                    .module = frag_shader,
-                    .pName = "main",
-                }
-            },
-            .pVertexInputState = &(VkPipelineVertexInputStateCreateInfo) {
-                .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
-                .vertexBindingDescriptionCount = 1,
-                .pVertexBindingDescriptions = &(VkVertexInputBindingDescription) {
-                    .binding = 0,
-                    .stride = params->vertex_stride,
-                    .inputRate = VK_VERTEX_INPUT_RATE_VERTEX,
-                },
-                .vertexAttributeDescriptionCount = params->num_vertex_attribs,
-                .pVertexAttributeDescriptions = attrs,
-            },
-            .pInputAssemblyState = &(VkPipelineInputAssemblyStateCreateInfo) {
-                .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
-                .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
-            },
-            .pViewportState = &(VkPipelineViewportStateCreateInfo) {
-                .sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
-                .viewportCount = 1,
-                .scissorCount = 1,
-            },
-            .pRasterizationState = &(VkPipelineRasterizationStateCreateInfo) {
-                .sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
-                .polygonMode = VK_POLYGON_MODE_FILL,
-                .cullMode = VK_CULL_MODE_NONE,
-                .lineWidth = 1.0f,
-            },
-            .pMultisampleState = &(VkPipelineMultisampleStateCreateInfo) {
-                .sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
-                .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT,
-            },
-            .pColorBlendState = &(VkPipelineColorBlendStateCreateInfo) {
-                .sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
-                .attachmentCount = 1,
-                .pAttachments = &(VkPipelineColorBlendAttachmentState) {
-                    .blendEnable = params->enable_blend,
-                    .colorBlendOp = VK_BLEND_OP_ADD,
-                    .srcColorBlendFactor = blendFactors[params->blend_src_rgb],
-                    .dstColorBlendFactor = blendFactors[params->blend_dst_rgb],
-                    .alphaBlendOp = VK_BLEND_OP_ADD,
-                    .srcAlphaBlendFactor = blendFactors[params->blend_src_alpha],
-                    .dstAlphaBlendFactor = blendFactors[params->blend_dst_alpha],
-                    .colorWriteMask = VK_COLOR_COMPONENT_R_BIT |
-                                      VK_COLOR_COMPONENT_G_BIT |
-                                      VK_COLOR_COMPONENT_B_BIT |
-                                      VK_COLOR_COMPONENT_A_BIT,
-                },
-            },
-            .pDynamicState = &(VkPipelineDynamicStateCreateInfo) {
-                .sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
-                .dynamicStateCount = 2,
-                .pDynamicStates = (VkDynamicState[]){
-                    VK_DYNAMIC_STATE_VIEWPORT,
-                    VK_DYNAMIC_STATE_SCISSOR,
-                },
-            },
-            .layout = pass_vk->pipeLayout,
-            .renderPass = pass_vk->renderPass,
-        };
-
-        VK(vkCreateGraphicsPipelines(vk->dev, pipeCache, 1, &cinfo,
-                                     MPVK_ALLOCATOR, &pass_vk->pipe));
-        break;
-    }
-    case RA_RENDERPASS_TYPE_COMPUTE: {
-        sinfo.pCode = (uint32_t *)comp.start;
-        sinfo.codeSize = comp.len;
-        VK(vkCreateShaderModule(vk->dev, &sinfo, MPVK_ALLOCATOR, &comp_shader));
-
-        VkComputePipelineCreateInfo cinfo = {
-            .sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
-            .stage = {
-                .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
-                .stage = VK_SHADER_STAGE_COMPUTE_BIT,
-                .module = comp_shader,
-                .pName = "main",
-            },
-            .layout = pass_vk->pipeLayout,
-        };
-
-        VK(vkCreateComputePipelines(vk->dev, pipeCache, 1, &cinfo,
-                                    MPVK_ALLOCATOR, &pass_vk->pipe));
-        break;
-    }
-    }
-
-    // Update params->cached_program
-    struct bstr cache = {0};
-    VK(vkGetPipelineCacheData(vk->dev, pipeCache, &cache.len, NULL));
-    cache.start = talloc_size(tmp, cache.len);
-    VK(vkGetPipelineCacheData(vk->dev, pipeCache, &cache.len, cache.start));
-
-    struct vk_cache_header header = {
-        .cache_version = vk_cache_version,
-        .compiler_version = vk->spirv->compiler_version,
-        .vert_spirv_len = vert.len,
-        .frag_spirv_len = frag.len,
-        .comp_spirv_len = comp.len,
-        .pipecache_len = cache.len,
-    };
-
-    for (int i = 0; i < MP_ARRAY_SIZE(header.magic); i++)
-        header.magic[i] = vk_cache_magic[i];
-    for (int i = 0; i < sizeof(vk->spirv->name); i++)
-        header.compiler[i] = vk->spirv->name[i];
-
-    struct bstr *prog = &pass->params.cached_program;
-    bstr_xappend(pass, prog, (struct bstr){ (char *) &header, sizeof(header) });
-    bstr_xappend(pass, prog, vert);
-    bstr_xappend(pass, prog, frag);
-    bstr_xappend(pass, prog, comp);
-    bstr_xappend(pass, prog, cache);
-
-    success = true;
-
-error:
-    if (!success) {
-        vk_renderpass_destroy(ra, pass);
-        pass = NULL;
-    }
-
-    vkDestroyShaderModule(vk->dev, vert_shader, MPVK_ALLOCATOR);
-    vkDestroyShaderModule(vk->dev, frag_shader, MPVK_ALLOCATOR);
-    vkDestroyShaderModule(vk->dev, comp_shader, MPVK_ALLOCATOR);
-    vkDestroyPipelineCache(vk->dev, pipeCache, MPVK_ALLOCATOR);
-    talloc_free(tmp);
-    return pass;
-}
-
-static const VkPipelineStageFlags passStages[] = {
-    [RA_RENDERPASS_TYPE_RASTER]  = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
-    [RA_RENDERPASS_TYPE_COMPUTE] = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
-};
-
-static void vk_update_descriptor(struct ra *ra, struct vk_cmd *cmd,
-                                 struct ra_renderpass *pass,
-                                 struct ra_renderpass_input_val val,
-                                 VkDescriptorSet ds, int idx)
-{
-    struct ra_renderpass_vk *pass_vk = pass->priv;
-    struct ra_renderpass_input *inp = &pass->params.inputs[val.index];
-
-    VkWriteDescriptorSet *wds = &pass_vk->dswrite[idx];
-    *wds = (VkWriteDescriptorSet) {
-        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
-        .dstSet = ds,
-        .dstBinding = inp->binding,
-        .descriptorCount = 1,
-        .descriptorType = dsType[inp->type],
-    };
-
-    switch (inp->type) {
-    case RA_VARTYPE_TEX: {
-        struct ra_tex *tex = *(struct ra_tex **)val.data;
-        struct ra_tex_vk *tex_vk = tex->priv;
-
-        assert(tex->params.render_src);
-        tex_barrier(ra, cmd, tex, passStages[pass->params.type],
-                    VK_ACCESS_SHADER_READ_BIT,
-                    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, false);
-
-        VkDescriptorImageInfo *iinfo = &pass_vk->dsiinfo[idx];
-        *iinfo = (VkDescriptorImageInfo) {
-            .sampler = tex_vk->sampler,
-            .imageView = tex_vk->view,
-            .imageLayout = tex_vk->current_layout,
-        };
-
-        wds->pImageInfo = iinfo;
-        break;
-    }
-    case RA_VARTYPE_IMG_W: {
-        struct ra_tex *tex = *(struct ra_tex **)val.data;
-        struct ra_tex_vk *tex_vk = tex->priv;
-
-        assert(tex->params.storage_dst);
-        tex_barrier(ra, cmd, tex, passStages[pass->params.type],
-                    VK_ACCESS_SHADER_WRITE_BIT,
-                    VK_IMAGE_LAYOUT_GENERAL, false);
-
-        VkDescriptorImageInfo *iinfo = &pass_vk->dsiinfo[idx];
-        *iinfo = (VkDescriptorImageInfo) {
-            .imageView = tex_vk->view,
-            .imageLayout = tex_vk->current_layout,
-        };
-
-        wds->pImageInfo = iinfo;
-        break;
-    }
-    case RA_VARTYPE_BUF_RO:
-    case RA_VARTYPE_BUF_RW: {
-        struct ra_buf *buf = *(struct ra_buf **)val.data;
-        struct ra_buf_vk *buf_vk = buf->priv;
-
-        VkBufferUsageFlags access = VK_ACCESS_SHADER_READ_BIT;
-        if (inp->type == RA_VARTYPE_BUF_RW)
-            access |= VK_ACCESS_SHADER_WRITE_BIT;
-
-        buf_barrier(ra, cmd, buf, passStages[pass->params.type],
-                    access, buf_vk->slice.mem.offset, buf->params.size);
-
-        VkDescriptorBufferInfo *binfo = &pass_vk->dsbinfo[idx];
-        *binfo = (VkDescriptorBufferInfo) {
-            .buffer = buf_vk->slice.buf,
-            .offset = buf_vk->slice.mem.offset,
-            .range = buf->params.size,
-        };
-
-        wds->pBufferInfo = binfo;
-        break;
-    }
-    }
-}
-
-static void vk_release_descriptor(struct ra *ra, struct vk_cmd *cmd,
-                                  struct ra_renderpass *pass,
-                                  struct ra_renderpass_input_val val)
-{
-    struct ra_renderpass_input *inp = &pass->params.inputs[val.index];
-
-    switch (inp->type) {
-    case RA_VARTYPE_IMG_W:
-    case RA_VARTYPE_TEX: {
-        struct ra_tex *tex = *(struct ra_tex **)val.data;
-        tex_signal(ra, cmd, tex, passStages[pass->params.type]);
-        break;
-    }
-    }
-}
-
-static void vk_renderpass_run(struct ra *ra,
-                              const struct ra_renderpass_run_params *params)
-{
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-    struct ra_renderpass *pass = params->pass;
-    struct ra_renderpass_vk *pass_vk = pass->priv;
-
-    static const enum queue_type types[] = {
-        [RA_RENDERPASS_TYPE_RASTER]  = GRAPHICS,
-        [RA_RENDERPASS_TYPE_COMPUTE] = COMPUTE,
-    };
-
-    struct vk_cmd *cmd = vk_require_cmd(ra, types[pass->params.type]);
-    if (!cmd)
-        goto error;
-
-    static const VkPipelineBindPoint bindPoint[] = {
-        [RA_RENDERPASS_TYPE_RASTER]  = VK_PIPELINE_BIND_POINT_GRAPHICS,
-        [RA_RENDERPASS_TYPE_COMPUTE] = VK_PIPELINE_BIND_POINT_COMPUTE,
-    };
-
-    vkCmdBindPipeline(cmd->buf, bindPoint[pass->params.type], pass_vk->pipe);
-
-    VkDescriptorSet ds = pass_vk->dss[pass_vk->dindex++];
-    pass_vk->dindex %= MPVK_NUM_DS;
-
-    for (int i = 0; i < params->num_values; i++)
-        vk_update_descriptor(ra, cmd, pass, params->values[i], ds, i);
-
-    if (params->num_values > 0) {
-        vkUpdateDescriptorSets(vk->dev, params->num_values, pass_vk->dswrite,
-                               0, NULL);
-    }
-
-    vkCmdBindDescriptorSets(cmd->buf, bindPoint[pass->params.type],
-                            pass_vk->pipeLayout, 0, 1, &ds, 0, NULL);
-
-    if (pass->params.push_constants_size) {
-        vkCmdPushConstants(cmd->buf, pass_vk->pipeLayout,
-                           stageFlags[pass->params.type], 0,
-                           pass->params.push_constants_size,
-                           params->push_constants);
-    }
-
-    switch (pass->params.type) {
-    case RA_RENDERPASS_TYPE_COMPUTE:
-        vkCmdDispatch(cmd->buf, params->compute_groups[0],
-                      params->compute_groups[1],
-                      params->compute_groups[2]);
-        break;
-    case RA_RENDERPASS_TYPE_RASTER: {
-        struct ra_tex *tex = params->target;
-        struct ra_tex_vk *tex_vk = tex->priv;
-        assert(tex->params.render_dst);
-
-        struct ra_buf_params buf_params = {
-            .type = RA_BUF_TYPE_VERTEX,
-            .size = params->vertex_count * pass->params.vertex_stride,
-            .host_mutable = true,
-        };
-
-        struct ra_buf *buf = ra_buf_pool_get(ra, &pass_vk->vbo, &buf_params);
-        if (!buf) {
-            MP_ERR(ra, "Failed allocating vertex buffer!\n");
-            goto error;
-        }
-        struct ra_buf_vk *buf_vk = buf->priv;
-
-        vk_buf_update(ra, buf, 0, params->vertex_data, buf_params.size);
-
-        buf_barrier(ra, cmd, buf, VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
-                    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
-                    buf_vk->slice.mem.offset, buf_params.size);
-
-        vkCmdBindVertexBuffers(cmd->buf, 0, 1, &buf_vk->slice.buf,
-                               &buf_vk->slice.mem.offset);
-
-        tex_barrier(ra, cmd, tex, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
-                    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, pass_vk->initialLayout,
-                    pass->params.invalidate_target);
-
-        VkViewport viewport = {
-            .x = params->viewport.x0,
-            .y = params->viewport.y0,
-            .width  = mp_rect_w(params->viewport),
-            .height = mp_rect_h(params->viewport),
-        };
-
-        VkRect2D scissor = {
-            .offset = {params->scissors.x0, params->scissors.y0},
-            .extent = {mp_rect_w(params->scissors), mp_rect_h(params->scissors)},
-        };
-
-        vkCmdSetViewport(cmd->buf, 0, 1, &viewport);
-        vkCmdSetScissor(cmd->buf, 0, 1, &scissor);
-
-        VkRenderPassBeginInfo binfo = {
-            .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
-            .renderPass = pass_vk->renderPass,
-            .framebuffer = tex_vk->framebuffer,
-            .renderArea = (VkRect2D){{0, 0}, {tex->params.w, tex->params.h}},
-        };
-
-        vkCmdBeginRenderPass(cmd->buf, &binfo, VK_SUBPASS_CONTENTS_INLINE);
-        vkCmdDraw(cmd->buf, params->vertex_count, 1, 0, 0);
-        vkCmdEndRenderPass(cmd->buf);
-
-        // The renderPass implicitly transitions the texture to this layout
-        tex_vk->current_layout = pass_vk->finalLayout;
-        tex_vk->current_access = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
-        tex_signal(ra, cmd, tex, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT);
-        break;
-    }
-    default: abort();
-    };
-
-    for (int i = 0; i < params->num_values; i++)
-        vk_release_descriptor(ra, cmd, pass, params->values[i]);
-
-    // flush the work so far into its own command buffer, for better cross-frame
-    // granularity
-    vk_submit(ra);
-
-error:
-    return;
-}
-
-static void vk_blit(struct ra *ra, struct ra_tex *dst, struct ra_tex *src,
-                    struct mp_rect *dst_rc, struct mp_rect *src_rc)
-{
-    assert(src->params.blit_src);
-    assert(dst->params.blit_dst);
-
-    struct ra_tex_vk *src_vk = src->priv;
-    struct ra_tex_vk *dst_vk = dst->priv;
-
-    struct vk_cmd *cmd = vk_require_cmd(ra, GRAPHICS);
-    if (!cmd)
-        return;
-
-    tex_barrier(ra, cmd, src, VK_PIPELINE_STAGE_TRANSFER_BIT,
-                VK_ACCESS_TRANSFER_READ_BIT,
-                VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
-                false);
-
-    bool discard = dst_rc->x0 == 0 &&
-                   dst_rc->y0 == 0 &&
-                   dst_rc->x1 == dst->params.w &&
-                   dst_rc->y1 == dst->params.h;
-
-    tex_barrier(ra, cmd, dst, VK_PIPELINE_STAGE_TRANSFER_BIT,
-                VK_ACCESS_TRANSFER_WRITE_BIT,
-                VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
-                discard);
-
-    // Under certain conditions we can use vkCmdCopyImage instead of
-    // vkCmdBlitImage, namely when the blit operation does not require
-    // scaling. and the formats are compatible.
-    if (src->params.format->pixel_size == dst->params.format->pixel_size &&
-        mp_rect_w(*src_rc) == mp_rect_w(*dst_rc) &&
-        mp_rect_h(*src_rc) == mp_rect_h(*dst_rc) &&
-        mp_rect_w(*src_rc) >= 0 && mp_rect_h(*src_rc) >= 0)
-    {
-        VkImageCopy region = {
-            .srcSubresource = vk_layers,
-            .dstSubresource = vk_layers,
-            .srcOffset = {src_rc->x0, src_rc->y0, 0},
-            .dstOffset = {dst_rc->x0, dst_rc->y0, 0},
-            .extent = {mp_rect_w(*src_rc), mp_rect_h(*src_rc), 1},
-        };
-
-        vkCmdCopyImage(cmd->buf, src_vk->img, src_vk->current_layout,
-                       dst_vk->img, dst_vk->current_layout, 1, &region);
-    } else {
-        VkImageBlit region = {
-            .srcSubresource = vk_layers,
-            .dstSubresource = vk_layers,
-            .srcOffsets = {{src_rc->x0, src_rc->y0, 0},
-                           {src_rc->x1, src_rc->y1, 1}},
-            .dstOffsets = {{dst_rc->x0, dst_rc->y0, 0},
-                           {dst_rc->x1, dst_rc->y1, 1}},
-        };
-
-        vkCmdBlitImage(cmd->buf, src_vk->img, src_vk->current_layout,
-                       dst_vk->img, dst_vk->current_layout, 1, &region,
-                       VK_FILTER_NEAREST);
-    }
-
-    tex_signal(ra, cmd, src, VK_PIPELINE_STAGE_TRANSFER_BIT);
-    tex_signal(ra, cmd, dst, VK_PIPELINE_STAGE_TRANSFER_BIT);
-}
-
-static void vk_clear(struct ra *ra, struct ra_tex *tex, float color[4],
-                     struct mp_rect *rc)
-{
-    struct ra_vk *p = ra->priv;
-    struct ra_tex_vk *tex_vk = tex->priv;
-    assert(tex->params.blit_dst);
-
-    struct vk_cmd *cmd = vk_require_cmd(ra, GRAPHICS);
-    if (!cmd)
-        return;
-
-    struct mp_rect full = {0, 0, tex->params.w, tex->params.h};
-    if (!rc || mp_rect_equals(rc, &full)) {
-        // To clear the entire image, we can use the efficient clear command
-        tex_barrier(ra, cmd, tex, VK_PIPELINE_STAGE_TRANSFER_BIT,
-                    VK_ACCESS_TRANSFER_WRITE_BIT,
-                    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, true);
-
-        VkClearColorValue clearColor = {0};
-        for (int c = 0; c < 4; c++)
-            clearColor.float32[c] = color[c];
-
-        vkCmdClearColorImage(cmd->buf, tex_vk->img, tex_vk->current_layout,
-                             &clearColor, 1, &vk_range);
-
-        tex_signal(ra, cmd, tex, VK_PIPELINE_STAGE_TRANSFER_BIT);
-    } else {
-        // To simulate per-region clearing, we blit from a 1x1 texture instead
-        struct ra_tex_upload_params ul_params = {
-            .tex = p->clear_tex,
-            .invalidate = true,
-            .src = &color[0],
-        };
-        vk_tex_upload(ra, &ul_params);
-        vk_blit(ra, tex, p->clear_tex, rc, &(struct mp_rect){0, 0, 1, 1});
-    }
-}
-
-static int vk_desc_namespace(enum ra_vartype type)
-{
-    return 0;
-}
-
-#define VK_QUERY_POOL_SIZE (MPVK_MAX_STREAMING_DEPTH * 4)
-
-struct vk_timer {
-    VkQueryPool pool;
-    int index_seen; // keeps track of which indices have been used at least once
-    int index;
-    uint64_t result;
-};
-
-static void vk_timer_destroy(struct ra *ra, ra_timer *ratimer)
-{
-    if (!ratimer)
-        return;
-
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-    struct vk_timer *timer = ratimer;
-
-    vkDestroyQueryPool(vk->dev, timer->pool, MPVK_ALLOCATOR);
-
-    talloc_free(timer);
-}
-
-MAKE_LAZY_DESTRUCTOR(vk_timer_destroy, ra_timer);
-
-static ra_timer *vk_timer_create(struct ra *ra)
-{
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-
-    struct vk_timer *timer = talloc_zero(NULL, struct vk_timer);
-    timer->index_seen = -1;
-
-    struct VkQueryPoolCreateInfo qinfo = {
-        .sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
-        .queryType = VK_QUERY_TYPE_TIMESTAMP,
-        .queryCount = VK_QUERY_POOL_SIZE,
-    };
-
-    VK(vkCreateQueryPool(vk->dev, &qinfo, MPVK_ALLOCATOR, &timer->pool));
-
-    return (ra_timer *)timer;
-
-error:
-    vk_timer_destroy(ra, timer);
-    return NULL;
-}
-
-static void vk_timer_record(struct ra *ra, VkQueryPool pool, int index,
-                            VkPipelineStageFlags stage)
-{
-    struct vk_cmd *cmd = vk_require_cmd(ra, GRAPHICS);
-    if (!cmd)
-        return;
-
-    vkCmdWriteTimestamp(cmd->buf, stage, pool, index);
-}
-
-static void vk_timer_start(struct ra *ra, ra_timer *ratimer)
-{
-    struct mpvk_ctx *vk = ra_vk_get(ra);
-    struct vk_timer *timer = ratimer;
-
-    VkResult res = VK_NOT_READY;
-    uint64_t out[2];
-
-    if (timer->index <= timer->index_seen) {
-        res = vkGetQueryPoolResults(vk->dev, timer->pool, timer->index, 2,
-                                    sizeof(out), &out[0], sizeof(uint64_t),
-                                    VK_QUERY_RESULT_64_BIT);
-    }
-
-    switch (res) {
-    case VK_SUCCESS:
-        timer->result = (out[1] - out[0]) * vk->limits.timestampPeriod;
-        break;
-    case VK_NOT_READY:
-        timer->result = 0;
-        break;
-    default:
-        MP_WARN(vk, "Failed reading timer query result: %s\n", vk_err(res));
-        return;
-    };
-
-    vk_timer_record(ra, timer->pool, timer->index,
-                    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT);
-}
-
-static uint64_t vk_timer_stop(struct ra *ra, ra_timer *ratimer)
-{
-    struct vk_timer *timer = ratimer;
-    vk_timer_record(ra, timer->pool, timer->index + 1,
-                    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT);
-
-    timer->index_seen = MPMAX(timer->index_seen, timer->index);
-    timer->index = (timer->index + 2) % VK_QUERY_POOL_SIZE;
-
-    return timer->result;
-}
-
-static struct ra_fns ra_fns_vk = {
-    .destroy                = vk_destroy_ra,
-    .tex_create             = vk_tex_create,
-    .tex_destroy            = vk_tex_destroy_lazy,
-    .tex_upload             = vk_tex_upload,
-    .buf_create             = vk_buf_create,
-    .buf_destroy            = vk_buf_destroy_lazy,
-    .buf_update             = vk_buf_update,
-    .buf_poll               = vk_buf_poll,
-    .clear                  = vk_clear,
-    .blit                   = vk_blit,
-    .uniform_layout         = std140_layout,
-    .push_constant_layout   = std430_layout,
-    .desc_namespace         = vk_desc_namespace,
-    .renderpass_create      = vk_renderpass_create,
-    .renderpass_destroy     = vk_renderpass_destroy_lazy,
-    .renderpass_run         = vk_renderpass_run,
-    .timer_create           = vk_timer_create,
-    .timer_destroy          = vk_timer_destroy_lazy,
-    .timer_start            = vk_timer_start,
-    .timer_stop             = vk_timer_stop,
-};
-
-struct vk_cmd *ra_vk_submit(struct ra *ra, struct ra_tex *tex)
-{
-    struct ra_vk *p = ra->priv;
-    struct vk_cmd *cmd = vk_require_cmd(ra, GRAPHICS);
-    if (!cmd)
-        return NULL;
-
-    struct ra_tex_vk *tex_vk = tex->priv;
-    assert(tex_vk->external_img);
-    tex_barrier(ra, cmd, tex, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
-                VK_ACCESS_MEMORY_READ_BIT, VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
-                false);
-
-    // Return this directly instead of going through vk_submit
-    p->cmd = NULL;
-    return cmd;
-}
diff -ruN mpv-0.29.1/video/out/vulkan/ra_vk.h mpv-master/video/out/vulkan/ra_vk.h
--- mpv-0.29.1/video/out/vulkan/ra_vk.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/ra_vk.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,31 +0,0 @@
-#pragma once
-
-#include "video/out/gpu/ra.h"
-
-#include "common.h"
-#include "utils.h"
-
-struct ra *ra_create_vk(struct mpvk_ctx *vk, struct mp_log *log);
-
-// Access to the VkDevice is needed for swapchain creation
-VkDevice ra_vk_get_dev(struct ra *ra);
-
-// Allocates a ra_tex that wraps a swapchain image. The contents of the image
-// will be invalidated, and access to it will only be internally synchronized.
-// So the calling could should not do anything else with the VkImage.
-struct ra_tex *ra_vk_wrap_swapchain_img(struct ra *ra, VkImage vkimg,
-                                        VkSwapchainCreateInfoKHR info);
-
-// Associates an external semaphore (dependency) with a ra_tex, such that this
-// ra_tex will not be used by the ra_vk until the external semaphore fires.
-void ra_tex_vk_external_dep(struct ra *ra, struct ra_tex *tex, VkSemaphore dep);
-
-// This function finalizes rendering, transitions `tex` (which must be a
-// wrapped swapchain image) into a format suitable for presentation, and returns
-// the resulting command buffer (or NULL on error). The caller may add their
-// own semaphores to this command buffer, and must submit it afterwards.
-struct vk_cmd *ra_vk_submit(struct ra *ra, struct ra_tex *tex);
-
-// May be called on a struct ra of any type. Returns NULL if the ra is not
-// a vulkan ra.
-struct mpvk_ctx *ra_vk_get(struct ra *ra);
diff -ruN mpv-0.29.1/video/out/vulkan/spirv_nvidia.c mpv-master/video/out/vulkan/spirv_nvidia.c
--- mpv-0.29.1/video/out/vulkan/spirv_nvidia.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/spirv_nvidia.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,54 +0,0 @@
-#include "video/out/gpu/spirv.h"
-
-#include "common.h"
-#include "context.h"
-#include "utils.h"
-
-static bool nv_glsl_compile(struct spirv_compiler *spirv, void *tactx,
-                            enum glsl_shader type, const char *glsl,
-                            struct bstr *out_spirv)
-{
-    // The nvidia extension literally assumes your SPIRV is in fact valid GLSL
-    *out_spirv = bstr0(glsl);
-    return true;
-}
-
-static bool nv_glsl_init(struct ra_ctx *ctx)
-{
-    struct mpvk_ctx *vk = ra_vk_ctx_get(ctx);
-    if (!vk)
-        return false;
-
-    struct spirv_compiler *spv = ctx->spirv;
-    spv->required_ext = VK_NV_GLSL_SHADER_EXTENSION_NAME;
-    spv->glsl_version = 450; // impossible to query, so hard-code it..
-    spv->ra_caps = RA_CAP_NESTED_ARRAY;
-
-    // Make sure the extension is actually available, and fail gracefully
-    // if it isn't
-    VkExtensionProperties *props = NULL;
-    uint32_t extnum = 0;
-    VK(vkEnumerateDeviceExtensionProperties(vk->physd, NULL, &extnum, NULL));
-    props = talloc_array(NULL, VkExtensionProperties, extnum);
-    VK(vkEnumerateDeviceExtensionProperties(vk->physd, NULL, &extnum, props));
-
-    bool ret = true;
-    for (int e = 0; e < extnum; e++) {
-        if (strncmp(props[e].extensionName, spv->required_ext,
-                    VK_MAX_EXTENSION_NAME_SIZE) == 0)
-            goto done;
-    }
-
-error:
-    MP_VERBOSE(ctx, "Device doesn't support VK_NV_glsl_shader, skipping..\n");
-    ret = false;
-
-done:
-    talloc_free(props);
-    return ret;
-}
-
-const struct spirv_compiler_fns spirv_nvidia_builtin = {
-    .compile_glsl = nv_glsl_compile,
-    .init = nv_glsl_init,
-};
diff -ruN mpv-0.29.1/video/out/vulkan/utils.c mpv-master/video/out/vulkan/utils.c
--- mpv-0.29.1/video/out/vulkan/utils.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/utils.c	2019-09-19 04:02:03.000000000 +0700
@@ -1,929 +1,46 @@
-#include <libavutil/macros.h>
-
-#include "video/out/gpu/spirv.h"
+#include "video/out/placebo/utils.h"
 #include "utils.h"
-#include "malloc.h"
-
-const char* vk_err(VkResult res)
-{
-    switch (res) {
-    // These are technically success codes, but include them nonetheless
-    case VK_SUCCESS:     return "VK_SUCCESS";
-    case VK_NOT_READY:   return "VK_NOT_READY";
-    case VK_TIMEOUT:     return "VK_TIMEOUT";
-    case VK_EVENT_SET:   return "VK_EVENT_SET";
-    case VK_EVENT_RESET: return "VK_EVENT_RESET";
-    case VK_INCOMPLETE:  return "VK_INCOMPLETE";
-    case VK_SUBOPTIMAL_KHR: return "VK_SUBOPTIMAL_KHR";
-
-    // Actual error codes
-    case VK_ERROR_OUT_OF_HOST_MEMORY:    return "VK_ERROR_OUT_OF_HOST_MEMORY";
-    case VK_ERROR_OUT_OF_DEVICE_MEMORY:  return "VK_ERROR_OUT_OF_DEVICE_MEMORY";
-    case VK_ERROR_INITIALIZATION_FAILED: return "VK_ERROR_INITIALIZATION_FAILED";
-    case VK_ERROR_DEVICE_LOST:           return "VK_ERROR_DEVICE_LOST";
-    case VK_ERROR_MEMORY_MAP_FAILED:     return "VK_ERROR_MEMORY_MAP_FAILED";
-    case VK_ERROR_LAYER_NOT_PRESENT:     return "VK_ERROR_LAYER_NOT_PRESENT";
-    case VK_ERROR_EXTENSION_NOT_PRESENT: return "VK_ERROR_EXTENSION_NOT_PRESENT";
-    case VK_ERROR_FEATURE_NOT_PRESENT:   return "VK_ERROR_FEATURE_NOT_PRESENT";
-    case VK_ERROR_INCOMPATIBLE_DRIVER:   return "VK_ERROR_INCOMPATIBLE_DRIVER";
-    case VK_ERROR_TOO_MANY_OBJECTS:      return "VK_ERROR_TOO_MANY_OBJECTS";
-    case VK_ERROR_FORMAT_NOT_SUPPORTED:  return "VK_ERROR_FORMAT_NOT_SUPPORTED";
-    case VK_ERROR_FRAGMENTED_POOL:       return "VK_ERROR_FRAGMENTED_POOL";
-    case VK_ERROR_INVALID_SHADER_NV:     return "VK_ERROR_INVALID_SHADER_NV";
-    case VK_ERROR_OUT_OF_DATE_KHR:       return "VK_ERROR_OUT_OF_DATE_KHR";
-    case VK_ERROR_SURFACE_LOST_KHR:      return "VK_ERROR_SURFACE_LOST_KHR";
-    }
-
-    return "Unknown error!";
-}
-
-static const char* vk_dbg_type(VkDebugReportObjectTypeEXT type)
-{
-    switch (type) {
-    case VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT:
-        return "VkInstance";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT:
-        return "VkPhysicalDevice";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT:
-        return "VkDevice";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT:
-        return "VkQueue";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT:
-        return "VkSemaphore";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT:
-        return "VkCommandBuffer";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT:
-        return "VkFence";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT:
-        return "VkDeviceMemory";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT:
-        return "VkBuffer";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT:
-        return "VkImage";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT:
-        return "VkEvent";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT:
-        return "VkQueryPool";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT:
-        return "VkBufferView";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT:
-        return "VkImageView";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT:
-        return "VkShaderModule";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT:
-        return "VkPipelineCache";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT:
-        return "VkPipelineLayout";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT:
-        return "VkRenderPass";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT:
-        return "VkPipeline";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT:
-        return "VkDescriptorSetLayout";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT:
-        return "VkSampler";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT:
-        return "VkDescriptorPool";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT:
-        return "VkDescriptorSet";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT:
-        return "VkFramebuffer";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT:
-        return "VkCommandPool";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT:
-        return "VkSurfaceKHR";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT:
-        return "VkSwapchainKHR";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT:
-        return "VkDebugReportCallbackEXT";
-    case VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT:
-    default:
-        return "unknown object";
-    }
-}
-
-static VkBool32 vk_dbg_callback(VkDebugReportFlagsEXT flags,
-                                VkDebugReportObjectTypeEXT objType,
-                                uint64_t obj, size_t loc, int32_t msgCode,
-                                const char *layer, const char *msg, void *priv)
-{
-    struct mpvk_ctx *vk = priv;
-    int lev = MSGL_V;
-
-    switch (flags) {
-    case VK_DEBUG_REPORT_ERROR_BIT_EXT:               lev = MSGL_ERR;   break;
-    case VK_DEBUG_REPORT_WARNING_BIT_EXT:             lev = MSGL_WARN;  break;
-    case VK_DEBUG_REPORT_INFORMATION_BIT_EXT:         lev = MSGL_TRACE; break;
-    case VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT: lev = MSGL_WARN;  break;
-    case VK_DEBUG_REPORT_DEBUG_BIT_EXT:               lev = MSGL_DEBUG; break;
-    };
-
-    MP_MSG(vk, lev, "vk [%s] %d: %s (obj 0x%llx (%s), loc 0x%zx)\n",
-           layer, (int)msgCode, msg, (unsigned long long)obj,
-           vk_dbg_type(objType), loc);
-
-    // The return value of this function determines whether the call will
-    // be explicitly aborted (to prevent GPU errors) or not. In this case,
-    // we generally want this to be on for the errors.
-    return (flags & VK_DEBUG_REPORT_ERROR_BIT_EXT);
-}
-
-static void vk_cmdpool_destroy(struct mpvk_ctx *vk, struct vk_cmdpool *pool);
-static struct vk_cmdpool *vk_cmdpool_create(struct mpvk_ctx *vk,
-                                            VkDeviceQueueCreateInfo qinfo,
-                                            VkQueueFamilyProperties props);
-
-void mpvk_uninit(struct mpvk_ctx *vk)
-{
-    if (!vk->inst)
-        return;
-
-    if (vk->dev) {
-        mpvk_flush_commands(vk);
-        mpvk_poll_commands(vk, UINT64_MAX);
-        assert(vk->num_cmds_queued == 0);
-        assert(vk->num_cmds_pending == 0);
-        talloc_free(vk->cmds_queued);
-        talloc_free(vk->cmds_pending);
-        for (int i = 0; i < vk->num_pools; i++)
-            vk_cmdpool_destroy(vk, vk->pools[i]);
-        talloc_free(vk->pools);
-        for (int i = 0; i < vk->num_signals; i++)
-            vk_signal_destroy(vk, &vk->signals[i]);
-        talloc_free(vk->signals);
-        vk_malloc_uninit(vk);
-        vkDestroyDevice(vk->dev, MPVK_ALLOCATOR);
-    }
-
-    if (vk->dbg) {
-        // Same deal as creating the debug callback, we need to load this
-        // first.
-        VK_LOAD_PFN(vkDestroyDebugReportCallbackEXT)
-        pfn_vkDestroyDebugReportCallbackEXT(vk->inst, vk->dbg, MPVK_ALLOCATOR);
-    }
-
-    vkDestroySurfaceKHR(vk->inst, vk->surf, MPVK_ALLOCATOR);
-    vkDestroyInstance(vk->inst, MPVK_ALLOCATOR);
-
-    *vk = (struct mpvk_ctx){0};
-}
-
-bool mpvk_instance_init(struct mpvk_ctx *vk, struct mp_log *log,
-                        const char *surf_ext_name, bool debug)
-{
-    *vk = (struct mpvk_ctx) {
-        .log = log,
-    };
-
-    VkInstanceCreateInfo info = {
-        .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
-    };
-
-    if (debug) {
-        // Enables the LunarG standard validation layer, which
-        // is a meta-layer that loads lots of other validators
-        static const char* layers[] = {
-            "VK_LAYER_LUNARG_standard_validation",
-        };
-
-        info.ppEnabledLayerNames = layers;
-        info.enabledLayerCount = MP_ARRAY_SIZE(layers);
-    }
-
-    // Enable whatever extensions were compiled in.
-    const char *extensions[] = {
-        VK_KHR_SURFACE_EXTENSION_NAME,
-        surf_ext_name,
-
-        // Extra extensions only used for debugging. These are toggled by
-        // decreasing the enabledExtensionCount, so the number needs to be
-        // synchronized with the code below.
-        VK_EXT_DEBUG_REPORT_EXTENSION_NAME,
-    };
-
-    const int debugExtensionCount = 1;
-
-    info.ppEnabledExtensionNames = extensions;
-    info.enabledExtensionCount = MP_ARRAY_SIZE(extensions);
-
-    if (!debug)
-        info.enabledExtensionCount -= debugExtensionCount;
-
-    MP_VERBOSE(vk, "Creating instance with extensions:\n");
-    for (int i = 0; i < info.enabledExtensionCount; i++)
-        MP_VERBOSE(vk, "    %s\n", info.ppEnabledExtensionNames[i]);
-
-    VkResult res = vkCreateInstance(&info, MPVK_ALLOCATOR, &vk->inst);
-    if (res != VK_SUCCESS) {
-        MP_VERBOSE(vk, "Failed creating instance: %s\n", vk_err(res));
-        return false;
-    }
-
-    if (debug) {
-        // Set up a debug callback to catch validation messages
-        VkDebugReportCallbackCreateInfoEXT dinfo = {
-            .sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
-            .flags = VK_DEBUG_REPORT_INFORMATION_BIT_EXT |
-                     VK_DEBUG_REPORT_WARNING_BIT_EXT |
-                     VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT |
-                     VK_DEBUG_REPORT_ERROR_BIT_EXT |
-                     VK_DEBUG_REPORT_DEBUG_BIT_EXT,
-            .pfnCallback = vk_dbg_callback,
-            .pUserData = vk,
-        };
-
-        // Since this is not part of the core spec, we need to load it. This
-        // can't fail because we've already successfully created an instance
-        // with this extension enabled.
-        VK_LOAD_PFN(vkCreateDebugReportCallbackEXT)
-        pfn_vkCreateDebugReportCallbackEXT(vk->inst, &dinfo, MPVK_ALLOCATOR,
-                                           &vk->dbg);
-    }
 
-    return true;
-}
-
-#define MPVK_MAX_DEVICES 16
-
-static bool physd_supports_surface(struct mpvk_ctx *vk, VkPhysicalDevice physd)
-{
-    uint32_t qfnum;
-    vkGetPhysicalDeviceQueueFamilyProperties(physd, &qfnum, NULL);
-
-    for (int i = 0; i < qfnum; i++) {
-        VkBool32 sup;
-        VK(vkGetPhysicalDeviceSurfaceSupportKHR(physd, i, vk->surf, &sup));
-        if (sup)
-            return true;
-    }
-
-error:
-    return false;
-}
-
-bool mpvk_find_phys_device(struct mpvk_ctx *vk, const char *name, bool sw)
+bool mpvk_init(struct mpvk_ctx *vk, struct ra_ctx *ctx, const char *surface_ext)
 {
-    assert(vk->surf);
-
-    MP_VERBOSE(vk, "Probing for vulkan devices:\n");
-
-    VkPhysicalDevice *devices = NULL;
-    uint32_t num = 0;
-    VK(vkEnumeratePhysicalDevices(vk->inst, &num, NULL));
-    devices = talloc_array(NULL, VkPhysicalDevice, num);
-    VK(vkEnumeratePhysicalDevices(vk->inst, &num, devices));
-
-    // Sorted by "priority". Reuses some m_opt code for convenience
-    static const struct m_opt_choice_alternatives types[] = {
-        {"discrete",   VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU},
-        {"integrated", VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU},
-        {"virtual",    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU},
-        {"software",   VK_PHYSICAL_DEVICE_TYPE_CPU},
-        {"unknown",    VK_PHYSICAL_DEVICE_TYPE_OTHER},
-        {0}
-    };
-
-    VkPhysicalDeviceProperties props[MPVK_MAX_DEVICES];
-    for (int i = 0; i < num; i++) {
-        vkGetPhysicalDeviceProperties(devices[i], &props[i]);
-        MP_VERBOSE(vk, "    GPU %d: %s (%s)\n", i, props[i].deviceName,
-                   m_opt_choice_str(types, props[i].deviceType));
-    }
-
-    // Iterate through each type in order of decreasing preference
-    for (int t = 0; types[t].name; t++) {
-        // Disallow SW rendering unless explicitly enabled
-        if (types[t].value == VK_PHYSICAL_DEVICE_TYPE_CPU && !sw)
-            continue;
-
-        for (int i = 0; i < num; i++) {
-            VkPhysicalDeviceProperties prop = props[i];
-            if (prop.deviceType != types[t].value)
-                continue;
-            if (name && strcmp(name, prop.deviceName) != 0)
-                continue;
-            if (!physd_supports_surface(vk, devices[i]))
-                continue;
-
-            MP_VERBOSE(vk, "Chose device:\n");
-            MP_VERBOSE(vk, "    Device Name: %s\n", prop.deviceName);
-            MP_VERBOSE(vk, "    Device ID: %x:%x\n",
-                       (unsigned)prop.vendorID, (unsigned)prop.deviceID);
-            MP_VERBOSE(vk, "    Driver version: %d\n", (int)prop.driverVersion);
-            MP_VERBOSE(vk, "    API version: %d.%d.%d\n",
-                    (int)VK_VERSION_MAJOR(prop.apiVersion),
-                    (int)VK_VERSION_MINOR(prop.apiVersion),
-                    (int)VK_VERSION_PATCH(prop.apiVersion));
-            vk->physd = devices[i];
-            vk->limits = prop.limits;
-            vkGetPhysicalDeviceFeatures(vk->physd, &vk->features);
-            talloc_free(devices);
-            return true;
-        }
-    }
-
-error:
-    MP_VERBOSE(vk, "Found no suitable device, giving up.\n");
-    talloc_free(devices);
-    return false;
-}
-
-bool mpvk_pick_surface_format(struct mpvk_ctx *vk)
-{
-    assert(vk->physd);
-
-    VkSurfaceFormatKHR *formats = NULL;
-    int num;
-
-    // Enumerate through the surface formats and find one that we can map to
-    // a ra_format
-    VK(vkGetPhysicalDeviceSurfaceFormatsKHR(vk->physd, vk->surf, &num, NULL));
-    formats = talloc_array(NULL, VkSurfaceFormatKHR, num);
-    VK(vkGetPhysicalDeviceSurfaceFormatsKHR(vk->physd, vk->surf, &num, formats));
-
-    for (int i = 0; i < num; i++) {
-        // A value of VK_FORMAT_UNDEFINED means we can pick anything we want
-        if (formats[i].format == VK_FORMAT_UNDEFINED) {
-            vk->surf_format = (VkSurfaceFormatKHR) {
-                .colorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
-                .format = VK_FORMAT_R16G16B16A16_UNORM,
-            };
-            break;
-        }
-
-        if (formats[i].colorSpace != VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)
-            continue;
-
-        // Format whitelist, since we want only >= 8 bit _UNORM formats
-        switch (formats[i].format) {
-        case VK_FORMAT_R8G8B8_UNORM:
-        case VK_FORMAT_B8G8R8_UNORM:
-        case VK_FORMAT_R8G8B8A8_UNORM:
-        case VK_FORMAT_B8G8R8A8_UNORM:
-        case VK_FORMAT_A8B8G8R8_UNORM_PACK32:
-        case VK_FORMAT_A2R10G10B10_UNORM_PACK32:
-        case VK_FORMAT_A2B10G10R10_UNORM_PACK32:
-        case VK_FORMAT_R16G16B16_UNORM:
-        case VK_FORMAT_R16G16B16A16_UNORM:
-             break; // accept
-        default: continue;
-        }
-
-        vk->surf_format = formats[i];
-        break;
-    }
-
-    talloc_free(formats);
-
-    if (!vk->surf_format.format)
+    vk->ctx = pl_context_create(PL_API_VER, NULL);
+    if (!vk->ctx)
         goto error;
 
-    return true;
-
-error:
-    MP_ERR(vk, "Failed picking surface format!\n");
-    talloc_free(formats);
-    return false;
-}
-
-// Find the most specialized queue supported a combination of flags. In cases
-// where there are multiple queue families at the same specialization level,
-// this finds the one with the most queues. Returns -1 if no queue was found.
-static int find_qf(VkQueueFamilyProperties *qfs, int qfnum, VkQueueFlags flags)
-{
-    int idx = -1;
-    for (int i = 0; i < qfnum; i++) {
-        if (!(qfs[i].queueFlags & flags))
-            continue;
-
-        // QF is more specialized. Since we don't care about other bits like
-        // SPARSE_BIT, mask the ones we're interestew in
-        const VkQueueFlags mask = VK_QUEUE_GRAPHICS_BIT |
-                                  VK_QUEUE_TRANSFER_BIT |
-                                  VK_QUEUE_COMPUTE_BIT;
-
-        if (idx < 0 || (qfs[i].queueFlags & mask) < (qfs[idx].queueFlags & mask))
-            idx = i;
-
-        // QF has more queues (at the same specialization level)
-        if (qfs[i].queueFlags == qfs[idx].queueFlags &&
-            qfs[i].queueCount > qfs[idx].queueCount)
-            idx = i;
-    }
-
-    return idx;
-}
-
-static void add_qinfo(void *tactx, VkDeviceQueueCreateInfo **qinfos,
-                      int *num_qinfos, VkQueueFamilyProperties *qfs, int idx,
-                      int qcount)
-{
-    if (idx < 0)
-        return;
-
-    // Check to see if we've already added this queue family
-    for (int i = 0; i < *num_qinfos; i++) {
-        if ((*qinfos)[i].queueFamilyIndex == idx)
-            return;
-    }
-
-    float *priorities = talloc_zero_array(tactx, float, qcount);
-    VkDeviceQueueCreateInfo qinfo = {
-        .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
-        .queueFamilyIndex = idx,
-        .queueCount = MPMIN(qcount, qfs[idx].queueCount),
-        .pQueuePriorities = priorities,
-    };
-
-    MP_TARRAY_APPEND(tactx, *qinfos, *num_qinfos, qinfo);
-}
-
-bool mpvk_device_init(struct mpvk_ctx *vk, struct mpvk_device_opts opts)
-{
-    assert(vk->physd);
-    void *tmp = talloc_new(NULL);
-
-    // Enumerate the queue families and find suitable families for each task
-    int qfnum;
-    vkGetPhysicalDeviceQueueFamilyProperties(vk->physd, &qfnum, NULL);
-    VkQueueFamilyProperties *qfs = talloc_array(tmp, VkQueueFamilyProperties, qfnum);
-    vkGetPhysicalDeviceQueueFamilyProperties(vk->physd, &qfnum, qfs);
-
-    MP_VERBOSE(vk, "Queue families supported by device:\n");
-
-    for (int i = 0; i < qfnum; i++) {
-        MP_VERBOSE(vk, "    QF %d: flags 0x%x num %d\n", i,
-                   (unsigned)qfs[i].queueFlags, (int)qfs[i].queueCount);
-    }
-
-    int idx_gfx = -1, idx_comp = -1, idx_tf = -1;
-    idx_gfx = find_qf(qfs, qfnum, VK_QUEUE_GRAPHICS_BIT);
-    if (opts.async_compute)
-        idx_comp = find_qf(qfs, qfnum, VK_QUEUE_COMPUTE_BIT);
-    if (opts.async_transfer)
-        idx_tf = find_qf(qfs, qfnum, VK_QUEUE_TRANSFER_BIT);
-
-    // Vulkan requires at least one GRAPHICS queue, so if this fails something
-    // is horribly wrong.
-    assert(idx_gfx >= 0);
-    MP_VERBOSE(vk, "Using graphics queue (QF %d)\n", idx_gfx);
-
-    // Ensure we can actually present to the surface using this queue
-    VkBool32 sup;
-    VK(vkGetPhysicalDeviceSurfaceSupportKHR(vk->physd, idx_gfx, vk->surf, &sup));
-    if (!sup) {
-        MP_ERR(vk, "Queue family does not support surface presentation!\n");
-        goto error;
-    }
-
-    if (idx_tf >= 0 && idx_tf != idx_gfx)
-        MP_VERBOSE(vk, "Using async transfer (QF %d)\n", idx_tf);
-    if (idx_comp >= 0 && idx_comp != idx_gfx)
-        MP_VERBOSE(vk, "Using async compute (QF %d)\n", idx_comp);
-
-    // Fall back to supporting compute shaders via the graphics pool for
-    // devices which support compute shaders but not async compute.
-    if (idx_comp < 0 && qfs[idx_gfx].queueFlags & VK_QUEUE_COMPUTE_BIT)
-        idx_comp = idx_gfx;
-
-    // Now that we know which QFs we want, we can create the logical device
-    VkDeviceQueueCreateInfo *qinfos = NULL;
-    int num_qinfos = 0;
-    add_qinfo(tmp, &qinfos, &num_qinfos, qfs, idx_gfx, opts.queue_count);
-    add_qinfo(tmp, &qinfos, &num_qinfos, qfs, idx_comp, opts.queue_count);
-    add_qinfo(tmp, &qinfos, &num_qinfos, qfs, idx_tf, opts.queue_count);
-
-    const char **exts = NULL;
-    int num_exts = 0;
-    MP_TARRAY_APPEND(tmp, exts, num_exts, VK_KHR_SWAPCHAIN_EXTENSION_NAME);
-    if (vk->spirv->required_ext)
-        MP_TARRAY_APPEND(tmp, exts, num_exts, vk->spirv->required_ext);
-
-    // Enable all features we optionally use
-#define FEATURE(name) .name = vk->features.name
-    VkPhysicalDeviceFeatures feats = {
-        FEATURE(shaderImageGatherExtended),
-        FEATURE(shaderStorageImageExtendedFormats),
-    };
-#undef FEATURE
-
-    VkDeviceCreateInfo dinfo = {
-        .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
-        .pQueueCreateInfos = qinfos,
-        .queueCreateInfoCount = num_qinfos,
-        .ppEnabledExtensionNames = exts,
-        .enabledExtensionCount = num_exts,
-        .pEnabledFeatures = &feats,
-    };
-
-    MP_VERBOSE(vk, "Creating vulkan device with extensions:\n");
-    for (int i = 0; i < num_exts; i++)
-        MP_VERBOSE(vk, "    %s\n", exts[i]);
-
-    VK(vkCreateDevice(vk->physd, &dinfo, MPVK_ALLOCATOR, &vk->dev));
-
-    // Create the command pools and memory allocator
-    for (int i = 0; i < num_qinfos; i++) {
-        int qf = qinfos[i].queueFamilyIndex;
-        struct vk_cmdpool *pool = vk_cmdpool_create(vk, qinfos[i], qfs[qf]);
-        if (!pool)
-            goto error;
-        MP_TARRAY_APPEND(NULL, vk->pools, vk->num_pools, pool);
-
-        // Update the pool_* pointers based on the corresponding QF index
-        if (qf == idx_gfx)
-            vk->pool_graphics = pool;
-        if (qf == idx_comp)
-            vk->pool_compute = pool;
-        if (qf == idx_tf)
-            vk->pool_transfer = pool;
-    }
-
-    vk_malloc_init(vk);
-    talloc_free(tmp);
-    return true;
+    vk->pl_log = mp_log_new(ctx, ctx->log, "libplacebo");
+    mppl_ctx_set_log(vk->ctx, vk->pl_log, true);
 
-error:
-    MP_ERR(vk, "Failed creating logical device!\n");
-    talloc_free(tmp);
-    return false;
-}
-
-// returns VK_SUCCESS (completed), VK_TIMEOUT (not yet completed) or an error
-static VkResult vk_cmd_poll(struct mpvk_ctx *vk, struct vk_cmd *cmd,
-                            uint64_t timeout)
-{
-    return vkWaitForFences(vk->dev, 1, &cmd->fence, false, timeout);
-}
-
-static void vk_cmd_reset(struct mpvk_ctx *vk, struct vk_cmd *cmd)
-{
-    for (int i = 0; i < cmd->num_callbacks; i++) {
-        struct vk_callback *cb = &cmd->callbacks[i];
-        cb->run(cb->priv, cb->arg);
-    }
-
-    cmd->num_callbacks = 0;
-    cmd->num_deps = 0;
-    cmd->num_sigs = 0;
-
-    // also make sure to reset vk->last_cmd in case this was the last command
-    if (vk->last_cmd == cmd)
-        vk->last_cmd = NULL;
-}
-
-static void vk_cmd_destroy(struct mpvk_ctx *vk, struct vk_cmd *cmd)
-{
-    if (!cmd)
-        return;
-
-    vk_cmd_poll(vk, cmd, UINT64_MAX);
-    vk_cmd_reset(vk, cmd);
-    vkDestroyFence(vk->dev, cmd->fence, MPVK_ALLOCATOR);
-    vkFreeCommandBuffers(vk->dev, cmd->pool->pool, 1, &cmd->buf);
-
-    talloc_free(cmd);
-}
-
-static struct vk_cmd *vk_cmd_create(struct mpvk_ctx *vk, struct vk_cmdpool *pool)
-{
-    struct vk_cmd *cmd = talloc_zero(NULL, struct vk_cmd);
-    cmd->pool = pool;
-
-    VkCommandBufferAllocateInfo ainfo = {
-        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
-        .commandPool = pool->pool,
-        .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
-        .commandBufferCount = 1,
-    };
-
-    VK(vkAllocateCommandBuffers(vk->dev, &ainfo, &cmd->buf));
-
-    VkFenceCreateInfo finfo = {
-        .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
-        .flags = VK_FENCE_CREATE_SIGNALED_BIT,
+    const char *exts[] = {
+        VK_KHR_SURFACE_EXTENSION_NAME,
+        surface_ext,
     };
 
-    VK(vkCreateFence(vk->dev, &finfo, MPVK_ALLOCATOR, &cmd->fence));
-
-    return cmd;
-
-error:
-    vk_cmd_destroy(vk, cmd);
-    return NULL;
-}
-
-void vk_cmd_callback(struct vk_cmd *cmd, vk_cb callback, void *p, void *arg)
-{
-    MP_TARRAY_APPEND(cmd, cmd->callbacks, cmd->num_callbacks, (struct vk_callback) {
-        .run  = callback,
-        .priv = p,
-        .arg  = arg,
+    vk->vkinst = pl_vk_inst_create(vk->ctx, &(struct pl_vk_inst_params) {
+        .debug = ctx->opts.debug,
+        .extensions = exts,
+        .num_extensions = MP_ARRAY_SIZE(exts),
     });
-}
-
-void vk_cmd_dep(struct vk_cmd *cmd, VkSemaphore dep, VkPipelineStageFlags stage)
-{
-    int idx = cmd->num_deps++;
-    MP_TARRAY_GROW(cmd, cmd->deps, idx);
-    MP_TARRAY_GROW(cmd, cmd->depstages, idx);
-    cmd->deps[idx] = dep;
-    cmd->depstages[idx] = stage;
-}
-
-void vk_cmd_sig(struct vk_cmd *cmd, VkSemaphore sig)
-{
-    MP_TARRAY_APPEND(cmd, cmd->sigs, cmd->num_sigs, sig);
-}
-
-static void vk_cmdpool_destroy(struct mpvk_ctx *vk, struct vk_cmdpool *pool)
-{
-    if (!pool)
-        return;
-
-    for (int i = 0; i < pool->num_cmds; i++)
-        vk_cmd_destroy(vk, pool->cmds[i]);
-
-    vkDestroyCommandPool(vk->dev, pool->pool, MPVK_ALLOCATOR);
-    talloc_free(pool);
-}
-
-static struct vk_cmdpool *vk_cmdpool_create(struct mpvk_ctx *vk,
-                                            VkDeviceQueueCreateInfo qinfo,
-                                            VkQueueFamilyProperties props)
-{
-    struct vk_cmdpool *pool = talloc_ptrtype(NULL, pool);
-    *pool = (struct vk_cmdpool) {
-        .props = props,
-        .qf = qinfo.queueFamilyIndex,
-        .queues = talloc_array(pool, VkQueue, qinfo.queueCount),
-        .num_queues = qinfo.queueCount,
-    };
-
-    for (int n = 0; n < pool->num_queues; n++)
-        vkGetDeviceQueue(vk->dev, pool->qf, n, &pool->queues[n]);
-
-    VkCommandPoolCreateInfo cinfo = {
-        .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
-        .flags = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT |
-                 VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
-        .queueFamilyIndex = pool->qf,
-    };
-
-    VK(vkCreateCommandPool(vk->dev, &cinfo, MPVK_ALLOCATOR, &pool->pool));
-
-    return pool;
-
-error:
-    vk_cmdpool_destroy(vk, pool);
-    return NULL;
-}
-
-void mpvk_poll_commands(struct mpvk_ctx *vk, uint64_t timeout)
-{
-    while (vk->num_cmds_pending > 0) {
-        struct vk_cmd *cmd = vk->cmds_pending[0];
-        struct vk_cmdpool *pool = cmd->pool;
-        VkResult res = vk_cmd_poll(vk, cmd, timeout);
-        if (res == VK_TIMEOUT)
-            break;
-        vk_cmd_reset(vk, cmd);
-        MP_TARRAY_REMOVE_AT(vk->cmds_pending, vk->num_cmds_pending, 0);
-        MP_TARRAY_APPEND(pool, pool->cmds, pool->num_cmds, cmd);
-    }
-}
-
-bool mpvk_flush_commands(struct mpvk_ctx *vk)
-{
-    bool ret = true;
-
-    for (int i = 0; i < vk->num_cmds_queued; i++) {
-        struct vk_cmd *cmd = vk->cmds_queued[i];
-        struct vk_cmdpool *pool = cmd->pool;
-
-        VkSubmitInfo sinfo = {
-            .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
-            .commandBufferCount = 1,
-            .pCommandBuffers = &cmd->buf,
-            .waitSemaphoreCount = cmd->num_deps,
-            .pWaitSemaphores = cmd->deps,
-            .pWaitDstStageMask = cmd->depstages,
-            .signalSemaphoreCount = cmd->num_sigs,
-            .pSignalSemaphores = cmd->sigs,
-        };
-
-        VK(vkQueueSubmit(cmd->queue, 1, &sinfo, cmd->fence));
-        MP_TARRAY_APPEND(NULL, vk->cmds_pending, vk->num_cmds_pending, cmd);
-
-        if (mp_msg_test(vk->log, MSGL_TRACE)) {
-            MP_TRACE(vk, "Submitted command on queue %p (QF %d):\n",
-                     (void *)cmd->queue, pool->qf);
-            for (int n = 0; n < cmd->num_deps; n++)
-                MP_TRACE(vk, "    waits on semaphore %p\n", (void *)cmd->deps[n]);
-            for (int n = 0; n < cmd->num_sigs; n++)
-                MP_TRACE(vk, "    signals semaphore %p\n", (void *)cmd->sigs[n]);
-        }
-        continue;
 
-error:
-        vk_cmd_reset(vk, cmd);
-        MP_TARRAY_APPEND(pool, pool->cmds, pool->num_cmds, cmd);
-        ret = false;
-    }
-
-    vk->num_cmds_queued = 0;
-
-    // Rotate the queues to ensure good parallelism across frames
-    for (int i = 0; i < vk->num_pools; i++) {
-        struct vk_cmdpool *pool = vk->pools[i];
-        pool->idx_queues = (pool->idx_queues + 1) % pool->num_queues;
-    }
-
-    return ret;
-}
-
-void vk_dev_callback(struct mpvk_ctx *vk, vk_cb callback, void *p, void *arg)
-{
-    if (vk->last_cmd) {
-        vk_cmd_callback(vk->last_cmd, callback, p, arg);
-    } else {
-        // The device was already idle, so we can just immediately call it
-        callback(p, arg);
-    }
-}
-
-struct vk_cmd *vk_cmd_begin(struct mpvk_ctx *vk, struct vk_cmdpool *pool)
-{
-    // garbage collect the cmdpool first, to increase the chances of getting
-    // an already-available command buffer
-    mpvk_poll_commands(vk, 0);
-
-    struct vk_cmd *cmd = NULL;
-    if (MP_TARRAY_POP(pool->cmds, pool->num_cmds, &cmd))
-        goto done;
-
-    // No free command buffers => allocate another one
-    cmd = vk_cmd_create(vk, pool);
-    if (!cmd)
+    if (!vk->vkinst)
         goto error;
 
-done: ;
-
-    VkCommandBufferBeginInfo binfo = {
-        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
-        .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
-    };
-
-    VK(vkBeginCommandBuffer(cmd->buf, &binfo));
-
-    cmd->queue = pool->queues[pool->idx_queues];
-    return cmd;
-
-error:
-    // Something has to be seriously messed up if we get to this point
-    vk_cmd_destroy(vk, cmd);
-    return NULL;
-}
-
-void vk_cmd_queue(struct mpvk_ctx *vk, struct vk_cmd *cmd)
-{
-    struct vk_cmdpool *pool = cmd->pool;
-
-    VK(vkEndCommandBuffer(cmd->buf));
-
-    VK(vkResetFences(vk->dev, 1, &cmd->fence));
-    MP_TARRAY_APPEND(NULL, vk->cmds_queued, vk->num_cmds_queued, cmd);
-    vk->last_cmd = cmd;
-    return;
-
-error:
-    vk_cmd_reset(vk, cmd);
-    MP_TARRAY_APPEND(pool, pool->cmds, pool->num_cmds, cmd);
-}
-
-void vk_signal_destroy(struct mpvk_ctx *vk, struct vk_signal **sig)
-{
-    if (!*sig)
-        return;
-
-    vkDestroySemaphore(vk->dev, (*sig)->semaphore, MPVK_ALLOCATOR);
-    vkDestroyEvent(vk->dev, (*sig)->event, MPVK_ALLOCATOR);
-    talloc_free(*sig);
-    *sig = NULL;
-}
-
-struct vk_signal *vk_cmd_signal(struct mpvk_ctx *vk, struct vk_cmd *cmd,
-                                VkPipelineStageFlags stage)
-{
-    struct vk_signal *sig = NULL;
-    if (MP_TARRAY_POP(vk->signals, vk->num_signals, &sig))
-        goto done;
-
-    // no available signal => initialize a new one
-    sig = talloc_zero(NULL, struct vk_signal);
-    static const VkSemaphoreCreateInfo sinfo = {
-        .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
-    };
-
-    VK(vkCreateSemaphore(vk->dev, &sinfo, MPVK_ALLOCATOR, &sig->semaphore));
-
-    static const VkEventCreateInfo einfo = {
-        .sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
-    };
-
-    VK(vkCreateEvent(vk->dev, &einfo, MPVK_ALLOCATOR, &sig->event));
-
-done:
-    // Signal both the semaphore and the event if possible. (We will only
-    // end up using one or the other)
-    vk_cmd_sig(cmd, sig->semaphore);
-
-    VkQueueFlags req = VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT;
-    if (cmd->pool->props.queueFlags & req) {
-        vkCmdSetEvent(cmd->buf, sig->event, stage);
-        sig->event_source = cmd->queue;
-    }
-
-    return sig;
+    mppl_ctx_set_log(vk->ctx, vk->pl_log, false); // disable probing
+    return true;
 
 error:
-    vk_signal_destroy(vk, &sig);
-    return NULL;
-}
-
-static bool unsignal_cmd(struct vk_cmd *cmd, VkSemaphore sem)
-{
-    for (int n = 0; n < cmd->num_sigs; n++) {
-        if (cmd->sigs[n] == sem) {
-            MP_TARRAY_REMOVE_AT(cmd->sigs, cmd->num_sigs, n);
-            return true;
-        }
-    }
-
-    return false;
-}
-
-// Attempts to remove a queued signal operation. Returns true if sucessful,
-// i.e. the signal could be removed before it ever got fired.
-static bool unsignal(struct mpvk_ctx *vk, struct vk_cmd *cmd, VkSemaphore sem)
-{
-    if (unsignal_cmd(cmd, sem))
-        return true;
-
-    // Attempt to remove it from any queued commands
-    for (int i = 0; i < vk->num_cmds_queued; i++) {
-        if (unsignal_cmd(vk->cmds_queued[i], sem))
-            return true;
-    }
-
+    mpvk_uninit(vk);
     return false;
 }
 
-static void release_signal(struct mpvk_ctx *vk, struct vk_signal *sig)
-{
-    // The semaphore never needs to be recreated, because it's either
-    // unsignaled while still queued, or unsignaled as a result of a device
-    // wait. But the event *may* need to be reset, so just always reset it.
-    if (sig->event_source)
-        vkResetEvent(vk->dev, sig->event);
-    sig->event_source = NULL;
-    MP_TARRAY_APPEND(NULL, vk->signals, vk->num_signals, sig);
-}
-
-void vk_cmd_wait(struct mpvk_ctx *vk, struct vk_cmd *cmd,
-                 struct vk_signal **sigptr, VkPipelineStageFlags stage,
-                 VkEvent *out_event)
+void mpvk_uninit(struct mpvk_ctx *vk)
 {
-    struct vk_signal *sig = *sigptr;
-    if (!sig)
-        return;
-
-    if (out_event && sig->event && sig->event_source == cmd->queue &&
-        unsignal(vk, cmd, sig->semaphore))
-    {
-        // If we can remove the semaphore signal operation from the history and
-        // pretend it never happened, then we get to use the VkEvent. This also
-        // requires that the VkEvent was signalled from the same VkQueue.
-        *out_event = sig->event;
-    } else if (sig->semaphore) {
-        // Otherwise, we use the semaphore. (This also unsignals it as a result
-        // of the command execution)
-        vk_cmd_dep(cmd, sig->semaphore, stage);
+    if (vk->surface) {
+        assert(vk->vkinst);
+        vkDestroySurfaceKHR(vk->vkinst->instance, vk->surface, NULL);
+        vk->surface = NULL;
     }
 
-    // In either case, once the command completes, we can release the signal
-    // resource back to the pool.
-    vk_cmd_callback(cmd, (vk_cb) release_signal, vk, sig);
-    *sigptr = NULL;
+    pl_vk_inst_destroy(&vk->vkinst);
+    pl_context_destroy(&vk->ctx);
+    TA_FREEP(&vk->pl_log);
 }
-
-const VkImageSubresourceRange vk_range = {
-    .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
-    .levelCount = 1,
-    .layerCount = 1,
-};
-
-const VkImageSubresourceLayers vk_layers = {
-    .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
-    .layerCount = 1,
-};
diff -ruN mpv-0.29.1/video/out/vulkan/utils.h mpv-master/video/out/vulkan/utils.h
--- mpv-0.29.1/video/out/vulkan/utils.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/vulkan/utils.h	2019-09-19 04:02:03.000000000 +0700
@@ -1,183 +1,6 @@
 #pragma once
-
-#include "video/out/vo.h"
-#include "video/out/gpu/context.h"
-#include "video/mp_image.h"
-
 #include "common.h"
-#include "formats.h"
-
-#define VK_LOAD_PFN(name) PFN_##name pfn_##name = (PFN_##name) \
-                            vkGetInstanceProcAddr(vk->inst, #name);
-
-// Return a human-readable name for various struct mpvk_ctx enums
-const char* vk_err(VkResult res);
-
-// Convenience macros to simplify a lot of common boilerplate
-#define VK_ASSERT(res, str)                               \
-    do {                                                  \
-        if (res != VK_SUCCESS) {                          \
-            MP_ERR(vk, str ": %s\n", vk_err(res));        \
-            goto error;                                   \
-        }                                                 \
-    } while (0)
-
-#define VK(cmd)                                           \
-    do {                                                  \
-        MP_TRACE(vk, #cmd "\n");                          \
-        VkResult res ## __LINE__ = (cmd);                 \
-        VK_ASSERT(res ## __LINE__, #cmd);                 \
-    } while (0)
+#include "video/out/gpu/context.h"
 
-// Uninits everything in the correct order
+bool mpvk_init(struct mpvk_ctx *vk, struct ra_ctx *ctx, const char *surface_ext);
 void mpvk_uninit(struct mpvk_ctx *vk);
-
-// Initialization functions: As a rule of thumb, these need to be called in
-// this order, followed by vk_malloc_init, followed by RA initialization, and
-// finally followed by vk_swchain initialization.
-
-// Create a vulkan instance. Returns VK_NULL_HANDLE on failure
-bool mpvk_instance_init(struct mpvk_ctx *vk, struct mp_log *log,
-                        const char *surf_ext_name, bool debug);
-
-// Generate a VkSurfaceKHR usable for video output. Returns VK_NULL_HANDLE on
-// failure. Must be called after mpvk_instance_init.
-bool mpvk_surface_init(struct vo *vo, struct mpvk_ctx *vk);
-
-// Find a suitable physical device for use with rendering and which supports
-// the surface.
-// name: only match a device with this name
-// sw: also allow software/virtual devices
-bool mpvk_find_phys_device(struct mpvk_ctx *vk, const char *name, bool sw);
-
-// Pick a suitable surface format that's supported by this physical device.
-bool mpvk_pick_surface_format(struct mpvk_ctx *vk);
-
-struct mpvk_device_opts {
-    int queue_count;    // number of queues to use
-    int async_transfer; // enable async transfer
-    int async_compute;  // enable async compute
-};
-
-// Create a logical device and initialize the vk_cmdpools
-bool mpvk_device_init(struct mpvk_ctx *vk, struct mpvk_device_opts opts);
-
-// Wait for all currently pending commands to have completed. This is the only
-// function that actually processes the callbacks. Will wait at most `timeout`
-// nanoseconds for the completion of each command. Using it with a value of
-// UINT64_MAX effectively means waiting until the pool/device is idle. The
-// timeout may also be passed as 0, in which case this function will not block,
-// but only poll for completed commands.
-void mpvk_poll_commands(struct mpvk_ctx *vk, uint64_t timeout);
-
-// Flush all currently queued commands. Call this once per frame, after
-// submitting all of the command buffers for that frame. Calling this more
-// often than that is possible but bad for performance.
-// Returns whether successful. Failed commands will be implicitly dropped.
-bool mpvk_flush_commands(struct mpvk_ctx *vk);
-
-// Since lots of vulkan operations need to be done lazily once the affected
-// resources are no longer in use, provide an abstraction for tracking these.
-// In practice, these are only checked and run when submitting new commands, so
-// the actual execution may be delayed by a frame.
-typedef void (*vk_cb)(void *priv, void *arg);
-
-struct vk_callback {
-    vk_cb run;
-    void *priv;
-    void *arg; // as a convenience, you also get to pass an arg for "free"
-};
-
-// Associate a callback with the completion of all currently pending commands.
-// This will essentially run once the device is completely idle.
-void vk_dev_callback(struct mpvk_ctx *vk, vk_cb callback, void *p, void *arg);
-
-// Helper wrapper around command buffers that also track dependencies,
-// callbacks and synchronization primitives
-struct vk_cmd {
-    struct vk_cmdpool *pool; // pool it was allocated from
-    VkQueue queue;           // the submission queue (for recording/pending)
-    VkCommandBuffer buf;     // the command buffer itself
-    VkFence fence;           // the fence guards cmd buffer reuse
-    // The semaphores represent dependencies that need to complete before
-    // this command can be executed. These are *not* owned by the vk_cmd
-    VkSemaphore *deps;
-    VkPipelineStageFlags *depstages;
-    int num_deps;
-    // The signals represent semaphores that fire once the command finishes
-    // executing. These are also not owned by the vk_cmd
-    VkSemaphore *sigs;
-    int num_sigs;
-    // Since VkFences are useless, we have to manually track "callbacks"
-    // to fire once the VkFence completes. These are used for multiple purposes,
-    // ranging from garbage collection (resource deallocation) to fencing.
-    struct vk_callback *callbacks;
-    int num_callbacks;
-};
-
-// Associate a callback with the completion of the current command. This
-// bool will be set to `true` once the command completes, or shortly thereafter.
-void vk_cmd_callback(struct vk_cmd *cmd, vk_cb callback, void *p, void *arg);
-
-// Associate a raw dependency for the current command. This semaphore must
-// signal by the corresponding stage before the command may execute.
-void vk_cmd_dep(struct vk_cmd *cmd, VkSemaphore dep, VkPipelineStageFlags stage);
-
-// Associate a raw signal with the current command. This semaphore will signal
-// after the command completes.
-void vk_cmd_sig(struct vk_cmd *cmd, VkSemaphore sig);
-
-// Signal abstraction: represents an abstract synchronization mechanism.
-// Internally, this may either resolve as a semaphore or an event depending
-// on whether the appropriate conditions are met.
-struct vk_signal {
-    VkSemaphore semaphore;
-    VkEvent event;
-    VkQueue event_source;
-};
-
-// Generates a signal after the execution of all previous commands matching the
-// given the pipeline stage. The signal is owned by the caller, and must be
-// consumed eith vk_cmd_wait or released with vk_signal_cancel in order to
-// free the resources.
-struct vk_signal *vk_cmd_signal(struct mpvk_ctx *vk, struct vk_cmd *cmd,
-                                VkPipelineStageFlags stage);
-
-// Consumes a previously generated signal. This signal must fire by the
-// indicated stage before the command can run. If *event is not NULL, then it
-// MAY be set to a VkEvent which the caller MUST manually wait on in the most
-// appropriate way. This function takes over ownership of the signal (and the
-// signal will be released/reused automatically)
-void vk_cmd_wait(struct mpvk_ctx *vk, struct vk_cmd *cmd,
-                 struct vk_signal **sigptr, VkPipelineStageFlags stage,
-                 VkEvent *out_event);
-
-// Destroys a currently pending signal, for example if the resource is no
-// longer relevant.
-void vk_signal_destroy(struct mpvk_ctx *vk, struct vk_signal **sig);
-
-// Command pool / queue family hybrid abstraction
-struct vk_cmdpool {
-    VkQueueFamilyProperties props;
-    int qf; // queue family index
-    VkCommandPool pool;
-    VkQueue *queues;
-    int num_queues;
-    int idx_queues;
-    // Command buffers associated with this queue. These are available for
-    // re-recording
-    struct vk_cmd **cmds;
-    int num_cmds;
-};
-
-// Fetch a command buffer from a command pool and begin recording to it.
-// Returns NULL on failure.
-struct vk_cmd *vk_cmd_begin(struct mpvk_ctx *vk, struct vk_cmdpool *pool);
-
-// Finish recording a command buffer and queue it for execution. This function
-// takes over ownership of *cmd, i.e. the caller should not touch it again.
-void vk_cmd_queue(struct mpvk_ctx *vk, struct vk_cmd *cmd);
-
-// Predefined structs for a simple non-layered, non-mipped image
-extern const VkImageSubresourceRange vk_range;
-extern const VkImageSubresourceLayers vk_layers;
diff -ruN mpv-0.29.1/video/out/w32_common.c mpv-master/video/out/w32_common.c
--- mpv-0.29.1/video/out/w32_common.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/w32_common.c	2019-09-19 04:02:03.000000000 +0700
@@ -101,9 +101,7 @@
     bool toggle_fs; // whether the current fullscreen state needs to be switched
 
     RECT windowrc; // currently known window rect
-    RECT screenrc; // current screen rect
-    // last non-fullscreen rect, updated only on fullscreen or on initialization
-    RECT prev_windowrc;
+    RECT prev_windowrc; // last non-fullscreen window rect
 
     // video size
     uint32_t o_dwidth;
@@ -606,6 +604,80 @@
                                                     TBPF_NORMAL);
 }
 
+struct get_monitor_data {
+    int i;
+    int target;
+    HMONITOR mon;
+};
+
+static BOOL CALLBACK get_monitor_proc(HMONITOR mon, HDC dc, LPRECT r, LPARAM p)
+{
+    struct get_monitor_data *data = (struct get_monitor_data*)p;
+
+    if (data->i == data->target) {
+        data->mon = mon;
+        return FALSE;
+    }
+    data->i++;
+    return TRUE;
+}
+
+static HMONITOR get_monitor(int id)
+{
+    struct get_monitor_data data = { .target = id };
+    EnumDisplayMonitors(NULL, NULL, get_monitor_proc, (LPARAM)&data);
+    return data.mon;
+}
+
+static HMONITOR get_default_monitor(struct vo_w32_state *w32)
+{
+    const int id = w32->current_fs ? w32->opts->fsscreen_id :
+                                     w32->opts->screen_id;
+
+    // Handle --fs-screen=<all|default> and --screen=default
+    if (id < 0)
+        return MonitorFromWindow(w32->window, MONITOR_DEFAULTTOPRIMARY);
+
+    HMONITOR mon = get_monitor(id);
+    if (mon)
+        return mon;
+    MP_VERBOSE(w32, "Screen %d does not exist, falling back to primary\n", id);
+    return MonitorFromPoint((POINT){0, 0}, MONITOR_DEFAULTTOPRIMARY);
+}
+
+static MONITORINFO get_monitor_info(struct vo_w32_state *w32)
+{
+    HMONITOR mon;
+    if (IsWindowVisible(w32->window) && !w32->current_fs) {
+        mon = MonitorFromWindow(w32->window, MONITOR_DEFAULTTOPRIMARY);
+    } else {
+        // The window is not visible during initialization, so get the
+        // monitor by --screen or --fs-screen id, or fallback to primary.
+        mon = get_default_monitor(w32);
+    }
+    MONITORINFO mi = { .cbSize = sizeof(mi) };
+    GetMonitorInfoW(mon, &mi);
+    return mi;
+}
+
+static RECT get_screen_area(struct vo_w32_state *w32)
+{
+    // Handle --fs-screen=all
+    if (w32->current_fs && w32->opts->fsscreen_id == -2) {
+        const int x = GetSystemMetrics(SM_XVIRTUALSCREEN);
+        const int y = GetSystemMetrics(SM_YVIRTUALSCREEN);
+        return (RECT) { x, y, x + GetSystemMetrics(SM_CXVIRTUALSCREEN),
+                              y + GetSystemMetrics(SM_CYVIRTUALSCREEN) };
+    }
+    return get_monitor_info(w32).rcMonitor;
+}
+
+static RECT get_working_area(struct vo_w32_state *w32)
+{
+    return w32->current_fs ? get_screen_area(w32) :
+                             get_monitor_info(w32).rcWork;
+}
+
 static bool snap_to_screen_edges(struct vo_w32_state *w32, RECT *rc)
 {
     if (w32->parent || w32->current_fs || IsMaximized(w32->window))
@@ -633,11 +705,8 @@
     if (rect_w(*rc) != rect_w(wr) || rect_h(*rc) != rect_h(wr))
         return false;
 
-    MONITORINFO mi = { .cbSize = sizeof(mi) };
-    if (!GetMonitorInfoW(w32->monitor, &mi))
-        return false;
     // Get the work area to let the window snap to taskbar
-    wr = mi.rcWork;
+    wr = get_working_area(w32);
 
     // Check for invisible borders and adjust the work area size
     RECT frame = {0};
@@ -686,64 +755,6 @@
     return true;
 }
 
-struct get_monitor_data {
-    int i;
-    int target;
-    HMONITOR mon;
-};
-
-static BOOL CALLBACK get_monitor_proc(HMONITOR mon, HDC dc, LPRECT r, LPARAM p)
-{
-    struct get_monitor_data *data = (struct get_monitor_data*)p;
-
-    if (data->i == data->target) {
-        data->mon = mon;
-        return FALSE;
-    }
-    data->i++;
-    return TRUE;
-}
-
-static HMONITOR get_monitor(int id)
-{
-    struct get_monitor_data data = { .target = id };
-    EnumDisplayMonitors(NULL, NULL, get_monitor_proc, (LPARAM)&data);
-    return data.mon;
-}
-
-static void update_screen_rect(struct vo_w32_state *w32)
-{
-    struct mp_vo_opts *opts = w32->opts;
-    int screen = w32->current_fs ? opts->fsscreen_id : opts->screen_id;
-
-    // Handle --fs-screen=all
-    if (w32->current_fs && screen == -2) {
-        const int x = GetSystemMetrics(SM_XVIRTUALSCREEN);
-        const int y = GetSystemMetrics(SM_YVIRTUALSCREEN);
-        SetRect(&w32->screenrc, x, y, x + GetSystemMetrics(SM_CXVIRTUALSCREEN),
-                                      y + GetSystemMetrics(SM_CYVIRTUALSCREEN));
-        return;
-    }
-
-    // When not using --fs-screen=all, mpv belongs to a specific HMONITOR
-    HMONITOR mon;
-    if (screen == -1) {
-        // Handle --fs-screen=current and --screen=default
-        mon = MonitorFromWindow(w32->window, MONITOR_DEFAULTTOPRIMARY);
-    } else {
-        mon = get_monitor(screen);
-        if (!mon) {
-            MP_INFO(w32, "Screen %d does not exist, falling back to primary\n",
-                    screen);
-            mon = MonitorFromPoint((POINT){0, 0}, MONITOR_DEFAULTTOPRIMARY);
-        }
-    }
-
-    MONITORINFO mi = { .cbSize = sizeof(mi) };
-    GetMonitorInfoW(mon, &mi);
-    w32->screenrc = mi.rcMonitor;
-}
-
 static DWORD update_style(struct vo_w32_state *w32, DWORD style)
 {
     const DWORD NO_FRAME = WS_OVERLAPPED | WS_MINIMIZEBOX;
@@ -803,7 +814,7 @@
     if (w32->parent || w32->current_fs || IsMaximized(w32->window))
         return;
 
-    RECT screen = w32->screenrc;
+    RECT screen = get_working_area(w32);
     if (w32->opts->border && w32->opts->fit_border)
         subtract_window_borders(w32->window, &screen);
 
@@ -830,26 +841,21 @@
     bool toggle_fs = w32->current_fs != new_fs;
     w32->current_fs = new_fs;
 
-    update_screen_rect(w32);
-
     if (toggle_fs) {
-        RECT rc;
-        char msg[50];
         if (w32->current_fs) {
             // Save window rect when switching to fullscreen.
-            rc = w32->prev_windowrc = w32->windowrc;
-            sprintf(msg, "save window bounds");
+            w32->prev_windowrc = w32->windowrc;
+            MP_VERBOSE(w32, "save window bounds: %d:%d:%d:%d\n",
+                       (int)w32->windowrc.left, (int)w32->windowrc.top,
+                       (int)rect_w(w32->windowrc), (int)rect_h(w32->windowrc));
         } else {
             // Restore window rect when switching from fullscreen.
-            rc = w32->windowrc = w32->prev_windowrc;
-            sprintf(msg, "restore window bounds");
+            w32->windowrc = w32->prev_windowrc;
         }
-        MP_VERBOSE(w32, "%s: %d:%d:%d:%d\n", msg,
-                   (int)rc.left, (int)rc.top, (int)rect_w(rc), (int)rect_h(rc));
     }
 
     if (w32->current_fs)
-        w32->windowrc = w32->screenrc;
+        w32->windowrc = get_screen_area(w32);
 
     MP_VERBOSE(w32, "reset window bounds: %d:%d:%d:%d\n",
                (int)w32->windowrc.left, (int)w32->windowrc.top,
@@ -1285,9 +1291,10 @@
     struct vo_w32_state *w32 = ptr;
     struct vo *vo = w32->vo;
 
+    RECT r = get_working_area(w32);
+    struct mp_rect screen = { r.left, r.top, r.right, r.bottom };
     struct vo_win_geometry geo;
-    struct mp_rect screen = { w32->screenrc.left, w32->screenrc.top,
-                              w32->screenrc.right, w32->screenrc.bottom };
+
     vo_calc_window_geometry(vo, &screen, &geo);
     vo_apply_window_geometry(vo, &geo);
 
@@ -1311,7 +1318,6 @@
 
     // The desired size always matches the window size in wid mode.
     if (!reset_size || w32->parent) {
-        RECT r;
         GetClientRect(w32->window, &r);
         // Restore vo_dwidth and vo_dheight, which were reset in vo_config()
         vo->dwidth = r.right;
@@ -1441,8 +1447,6 @@
     w32->snapped = false;
     w32->snap_dx = w32->snap_dy = 0;
 
-    update_screen_rect(w32);
-
     mp_dispatch_set_wakeup_fn(w32->dispatch, wakeup_gui_thread, w32);
 
     res = 1;
diff -ruN mpv-0.29.1/video/out/wayland/server-decoration.xml mpv-master/video/out/wayland/server-decoration.xml
--- mpv-0.29.1/video/out/wayland/server-decoration.xml	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/wayland/server-decoration.xml	1970-01-01 07:00:00.000000000 +0700
@@ -1,94 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<protocol name="server_decoration">
-  <copyright><![CDATA[
-    Copyright (C) 2015 Martin Gräßlin
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-  ]]></copyright>
-  <interface  name="org_kde_kwin_server_decoration_manager" version="1">
-      <description summary="Server side window decoration manager">
-        This interface allows to coordinate whether the server should create
-        a server-side window decoration around a wl_surface representing a
-        shell surface (wl_shell_surface or similar). By announcing support
-        for this interface the server indicates that it supports server
-        side decorations.
-      </description>
-      <request name="create">
-        <description summary="Create a server-side decoration object for a given surface">
-            When a client creates a server-side decoration object it indicates
-            that it supports the protocol. The client is supposed to tell the
-            server whether it wants server-side decorations or will provide
-            client-side decorations.
-
-            If the client does not create a server-side decoration object for
-            a surface the server interprets this as lack of support for this
-            protocol and considers it as client-side decorated. Nevertheless a
-            client-side decorated surface should use this protocol to indicate
-            to the server that it does not want a server-side deco.
-        </description>
-        <arg name="id" type="new_id" interface="org_kde_kwin_server_decoration"/>
-        <arg name="surface" type="object" interface="wl_surface"/>
-      </request>
-      <enum name="mode">
-            <description summary="Possible values to use in request_mode and the event mode."/>
-            <entry name="None" value="0" summary="Undecorated: The surface is not decorated at all, neither server nor client-side. An example is a popup surface which should not be decorated."/>
-            <entry name="Client" value="1" summary="Client-side decoration: The decoration is part of the surface and the client."/>
-            <entry name="Server" value="2" summary="Server-side decoration: The server embeds the surface into a decoration frame."/>
-      </enum>
-      <event name="default_mode">
-          <description summary="The default mode used on the server">
-              This event is emitted directly after binding the interface. It contains
-              the default mode for the decoration. When a new server decoration object
-              is created this new object will be in the default mode until the first
-              request_mode is requested.
-
-              The server may change the default mode at any time.
-          </description>
-          <arg name="mode" type="uint" summary="The default decoration mode applied to newly created server decorations."/>
-      </event>
-  </interface>
-  <interface name="org_kde_kwin_server_decoration" version="1">
-      <request name="release" type="destructor">
-        <description summary="release the server decoration object"/>
-      </request>
-      <enum name="mode">
-            <description summary="Possible values to use in request_mode and the event mode."/>
-            <entry name="None" value="0" summary="Undecorated: The surface is not decorated at all, neither server nor client-side. An example is a popup surface which should not be decorated."/>
-            <entry name="Client" value="1" summary="Client-side decoration: The decoration is part of the surface and the client."/>
-            <entry name="Server" value="2" summary="Server-side decoration: The server embeds the surface into a decoration frame."/>
-      </enum>
-      <request name="request_mode">
-          <description summary="The decoration mode the surface wants to use."/>
-          <arg name="mode" type="uint" summary="The mode this surface wants to use."/>
-      </request>
-      <event name="mode">
-          <description summary="The new decoration mode applied by the server">
-              This event is emitted directly after the decoration is created and
-              represents the base decoration policy by the server. E.g. a server
-              which wants all surfaces to be client-side decorated will send Client,
-              a server which wants server-side decoration will send Server.
-
-              The client can request a different mode through the decoration request.
-              The server will acknowledge this by another event with the same mode. So
-              even if a server prefers server-side decoration it's possible to force a
-              client-side decoration.
-
-              The server may emit this event at any time. In this case the client can
-              again request a different mode. It's the responsibility of the server to
-              prevent a feedback loop.
-          </description>
-          <arg name="mode" type="uint" summary="The decoration mode applied to the surface by the server."/>
-      </event>
-  </interface>
-</protocol>
diff -ruN mpv-0.29.1/video/out/wayland_common.c mpv-master/video/out/wayland_common.c
--- mpv-0.29.1/video/out/wayland_common.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/wayland_common.c	2019-09-19 04:02:03.000000000 +0700
@@ -32,16 +32,16 @@
 // Generated from idle-inhibit-unstable-v1.xml
 #include "video/out/wayland/idle-inhibit-v1.h"
 
-// Generated from server-decoration.xml
-#include "video/out/wayland/srv-decor.h"
+// Generated from xdg-decoration-unstable-v1.xml
+#include "video/out/wayland/xdg-decoration-v1.h"
 
-static void xdg_shell_ping(void *data, struct xdg_wm_base *shell, uint32_t serial)
+static void xdg_wm_base_ping(void *data, struct xdg_wm_base *wm_base, uint32_t serial)
 {
-    xdg_wm_base_pong(shell, serial);
+    xdg_wm_base_pong(wm_base, serial);
 }
 
-static const struct xdg_wm_base_listener xdg_shell_listener = {
-    xdg_shell_ping,
+static const struct xdg_wm_base_listener xdg_wm_base_listener = {
+    xdg_wm_base_ping,
 };
 
 static int spawn_cursor(struct vo_wayland_state *wl)
@@ -806,8 +806,8 @@
 
     if (!strcmp(interface, xdg_wm_base_interface.name) && found++) {
         ver = MPMIN(ver, 2); /* We can use either 1 or 2 */
-        wl->shell = wl_registry_bind(reg, id, &xdg_wm_base_interface, ver);
-        xdg_wm_base_add_listener(wl->shell, &xdg_shell_listener, wl);
+        wl->wm_base = wl_registry_bind(reg, id, &xdg_wm_base_interface, ver);
+        xdg_wm_base_add_listener(wl->wm_base, &xdg_wm_base_listener, wl);
     }
 
     if (!strcmp(interface, wl_seat_interface.name) && found++) {
@@ -823,8 +823,8 @@
         wl->dnd_devman = wl_registry_bind(reg, id, &wl_data_device_manager_interface, 3);
     }
 
-    if (!strcmp(interface, org_kde_kwin_server_decoration_manager_interface.name) && found++) {
-        wl->server_decoration_manager = wl_registry_bind(reg, id, &org_kde_kwin_server_decoration_manager_interface, 1);
+    if (!strcmp(interface, zxdg_decoration_manager_v1_interface.name) && found++) {
+        wl->xdg_decoration_manager = wl_registry_bind(reg, id, &zxdg_decoration_manager_v1_interface, 1);
     }
 
     if (!strcmp(interface, zwp_idle_inhibit_manager_v1_interface.name) && found++) {
@@ -956,7 +956,7 @@
 
 static int create_xdg_surface(struct vo_wayland_state *wl)
 {
-    wl->xdg_surface = xdg_wm_base_get_xdg_surface(wl->shell, wl->surface);
+    wl->xdg_surface = xdg_wm_base_get_xdg_surface(wl->wm_base, wl->surface);
     xdg_surface_add_listener(wl->xdg_surface, &xdg_surface_listener, wl);
 
     wl->xdg_toplevel = xdg_surface_get_toplevel(wl->xdg_surface);
@@ -970,17 +970,18 @@
 
 static int set_border_decorations(struct vo_wayland_state *wl, int state)
 {
-    if (!wl->server_decoration)
+    if (!wl->xdg_toplevel_decoration)
         return VO_NOTIMPL;
-    enum org_kde_kwin_server_decoration_mode mode;
+
+    enum zxdg_toplevel_decoration_v1_mode mode;
     if (state) {
         MP_VERBOSE(wl, "Enabling server decorations\n");
-        mode = ORG_KDE_KWIN_SERVER_DECORATION_MODE_SERVER;
+        mode = ZXDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE;
     } else {
         MP_VERBOSE(wl, "Disabling server decorations\n");
-        mode = ORG_KDE_KWIN_SERVER_DECORATION_MODE_NONE;
+        mode = ZXDG_TOPLEVEL_DECORATION_V1_MODE_CLIENT_SIDE;
     }
-    org_kde_kwin_server_decoration_request_mode(wl->server_decoration, mode);
+    zxdg_toplevel_decoration_v1_set_mode(wl->xdg_toplevel_decoration, mode);
     return VO_TRUE;
 }
 
@@ -1012,7 +1013,7 @@
     /* Do a roundtrip to run the registry */
     wl_display_roundtrip(wl->display);
 
-    if (!wl->shell) {
+    if (!wl->wm_base) {
         MP_FATAL(wl, "Compositor doesn't support the required %s protocol!\n",
                  xdg_wm_base_interface.name);
         return false;
@@ -1036,12 +1037,12 @@
                    wl_data_device_manager_interface.name);
     }
 
-    if (wl->server_decoration_manager) {
-        wl->server_decoration = org_kde_kwin_server_decoration_manager_create(wl->server_decoration_manager, wl->surface);
+    if (wl->xdg_decoration_manager) {
+        wl->xdg_toplevel_decoration = zxdg_decoration_manager_v1_get_toplevel_decoration(wl->xdg_decoration_manager, wl->xdg_toplevel);
         set_border_decorations(wl, vo->opts->border);
     } else {
         MP_VERBOSE(wl, "Compositor doesn't support the %s protocol!\n",
-                   org_kde_kwin_server_decoration_manager_interface.name);
+                   zxdg_decoration_manager_v1_interface.name);
     }
 
     if (!wl->idle_inhibit_manager)
@@ -1062,6 +1063,9 @@
 
     mp_input_put_key(wl->vo->input_ctx, MP_INPUT_RELEASE_ALL);
 
+    if (wl->current_output && wl->current_output->output)
+        wl_output_destroy(wl->current_output->output);
+
     if (wl->cursor_theme)
         wl_cursor_theme_destroy(wl->cursor_theme);
 
@@ -1071,26 +1075,47 @@
     if (wl->xkb_context)
         xkb_context_unref(wl->xkb_context);
 
+    if (wl->xkb_state)
+        xkb_state_unref(wl->xkb_state);
+
+    if (wl->xkb_keymap)
+        xkb_keymap_unref(wl->xkb_keymap);
+
     if (wl->idle_inhibitor)
         zwp_idle_inhibitor_v1_destroy(wl->idle_inhibitor);
 
     if (wl->idle_inhibit_manager)
         zwp_idle_inhibit_manager_v1_destroy(wl->idle_inhibit_manager);
 
-    if (wl->shell)
-        xdg_wm_base_destroy(wl->shell);
+    if (wl->wm_base)
+        xdg_wm_base_destroy(wl->wm_base);
 
     if (wl->shm)
         wl_shm_destroy(wl->shm);
 
+    if (wl->dnd_ddev)
+        wl_data_device_destroy(wl->dnd_ddev);
+
     if (wl->dnd_devman)
         wl_data_device_manager_destroy(wl->dnd_devman);
 
-    if (wl->server_decoration)
-        org_kde_kwin_server_decoration_destroy(wl->server_decoration);
+    if (wl->dnd_offer)
+        wl_data_offer_destroy(wl->dnd_offer);
 
-    if (wl->server_decoration_manager)
-        org_kde_kwin_server_decoration_manager_destroy(wl->server_decoration_manager);
+    if (wl->xdg_toplevel_decoration)
+        zxdg_toplevel_decoration_v1_destroy(wl->xdg_toplevel_decoration);
+
+    if (wl->xdg_decoration_manager)
+        zxdg_decoration_manager_v1_destroy(wl->xdg_decoration_manager);
+
+    if (wl->xdg_toplevel)
+        xdg_toplevel_destroy(wl->xdg_toplevel);
+
+    if (wl->xdg_surface)
+        xdg_surface_destroy(wl->xdg_surface);
+
+    if (wl->compositor)
+        wl_compositor_destroy(wl->compositor);
 
     if (wl->surface)
         wl_surface_destroy(wl->surface);
@@ -1098,6 +1123,18 @@
     if (wl->frame_callback)
         wl_callback_destroy(wl->frame_callback);
 
+    if (wl->pointer)
+        wl_pointer_destroy(wl->pointer);
+
+    if (wl->keyboard)
+        wl_keyboard_destroy(wl->keyboard);
+
+    if (wl->seat)
+        wl_seat_destroy(wl->seat);
+
+    if (wl->registry)
+        wl_registry_destroy(wl->registry);
+
     if (wl->display) {
         close(wl_display_get_fd(wl->display));
         wl_display_disconnect(wl->display);
diff -ruN mpv-0.29.1/video/out/wayland_common.h mpv-master/video/out/wayland_common.h
--- mpv-0.29.1/video/out/wayland_common.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/wayland_common.h	2019-09-19 04:02:03.000000000 +0700
@@ -70,11 +70,11 @@
 
     /* Shell */
     struct wl_surface       *surface;
-    struct xdg_wm_base      *shell;
+    struct xdg_wm_base      *wm_base;
     struct xdg_toplevel     *xdg_toplevel;
     struct xdg_surface      *xdg_surface;
-    struct org_kde_kwin_server_decoration_manager *server_decoration_manager;
-    struct org_kde_kwin_server_decoration *server_decoration;
+    struct zxdg_decoration_manager_v1 *xdg_decoration_manager;
+    struct zxdg_toplevel_decoration_v1 *xdg_toplevel_decoration;
     struct zwp_idle_inhibit_manager_v1 *idle_inhibit_manager;
     struct zwp_idle_inhibitor_v1 *idle_inhibitor;
 
diff -ruN mpv-0.29.1/video/out/x11_common.c mpv-master/video/out/x11_common.c
--- mpv-0.29.1/video/out/x11_common.c	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/x11_common.c	2019-09-19 04:02:03.000000000 +0700
@@ -248,7 +248,7 @@
     x11_send_ewmh_msg(x11, "_NET_WM_STATE", params);
 }
 
-static void vo_set_cursor_hidden(struct vo *vo, bool cursor_hidden)
+static void vo_update_cursor(struct vo *vo)
 {
     Cursor no_ptr;
     Pixmap bm_no;
@@ -258,16 +258,17 @@
     struct vo_x11_state *x11 = vo->x11;
     Display *disp = x11->display;
     Window win = x11->window;
+    bool should_hide = x11->has_focus && !x11->mouse_cursor_visible;
 
-    if (cursor_hidden == x11->mouse_cursor_hidden)
+    if (should_hide == x11->mouse_cursor_set)
         return;
 
-    x11->mouse_cursor_hidden = cursor_hidden;
+    x11->mouse_cursor_set = should_hide;
 
     if (x11->parent == x11->rootwin || !win)
         return;                 // do not hide if playing on the root window
 
-    if (x11->mouse_cursor_hidden) {
+    if (x11->mouse_cursor_set) {
         colormap = DefaultColormap(disp, DefaultScreen(disp));
         if (!XAllocNamedColor(disp, colormap, "black", &black, &dummy))
             return; // color alloc failed, give up
@@ -588,7 +589,8 @@
         dispName += 4;
     else if (strncmp(dispName, "localhost:", 10) == 0)
         dispName += 9;
-    x11->display_is_local = dispName[0] == ':' && atoi(dispName + 1) < 10;
+    x11->display_is_local = dispName[0] == ':' &&
+                            strtoul(dispName + 1, NULL, 10) < 10;
     MP_VERBOSE(x11, "X11 running at %dx%d (\"%s\" => %s display)\n",
                x11->ws_width, x11->ws_height, dispName,
                x11->display_is_local ? "local" : "remote");
@@ -752,9 +754,6 @@
 
     set_screensaver(x11, true);
 
-    if (x11->window != None)
-        vo_set_cursor_hidden(vo, false);
-
     if (x11->window != None && x11->window != x11->rootwin) {
         XUnmapWindow(x11->display, x11->window);
         XDestroyWindow(x11->display, x11->window);
@@ -1039,6 +1038,17 @@
     }
 }
 
+// Releasing all keys on key-up or defocus is simpler and ensures no keys can
+// get "stuck".
+static void release_all_keys(struct vo *vo)
+{
+    struct vo_x11_state *x11 = vo->x11;
+
+    if (x11->no_autorepeat)
+        mp_input_put_key(x11->input_ctx, MP_INPUT_RELEASE_ALL);
+    x11->win_drag_button1_down = false;
+}
+
 void vo_x11_check_events(struct vo *vo)
 {
     struct vo_x11_state *x11 = vo->x11;
@@ -1090,16 +1100,18 @@
             }
             break;
         }
-        // Releasing all keys in these situations is simpler and ensures no
-        // keys can be get "stuck".
+        case FocusIn:
+            x11->has_focus = true;
+            vo_update_cursor(vo);
+            break;
         case FocusOut:
+            release_all_keys(vo);
+            x11->has_focus = false;
+            vo_update_cursor(vo);
+            break;
         case KeyRelease:
-        {
-            if (x11->no_autorepeat)
-                mp_input_put_key(x11->input_ctx, MP_INPUT_RELEASE_ALL);
-            x11->win_drag_button1_down = false;
+            release_all_keys(vo);
             break;
-        }
         case MotionNotify:
             if (x11->win_drag_button1_down && !x11->fs &&
                 !mp_input_test_dragging(x11->input_ctx, Event.xmotion.x,
@@ -1412,10 +1424,10 @@
     Atom protos[1] = {XA(x11, WM_DELETE_WINDOW)};
     XSetWMProtocols(x11->display, x11->window, protos, 1);
 
-    if (x11->mouse_cursor_hidden) {
-        x11->mouse_cursor_hidden = false;
-        vo_set_cursor_hidden(vo, true);
-    }
+    x11->mouse_cursor_set = false;
+    x11->mouse_cursor_visible = true;
+    vo_update_cursor(vo);
+
     if (x11->xim) {
         x11->xic = XCreateIC(x11->xim,
                              XNInputStyle, XIMPreeditNone | XIMStatusNone,
@@ -1641,7 +1653,7 @@
     struct vo_x11_state *x11 = vo->x11;
     int cx = x11->winrc.x0 + (x11->winrc.x1 - x11->winrc.x0)/2,
     cy = x11->winrc.y0 + (x11->winrc.y1 - x11->winrc.y0)/2;
-    int screen = 0; // xinerama screen number
+    int screen = x11->current_icc_screen; // xinerama screen number
     for (int n = 0; n < x11->num_displays; n++) {
         struct xrandr_display *disp = &x11->displays[n];
         if (mp_rect_contains(&disp->rc, cx, cy)) {
@@ -1857,7 +1869,8 @@
         return VO_TRUE;
     }
     case VOCTRL_SET_CURSOR_VISIBILITY:
-        vo_set_cursor_hidden(vo, !(*(bool *)arg));
+        x11->mouse_cursor_visible = *(bool *)arg;
+        vo_update_cursor(vo);
         return VO_TRUE;
     case VOCTRL_KILL_SCREENSAVER:
         set_screensaver(x11, false);
diff -ruN mpv-0.29.1/video/out/x11_common.h mpv-master/video/out/x11_common.h
--- mpv-0.29.1/video/out/x11_common.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/out/x11_common.h	2019-09-19 04:02:03.000000000 +0700
@@ -88,7 +88,10 @@
     bool pseudo_mapped; // not necessarily mapped, but known window size
     int fs;     // whether we assume the window is in fullscreen mode
 
-    bool mouse_cursor_hidden;
+    bool mouse_cursor_visible; // whether we want the cursor to be visible (only
+                               // takes effect when the window is focused)
+    bool mouse_cursor_set; // whether the cursor is *currently* *hidden*
+    bool has_focus;
     long orig_layer;
 
     // Current actual window position (updated on window move/resize events).
diff -ruN mpv-0.29.1/video/vaapi.h mpv-master/video/vaapi.h
--- mpv-0.29.1/video/vaapi.h	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/video/vaapi.h	2019-09-19 04:02:03.000000000 +0700
@@ -36,9 +36,12 @@
     void (*destroy_native_ctx)(void *native_ctx);
 };
 
-#define CHECK_VA_STATUS(ctx, msg) \
+#define CHECK_VA_STATUS_LEVEL(ctx, msg, level) \
     (status == VA_STATUS_SUCCESS ? true \
-        : (MP_ERR(ctx, "%s failed (%s)\n", msg, vaErrorStr(status)), false))
+        : (MP_MSG(ctx, level, "%s failed (%s)\n", msg, vaErrorStr(status)), false))
+
+#define CHECK_VA_STATUS(ctx, msg) \
+    CHECK_VA_STATUS_LEVEL(ctx, msg, MSGL_ERR)
 
 int                      va_get_colorspace_flag(enum mp_csp csp);
 
diff -ruN mpv-0.29.1/waftools/checks/custom.py mpv-master/waftools/checks/custom.py
--- mpv-0.29.1/waftools/checks/custom.py	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/waftools/checks/custom.py	2019-09-19 04:02:03.000000000 +0700
@@ -1,6 +1,7 @@
 from waftools import inflector
 from waftools.checks.generic import *
 from waflib import Utils
+from distutils.version import StrictVersion
 import os
 
 __all__ = ["check_pthreads", "check_iconv", "check_lua",
@@ -85,7 +86,7 @@
 
 def check_wl_protocols(ctx, dependency_identifier):
     def fn(ctx, dependency_identifier):
-        ret = check_pkg_config_datadir("wayland-protocols", ">= 1.14")
+        ret = check_pkg_config_datadir("wayland-protocols", ">= 1.15")
         ret = ret(ctx, dependency_identifier)
         if ret != None:
             ctx.env.WL_PROTO_DIR = ret.split()[0]
@@ -97,7 +98,7 @@
         fragment         = load_fragment('cocoa.m'),
         compile_filename = 'test.m',
         framework_name   = ['Cocoa', 'IOKit', 'OpenGL', 'QuartzCore'],
-        includes         = ctx.srcnode.abspath(),
+        includes         = [ctx.srcnode.abspath()],
         linkflags        = '-fobjc-arc')
 
     res = fn(ctx, dependency_identifier)
@@ -113,10 +114,13 @@
     return res
 
 def check_swift(ctx, dependency_identifier):
+    minVer = StrictVersion("3.0.2")
     if ctx.env.SWIFT_VERSION:
-        major = int(ctx.env.SWIFT_VERSION.split('.')[0])
-        ctx.add_optional_message(dependency_identifier,
-                                 'version found: ' + ctx.env.SWIFT_VERSION)
-        if major >= 3:
+        if StrictVersion(ctx.env.SWIFT_VERSION) >= minVer:
+            ctx.add_optional_message(dependency_identifier,
+                                     'version found: ' + str(ctx.env.SWIFT_VERSION))
             return True
+    ctx.add_optional_message(dependency_identifier,
+                             "'swift >= " + str(minVer) + "' not found, found " +
+                             str(ctx.env.SWIFT_VERSION or None))
     return False
diff -ruN mpv-0.29.1/waftools/checks/generic.py mpv-master/waftools/checks/generic.py
--- mpv-0.29.1/waftools/checks/generic.py	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/waftools/checks/generic.py	2019-09-19 04:02:03.000000000 +0700
@@ -1,5 +1,6 @@
 import os
 import inflector
+from distutils.version import StrictVersion
 from waflib.ConfigSet import ConfigSet
 from waflib import Utils
 
@@ -8,7 +9,7 @@
     "check_pkg_config_cflags", "check_cc", "check_statement", "check_libs",
     "check_headers", "compose_checks", "check_true", "any_version",
     "load_fragment", "check_stub", "check_ctx_vars", "check_program",
-    "check_pkg_config_datadir"]
+    "check_pkg_config_datadir", "check_macos_sdk"]
 
 any_version = None
 
@@ -186,3 +187,13 @@
     fragment_code = fp.read()
     fp.close()
     return fragment_code
+
+def check_macos_sdk(version):
+    def fn(ctx, dependency_identifier):
+        if ctx.env.MACOS_SDK_VERSION:
+            if StrictVersion(ctx.env.MACOS_SDK_VERSION) >= StrictVersion(version):
+                ctx.define(inflector.define_key(dependency_identifier), 1)
+                return True
+        return False
+
+    return fn
diff -ruN mpv-0.29.1/waftools/detections/compiler.py mpv-master/waftools/detections/compiler.py
--- mpv-0.29.1/waftools/detections/compiler.py	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/waftools/detections/compiler.py	2019-09-19 04:02:03.000000000 +0700
@@ -20,7 +20,12 @@
     ctx.env.CFLAGS += ["-D_ISOC99_SOURCE", "-D_GNU_SOURCE",
                        "-D_LARGEFILE_SOURCE", "-D_FILE_OFFSET_BITS=64",
                        "-D_LARGEFILE64_SOURCE",
-                       "-std=c99", "-Wall"]
+                       "-Wall"]
+
+    if ctx.check_cc(cflags="-std=c11", mandatory=False):
+        ctx.env.CFLAGS += ["-std=c11"]
+    else:
+        ctx.env.CFLAGS += ["-std=c99"]
 
     if ctx.is_optimization():
         ctx.env.CFLAGS += ['-O2']
diff -ruN mpv-0.29.1/waftools/detections/compiler_swift.py mpv-master/waftools/detections/compiler_swift.py
--- mpv-0.29.1/waftools/detections/compiler_swift.py	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/waftools/detections/compiler_swift.py	2019-09-19 04:02:03.000000000 +0700
@@ -1,60 +1,182 @@
+import re
+import string
+import os.path
 from waflib import Utils
+from distutils.version import StrictVersion
 
 def __run(cmd):
     try:
-        output = Utils.subprocess.check_output(cmd, universal_newlines=True)
+        output = Utils.subprocess.check_output(cmd, stderr=Utils.subprocess.STDOUT, universal_newlines=True)
         return output.strip()
     except Exception:
         return ""
 
 def __add_swift_flags(ctx):
-    ctx.env.SWIFT_FLAGS = ('-frontend -c -sdk %s -enable-objc-interop'
-                           ' -emit-objc-header -parse-as-library'
-                           ' -target x86_64-apple-macosx10.10') % (ctx.env.MACOS_SDK)
-    ctx.env.SWIFT_VERSION = __run([ctx.env.SWIFT, '-version']).split(' ')[3]
-    major, minor = [int(n) for n in ctx.env.SWIFT_VERSION.split('.')[:2]]
-
-    # the -swift-version parameter is only supported on swift 3.1 and newer
-    if major >= 3 and minor >= 1 or major >= 4:
-        ctx.env.SWIFT_FLAGS += ' -swift-version 3'
+    ctx.env.SWIFT_FLAGS = [
+        "-frontend", "-c", "-sdk", ctx.env.MACOS_SDK,
+        "-enable-objc-interop", "-emit-objc-header", "-parse-as-library",
+        "-target", "x86_64-apple-macosx10.10"
+    ]
+
+    verRe = re.compile("(?i)version\s?([\d.]+)")
+    ctx.env.SWIFT_VERSION = verRe.search(__run([ctx.env.SWIFT, '-version'])).group(1)
+
+    # prevent possible breakages with future swift versions
+    if StrictVersion(ctx.env.SWIFT_VERSION) >= StrictVersion("6.0"):
+        ctx.env.SWIFT_FLAGS.extend([ "-swift-version", "5" ])
+
+    if ctx.is_debug_build():
+        ctx.env.SWIFT_FLAGS.append("-g")
 
     if ctx.is_optimization():
-        ctx.env.SWIFT_FLAGS += ' -O'
+        ctx.env.SWIFT_FLAGS.append("-O")
 
-def __add_swift_library_linking_flags(ctx, swift_library):
+def __add_static_swift_library_linking_flags(ctx, swift_library):
     ctx.env.append_value('LINKFLAGS', [
         '-L%s' % swift_library,
         '-Xlinker', '-force_load_swift_libs', '-lc++',
     ])
 
+def __add_dynamic_swift_library_linking_flags(ctx, swift_library):
+    ctx.env.append_value('LINKFLAGS', [ '-L%s' % swift_library ])
+
+    #ABI compatibility
+    if StrictVersion(ctx.env.SWIFT_VERSION) >= StrictVersion("5.0"):
+        ctx.env.append_value('LINKFLAGS', [
+            '-Xlinker', '-rpath', '-Xlinker', '/usr/lib/swift',
+        ])
+
+    ctx.env.append_value('LINKFLAGS', [
+        '-Xlinker', '-rpath', '-Xlinker', swift_library,
+    ])
+
 def __find_swift_library(ctx):
-    swift_library_paths = [
-        'Toolchains/XcodeDefault.xctoolchain/usr/lib/swift_static/macosx',
-        'usr/lib/swift_static/macosx'
-    ]
+    swift_libraries = {}
+    #look for set lib paths in passed environment variables
+    if 'SWIFT_LIB_DYNAMIC' in ctx.environ:
+        swift_libraries['SWIFT_LIB_DYNAMIC'] = ctx.environ['SWIFT_LIB_DYNAMIC']
+    if 'SWIFT_LIB_STATIC' in ctx.environ:
+        swift_libraries['SWIFT_LIB_STATIC'] = ctx.environ['SWIFT_LIB_STATIC']
+
+    #search for swift libs relative to the swift compiler executable
+    swift_library_relative_paths = {
+        'SWIFT_LIB_DYNAMIC': '../../lib/swift/macosx',
+        'SWIFT_LIB_STATIC': '../../lib/swift_static/macosx'
+    }
+
+    for lib_type, path in swift_library_relative_paths.items():
+        if lib_type not in swift_libraries:
+            lib_path = os.path.join(ctx.env.SWIFT, path)
+            swift_library = ctx.root.find_dir(lib_path)
+            if swift_library is not None:
+                swift_libraries[lib_type] = swift_library.abspath()
+
+    #fall back to xcode-select path
+    swift_library_paths = {
+        'SWIFT_LIB_DYNAMIC': [
+            'Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/macosx',
+            'usr/lib/swift/macosx'
+        ],
+        'SWIFT_LIB_STATIC': [
+            'Toolchains/XcodeDefault.xctoolchain/usr/lib/swift_static/macosx',
+            'usr/lib/swift_static/macosx'
+        ]
+    }
     dev_path = __run(['xcode-select', '-p'])[1:]
 
-    ctx.start_msg('Checking for Swift Library')
-    for path in swift_library_paths:
-        swift_library = ctx.root.find_dir([dev_path, path])
-        if swift_library is not None:
-            ctx.end_msg(swift_library.abspath())
-            __add_swift_library_linking_flags(ctx, swift_library.abspath())
-            return
-    ctx.end_msg(False)
+    for lib_type, paths in swift_library_paths.items():
+        for path in paths:
+            if lib_type not in swift_libraries:
+                swift_library = ctx.root.find_dir([dev_path, path])
+                if swift_library is not None:
+                    swift_libraries[lib_type] = swift_library.abspath()
+                    break
+            else:
+                break
+
+    #check if library paths were found
+    ctx.start_msg('Checking for dynamic Swift Library')
+    if 'SWIFT_LIB_DYNAMIC' in swift_libraries:
+        ctx.end_msg(swift_libraries['SWIFT_LIB_DYNAMIC'])
+    else:
+        ctx.end_msg(False)
+
+    ctx.start_msg('Checking for static Swift Library')
+    if 'SWIFT_LIB_STATIC' in swift_libraries:
+        ctx.end_msg(swift_libraries['SWIFT_LIB_STATIC'])
+        ctx.env['SWIFT_LIB_STATIC'] = swift_libraries['SWIFT_LIB_STATIC']
+    else:
+        ctx.end_msg(False)
+
+    enableStatic = getattr(ctx.options, 'enable_swift-static')
+    if (enableStatic) and 'SWIFT_LIB_STATIC' in swift_libraries:
+        __add_static_swift_library_linking_flags(ctx, swift_libraries['SWIFT_LIB_STATIC'])
+    else:
+        __add_dynamic_swift_library_linking_flags(ctx, swift_libraries['SWIFT_LIB_DYNAMIC'])
 
 def __find_macos_sdk(ctx):
     ctx.start_msg('Checking for macOS SDK')
-    sdk = __run(['xcrun', '--sdk', 'macosx', '--show-sdk-path'])
+    sdk = None
+    sdk_build_version = None
+    sdk_version = None
+
+    #look for set macOS SDK paths and version in passed environment variables
+    if 'MACOS_SDK' in ctx.environ:
+        sdk = ctx.environ['MACOS_SDK']
+    if 'MACOS_SDK_VERSION' in ctx.environ:
+        ctx.env.MACOS_SDK_VERSION = ctx.environ['MACOS_SDK_VERSION']
+
+    #find macOS SDK paths and version
+    if not sdk:
+        sdk = __run(['xcrun', '--sdk', 'macosx', '--show-sdk-path'])
+    if not ctx.env.MACOS_SDK_VERSION:
+        #show-sdk-build-version: is not available on older command line tools, but return a build version (eg 17A360)
+        #show-sdk-version: is always available, but on older dev tools it's only the major version
+        sdk_build_version = __run(['xcrun', '--sdk', 'macosx', '--show-sdk-build-version' ])
+        sdk_version = __run(['xcrun', '--sdk', 'macosx', '--show-sdk-version' ])
+
     if sdk:
-        ctx.end_msg(sdk)
         ctx.env.MACOS_SDK = sdk
+        build_version = '10.10.0'
+
+        if not ctx.env.MACOS_SDK_VERSION:
+            #convert build version to a version string
+            #first 2 two digits are the major version, starting with 15 which is 10.11 (offset of 4)
+            #1 char is the minor version, A => 0, B => 1 and ongoing
+            #las digits are bugfix version, which are nor relevant for us
+            #eg 16E185 => 10.12.4, 17A360 => 10.13, 18B71 => 10.14.1
+            if sdk_build_version and isinstance(sdk_build_version, str):
+                verRe = re.compile("(\d+)(\D+)(\d+)")
+                version_parts = verRe.search(sdk_build_version)
+                major = int(version_parts.group(1))-4
+                minor = string.ascii_lowercase.index(version_parts.group(2).lower())
+                build_version = '10.' + str(major) + '.' + str(minor)
+
+            if not isinstance(sdk_version, str):
+                sdk_version = '10.10.0'
+
+            #pick the higher version, always pick sdk over build if newer
+            if StrictVersion(build_version) > StrictVersion(sdk_version):
+                ctx.env.MACOS_SDK_VERSION = build_version
+            else:
+                ctx.env.MACOS_SDK_VERSION = sdk_version
+
+        ctx.end_msg(sdk + ' (version found: ' + ctx.env.MACOS_SDK_VERSION + ')')
     else:
         ctx.end_msg(False)
 
 def __find_swift_compiler(ctx):
     ctx.start_msg('Checking for swift (Swift compiler)')
-    swift = __run(['xcrun', '-find', 'swift'])
+    swift = ''
+
+    #look for set swift paths in passed environment variables
+    if 'SWIFT' in ctx.environ:
+        swift = ctx.environ['SWIFT']
+
+    #find swift executable
+    if not swift:
+        swift = __run(['xcrun', '-find', 'swift'])
+
     if swift:
         ctx.end_msg(swift)
         ctx.env.SWIFT = swift
@@ -66,4 +188,5 @@
 def configure(ctx):
     if ctx.env.DEST_OS == "darwin":
         __find_macos_sdk(ctx)
-        __find_swift_compiler(ctx)
+        if ctx.options.enable_swift is not False:
+            __find_swift_compiler(ctx)
diff -ruN mpv-0.29.1/waftools/generators/headers.py mpv-master/waftools/generators/headers.py
--- mpv-0.29.1/waftools/generators/headers.py	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/waftools/generators/headers.py	2019-09-19 04:02:03.000000000 +0700
@@ -10,6 +10,15 @@
     __cp_to_variant__(ctx, ctx.options.variant, 'config.h')
     ctx.end_msg("config.h", "PINK")
 
+def __add_swift_defines__(ctx):
+    if ctx.dependency_satisfied("swift"):
+        ctx.start_msg("Adding conditional Swift flags:")
+        from waflib.Tools.c_config import DEFKEYS, INCKEYS
+        for define in ctx.env[DEFKEYS]:
+            if ctx.is_defined(define) and ctx.get_define(define) == "1":
+                ctx.env.SWIFT_FLAGS.extend(["-D", define])
+        ctx.end_msg("yes")
+
 # Approximately escape the string as C string literal
 def __escape_c_string(s):
     return s.replace("\"", "\\\"").replace("\n", "\\n")
@@ -32,4 +41,5 @@
 
 def configure(ctx):
     __add_mpv_defines__(ctx)
+    __add_swift_defines__(ctx)
     __write_config_h__(ctx)
diff -ruN mpv-0.29.1/waftools/generators/sources.py mpv-master/waftools/generators/sources.py
--- mpv-0.29.1/waftools/generators/sources.py	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/waftools/generators/sources.py	2019-09-19 04:02:03.000000000 +0700
@@ -94,7 +94,7 @@
 @TaskGen.feature('cshlib')
 @TaskGen.feature('cstlib')
 @TaskGen.feature('apply_link')
-@TaskGen.after_method('do_the_symbol_stuff')
+@TaskGen.after_method('process_source', 'process_use', 'apply_link', 'process_uselib_local', 'propagate_uselib_vars', 'do_the_symbol_stuff')
 def handle_add_object(tgen):
     if getattr(tgen, 'add_object', None):
         for input in Utils.to_list(tgen.add_object):
diff -ruN mpv-0.29.1/wscript mpv-master/wscript
--- mpv-0.29.1/wscript	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/wscript	2019-09-19 04:02:03.000000000 +0700
@@ -3,6 +3,7 @@
 import sys, os, re
 sys.path.insert(0, os.path.join(os.getcwd(), 'waftools'))
 sys.path.insert(0, os.getcwd())
+from shlex import split
 from waflib.Configure import conf
 from waflib.Tools import c_preproc
 from waflib import Utils
@@ -124,6 +125,12 @@
         'desc': 'generate a clang compilation database',
         'func': check_true,
         'default': 'disable',
+    } , {
+        'name': '--swift-static',
+        'desc': 'static Swift linking',
+        'deps': 'os-darwin',
+        'func': check_ctx_vars('SWIFT_LIB_STATIC'),
+        'default': 'disable'
     }
 ]
 
@@ -155,11 +162,13 @@
     }, {
         'name': '--android',
         'desc': 'Android environment',
-        'func': compose_checks(
-            check_statement('android/api-level.h', '(void)__ANDROID__'),  # arbitrary android-specific header
-            check_cc(lib="android"),
-            check_cc(lib="EGL"),
-        )
+        'func': check_statement('android/api-level.h', '(void)__ANDROID__'),  # arbitrary android-specific header
+    }, {
+        'name': '--egl-android',
+        'desc': 'Android EGL support',
+        'deps': 'android',
+        'groups': [ 'gl' ],
+        'func': check_cc(lib=['android', 'EGL']),
     }, {
         'name': 'posix-or-mingw',
         'desc': 'development environment',
@@ -355,12 +364,6 @@
         'func': check_pkg_config('libbluray', '>= 0.3.0'),
         #'default': 'disable',
     }, {
-        'name': '--dvdread',
-        'desc': 'dvdread support',
-        'deps': 'gpl',
-        'func': check_pkg_config('dvdread', '>= 4.1.0'),
-        'default': 'disable',
-    }, {
         'name': '--dvdnav',
         'desc': 'dvdnav support',
         'deps': 'gpl',
@@ -368,11 +371,6 @@
                                  'dvdread', '>= 4.1.0'),
         'default': 'disable',
     }, {
-        'name': 'dvdread-common',
-        'desc': 'DVD/IFO support',
-        'deps': 'gpl && (dvdread || dvdnav)',
-        'func': check_true,
-    }, {
         'name': '--cdda',
         'desc': 'cdda support (libcdio)',
         'deps': 'gpl',
@@ -411,11 +409,17 @@
         'name': '--libarchive',
         'desc': 'libarchive wrapper for reading zip files and more',
         'func': check_pkg_config('libarchive >= 3.0.0'),
+    }, {
+        'name': '--dvbin',
+        'desc': 'DVB input module',
+        'deps': 'gpl',
+        'func': check_true,
+        'default': 'disable',
     }
 ]
 
 ffmpeg_pkg_config_checks = [
-    'libavutil',     '>= 56.12.100',
+    'libavutil',     '>= 56.27.100',
     'libavcodec',    '>= 58.16.100',
     'libavformat',   '>= 58.9.100',
     'libswscale',    '>= 5.0.101',
@@ -696,11 +700,6 @@
         'deps': 'vaapi && egl-drm',
         'func': check_pkg_config('libva-drm', '>= 0.36.0'),
     }, {
-        'name': '--vaapi-glx',
-        'desc': 'VAAPI GLX',
-        'deps': 'gpl && vaapi-x11 && gl-x11',
-        'func': check_true,
-    }, {
         'name': '--vaapi-x-egl',
         'desc': 'VAAPI EGL on X11',
         'deps': 'vaapi-x11 && egl-x11',
@@ -708,7 +707,7 @@
     }, {
         'name': 'vaapi-egl',
         'desc': 'VAAPI EGL',
-        'deps': 'vaapi-x-egl || vaapi-wayland',
+        'deps': 'vaapi-x-egl || vaapi-wayland || vaapi-drm',
         'func': check_true,
     }, {
         'name': '--caca',
@@ -744,13 +743,26 @@
         'deps': 'shaderc-shared || shaderc-static',
         'func': check_true,
     }, {
-        'name': '--crossc',
-        'desc': 'libcrossc SPIR-V translator',
-        'func': check_pkg_config('crossc'),
+        'name': 'spirv-cross-shared',
+        'desc': 'SPIRV-Cross SPIR-V shader converter (shared library)',
+        'deps': '!static-build',
+        'groups': ['spirv-cross'],
+        'func': check_pkg_config('spirv-cross-c-shared'),
+    }, {
+        'name': 'spirv-cross-static',
+        'desc': 'SPIRV-Cross SPIR-V shader converter (static library)',
+        'deps': '!spirv-cross-shared',
+        'groups': ['spirv-cross'],
+        'func': check_pkg_config('spirv-cross'),
+    }, {
+        'name': '--spirv-cross',
+        'desc': 'SPIRV-Cross SPIR-V shader converter',
+        'deps': 'spirv-cross-shared || spirv-cross-static',
+        'func': check_true,
     }, {
         'name': '--d3d11',
         'desc': 'Direct3D 11 video output',
-        'deps': 'win32-desktop && shaderc && crossc',
+        'deps': 'win32-desktop && shaderc && spirv-cross',
         'func': check_cc(header_name=['d3d11_1.h', 'dxgi1_2.h']),
     }, {
         # We need MMAL/bcm_host/dispmanx APIs. Also, most RPI distros require
@@ -802,14 +814,24 @@
                 "Aborting. If you really mean to compile without OpenGL " +
                 "video outputs use --disable-gl.",
     }, {
+        'name': '--libplacebo',
+        'desc': 'libplacebo support',
+        'func': check_pkg_config('libplacebo >= 1.18.0'),
+    }, {
         'name': '--vulkan',
         'desc':  'Vulkan context support',
+        'deps': 'libplacebo',
         'func': check_pkg_config('vulkan'),
     }, {
+        'name': 'vaapi-vulkan',
+        'desc': 'VAAPI Vulkan',
+        'deps': 'vaapi && vulkan',
+        'func': check_true,
+    }, {
         'name': 'egl-helpers',
         'desc': 'EGL helper functions',
         'deps': 'egl-x11 || mali-fbdev || rpi || gl-wayland || egl-drm || ' +
-                'egl-angle-win32 || android',
+                'egl-angle-win32 || egl-android',
         'func': check_true
     }
 ]
@@ -844,56 +866,15 @@
     }, {
         'name': 'ffnvcodec',
         'desc': 'CUDA Headers and dynamic loader',
-        'func': check_pkg_config('ffnvcodec >= 8.1.24.1'),
+        'func': check_pkg_config('ffnvcodec >= 8.2.15.7'),
     }, {
         'name': '--cuda-hwaccel',
         'desc': 'CUDA hwaccel',
-        'deps': 'gl && ffnvcodec',
+        'deps': '(gl || vulkan) && ffnvcodec',
         'func': check_true,
     }
 ]
 
-radio_and_tv_features = [
-    {
-        'name': '--tv',
-        'desc': 'TV interface',
-        'deps': 'gpl',
-        'func': check_true,
-        'default': 'disable',
-    }, {
-        'name': 'sys_videoio_h',
-        'desc': 'videoio.h',
-        'func': check_cc(header_name=['sys/time.h', 'sys/videoio.h']),
-        'deps': 'tv',
-    }, {
-        'name': 'videodev',
-        'desc': 'videodev2.h',
-        'func': check_cc(header_name=['sys/time.h', 'linux/videodev2.h']),
-        'deps': 'tv && !sys_videoio_h',
-    }, {
-        'name': '--tv-v4l2',
-        'desc': 'Video4Linux2 TV interface',
-        'deps': 'tv && (sys_videoio_h || videodev)',
-        'func': check_true,
-    }, {
-        'name': '--libv4l2',
-        'desc': 'libv4l2 support',
-        'func': check_pkg_config('libv4l2'),
-        'deps': 'tv-v4l2',
-    }, {
-        'name': '--audio-input',
-        'desc': 'audio input support',
-        'deps': 'tv-v4l2',
-        'func': check_true
-    } , {
-        'name': '--dvbin',
-        'desc': 'DVB input module',
-        'deps': 'gpl',
-        'func': check_true,
-        'default': 'disable',
-    }
-]
-
 standalone_features = [
     {
         'name': 'win32-executable',
@@ -914,10 +895,20 @@
             framework_name=['AppKit'],
             compile_filename='test-touchbar.m',
             linkflags='-fobjc-arc')
-     }, {
+    }, {
+        'name': '--macos-10-11-features',
+        'desc': 'macOS 10.11 SDK Features',
+        'deps': 'cocoa',
+        'func': check_macos_sdk('10.11')
+    }, {
+        'name': '--macos-10-14-features',
+        'desc': 'macOS 10.14 SDK Features',
+        'deps': 'cocoa',
+        'func': check_macos_sdk('10.14')
+    }, {
         'name': '--macos-cocoa-cb',
         'desc': 'macOS opengl-cb backend',
-        'deps': 'cocoa  && swift',
+        'deps': 'cocoa && swift',
         'func': check_true
     }
 ]
@@ -972,7 +963,6 @@
     opt.parse_features('audio outputs',     audio_output_features)
     opt.parse_features('video outputs',     video_output_features)
     opt.parse_features('hwaccels',          hwaccel_features)
-    opt.parse_features('tv features',       radio_and_tv_features)
     opt.parse_features('standalone app',    standalone_features)
 
     group = opt.get_option_group("optional features")
@@ -1045,13 +1035,12 @@
     ctx.parse_dependencies(video_output_features)
     ctx.parse_dependencies(libav_dependencies)
     ctx.parse_dependencies(hwaccel_features)
-    ctx.parse_dependencies(radio_and_tv_features)
 
     if ctx.options.LUA_VER:
         ctx.options.enable_lua = True
 
     if ctx.options.SWIFT_FLAGS:
-        ctx.env.SWIFT_FLAGS += ' ' + ctx.options.SWIFT_FLAGS
+        ctx.env.SWIFT_FLAGS.extend(split(ctx.options.SWIFT_FLAGS))
 
     ctx.parse_dependencies(standalone_features)
 
diff -ruN mpv-0.29.1/wscript_build.py mpv-master/wscript_build.py
--- mpv-0.29.1/wscript_build.py	2018-10-03 02:03:41.000000000 +0700
+++ mpv-master/wscript_build.py	2019-09-19 04:02:03.000000000 +0700
@@ -129,52 +129,62 @@
         ctx.wayland_protocol_header(proto_dir = ctx.env.WL_PROTO_DIR,
             protocol  = "unstable/idle-inhibit/idle-inhibit-unstable-v1",
             target    = "video/out/wayland/idle-inhibit-v1.h")
-        ctx.wayland_protocol_code(proto_dir = "video/out/wayland",
-            protocol          = "server-decoration",
-            vendored_protocol = True,
-            target            = "video/out/wayland/srv-decor.c")
-        ctx.wayland_protocol_header(proto_dir = "video/out/wayland",
-            protocol          = "server-decoration",
-            vendored_protocol = True,
-            target            = "video/out/wayland/srv-decor.h")
+        ctx.wayland_protocol_code(proto_dir = ctx.env.WL_PROTO_DIR,
+            protocol  = "unstable/xdg-decoration/xdg-decoration-unstable-v1",
+            target    = "video/out/wayland/xdg-decoration-v1.c")
+        ctx.wayland_protocol_header(proto_dir = ctx.env.WL_PROTO_DIR,
+            protocol  = "unstable/xdg-decoration/xdg-decoration-unstable-v1",
+            target    = "video/out/wayland/xdg-decoration-v1.h")
 
     ctx(features = "ebml_header", target = "ebml_types.h")
     ctx(features = "ebml_definitions", target = "ebml_defs.c")
 
     def swift(task):
-        src = ' '.join([x.abspath() for x in task.inputs])
+        src = [x.abspath() for x in task.inputs]
         bridge = ctx.path.find_node("osdep/macOS_swift_bridge.h").abspath()
         tgt = task.outputs[0].abspath()
         header = task.outputs[1].abspath()
         module = task.outputs[2].abspath()
+        module_name = os.path.basename(module).rsplit(".", 1)[0]
+
+        cmd = [ ctx.env.SWIFT ]
+        cmd.extend(ctx.env.SWIFT_FLAGS)
+        cmd.extend([
+            "-module-name", module_name,
+            "-emit-module-path", module,
+            "-import-objc-header", bridge,
+            "-emit-objc-header-path", header,
+            "-o", tgt,
+        ])
+        cmd.extend(src)
+        cmd.extend([ "-I.", "-I%s" % ctx.srcnode.abspath() ])
 
-        cmd = ('%s %s -module-name macOS_swift -emit-module-path %s '
-               '-import-objc-header %s -emit-objc-header-path %s -o %s %s '
-               '-I. -I%s') % (ctx.env.SWIFT, ctx.env.SWIFT_FLAGS, module,
-                              bridge, header, tgt, src, ctx.srcnode.abspath())
         return task.exec_command(cmd)
 
     if ctx.dependency_satisfied('macos-cocoa-cb'):
         swift_source = [
             ( "osdep/macOS_mpv_helper.swift" ),
+            ( "osdep/macOS_swift_extensions.swift" ),
+            ( "osdep/macOS_swift_compat.swift" ),
             ( "video/out/cocoa-cb/events_view.swift" ),
             ( "video/out/cocoa-cb/video_layer.swift" ),
             ( "video/out/cocoa-cb/window.swift" ),
+            ( "video/out/cocoa-cb/title_bar.swift" ),
             ( "video/out/cocoa_cb_common.swift" ),
         ]
 
         ctx(
             rule   = swift,
             source = ctx.filtered_sources(swift_source),
-            target = ('osdep/macOS_swift.o '
-                      'osdep/macOS_swift.h '
-                      'osdep/macOS_swift.swiftmodule'),
+            target = [ "osdep/macOS_swift.o",
+                       "osdep/macOS_swift.h",
+                       "osdep/macOS_swift.swiftmodule" ],
             before = 'c',
         )
 
         ctx.env.append_value('LINKFLAGS', [
             '-Xlinker', '-add_ast_path',
-            '-Xlinker', '%s' % ctx.path.find_or_declare("osdep/macOS_swift.swiftmodule").abspath()
+            '-Xlinker', ctx.path.find_or_declare("osdep/macOS_swift.swiftmodule").abspath()
         ])
 
     if ctx.dependency_satisfied('cplayer'):
@@ -227,12 +237,10 @@
         ( "audio/out/ao_alsa.c",                 "alsa" ),
         ( "audio/out/ao_audiounit.m",            "audiounit" ),
         ( "audio/out/ao_coreaudio.c",            "coreaudio" ),
-        ( "audio/out/ao_coreaudio_chmap.c",      "audiounit" ),
-        ( "audio/out/ao_coreaudio_chmap.c",      "coreaudio" ),
+        ( "audio/out/ao_coreaudio_chmap.c",      "coreaudio || audiounit" ),
         ( "audio/out/ao_coreaudio_exclusive.c",  "coreaudio" ),
         ( "audio/out/ao_coreaudio_properties.c", "coreaudio" ),
-        ( "audio/out/ao_coreaudio_utils.c",      "audiounit" ),
-        ( "audio/out/ao_coreaudio_utils.c",      "coreaudio" ),
+        ( "audio/out/ao_coreaudio_utils.c",      "coreaudio || audiounit" ),
         ( "audio/out/ao_jack.c",                 "jack" ),
         ( "audio/out/ao_lavc.c" ),
         ( "audio/out/ao_null.c" ),
@@ -267,7 +275,6 @@
         ( "demux/cue.c" ),
         ( "demux/demux.c" ),
         ( "demux/demux_cue.c" ),
-        ( "demux/demux_disc.c" ),
         ( "demux/demux_edl.c" ),
         ( "demux/demux_lavf.c" ),
         ( "demux/demux_libarchive.c",            "libarchive" ),
@@ -276,10 +283,8 @@
         ( "demux/demux_mkv_timeline.c" ),
         ( "demux/demux_null.c" ),
         ( "demux/demux_playlist.c" ),
-        ( "demux/demux_rar.c" ),
         ( "demux/demux_raw.c" ),
         ( "demux/demux_timeline.c" ),
-        ( "demux/demux_tv.c",                    "tv" ),
         ( "demux/ebml.c" ),
         ( "demux/packet.c" ),
         ( "demux/timeline.c" ),
@@ -316,6 +321,7 @@
         ( "misc/rendezvous.c" ),
         ( "misc/ring.c" ),
         ( "misc/thread_pool.c" ),
+        ( "misc/thread_tools.c" ),
 
         ## Options
         ( "options/m_config.c" ),
@@ -345,24 +351,14 @@
         ( "player/video.c" ),
 
         ## Streams
-        ( "stream/ai_alsa1x.c",                  "alsa && audio-input" ),
-        ( "stream/ai_oss.c",                     "oss-audio && audio-input" ),
-        ( "stream/ai_sndio.c",                   "sndio && audio-input" ),
-        ( "stream/audio_in.c",                   "audio-input" ),
-        ( "stream/cache.c" ),
-        ( "stream/cache_file.c" ),
         ( "stream/cookies.c" ),
         ( "stream/dvb_tune.c",                   "dvbin" ),
-        ( "stream/frequencies.c",                "tv" ),
-        ( "stream/rar.c" ),
         ( "stream/stream.c" ),
         ( "stream/stream_avdevice.c" ),
         ( "stream/stream_bluray.c",              "libbluray" ),
         ( "stream/stream_cb.c" ),
         ( "stream/stream_cdda.c",                "cdda" ),
         ( "stream/stream_dvb.c",                 "dvbin" ),
-        ( "stream/stream_dvd.c",                 "dvdread-common" ),
-        ( "stream/stream_dvd_common.c",          "dvdread-common" ),
         ( "stream/stream_dvdnav.c",              "dvdnav" ),
         ( "stream/stream_edl.c" ),
         ( "stream/stream_file.c" ),
@@ -371,12 +367,7 @@
         ( "stream/stream_memory.c" ),
         ( "stream/stream_mf.c" ),
         ( "stream/stream_null.c" ),
-        ( "stream/stream_rar.c" ),
         ( "stream/stream_smb.c",                 "libsmbclient" ),
-        ( "stream/stream_tv.c",                  "tv" ),
-        ( "stream/tv.c",                         "tv" ),
-        ( "stream/tvi_dummy.c",                  "tv" ),
-        ( "stream/tvi_v4l2.c",                   "tv-v4l2"),
 
         ## Subtitles
         ( "sub/ass_mp.c",                        "libass"),
@@ -427,6 +418,7 @@
         ( "video/out/filter_kernels.c" ),
         ( "video/out/gpu/context.c" ),
         ( "video/out/gpu/d3d11_helpers.c",       "d3d11 || egl-angle-win32" ),
+        ( "video/out/gpu/error_diffusion.c" ),
         ( "video/out/gpu/hwdec.c" ),
         ( "video/out/gpu/lcms.c" ),
         ( "video/out/gpu/libmpv_gpu.c" ),
@@ -439,10 +431,18 @@
         ( "video/out/gpu/utils.c" ),
         ( "video/out/gpu/video.c" ),
         ( "video/out/gpu/video_shaders.c" ),
+        ( "video/out/hwdec/hwdec_cuda.c",        "cuda-hwaccel" ),
+        ( "video/out/hwdec/hwdec_cuda_gl.c",     "cuda-hwaccel && gl" ),
+        ( "video/out/hwdec/hwdec_cuda_vk.c",     "cuda-hwaccel && vulkan" ),
+        ( "video/out/hwdec/hwdec_vaapi.c",       "vaapi-egl || vaapi-vulkan" ),
+        ( "video/out/hwdec/hwdec_vaapi_gl.c",    "vaapi-egl" ),
+        ( "video/out/hwdec/hwdec_vaapi_vk.c",    "vaapi-vulkan" ),
+        ( "video/out/placebo/ra_pl.c",           "libplacebo" ),
+        ( "video/out/placebo/utils.c",           "libplacebo" ),
         ( "video/out/opengl/angle_dynamic.c",    "egl-angle" ),
         ( "video/out/opengl/common.c",           "gl" ),
         ( "video/out/opengl/context.c",          "gl" ),
-        ( "video/out/opengl/context_android.c",  "android" ),
+        ( "video/out/opengl/context_android.c",  "egl-android" ),
         ( "video/out/opengl/context_angle.c",    "egl-angle-win32" ),
         ( "video/out/opengl/context_cocoa.c",    "gl-cocoa" ),
         ( "video/out/opengl/context_drm_egl.c",  "egl-drm" ),
@@ -456,7 +456,6 @@
         ( "video/out/opengl/context_x11egl.c",   "egl-x11" ),
         ( "video/out/opengl/egl_helpers.c",      "egl-helpers" ),
         ( "video/out/opengl/formats.c",          "gl" ),
-        ( "video/out/opengl/hwdec_cuda.c",       "cuda-hwaccel" ),
         ( "video/out/opengl/hwdec_d3d11egl.c",   "d3d-hwaccel && egl-angle" ),
         ( "video/out/opengl/hwdec_d3d11eglrgb.c","d3d-hwaccel && egl-angle" ),
         ( "video/out/opengl/hwdec_drmprime_drm.c","drmprime && drm" ),
@@ -465,9 +464,9 @@
         ( "video/out/opengl/hwdec_ios.m",        "ios-gl" ),
         ( "video/out/opengl/hwdec_osx.c",        "videotoolbox-gl" ),
         ( "video/out/opengl/hwdec_rpi.c",        "rpi" ),
-        ( "video/out/opengl/hwdec_vaegl.c",      "vaapi-egl" ),
         ( "video/out/opengl/hwdec_vdpau.c",      "vdpau-gl-x11" ),
         ( "video/out/opengl/libmpv_gl.c",        "gl" ),
+        ( "video/out/opengl/oml_sync.c",         "egl-x11 || gl-x11" ),
         ( "video/out/opengl/ra_gl.c",            "gl" ),
         ( "video/out/opengl/utils.c",            "gl" ),
         ( "video/out/vo.c" ),
@@ -491,14 +490,10 @@
         ( "video/out/vulkan/context_wayland.c",  "vulkan && wayland" ),
         ( "video/out/vulkan/context_win.c",      "vulkan && win32-desktop" ),
         ( "video/out/vulkan/context_xlib.c",     "vulkan && x11" ),
-        ( "video/out/vulkan/formats.c",          "vulkan" ),
-        ( "video/out/vulkan/malloc.c",           "vulkan" ),
-        ( "video/out/vulkan/ra_vk.c",            "vulkan" ),
-        ( "video/out/vulkan/spirv_nvidia.c",     "vulkan" ),
         ( "video/out/vulkan/utils.c",            "vulkan" ),
         ( "video/out/w32_common.c",              "win32-desktop" ),
         ( "video/out/wayland/idle-inhibit-v1.c", "wayland" ),
-        ( "video/out/wayland/srv-decor.c",       "wayland" ),
+        ( "video/out/wayland/xdg-decoration-v1.c", "wayland" ),
         ( "video/out/wayland/xdg-shell.c",       "wayland" ),
         ( "video/out/wayland_common.c",          "wayland" ),
         ( "video/out/win32/displayconfig.c",     "win32-desktop" ),
